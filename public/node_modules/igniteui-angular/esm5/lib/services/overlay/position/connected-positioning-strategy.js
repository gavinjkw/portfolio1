/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { getTargetRect, cloneInstance, HorizontalAlignment, VerticalAlignment } from './../utilities';
import { scaleInVerTop, scaleOutVerTop } from '../../../animations/main';
/**
 * Positions the element based on the directions and start point passed in trough PositionSettings.
 * It is possible to either pass a start point or an HTMLElement as a positioning base.
 */
var /**
 * Positions the element based on the directions and start point passed in trough PositionSettings.
 * It is possible to either pass a start point or an HTMLElement as a positioning base.
 */
ConnectedPositioningStrategy = /** @class */ (function () {
    function ConnectedPositioningStrategy(settings) {
        this._defaultSettings = {
            // default Point(0, 0) in getPointFromPositionsSettings
            target: null,
            horizontalDirection: HorizontalAlignment.Right,
            verticalDirection: VerticalAlignment.Bottom,
            horizontalStartPoint: HorizontalAlignment.Left,
            verticalStartPoint: VerticalAlignment.Bottom,
            openAnimation: scaleInVerTop,
            closeAnimation: scaleOutVerTop,
            minSize: { width: 0, height: 0 }
        };
        this.settings = Object.assign({}, this._defaultSettings, settings);
    }
    /** @inheritdoc */
    /**
     * \@inheritdoc
     * @param {?} contentElement
     * @param {?} size
     * @param {?=} document
     * @param {?=} initialCall
     * @return {?}
     */
    ConnectedPositioningStrategy.prototype.position = /**
     * \@inheritdoc
     * @param {?} contentElement
     * @param {?} size
     * @param {?=} document
     * @param {?=} initialCall
     * @return {?}
     */
    function (contentElement, size, document, initialCall) {
        /** @type {?} */
        var targetRect = getTargetRect(this.settings);
        /** @type {?} */
        var contentElementRect = contentElement.getBoundingClientRect();
        this.setStyle(contentElement, targetRect, contentElementRect);
    };
    /**
     * @inheritdoc
     * Creates clone of this position strategy
     * @returns clone of this position strategy
     */
    /**
     * \@inheritdoc
     * Creates clone of this position strategy
     * @return {?} clone of this position strategy
     */
    ConnectedPositioningStrategy.prototype.clone = /**
     * \@inheritdoc
     * Creates clone of this position strategy
     * @return {?} clone of this position strategy
     */
    function () {
        return cloneInstance(this);
    };
    /**
     * Sets element's style which effectively positions provided element according
     * to provided position settings
     * @param element Element to position
     * @param targetRect Bounding rectangle of strategy target
     * @param elementRect Bounding rectangle of the element
     */
    /**
     * Sets element's style which effectively positions provided element according
     * to provided position settings
     * @protected
     * @param {?} element Element to position
     * @param {?} targetRect Bounding rectangle of strategy target
     * @param {?} elementRect Bounding rectangle of the element
     * @return {?}
     */
    ConnectedPositioningStrategy.prototype.setStyle = /**
     * Sets element's style which effectively positions provided element according
     * to provided position settings
     * @protected
     * @param {?} element Element to position
     * @param {?} targetRect Bounding rectangle of strategy target
     * @param {?} elementRect Bounding rectangle of the element
     * @return {?}
     */
    function (element, targetRect, elementRect) {
        /** @type {?} */
        var startPoint = {
            x: targetRect.right + targetRect.width * this.settings.horizontalStartPoint,
            y: targetRect.bottom + targetRect.height * this.settings.verticalStartPoint,
        };
        /** @type {?} */
        var wrapperRect = element.parentElement.getBoundingClientRect();
        //  clean up styles - if auto position strategy is chosen we may pass here several times
        element.style.right = '';
        element.style.left = '';
        element.style.bottom = '';
        element.style.top = '';
        switch (this.settings.horizontalDirection) {
            case HorizontalAlignment.Left:
                element.style.right = Math.round(wrapperRect.right - startPoint.x) + "px";
                break;
            case HorizontalAlignment.Center:
                element.style.left = Math.round(startPoint.x - wrapperRect.left - elementRect.width / 2) + "px";
                break;
            case HorizontalAlignment.Right:
                element.style.left = Math.round(startPoint.x - wrapperRect.left) + "px";
                break;
        }
        switch (this.settings.verticalDirection) {
            case VerticalAlignment.Top:
                element.style.bottom = Math.round(wrapperRect.bottom - startPoint.y) + "px";
                break;
            case VerticalAlignment.Middle:
                element.style.top = Math.round(startPoint.y - wrapperRect.top - elementRect.height / 2) + "px";
                break;
            case VerticalAlignment.Bottom:
                element.style.top = Math.round(startPoint.y - wrapperRect.top) + "px";
                break;
        }
    };
    return ConnectedPositioningStrategy;
}());
/**
 * Positions the element based on the directions and start point passed in trough PositionSettings.
 * It is possible to either pass a start point or an HTMLElement as a positioning base.
 */
export { ConnectedPositioningStrategy };
if (false) {
    /**
     * @type {?}
     * @private
     */
    ConnectedPositioningStrategy.prototype._defaultSettings;
    /**
     * \@inheritdoc
     * @type {?}
     */
    ConnectedPositioningStrategy.prototype.settings;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29ubmVjdGVkLXBvc2l0aW9uaW5nLXN0cmF0ZWd5LmpzIiwic291cmNlUm9vdCI6Im5nOi8vaWduaXRldWktYW5ndWxhci8iLCJzb3VyY2VzIjpbImxpYi9zZXJ2aWNlcy9vdmVybGF5L3Bvc2l0aW9uL2Nvbm5lY3RlZC1wb3NpdGlvbmluZy1zdHJhdGVneS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQ0EsT0FBTyxFQUNMLGFBQWEsRUFDYixhQUFhLEVBQ2IsbUJBQW1CLEVBSW5CLGlCQUFpQixFQUNsQixNQUFNLGdCQUFnQixDQUFDO0FBQ3hCLE9BQU8sRUFBRSxhQUFhLEVBQUUsY0FBYyxFQUFFLE1BQU0sMEJBQTBCLENBQUM7Ozs7O0FBTXpFOzs7OztJQWdCRSxzQ0FBWSxRQUEyQjtRQWYvQixxQkFBZ0IsR0FBcUI7O1lBRTNDLE1BQU0sRUFBRSxJQUFJO1lBQ1osbUJBQW1CLEVBQUUsbUJBQW1CLENBQUMsS0FBSztZQUM5QyxpQkFBaUIsRUFBRSxpQkFBaUIsQ0FBQyxNQUFNO1lBQzNDLG9CQUFvQixFQUFFLG1CQUFtQixDQUFDLElBQUk7WUFDOUMsa0JBQWtCLEVBQUUsaUJBQWlCLENBQUMsTUFBTTtZQUM1QyxhQUFhLEVBQUUsYUFBYTtZQUM1QixjQUFjLEVBQUUsY0FBYztZQUM5QixPQUFPLEVBQUUsRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFFLE1BQU0sRUFBRSxDQUFDLEVBQUU7U0FDakMsQ0FBQztRQU1BLElBQUksQ0FBQyxRQUFRLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLGdCQUFnQixFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ3JFLENBQUM7SUFFRCxrQkFBa0I7Ozs7Ozs7OztJQUNsQiwrQ0FBUTs7Ozs7Ozs7SUFBUixVQUFTLGNBQTJCLEVBQUUsSUFBVSxFQUFFLFFBQW1CLEVBQUUsV0FBcUI7O1lBQ3BGLFVBQVUsR0FBRyxhQUFhLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQzs7WUFDekMs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LHdEQVVFOzs7OztJQUdGLGdEQUFrQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElQb3NpdGlvblN0cmF0ZWd5IH0gZnJvbSAnLi9JUG9zaXRpb25TdHJhdGVneSc7XG5pbXBvcnQge1xuICBnZXRUYXJnZXRSZWN0LFxuICBjbG9uZUluc3RhbmNlLFxuICBIb3Jpem9udGFsQWxpZ25tZW50LFxuICBQb2ludCxcbiAgUG9zaXRpb25TZXR0aW5ncyxcbiAgU2l6ZSxcbiAgVmVydGljYWxBbGlnbm1lbnRcbn0gZnJvbSAnLi8uLi91dGlsaXRpZXMnO1xuaW1wb3J0IHsgc2NhbGVJblZlclRvcCwgc2NhbGVPdXRWZXJUb3AgfSBmcm9tICcuLi8uLi8uLi9hbmltYXRpb25zL21haW4nO1xuXG4vKipcbiAqIFBvc2l0aW9ucyB0aGUgZWxlbWVudCBiYXNlZCBvbiB0aGUgZGlyZWN0aW9ucyBhbmQgc3RhcnQgcG9pbnQgcGFzc2VkIGluIHRyb3VnaCBQb3NpdGlvblNldHRpbmdzLlxuICogSXQgaXMgcG9zc2libGUgdG8gZWl0aGVyIHBhc3MgYSBzdGFydCBwb2ludCBvciBhbiBIVE1MRWxlbWVudCBhcyBhIHBvc2l0aW9uaW5nIGJhc2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBDb25uZWN0ZWRQb3NpdGlvbmluZ1N0cmF0ZWd5IGltcGxlbWVudHMgSVBvc2l0aW9uU3RyYXRlZ3kge1xuICBwcml2YXRlIF9kZWZhdWx0U2V0dGluZ3M6IFBvc2l0aW9uU2V0dGluZ3MgPSB7XG4gICAgLy8gZGVmYXVsdCBQb2ludCgwLCAwKSBpbiBnZXRQb2ludEZyb21Qb3NpdGlvbnNTZXR0aW5nc1xuICAgIHRhcmdldDogbnVsbCxcbiAgICBob3Jpem9udGFsRGlyZWN0aW9uOiBIb3Jpem9udGFsQWxpZ25tZW50LlJpZ2h0LFxuICAgIHZlcnRpY2FsRGlyZWN0aW9uOiBWZXJ0aWNhbEFsaWdubWVudC5Cb3R0b20sXG4gICAgaG9yaXpvbnRhbFN0YXJ0UG9pbnQ6IEhvcml6b250YWxBbGlnbm1lbnQuTGVmdCxcbiAgICB2ZXJ0aWNhbFN0YXJ0UG9pbnQ6IFZlcnRpY2FsQWxpZ25tZW50LkJvdHRvbSxcbiAgICBvcGVuQW5pbWF0aW9uOiBzY2FsZUluVmVyVG9wLFxuICAgIGNsb3NlQW5pbWF0aW9uOiBzY2FsZU91dFZlclRvcCxcbiAgICBtaW5TaXplOiB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfVxuICB9O1xuXG4gIC8qKiBAaW5oZXJpdGRvYyAqL1xuICBwdWJsaWMgc2V0dGluZ3M6IFBvc2l0aW9uU2V0dGluZ3M7XG5cbiAgY29uc3RydWN0b3Ioc2V0dGluZ3M/OiBQb3NpdGlvblNldHRpbmdzKSB7XG4gICAgdGhpcy5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX2RlZmF1bHRTZXR0aW5ncywgc2V0dGluZ3MpO1xuICB9XG5cbiAgLyoqIEBpbmhlcml0ZG9jICovXG4gIHBvc2l0aW9uKGNvbnRlbnRFbGVtZW50OiBIVE1MRWxlbWVudCwgc2l6ZTogU2l6ZSwgZG9jdW1lbnQ/OiBEb2N1bWVudCwgaW5pdGlhbENhbGw/OiBib29sZWFuKTogdm9pZCB7XG4gICAgY29uc3QgdGFyZ2V0UmVjdCA9IGdldFRhcmdldFJlY3QodGhpcy5zZXR0aW5ncyk7XG4gICAgY29uc3QgY29udGVudEVsZW1lbnRSZWN0ID0gY29udGVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdGhpcy5zZXRTdHlsZShjb250ZW50RWxlbWVudCwgdGFyZ2V0UmVjdCwgY29udGVudEVsZW1lbnRSZWN0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdGRvY1xuICAgKiBDcmVhdGVzIGNsb25lIG9mIHRoaXMgcG9zaXRpb24gc3RyYXRlZ3lcbiAgICogQHJldHVybnMgY2xvbmUgb2YgdGhpcyBwb3NpdGlvbiBzdHJhdGVneVxuICAgKi9cbiAgY2xvbmUoKTogSVBvc2l0aW9uU3RyYXRlZ3kge1xuICAgIHJldHVybiBjbG9uZUluc3RhbmNlKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgZWxlbWVudCdzIHN0eWxlIHdoaWNoIGVmZmVjdGl2ZWx5IHBvc2l0aW9ucyBwcm92aWRlZCBlbGVtZW50IGFjY29yZGluZ1xuICAgKiB0byBwcm92aWRlZCBwb3NpdGlvbiBzZXR0aW5nc1xuICAgKiBAcGFyYW0gZWxlbWVudCBFbGVtZW50IHRvIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB0YXJnZXRSZWN0IEJvdW5kaW5nIHJlY3RhbmdsZSBvZiBzdHJhdGVneSB0YXJnZXRcbiAgICogQHBhcmFtIGVsZW1lbnRSZWN0IEJvdW5kaW5nIHJlY3RhbmdsZSBvZiB0aGUgZWxlbWVudFxuICAgKi9cbiAgcHJvdGVjdGVkIHNldFN0eWxlKGVsZW1lbnQ6IEhUTUxFbGVtZW50LCB0YXJnZXRSZWN0OiBDbGllbnRSZWN0LCBlbGVtZW50UmVjdDogQ2xpZW50UmVjdCkge1xuICAgIGNvbnN0IHN0YXJ0UG9pbnQ6IFBvaW50ID0ge1xuICAgICAgeDogdGFyZ2V0UmVjdC5yaWdodCArIHRhcmdldFJlY3Qud2lkdGggKiB0aGlzLnNldHRpbmdzLmhvcml6b250YWxTdGFydFBvaW50LFxuICAgICAgeTogdGFyZ2V0UmVjdC5ib3R0b20gKyB0YXJnZXRSZWN0LmhlaWdodCAqIHRoaXMuc2V0dGluZ3MudmVydGljYWxTdGFydFBvaW50LFxuICAgIH07XG4gICAgY29uc3Qgd3JhcHBlclJlY3Q6IENsaWVudFJlY3QgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAvLyAgY2xlYW4gdXAgc3R5bGVzIC0gaWYgYXV0byBwb3NpdGlvbiBzdHJhdGVneSBpcyBjaG9zZW4gd2UgbWF5IHBhc3MgaGVyZSBzZXZlcmFsIHRpbWVzXG4gICAgZWxlbWVudC5zdHlsZS5yaWdodCA9ICcnO1xuICAgIGVsZW1lbnQuc3R5bGUubGVmdCA9ICcnO1xuICAgIGVsZW1lbnQuc3R5bGUuYm90dG9tID0gJyc7XG4gICAgZWxlbWVudC5zdHlsZS50b3AgPSAnJztcblxuICAgIHN3aXRjaCAodGhpcy5zZXR0aW5ncy5ob3Jpem9udGFsRGlyZWN0aW9uKSB7XG4gICAgICBjYXNlIEhvcml6b250YWxBbGlnbm1lbnQuTGVmdDpcbiAgICAgICAgZWxlbWVudC5zdHlsZS5yaWdodCA9IGAke01hdGgucm91bmQod3JhcHBlclJlY3QucmlnaHQgLSBzdGFydFBvaW50LngpfXB4YDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvcml6b250YWxBbGlnbm1lbnQuQ2VudGVyOlxuICAgICAgICBlbGVtZW50LnN0eWxlLmxlZnQgPSBgJHtNYXRoLnJvdW5kKHN0YXJ0UG9pbnQueCAtIHdyYXBwZXJSZWN0LmxlZnQgLSBlbGVtZW50UmVjdC53aWR0aCAvIDIpfXB4YDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvcml6b250YWxBbGlnbm1lbnQuUmlnaHQ6XG4gICAgICAgIGVsZW1lbnQuc3R5bGUubGVmdCA9IGAke01hdGgucm91bmQoc3RhcnRQb2ludC54IC0gd3JhcHBlclJlY3QubGVmdCl9cHhgO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRoaXMuc2V0dGluZ3MudmVydGljYWxEaXJlY3Rpb24pIHtcbiAgICAgIGNhc2UgVmVydGljYWxBbGlnbm1lbnQuVG9wOlxuICAgICAgICBlbGVtZW50LnN0eWxlLmJvdHRvbSA9IGAke01hdGgucm91bmQod3JhcHBlclJlY3QuYm90dG9tIC0gc3RhcnRQb2ludC55KX1weGA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBWZXJ0aWNhbEFsaWdubWVudC5NaWRkbGU6XG4gICAgICAgIGVsZW1lbnQuc3R5bGUudG9wID0gYCR7TWF0aC5yb3VuZChzdGFydFBvaW50LnkgLSB3cmFwcGVyUmVjdC50b3AgLSBlbGVtZW50UmVjdC5oZWlnaHQgLyAyKX1weGA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBWZXJ0aWNhbEFsaWdubWVudC5Cb3R0b206XG4gICAgICAgIGVsZW1lbnQuc3R5bGUudG9wID0gYCR7TWF0aC5yb3VuZChzdGFydFBvaW50LnkgLSB3cmFwcGVyUmVjdC50b3ApfXB4YDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG4iXX0=