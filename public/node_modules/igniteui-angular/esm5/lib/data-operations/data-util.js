/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { IgxSorting, IgxDataRecordSorting } from './sorting-strategy';
import { IgxGrouping } from './grouping-strategy';
import { PagingError } from './paging-state.interface';
import { TreeGridFilteringStrategy } from '../grids/tree-grid/tree-grid.filtering.pipe';
import { FilteringStrategy } from './filtering-strategy';
import { cloneValue, mergeObjects } from '../core/utils';
import { TransactionType } from '../services/transaction/transaction';
/** @enum {string} */
var DataType = {
    String: 'string',
    Number: 'number',
    Boolean: 'boolean',
    Date: 'date',
};
export { DataType };
/**
 * @hidden
 */
var /**
 * @hidden
 */
DataUtil = /** @class */ (function () {
    function DataUtil() {
    }
    /**
     * @template T
     * @param {?} data
     * @param {?} expressions
     * @param {?=} sorting
     * @return {?}
     */
    DataUtil.sort = /**
     * @template T
     * @param {?} data
     * @param {?} expressions
     * @param {?=} sorting
     * @return {?}
     */
    function (data, expressions, sorting) {
        if (sorting === void 0) { sorting = new IgxSorting(); }
        return sorting.sort(data, expressions);
    };
    /**
     * @param {?} hierarchicalData
     * @param {?} expressions
     * @param {?=} parent
     * @return {?}
     */
    DataUtil.treeGridSort = /**
     * @param {?} hierarchicalData
     * @param {?} expressions
     * @param {?=} parent
     * @return {?}
     */
    function (hierarchicalData, expressions, parent) {
        /** @type {?} */
        var res = [];
        hierarchicalData.forEach(function (hr) {
            /** @type {?} */
            var rec = DataUtil.cloneTreeGridRecord(hr);
            rec.parent = parent;
            if (rec.children) {
                rec.children = DataUtil.treeGridSort(rec.children, expressions, rec);
            }
            res.push(rec);
        });
        res = DataUtil.sort(res, expressions, new IgxDataRecordSorting());
        return res;
    };
    /**
     * @param {?} hierarchicalRecord
     * @return {?}
     */
    DataUtil.cloneTreeGridRecord = /**
     * @param {?} hierarchicalRecord
     * @return {?}
     */
    function (hierarchicalRecord) {
        /** @type {?} */
        var rec = {
            rowID: hierarchicalRecord.rowID,
            data: hierarchicalRecord.data,
            children: hierarchicalRecord.children,
            isFilteredOutParent: hierarchicalRecord.isFilteredOutParent,
            level: hierarchicalRecord.level,
            expanded: hierarchicalRecord.expanded
        };
        return rec;
    };
    /**
     * @template T
     * @param {?} data
     * @param {?} state
     * @param {?=} grid
     * @param {?=} groupsRecords
     * @return {?}
     */
    DataUtil.group = /**
     * @template T
     * @param {?} data
     * @param {?} state
     * @param {?=} grid
     * @param {?=} groupsRecords
     * @return {?}
     */
    function (data, state, grid, groupsRecords) {
        if (grid === void 0) { grid = null; }
        if (groupsRecords === void 0) { groupsRecords = []; }
        /** @type {?} */
        var grouping = new IgxGrouping();
        groupsRecords.splice(0, groupsRecords.length);
        return grouping.groupBy(data, state.expressions, grid, groupsRecords);
    };
    /**
     * @param {?} groupData
     * @param {?} state
     * @return {?}
     */
    DataUtil.restoreGroups = /**
     * @param {?} groupData
     * @param {?} state
     * @return {?}
     */
    function (groupData, state) {
        if (state.expressions.length === 0) {
            return groupData.data;
        }
        return this.restoreGroupsIterative(groupData, state);
    };
    /**
     * @private
     * @param {?} groupData
     * @param {?} state
     * @return {?}
     */
    DataUtil.restoreGroupsIterative = /**
     * @private
     * @param {?} groupData
     * @param {?} state
     * @return {?}
     */
    function (groupData, state) {
        var _this = this;
        /** @type {?} */
        var metadata = groupData.metadata;
        /** @type {?} */
        var result = [];
        /** @type {?} */
        var added = [];
        /** @type {?} */
        var chain;
        /** @type {?} */
        var i = 0;
        /** @type {?} */
        var j;
        /** @type {?} */
        var pointer;
        /** @type {?} */
        var expanded;
        for (i = 0; i < metadata.length;) {
            chain = [metadata[i]];
            pointer = metadata[i].groupParent;
            // break off if the parent is already added
            while (pointer && added[0] !== pointer) {
                chain.push(pointer);
                if (added[0] && added[0].level === pointer.level) {
                    added.shift();
                }
                pointer = pointer.groupParent;
            }
            var _loop_1 = function () {
                result.push(chain[j]);
                added.unshift(chain[j]);
                /** @type {?} */
                var hierarchy = this_1.getHierarchy(chain[j]);
                /** @type {?} */
                var expandState = state.expansion.find(function (s) {
                    return _this.isHierarchyMatch(s.hierarchy || [{ fieldName: chain[j].expression.fieldName, value: chain[j].value }], hierarchy);
                });
                expanded = expandState ? expandState.expanded : state.defaultExpanded;
                if (!expanded) {
                    return "break";
                }
            };
            var this_1 = this;
            for (j = chain.length - 1; j >= 0; j--) {
                var state_1 = _loop_1();
                if (state_1 === "break")
                    break;
            }
            added.shift();
            j = Math.max(j, 0);
            /** @type {?} */
            var start = chain[j].records.findIndex(function (r) { return r === groupData.data[i]; });
            /** @type {?} */
            var end = Math.min(metadata.length - i + start, chain[j].records.length);
            if (expanded) {
                result.push.apply(result, tslib_1.__spread(chain[j].records.slice(start, end)));
            }
            i += end - start;
        }
        return result;
    };
    /**
     * @template T
     * @param {?} data
     * @param {?} state
     * @return {?}
     */
    DataUtil.page = /**
     * @template T
     * @param {?} data
     * @param {?} state
     * @return {?}
     */
    function (data, state) {
        if (!state) {
            return data;
        }
        /** @type {?} */
        var len = data.length;
        /** @type {?} */
        var index = state.index;
        /** @type {?} */
        var res = [];
        /** @type {?} */
        var recordsPerPage = state.recordsPerPage;
        state.metadata = {
            countPages: 0,
            countRecords: data.length,
            error: PagingError.None
        };
        if (index < 0 || isNaN(index)) {
            state.metadata.error = PagingError.IncorrectPageIndex;
            return res;
        }
        if (recordsPerPage <= 0 || isNaN(recordsPerPage)) {
            state.metadata.error = PagingError.IncorrectRecordsPerPage;
            return res;
        }
        state.metadata.countPages = Math.ceil(len / recordsPerPage);
        if (!len) {
            return data;
        }
        if (index >= state.metadata.countPages) {
            state.metadata.error = PagingError.IncorrectPageIndex;
            return res;
        }
        return data.slice(index * recordsPerPage, (index + 1) * recordsPerPage);
    };
    /**
     * @template T
     * @param {?} data
     * @param {?} state
     * @return {?}
     */
    DataUtil.filter = /**
     * @template T
     * @param {?} data
     * @param {?} state
     * @return {?}
     */
    function (data, state) {
        if (!state.strategy) {
            state.strategy = new FilteringStrategy();
        }
        return state.strategy.filter(data, state.expressionsTree);
    };
    /**
     * @param {?} data
     * @param {?} state
     * @return {?}
     */
    DataUtil.treeGridFilter = /**
     * @param {?} data
     * @param {?} state
     * @return {?}
     */
    function (data, state) {
        if (!state.strategy) {
            state.strategy = new TreeGridFilteringStrategy();
        }
        return state.strategy.filter(data, state.expressionsTree);
    };
    /**
     * @param {?} gRow
     * @return {?}
     */
    DataUtil.getHierarchy = /**
     * @param {?} gRow
     * @return {?}
     */
    function (gRow) {
        /** @type {?} */
        var hierarchy = [];
        if (gRow !== undefined && gRow.expression) {
            hierarchy.push({ fieldName: gRow.expression.fieldName, value: gRow.value });
            while (gRow.groupParent) {
                gRow = gRow.groupParent;
                hierarchy.unshift({ fieldName: gRow.expression.fieldName, value: gRow.value });
            }
        }
        return hierarchy;
    };
    /**
     * @param {?} h1
     * @param {?} h2
     * @return {?}
     */
    DataUtil.isHierarchyMatch = /**
     * @param {?} h1
     * @param {?} h2
     * @return {?}
     */
    function (h1, h2) {
        if (h1.length !== h2.length) {
            return false;
        }
        return h1.every(function (level, index) {
            return level.fieldName === h2[index].fieldName && level.value === h2[index].value;
        });
    };
    /**
     * Merges all changes from provided transactions into provided data collection
     * @param data Collection to merge
     * @param transactions Transactions to merge into data
     * @param primaryKey Primary key of the collection, if any
     * @param deleteRows Should delete rows with DELETE transaction type from data
     * @returns Provided data collections updated with all provided transactions
     */
    /**
     * Merges all changes from provided transactions into provided data collection
     * @template T
     * @param {?} data Collection to merge
     * @param {?} transactions Transactions to merge into data
     * @param {?=} primaryKey Primary key of the collection, if any
     * @param {?=} deleteRows Should delete rows with DELETE transaction type from data
     * @return {?} Provided data collections updated with all provided transactions
     */
    DataUtil.mergeTransactions = /**
     * Merges all changes from provided transactions into provided data collection
     * @template T
     * @param {?} data Collection to merge
     * @param {?} transactions Transactions to merge into data
     * @param {?=} primaryKey Primary key of the collection, if any
     * @param {?=} deleteRows Should delete rows with DELETE transaction type from data
     * @return {?} Provided data collections updated with all provided transactions
     */
    function (data, transactions, primaryKey, deleteRows) {
        if (deleteRows === void 0) { deleteRows = false; }
        data.forEach(function (item, index) {
            /** @type {?} */
            var rowId = primaryKey ? item[primaryKey] : item;
            /** @type {?} */
            var transaction = transactions.find(function (t) { return t.id === rowId; });
            if (transaction && transaction.type === TransactionType.UPDATE) {
                data[index] = transaction.newValue;
            }
        });
        if (deleteRows) {
            transactions
                .filter(function (t) { return t.type === TransactionType.DELETE; })
                .forEach(function (t) {
                /** @type {?} */
                var index = primaryKey ? data.findIndex(function (d) { return d[primaryKey] === t.id; }) : data.findIndex(function (d) { return d === t.id; });
                if (0 <= index && index < data.length) {
                    data.splice(index, 1);
                }
            });
        }
        data.push.apply(data, tslib_1.__spread(transactions
            .filter(function (t) { return t.type === TransactionType.ADD; })
            .map(function (t) { return t.newValue; })));
        return data;
    };
    /**
     * Merges all changes from provided transactions into provided hierarchical data collection
     * @param data Collection to merge
     * @param transactions Transactions to merge into data
     * @param childDataKey Data key of child collections
     * @param primaryKey Primary key of the collection, if any
     * @param deleteRows Should delete rows with DELETE transaction type from data
     * @returns Provided data collections updated with all provided transactions
     */
    /**
     * Merges all changes from provided transactions into provided hierarchical data collection
     * @param {?} data Collection to merge
     * @param {?} transactions Transactions to merge into data
     * @param {?} childDataKey Data key of child collections
     * @param {?=} primaryKey Primary key of the collection, if any
     * @param {?=} deleteRows Should delete rows with DELETE transaction type from data
     * @return {?} Provided data collections updated with all provided transactions
     */
    DataUtil.mergeHierarchicalTransactions = /**
     * Merges all changes from provided transactions into provided hierarchical data collection
     * @param {?} data Collection to merge
     * @param {?} transactions Transactions to merge into data
     * @param {?} childDataKey Data key of child collections
     * @param {?=} primaryKey Primary key of the collection, if any
     * @param {?=} deleteRows Should delete rows with DELETE transaction type from data
     * @return {?} Provided data collections updated with all provided transactions
     */
    function (data, transactions, childDataKey, primaryKey, deleteRows) {
        if (deleteRows === void 0) { deleteRows = false; }
        var e_1, _a;
        var _loop_2 = function (transaction) {
            if (transaction.path) {
                /** @type {?} */
                var parent_1 = this_2.findParentFromPath(data, primaryKey, childDataKey, transaction.path);
                /** @type {?} */
                var collection = parent_1 ? parent_1[childDataKey] : data;
                switch (transaction.type) {
                    case TransactionType.ADD:
                        //  if there is no parent this is ADD row at root level
                        if (parent_1 && !parent_1[childDataKey]) {
                            parent_1[childDataKey] = collection = [];
                        }
                        collection.push(transaction.newValue);
                        break;
                    case TransactionType.UPDATE:
                        /** @type {?} */
                        var updateIndex = collection.findIndex(function (x) { return x[primaryKey] === transaction.id; });
                        if (updateIndex !== -1) {
                            collection[updateIndex] = mergeObjects(cloneValue(collection[updateIndex]), transaction.newValue);
                        }
                        break;
                    case TransactionType.DELETE:
                        if (deleteRows) {
                            /** @type {?} */
                            var deleteIndex = collection.findIndex(function (r) { return r[primaryKey] === transaction.id; });
                            if (deleteIndex !== -1) {
                                collection.splice(deleteIndex, 1);
                            }
                        }
                        break;
                }
            }
            else {
                //  if there is no path this is ADD row in root. Push the newValue to data
                data.push(transaction.newValue);
            }
        };
        var this_2 = this;
        try {
            for (var transactions_1 = tslib_1.__values(transactions), transactions_1_1 = transactions_1.next(); !transactions_1_1.done; transactions_1_1 = transactions_1.next()) {
                var transaction = transactions_1_1.value;
                _loop_2(transaction);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (transactions_1_1 && !transactions_1_1.done && (_a = transactions_1.return)) _a.call(transactions_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return data;
    };
    /**
     * @private
     * @param {?} data
     * @param {?} primaryKey
     * @param {?} childDataKey
     * @param {?} path
     * @return {?}
     */
    DataUtil.findParentFromPath = /**
     * @private
     * @param {?} data
     * @param {?} primaryKey
     * @param {?} childDataKey
     * @param {?} path
     * @return {?}
     */
    function (data, primaryKey, childDataKey, path) {
        var e_2, _a;
        /** @type {?} */
        var collection = data;
        /** @type {?} */
        var result;
        var _loop_3 = function (id) {
            result = collection && collection.find(function (x) { return x[primaryKey] === id; });
            if (!result) {
                return "break";
            }
            collection = result[childDataKey];
        };
        try {
            for (var path_1 = tslib_1.__values(path), path_1_1 = path_1.next(); !path_1_1.done; path_1_1 = path_1.next()) {
                var id = path_1_1.value;
                var state_2 = _loop_3(id);
                if (state_2 === "break")
                    break;
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (path_1_1 && !path_1_1.done && (_a = path_1.return)) _a.call(path_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return result;
    };
    return DataUtil;
}());
/**
 * @hidden
 */
export { DataUtil };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YS11dGlsLmpzIiwic291cmNlUm9vdCI6Im5nOi8vaWduaXRldWktYW5ndWxhci8iLCJzb3VyY2VzIjpbImxpYi9kYXRhLW9wZXJhdGlvbnMvZGF0YS11dGlsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBRUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxvQkFBb0IsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQ3RFLE9BQU8sRUFBa0IsV0FBVyxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFFbEUsT0FBTyxFQUFnQixXQUFXLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUtyRSxPQUFPLEVBQUUseUJBQXlCLEVBQUUsTUFBTSw2Q0FBNkMsQ0FBQztBQUV4RixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUV6RCxPQUFPLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN6RCxPQUFPLEVBQWUsZUFBZSxFQUEyQixNQUFNLHFDQUFxQyxDQUFDOzs7SUFNeEcsUUFBUyxRQUFRO0lBQ2pCLFFBQVMsUUFBUTtJQUNqQixTQUFVLFNBQVM7SUFDbkIsTUFBTyxNQUFNOzs7Ozs7QUFNakI7Ozs7SUFBQTtJQTZQQSxDQUFDOzs7Ozs7OztJQTVQaUIsYUFBSTs7Ozs7OztJQUFsQixVQUFzQixJQUFTLEVBQUUsV0FBaUMsRUFBRSxPQUFzQztRQUF0Qyx3QkFBQSxFQUFBLGNBQTBCLFVBQVUsRUFBRTtRQUN0RyxPQUFPLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBQzNDLENBQUM7Ozs7Ozs7SUFFYSxxQkFBWTs7Ozs7O0lBQTFCLFVBQTJCLGdCQUFtQyxFQUMxRCxXQUFpQyxFQUNqQyxNQUF3Qjs7WUFDcEIsR0FBRyxHQUFzQixFQUFFO1FBQy9CLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxVQUFDLEVBQW1COztnQkFDbkMsR0FBRyxHQUFvQixRQUFRLENBQUMsbUJBQW1CLENB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RTs7YUFFWjtZQUVELFVBQVUsR0FBRyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUM7OztZQU50QyxLQUFpQixJQUFBLFNBQUEsaUJBQUEsSUFBSSxDQUFBLDBCQUFBO2dCQUFoQixJQUFNLEVBQUUsaUJBQUE7c0NBQUYsRUFBRTs7O2FBT1o7Ozs7Ozs7OztRQUVELE9BQU8sTUFBTSxDQUFDO0lBQ2xCLENBQUM7SUFDTCxlQUFDO0FBQUQsQ0FBQyxBQTdQRCxJQTZQQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElGaWx0ZXJpbmdTdGF0ZSB9IGZyb20gJy4vZmlsdGVyaW5nLXN0YXRlLmludGVyZmFjZSc7XG5cbmltcG9ydCB7IElneFNvcnRpbmcsIElneERhdGFSZWNvcmRTb3J0aW5nIH0gZnJvbSAnLi9zb3J0aW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7IElHcm91cEJ5UmVzdWx0LCBJZ3hHcm91cGluZyB9IGZyb20gJy4vZ3JvdXBpbmctc3RyYXRlZ3knO1xuXG5pbXBvcnQgeyBJUGFnaW5nU3RhdGUsIFBhZ2luZ0Vycm9yIH0gZnJvbSAnLi9wYWdpbmctc3RhdGUuaW50ZXJmYWNlJztcblxuaW1wb3J0IHsgSUdyb3VwQnlFeHBhbmRTdGF0ZSwgSUdyb3VwQnlLZXkgfSBmcm9tICcuL2dyb3VwYnktZXhwYW5kLXN0YXRlLmludGVyZmFjZSc7XG5pbXBvcnQgeyBJR3JvdXBCeVJlY29yZCB9IGZyb20gJy4vZ3JvdXBieS1yZWNvcmQuaW50ZXJmYWNlJztcbmltcG9ydCB7IElHcm91cGluZ1N0YXRlIH0gZnJvbSAnLi9ncm91cGJ5LXN0YXRlLmludGVyZmFjZSc7XG5pbXBvcnQgeyBUcmVlR3JpZEZpbHRlcmluZ1N0cmF0ZWd5IH0gZnJvbSAnLi4vZ3JpZHMvdHJlZS1ncmlkL3RyZWUtZ3JpZC5maWx0ZXJpbmcucGlwZSc7XG5pbXBvcnQgeyBJU29ydGluZ0V4cHJlc3Npb24gfSBmcm9tICcuL3NvcnRpbmctZXhwcmVzc2lvbi5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgRmlsdGVyaW5nU3RyYXRlZ3kgfSBmcm9tICcuL2ZpbHRlcmluZy1zdHJhdGVneSc7XG5pbXBvcnQgeyBJVHJlZUdyaWRSZWNvcmQgfSBmcm9tICcuLi9ncmlkcy90cmVlLWdyaWQnO1xuaW1wb3J0IHsgY2xvbmVWYWx1ZSwgbWVyZ2VPYmplY3RzIH0gZnJvbSAnLi4vY29yZS91dGlscyc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiwgVHJhbnNhY3Rpb25UeXBlLCBIaWVyYXJjaGljYWxUcmFuc2FjdGlvbiB9IGZyb20gJy4uL3NlcnZpY2VzL3RyYW5zYWN0aW9uL3RyYW5zYWN0aW9uJztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBlbnVtIERhdGFUeXBlIHtcbiAgICBTdHJpbmcgPSAnc3RyaW5nJyxcbiAgICBOdW1iZXIgPSAnbnVtYmVyJyxcbiAgICBCb29sZWFuID0gJ2Jvb2xlYW4nLFxuICAgIERhdGUgPSAnZGF0ZSdcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBEYXRhVXRpbCB7XG4gICAgcHVibGljIHN0YXRpYyBzb3J0PFQ+KGRhdGE6IFRbXSwgZXhwcmVzc2lvbnM6IElTb3J0aW5nRXhwcmVzc2lvbltdLCBzb3J0aW5nOiBJZ3hTb3J0aW5nID0gbmV3IElneFNvcnRpbmcoKSk6IFRbXSB7XG4gICAgICAgIHJldHVybiBzb3J0aW5nLnNvcnQoZGF0YSwgZXhwcmVzc2lvbnMpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgdHJlZUdyaWRTb3J0KGhpZXJhcmNoaWNhbERhdGE6IElUcmVlR3JpZFJlY29yZFtdLFxuICAgICAgICBleHByZXNzaW9uczogSVNvcnRpbmdFeHByZXNzaW9uW10sXG4gICAgICAgIHBhcmVudD86IElUcmVlR3JpZFJlY29yZCk6IElUcmVlR3JpZFJlY29yZFtdIHtcbiAgICAgICAgbGV0IHJlczogSVRyZWVHcmlkUmVjb3JkW10gPSBbXTtcbiAgICAgICAgaGllcmFyY2hpY2FsRGF0YS5mb3JFYWNoKChocjogSVRyZWVHcmlkUmVjb3JkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZWM6IElUcmVlR3JpZFJlY29yZCA9IERhdGFVdGlsLmNsb25lVHJlZUdyaWRSZWNvcmQoaHIpO1xuICAgICAgICAgICAgcmVjLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgIGlmIChyZWMuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICByZWMuY2hpbGRyZW4gPSBEYXRhVXRpbC50cmVlR3JpZFNvcnQocmVjLmNoaWxkcmVuLCBleHByZXNzaW9ucywgcmVjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcy5wdXNoKHJlYyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJlcyA9IERhdGFVdGlsLnNvcnQocmVzLCBleHByZXNzaW9ucywgbmV3IElneERhdGFSZWNvcmRTb3J0aW5nKCkpO1xuXG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBjbG9uZVRyZWVHcmlkUmVjb3JkKGhpZXJhcmNoaWNhbFJlY29yZDogSVRyZWVHcmlkUmVjb3JkKSB7XG4gICAgICAgIGNvbnN0IHJlYzogSVRyZWVHcmlkUmVjb3JkID0ge1xuICAgICAgICAgICAgcm93SUQ6IGhpZXJhcmNoaWNhbFJlY29yZC5yb3dJRCxcbiAgICAgICAgICAgIGRhdGE6IGhpZXJhcmNoaWNhbFJlY29yZC5kYXRhLFxuICAgICAgICAgICAgY2hpbGRyZW46IGhpZXJhcmNoaWNhbFJlY29yZC5jaGlsZHJlbixcbiAgICAgICAgICAgIGlzRmlsdGVyZWRPdXRQYXJlbnQ6IGhpZXJhcmNoaWNhbFJlY29yZC5pc0ZpbHRlcmVkT3V0UGFyZW50LFxuICAgICAgICAgICAgbGV2ZWw6IGhpZXJhcmNoaWNhbFJlY29yZC5sZXZlbCxcbiAgICAgICAgICAgIGV4cGFuZGVkOiBoaWVyYXJjaGljYWxSZWNvcmQuZXhwYW5kZWRcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlYztcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGdyb3VwPFQ+KGRhdGE6IFRbXSwgc3RhdGU6IElHcm91cGluZ1N0YXRlLCBncmlkOiBhbnkgPSBudWxsLCBncm91cHNSZWNvcmRzOiBhbnlbXSA9IFtdKTogSUdyb3VwQnlSZXN1bHQge1xuICAgICAgICBjb25zdCBncm91cGluZyA9IG5ldyBJZ3hHcm91cGluZygpO1xuICAgICAgICBncm91cHNSZWNvcmRzLnNwbGljZSgwLCBncm91cHNSZWNvcmRzLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBncm91cGluZy5ncm91cEJ5KGRhdGEsIHN0YXRlLmV4cHJlc3Npb25zLCBncmlkLCBncm91cHNSZWNvcmRzKTtcbiAgICB9XG4gICAgcHVibGljIHN0YXRpYyByZXN0b3JlR3JvdXBzKGdyb3VwRGF0YTogSUdyb3VwQnlSZXN1bHQsIHN0YXRlOiBJR3JvdXBpbmdTdGF0ZSk6IGFueVtdIHtcbiAgICAgICAgaWYgKHN0YXRlLmV4cHJlc3Npb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGdyb3VwRGF0YS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3RvcmVHcm91cHNJdGVyYXRpdmUoZ3JvdXBEYXRhLCBzdGF0ZSk7XG4gICAgfVxuICAgIHByaXZhdGUgc3RhdGljIHJlc3RvcmVHcm91cHNJdGVyYXRpdmUoZ3JvdXBEYXRhOiBJR3JvdXBCeVJlc3VsdCwgc3RhdGU6IElHcm91cGluZ1N0YXRlKTogYW55W10ge1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGdyb3VwRGF0YS5tZXRhZGF0YTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW10sIGFkZGVkID0gW107XG4gICAgICAgIGxldCBjaGFpbjogYW55W107XG4gICAgICAgIGxldCBpID0gMCwgajtcbiAgICAgICAgbGV0IHBvaW50ZXI6IElHcm91cEJ5UmVjb3JkO1xuICAgICAgICBsZXQgZXhwYW5kZWQ6IGJvb2xlYW47XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBtZXRhZGF0YS5sZW5ndGg7KSB7XG4gICAgICAgICAgICBjaGFpbiA9IFttZXRhZGF0YVtpXV07XG4gICAgICAgICAgICBwb2ludGVyID0gbWV0YWRhdGFbaV0uZ3JvdXBQYXJlbnQ7XG4gICAgICAgICAgICAvLyBicmVhayBvZmYgaWYgdGhlIHBhcmVudCBpcyBhbHJlYWR5IGFkZGVkXG4gICAgICAgICAgICB3aGlsZSAocG9pbnRlciAmJiBhZGRlZFswXSAhPT0gcG9pbnRlcikge1xuICAgICAgICAgICAgICAgIGNoYWluLnB1c2gocG9pbnRlcik7XG4gICAgICAgICAgICAgICAgaWYgKGFkZGVkWzBdICYmIGFkZGVkWzBdLmxldmVsID09PSBwb2ludGVyLmxldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZGVkLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvaW50ZXIgPSBwb2ludGVyLmdyb3VwUGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChqID0gY2hhaW4ubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjaGFpbltqXSk7XG4gICAgICAgICAgICAgICAgYWRkZWQudW5zaGlmdChjaGFpbltqXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGllcmFyY2h5ID0gdGhpcy5nZXRIaWVyYXJjaHkoY2hhaW5bal0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cGFuZFN0YXRlOiBJR3JvdXBCeUV4cGFuZFN0YXRlID0gc3RhdGUuZXhwYW5zaW9uLmZpbmQoKHMpID0+XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNIaWVyYXJjaHlNYXRjaChzLmhpZXJhcmNoeSB8fCBbeyBmaWVsZE5hbWU6IGNoYWluW2pdLmV4cHJlc3Npb24uZmllbGROYW1lLCB2YWx1ZTogY2hhaW5bal0udmFsdWUgfV0sIGhpZXJhcmNoeSkpO1xuICAgICAgICAgICAgICAgIGV4cGFuZGVkID0gZXhwYW5kU3RhdGUgPyBleHBhbmRTdGF0ZS5leHBhbmRlZCA6IHN0YXRlLmRlZmF1bHRFeHBhbmRlZDtcbiAgICAgICAgICAgICAgICBpZiAoIWV4cGFuZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZGVkLnNoaWZ0KCk7XG4gICAgICAgICAgICBqID0gTWF0aC5tYXgoaiwgMCk7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IGNoYWluW2pdLnJlY29yZHMuZmluZEluZGV4KHIgPT4gciA9PT0gZ3JvdXBEYXRhLmRhdGFbaV0pO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gTWF0aC5taW4obWV0YWRhdGEubGVuZ3RoIC0gaSArIHN0YXJ0LCBjaGFpbltqXS5yZWNvcmRzLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoZXhwYW5kZWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCguLi5jaGFpbltqXS5yZWNvcmRzLnNsaWNlKHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkgKz0gZW5kIC0gc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcHVibGljIHN0YXRpYyBwYWdlPFQ+KGRhdGE6IFRbXSwgc3RhdGU6IElQYWdpbmdTdGF0ZSk6IFRbXSB7XG4gICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBjb25zdCBpbmRleCA9IHN0YXRlLmluZGV4O1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVjb3Jkc1BlclBhZ2UgPSBzdGF0ZS5yZWNvcmRzUGVyUGFnZTtcbiAgICAgICAgc3RhdGUubWV0YWRhdGEgPSB7XG4gICAgICAgICAgICBjb3VudFBhZ2VzOiAwLFxuICAgICAgICAgICAgY291bnRSZWNvcmRzOiBkYXRhLmxlbmd0aCxcbiAgICAgICAgICAgIGVycm9yOiBQYWdpbmdFcnJvci5Ob25lXG4gICAgICAgIH07XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaXNOYU4oaW5kZXgpKSB7XG4gICAgICAgICAgICBzdGF0ZS5tZXRhZGF0YS5lcnJvciA9IFBhZ2luZ0Vycm9yLkluY29ycmVjdFBhZ2VJbmRleDtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlY29yZHNQZXJQYWdlIDw9IDAgfHwgaXNOYU4ocmVjb3Jkc1BlclBhZ2UpKSB7XG4gICAgICAgICAgICBzdGF0ZS5tZXRhZGF0YS5lcnJvciA9IFBhZ2luZ0Vycm9yLkluY29ycmVjdFJlY29yZHNQZXJQYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tZXRhZGF0YS5jb3VudFBhZ2VzID0gTWF0aC5jZWlsKGxlbiAvIHJlY29yZHNQZXJQYWdlKTtcbiAgICAgICAgaWYgKCFsZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA+PSBzdGF0ZS5tZXRhZGF0YS5jb3VudFBhZ2VzKSB7XG4gICAgICAgICAgICBzdGF0ZS5tZXRhZGF0YS5lcnJvciA9IFBhZ2luZ0Vycm9yLkluY29ycmVjdFBhZ2VJbmRleDtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGEuc2xpY2UoaW5kZXggKiByZWNvcmRzUGVyUGFnZSwgKGluZGV4ICsgMSkgKiByZWNvcmRzUGVyUGFnZSk7XG4gICAgfVxuICAgIHB1YmxpYyBzdGF0aWMgZmlsdGVyPFQ+KGRhdGE6IFRbXSwgc3RhdGU6IElGaWx0ZXJpbmdTdGF0ZSk6IFRbXSB7XG4gICAgICAgIGlmICghc3RhdGUuc3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIHN0YXRlLnN0cmF0ZWd5ID0gbmV3IEZpbHRlcmluZ1N0cmF0ZWd5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlLnN0cmF0ZWd5LmZpbHRlcihkYXRhLCBzdGF0ZS5leHByZXNzaW9uc1RyZWUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgdHJlZUdyaWRGaWx0ZXIoZGF0YTogSVRyZWVHcmlkUmVjb3JkW10sIHN0YXRlOiBJRmlsdGVyaW5nU3RhdGUpOiBJVHJlZUdyaWRSZWNvcmRbXSB7XG4gICAgICAgIGlmICghc3RhdGUuc3RyYXRlZ3kpIHtcbiAgICAgICAgICAgIHN0YXRlLnN0cmF0ZWd5ID0gbmV3IFRyZWVHcmlkRmlsdGVyaW5nU3RyYXRlZ3koKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGUuc3RyYXRlZ3kuZmlsdGVyKGRhdGEsIHN0YXRlLmV4cHJlc3Npb25zVHJlZSk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBnZXRIaWVyYXJjaHkoZ1JvdzogSUdyb3VwQnlSZWNvcmQpOiBBcnJheTxJR3JvdXBCeUtleT4ge1xuICAgICAgICBjb25zdCBoaWVyYXJjaHk6IEFycmF5PElHcm91cEJ5S2V5PiA9IFtdO1xuICAgICAgICBpZiAoZ1JvdyAhPT0gdW5kZWZpbmVkICYmIGdSb3cuZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgaGllcmFyY2h5LnB1c2goeyBmaWVsZE5hbWU6IGdSb3cuZXhwcmVzc2lvbi5maWVsZE5hbWUsIHZhbHVlOiBnUm93LnZhbHVlIH0pO1xuICAgICAgICAgICAgd2hpbGUgKGdSb3cuZ3JvdXBQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBnUm93ID0gZ1Jvdy5ncm91cFBhcmVudDtcbiAgICAgICAgICAgICAgICBoaWVyYXJjaHkudW5zaGlmdCh7IGZpZWxkTmFtZTogZ1Jvdy5leHByZXNzaW9uLmZpZWxkTmFtZSwgdmFsdWU6IGdSb3cudmFsdWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhpZXJhcmNoeTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGlzSGllcmFyY2h5TWF0Y2goaDE6IEFycmF5PElHcm91cEJ5S2V5PiwgaDI6IEFycmF5PElHcm91cEJ5S2V5Pik6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoaDEubGVuZ3RoICE9PSBoMi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaDEuZXZlcnkoKGxldmVsLCBpbmRleCk6IGJvb2xlYW4gPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGxldmVsLmZpZWxkTmFtZSA9PT0gaDJbaW5kZXhdLmZpZWxkTmFtZSAmJiBsZXZlbC52YWx1ZSA9PT0gaDJbaW5kZXhdLnZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgYWxsIGNoYW5nZXMgZnJvbSBwcm92aWRlZCB0cmFuc2FjdGlvbnMgaW50byBwcm92aWRlZCBkYXRhIGNvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0gZGF0YSBDb2xsZWN0aW9uIHRvIG1lcmdlXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9ucyBUcmFuc2FjdGlvbnMgdG8gbWVyZ2UgaW50byBkYXRhXG4gICAgICogQHBhcmFtIHByaW1hcnlLZXkgUHJpbWFyeSBrZXkgb2YgdGhlIGNvbGxlY3Rpb24sIGlmIGFueVxuICAgICAqIEBwYXJhbSBkZWxldGVSb3dzIFNob3VsZCBkZWxldGUgcm93cyB3aXRoIERFTEVURSB0cmFuc2FjdGlvbiB0eXBlIGZyb20gZGF0YVxuICAgICAqIEByZXR1cm5zIFByb3ZpZGVkIGRhdGEgY29sbGVjdGlvbnMgdXBkYXRlZCB3aXRoIGFsbCBwcm92aWRlZCB0cmFuc2FjdGlvbnNcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIG1lcmdlVHJhbnNhY3Rpb25zPFQ+KGRhdGE6IFRbXSwgdHJhbnNhY3Rpb25zOiBUcmFuc2FjdGlvbltdLCBwcmltYXJ5S2V5PzogYW55LCBkZWxldGVSb3dzOiBib29sZWFuID0gZmFsc2UpOiBUW10ge1xuICAgICAgICBkYXRhLmZvckVhY2goKGl0ZW06IGFueSwgaW5kZXg6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgY29uc3Qgcm93SWQgPSBwcmltYXJ5S2V5ID8gaXRlbVtwcmltYXJ5S2V5XSA6IGl0ZW07XG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9ucy5maW5kKHQgPT4gdC5pZCA9PT0gcm93SWQpO1xuICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uICYmIHRyYW5zYWN0aW9uLnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5VUERBVEUpIHtcbiAgICAgICAgICAgICAgICBkYXRhW2luZGV4XSA9IHRyYW5zYWN0aW9uLm5ld1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZGVsZXRlUm93cykge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25zXG4gICAgICAgICAgICAgICAgLmZpbHRlcih0ID0+IHQudHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLkRFTEVURSlcbiAgICAgICAgICAgICAgICAuZm9yRWFjaCh0ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwcmltYXJ5S2V5ID8gZGF0YS5maW5kSW5kZXgoZCA9PiBkW3ByaW1hcnlLZXldID09PSB0LmlkKSA6IGRhdGEuZmluZEluZGV4KGQgPT4gZCA9PT0gdC5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgwIDw9IGluZGV4ICYmIGluZGV4IDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZGF0YS5wdXNoKC4uLnRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgLmZpbHRlcih0ID0+IHQudHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLkFERClcbiAgICAgICAgICAgIC5tYXAodCA9PiB0Lm5ld1ZhbHVlKSk7XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVyZ2VzIGFsbCBjaGFuZ2VzIGZyb20gcHJvdmlkZWQgdHJhbnNhY3Rpb25zIGludG8gcHJvdmlkZWQgaGllcmFyY2hpY2FsIGRhdGEgY29sbGVjdGlvblxuICAgICAqIEBwYXJhbSBkYXRhIENvbGxlY3Rpb24gdG8gbWVyZ2VcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25zIFRyYW5zYWN0aW9ucyB0byBtZXJnZSBpbnRvIGRhdGFcbiAgICAgKiBAcGFyYW0gY2hpbGREYXRhS2V5IERhdGEga2V5IG9mIGNoaWxkIGNvbGxlY3Rpb25zXG4gICAgICogQHBhcmFtIHByaW1hcnlLZXkgUHJpbWFyeSBrZXkgb2YgdGhlIGNvbGxlY3Rpb24sIGlmIGFueVxuICAgICAqIEBwYXJhbSBkZWxldGVSb3dzIFNob3VsZCBkZWxldGUgcm93cyB3aXRoIERFTEVURSB0cmFuc2FjdGlvbiB0eXBlIGZyb20gZGF0YVxuICAgICAqIEByZXR1cm5zIFByb3ZpZGVkIGRhdGEgY29sbGVjdGlvbnMgdXBkYXRlZCB3aXRoIGFsbCBwcm92aWRlZCB0cmFuc2FjdGlvbnNcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIG1lcmdlSGllcmFyY2hpY2FsVHJhbnNhY3Rpb25zKFxuICAgICAgICBkYXRhOiBhbnlbXSxcbiAgICAgICAgdHJhbnNhY3Rpb25zOiBIaWVyYXJjaGljYWxUcmFuc2FjdGlvbltdLFxuICAgICAgICBjaGlsZERhdGFLZXk6IGFueSxcbiAgICAgICAgcHJpbWFyeUtleT86IGFueSxcbiAgICAgICAgZGVsZXRlUm93czogYm9vbGVhbiA9IGZhbHNlKTogYW55W10ge1xuXG4gICAgICAgIGZvciAoY29uc3QgdHJhbnNhY3Rpb24gb2YgdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICBpZiAodHJhbnNhY3Rpb24ucGF0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZmluZFBhcmVudEZyb21QYXRoKGRhdGEsIHByaW1hcnlLZXksIGNoaWxkRGF0YUtleSwgdHJhbnNhY3Rpb24ucGF0aCk7XG4gICAgICAgICAgICAgICAgbGV0IGNvbGxlY3Rpb246IGFueVtdID0gcGFyZW50ID8gcGFyZW50W2NoaWxkRGF0YUtleV0gOiBkYXRhO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodHJhbnNhY3Rpb24udHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5BREQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgaWYgdGhlcmUgaXMgbm8gcGFyZW50IHRoaXMgaXMgQUREIHJvdyBhdCByb290IGxldmVsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50ICYmICFwYXJlbnRbY2hpbGREYXRhS2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFtjaGlsZERhdGFLZXldID0gY29sbGVjdGlvbiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbi5wdXNoKHRyYW5zYWN0aW9uLm5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5VUERBVEU6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVJbmRleCA9IGNvbGxlY3Rpb24uZmluZEluZGV4KHggPT4geFtwcmltYXJ5S2V5XSA9PT0gdHJhbnNhY3Rpb24uaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZUluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25bdXBkYXRlSW5kZXhdID0gbWVyZ2VPYmplY3RzKGNsb25lVmFsdWUoY29sbGVjdGlvblt1cGRhdGVJbmRleF0pLCB0cmFuc2FjdGlvbi5uZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuREVMRVRFOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlbGV0ZVJvd3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWxldGVJbmRleCA9IGNvbGxlY3Rpb24uZmluZEluZGV4KHIgPT4gcltwcmltYXJ5S2V5XSA9PT0gdHJhbnNhY3Rpb24uaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWxldGVJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbi5zcGxpY2UoZGVsZXRlSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gIGlmIHRoZXJlIGlzIG5vIHBhdGggdGhpcyBpcyBBREQgcm93IGluIHJvb3QuIFB1c2ggdGhlIG5ld1ZhbHVlIHRvIGRhdGFcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2godHJhbnNhY3Rpb24ubmV3VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3RhdGljIGZpbmRQYXJlbnRGcm9tUGF0aChkYXRhOiBhbnlbXSwgcHJpbWFyeUtleTogYW55LCBjaGlsZERhdGFLZXk6IGFueSwgcGF0aDogYW55W10pOiBhbnkge1xuICAgICAgICBsZXQgY29sbGVjdGlvbjogYW55W10gPSBkYXRhO1xuICAgICAgICBsZXQgcmVzdWx0OiBhbnk7XG5cbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBwYXRoKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjb2xsZWN0aW9uICYmIGNvbGxlY3Rpb24uZmluZCh4ID0+IHhbcHJpbWFyeUtleV0gPT09IGlkKTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbGxlY3Rpb24gPSByZXN1bHRbY2hpbGREYXRhS2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuIl19