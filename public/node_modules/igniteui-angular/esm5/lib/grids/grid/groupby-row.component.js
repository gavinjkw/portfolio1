/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, HostBinding, HostListener, Input, ViewChild, } from '@angular/core';
import { GridBaseAPIService } from '../api.service';
import { IgxGridSelectionService } from '../../core/grid-selection';
import { ROW_COLLAPSE_KEYS, ROW_EXPAND_KEYS, SUPPORTED_KEYS } from '../../core/utils';
var IgxGridGroupByRowComponent = /** @class */ (function () {
    function IgxGridGroupByRowComponent(gridAPI, gridSelection, element, cdr) {
        this.gridAPI = gridAPI;
        this.gridSelection = gridSelection;
        this.element = element;
        this.cdr = cdr;
        /**
         * @hidden
         */
        this.defaultCssClass = 'igx-grid__group-row';
        /**
         * @hidden
         */
        this.paddingIndentationCssClass = 'igx-grid__group-row--padding-level';
        /**
         * @hidden
         */
        this.isFocused = false;
        /**
         * @hidden
         */
        this.tabindex = 0;
    }
    Object.defineProperty(IgxGridGroupByRowComponent.prototype, "focused", {
        /**
         * Returns whether the row is focused.
         * ```
         * let gridRowFocused = this.grid1.rowList.first.focused;
         * ```
         */
        get: /**
         * Returns whether the row is focused.
         * ```
         * let gridRowFocused = this.grid1.rowList.first.focused;
         * ```
         * @return {?}
         */
        function () {
            return this.isFocused;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridGroupByRowComponent.prototype, "expanded", {
        /**
         * Returns whether the group row is expanded.
         * ```typescript
         * const groupRowExpanded = this.grid1.rowList.first.expanded;
         * ```
         */
        get: /**
         * Returns whether the group row is expanded.
         * ```typescript
         * const groupRowExpanded = this.grid1.rowList.first.expanded;
         * ```
         * @return {?}
         */
        function () {
            return this.grid.isExpandedGroup(this.groupRow);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridGroupByRowComponent.prototype, "describedBy", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            /** @type {?} */
            var grRowExpr = this.groupRow.expression !== undefined ? this.groupRow.expression.fieldName : '';
            return this.gridID + '_' + grRowExpr;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridGroupByRowComponent.prototype, "dataRowIndex", {
        get: /**
         * @return {?}
         */
        function () {
            return this.index;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridGroupByRowComponent.prototype, "nativeElement", {
        /**
         * Returns a reference to the underlying HTML element.
         * ```typescript
         * const groupRowElement = this.nativeElement;
         * ```
         */
        get: /**
         * Returns a reference to the underlying HTML element.
         * ```typescript
         * const groupRowElement = this.nativeElement;
         * ```
         * @return {?}
         */
        function () {
            return this.element.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridGroupByRowComponent.prototype, "styleClasses", {
        /**
         * Returns the style classes applied to the group rows.
         * ```typescript
         * const groupCssStyles = this.grid1.rowList.first.styleClasses;
         * ```
         */
        get: /**
         * Returns the style classes applied to the group rows.
         * ```typescript
         * const groupCssStyles = this.grid1.rowList.first.styleClasses;
         * ```
         * @return {?}
         */
        function () {
            return this.defaultCssClass + " " + (this.paddingIndentationCssClass + "-") + this.groupRow.level +
                (this.focused ? " " + this.defaultCssClass + "--active" : '');
        },
        enumerable: true,
        configurable: true
    });
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxGridGroupByRowComponent.prototype.onFocus = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.isFocused = true;
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxGridGroupByRowComponent.prototype.onBlur = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.isFocused = false;
    };
    /**
     * Toggles the group row.
     * ```typescript
     * this.grid1.rowList.first.toggle()
     * ```
     */
    /**
     * Toggles the group row.
     * ```typescript
     * this.grid1.rowList.first.toggle()
     * ```
     * @return {?}
     */
    IgxGridGroupByRowComponent.prototype.toggle = /**
     * Toggles the group row.
     * ```typescript
     * this.grid1.rowList.first.toggle()
     * ```
     * @return {?}
     */
    function () {
        /** @type {?} */
        var isVirtualized = !this.grid.verticalScrollContainer.dc.instance.notVirtual;
        /** @type {?} */
        var groupRowIndex = this.index;
        this.grid.toggleGroup(this.groupRow);
        if (isVirtualized) {
            /** @type {?} */
            var groupRow = this.grid.nativeElement.querySelector("[data-rowIndex=\"" + groupRowIndex + "\"]");
            if (groupRow) {
                groupRow.focus();
            }
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxGridGroupByRowComponent.prototype.onKeydown = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // TODO: Refactor
        /** @type {?} */
        var key = event.key.toLowerCase();
        if (!SUPPORTED_KEYS.has(key)) {
            return;
        }
        event.stopPropagation();
        /** @type {?} */
        var keydownArgs = { targetType: 'groupRow', target: this, event: event, cancel: false };
        this.grid.onGridKeydown.emit(keydownArgs);
        if (keydownArgs.cancel) {
            return;
        }
        event.preventDefault();
        if (!this.isKeySupportedInGroupRow(key, event.shiftKey, event.altKey) || event.ctrlKey) {
            return;
        }
        if (this.isToggleKey(key, event.altKey)) {
            if ((this.expanded && ROW_COLLAPSE_KEYS.has(key)) || (!this.expanded && ROW_EXPAND_KEYS.has(key))) {
                this.toggle();
            }
            return;
        }
        // TODO: to be deleted when onFocusChange event is removed #4054
        /** @type {?} */
        var args = { cell: this, groupRow: null, event: event, cancel: false };
        this.grid.onFocusChange.emit(args);
        if (args.cancel) {
            return;
        }
        /** @type {?} */
        var selection = this.gridSelection;
        selection.keyboardState.shift = event.shiftKey && !(key === 'tab');
        /** @type {?} */
        var visibleColumnIndex = selection.activeElement && this.grid.columnList.filter(function (col) { return !col.hidden; }).map(function (c) { return c.visibleIndex; })
            .indexOf(selection.activeElement.column) !== -1 ? selection.activeElement.column : 0;
        switch (key) {
            case 'arrowdown':
            case 'down':
                this.grid.navigation.navigateDown(this.nativeElement, this.index, visibleColumnIndex);
                break;
            case 'arrowup':
            case 'up':
                this.grid.navigation.navigateUp(this.nativeElement, this.index, visibleColumnIndex);
                break;
            case 'tab':
                this.handleTabKey(event.shiftKey);
                break;
        }
    };
    Object.defineProperty(IgxGridGroupByRowComponent.prototype, "grid", {
        /**
         * Returns a reference to the `IgxGridComponent` the `IgxGridGroupByRowComponent` belongs to.
         * ```typescript
         * this.grid1.rowList.first.grid;
         * ```
         */
        get: /**
         * Returns a reference to the `IgxGridComponent` the `IgxGridGroupByRowComponent` belongs to.
         * ```typescript
         * this.grid1.rowList.first.grid;
         * ```
         * @return {?}
         */
        function () {
            return this.gridAPI.grid;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridGroupByRowComponent.prototype, "dataType", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.grid.getColumnByName(this.groupRow.expression.fieldName).dataType;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @param {?} shift
     * @return {?}
     */
    IgxGridGroupByRowComponent.prototype.handleTabKey = /**
     * @private
     * @param {?} shift
     * @return {?}
     */
    function (shift) {
        if (shift) {
            this.grid.navigation.performShiftTabKey(this.nativeElement, this.index, 0);
        }
        else {
            if (this.index === this.grid.verticalScrollContainer.igxForOf.length - 1 && this.grid.rootSummariesEnabled) {
                this.grid.navigation.onKeydownHome(0, true);
            }
            else {
                this.grid.navigation.navigateDown(this.nativeElement, this.index, 0);
            }
        }
    };
    /**
     * @private
     * @param {?} key
     * @param {?=} shift
     * @param {?=} alt
     * @return {?}
     */
    IgxGridGroupByRowComponent.prototype.isKeySupportedInGroupRow = /**
     * @private
     * @param {?} key
     * @param {?=} shift
     * @param {?=} alt
     * @return {?}
     */
    function (key, shift, alt) {
        if (shift === void 0) { shift = false; }
        if (alt === void 0) { alt = false; }
        if (shift) {
            return ['down', 'up', 'arrowdown', 'arrowup', 'tab'].indexOf(key) !== -1;
        }
        return this.isToggleKey(key, alt) ? true : ['down', 'up', 'arrowdown', 'arrowup', 'tab'].indexOf(key) !== -1;
    };
    /**
     * @private
     * @param {?} key
     * @param {?} altKey
     * @return {?}
     */
    IgxGridGroupByRowComponent.prototype.isToggleKey = /**
     * @private
     * @param {?} key
     * @param {?} altKey
     * @return {?}
     */
    function (key, altKey) {
        return altKey && ['left', 'right', 'up', 'down', 'arrowleft', 'arrowright', 'arrowup', 'arrowdown'].indexOf(key) !== -1;
    };
    IgxGridGroupByRowComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-grid-groupby-row',
                    template: "<ng-container #defaultGroupRow>\n    <div (click)=\"toggle()\" class=\"igx-grid__grouping-indicator\">\n        <igx-icon *ngIf=\"!expanded\" fontSet=\"material\">expand_more</igx-icon>\n        <igx-icon *ngIf=\"expanded\" fontSet=\"material\">expand_less</igx-icon>\n    </div>\n\n    <div class=\"igx-grid__group-content\" #groupContent>\n        <ng-container *ngTemplateOutlet=\"grid.groupRowTemplate ? grid.groupRowTemplate : defaultGroupByTemplate; context: { $implicit: groupRow }\">\n        </ng-container>\n    </div>\n\n    <ng-template #defaultGroupByTemplate>\n        <div class=\"igx-group-label\">\n            <igx-icon fontSet=\"material\" class=\"igx-group-label__icon\">group_work</igx-icon>\n            <span class=\"igx-group-label__column-name\">\n            {{ groupRow.expression ? groupRow.expression.fieldName : '' }}:\n            </span>\n\n            <ng-container *ngIf=\"dataType === 'boolean' || dataType === 'string'; else default\" >\n                <span class=\"igx-group-label__text\">{{ groupRow.value }}</span>\n            </ng-container>\n            <ng-template #default>\n                <ng-container *ngIf=\"dataType === 'number'\">\n                    <span class=\"igx-group-label__text\">{{ groupRow.value | number }}</span>\n                </ng-container>\n                <ng-container *ngIf=\"dataType === 'date'\">\n                    <span class=\"igx-group-label__text\">{{ groupRow.value | date }}</span>\n                </ng-container>\n            </ng-template>\n\n            <igx-badge [value]=\"groupRow.records ? groupRow.records.length : 0\" class='igx-group-label__count-badge'></igx-badge>\n        </div>\n    </ng-template>\n</ng-container>\n"
                }] }
    ];
    /** @nocollapse */
    IgxGridGroupByRowComponent.ctorParameters = function () { return [
        { type: GridBaseAPIService },
        { type: IgxGridSelectionService },
        { type: ElementRef },
        { type: ChangeDetectorRef }
    ]; };
    IgxGridGroupByRowComponent.propDecorators = {
        isFocused: [{ type: Input }],
        index: [{ type: Input }],
        gridID: [{ type: Input }],
        groupRow: [{ type: Input }],
        groupContent: [{ type: ViewChild, args: ['groupContent',] }],
        expanded: [{ type: HostBinding, args: ['attr.aria-expanded',] }],
        tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
        describedBy: [{ type: HostBinding, args: ['attr.aria-describedby',] }],
        dataRowIndex: [{ type: HostBinding, args: ['attr.data-rowIndex',] }],
        styleClasses: [{ type: HostBinding, args: ['class',] }],
        onFocus: [{ type: HostListener, args: ['focus',] }],
        onBlur: [{ type: HostListener, args: ['blur',] }],
        onKeydown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
    };
    return IgxGridGroupByRowComponent;
}());
export { IgxGridGroupByRowComponent };
if (false) {
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxGridGroupByRowComponent.prototype.defaultCssClass;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxGridGroupByRowComponent.prototype.paddingIndentationCssClass;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxGridGroupByRowComponent.prototype.isFocused;
    /**
     * An \@Input property that sets the index of the row.
     * ```html
     * <igx-grid-groupby-row [gridID]="id" [index]="rowIndex" [groupRow]="rowData" #row></igx-grid-groupby-row>
     * ```
     * @type {?}
     */
    IgxGridGroupByRowComponent.prototype.index;
    /**
     * An \@Input property that sets the id of the grid the row belongs to.
     * ```html
     * <igx-grid-groupby-row [gridID]="id" [index]="rowIndex" [groupRow]="rowData" #row></igx-grid-groupby-row>
     * ```
     * @type {?}
     */
    IgxGridGroupByRowComponent.prototype.gridID;
    /**
     * An \@Input property that specifies the group record the component renders for.
     * ```typescript
     * <igx-grid-groupby-row [gridID]="id" [index]="rowIndex" [groupRow]="rowData" #row></igx-grid-groupby-row>
     * ```
     * @type {?}
     */
    IgxGridGroupByRowComponent.prototype.groupRow;
    /**
     * Returns a reference of the content of the group.
     * ```typescript
     * const groupRowContent = this.grid1.rowList.first.groupContent;
     * ```
     * @type {?}
     */
    IgxGridGroupByRowComponent.prototype.groupContent;
    /**
     * @hidden
     * @type {?}
     */
    IgxGridGroupByRowComponent.prototype.tabindex;
    /** @type {?} */
    IgxGridGroupByRowComponent.prototype.gridAPI;
    /**
     * @type {?}
     * @private
     */
    IgxGridGroupByRowComponent.prototype.gridSelection;
    /** @type {?} */
    IgxGridGroupByRowComponent.prototype.element;
    /** @type {?} */
    IgxGridGroupByRowComponent.prototype.cdr;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JvdXBieS1yb3cuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vaWduaXRldWktYW5ndWxhci8iLCJzb3VyY2VzIjpbImxpYi9ncmlkcy9ncmlkL2dyb3VwYnktcm93LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUNILHVCQUF1QixFQUN2QixpQkFBaUIsRUFDakIsU0FBUyxFQUNULFVBQVUsRUFDVixXQUFXLEVBQ1gsWUFBWSxFQUNaLEtBQUssRUFDTCxTQUFTLEdBQ1osTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFcEQsT0FBTyxFQUFFLHVCQUF1QixFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDcEUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLGVBQWUsRUFBRSxjQUFjLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUV0RjtJQVFJLG9DQUFtQixPQUFxRSxFQUM1RSxhQUFzQyxFQUN2QyxPQUFtQixFQUNuQixHQUFzQjtRQUhkLFlBQU8sR0FBUCxPQUFPLENBQThEO1FBQzVFLGtCQUFhLEdBQWIsYUFBYSxDQUF5QjtRQUN2QyxZQUFPLEdBQVAsT0FBTyxDQUFZO1FBQ25CLFFBQUcsR0FBSCxHQUFHLENBQW1COzs7O1FBS3ZCLG9CQUFlLEdBQUcscUJBQXFCLENBQUM7Ozs7UUFLeEMsK0JBQTBCLEdBQUcsb0NBQW9DLENBQUM7Ozs7UUFNbEUsY0FBUyxHQUFHLEtBQUssQ0FBQzs7OztRQStEckIsYUFBUSxHQUFHLENBQUMsQ0FBQztJQS9FaUIsQ0FBQztJQXdCdEMsc0JBQUksK0NBQU87UUFOWDs7Ozs7V0FLRzs7Ozs7Ozs7UUFDSDtZQUNJLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQztRQUMxQixDQUFDOzs7T0FBQTtJQTRDRCxzQkFDSSxnREFBUTtRQVBaOzs7OztXQUtHOzs7Ozs7OztRQUNIO1lBRUksT0FBTyxJQUFJLENBQUMsSUFB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LENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQzVILENBQUM7O2dCQTNQSixTQUFTLFNBQUM7b0JBQ1AsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07b0JBQy9DLG1CQUFtQixFQUFFLEtBQUs7b0JBQzFCLFFBQVEsRUFBRSxzQkFBc0I7b0JBQ2hDLG9zREFBMkM7aUJBQzlDOzs7O2dCQVZRLGtCQUFrQjtnQkFFbEIsdUJBQXVCO2dCQVQ1QixVQUFVO2dCQUZWLGlCQUFpQjs7OzRCQXdDaEIsS0FBSzt3QkFtQkwsS0FBSzt5QkFTTCxLQUFLOzJCQVNMLEtBQUs7K0JBU0wsU0FBUyxTQUFDLGNBQWM7MkJBU3hCLFdBQVcsU0FBQyxvQkFBb0I7MkJBUWhDLFdBQVcsU0FBQyxlQUFlOzhCQU0zQixXQUFXLFNBQUMsdUJBQXVCOytCQU1uQyxXQUFXLFNBQUMsb0JBQW9COytCQXFCaEMsV0FBVyxTQUFDLE9BQU87MEJBU25CLFlBQVksU0FBQyxPQUFPO3lCQVFwQixZQUFZLFNBQUMsTUFBTTs0QkEwQm5CLFlBQVksU0FBQyxTQUFTLEVBQUUsQ0FBQyxRQUFRLENBQUM7O0lBd0Z2QyxpQ0FBQztDQUFBLEFBN1BELElBNlBDO1NBdlBZLDBCQUEwQjs7Ozs7OztJQVVuQyxxREFBa0Q7Ozs7OztJQUtsRCxnRUFBNEU7Ozs7OztJQUs1RSwrQ0FDNEI7Ozs7Ozs7O0lBa0I1QiwyQ0FDcUI7Ozs7Ozs7O0lBUXJCLDRDQUNzQjs7Ozs7Ozs7SUFRdEIsOENBQ2dDOzs7Ozs7OztJQVFoQyxrREFDZ0M7Ozs7O0lBZ0JoQyw4Q0FDb0I7O0lBbEZSLDZDQUE0RTs7Ozs7SUFDcEYsbURBQThDOztJQUM5Qyw2Q0FBMEI7O0lBQzFCLHlDQUE2QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQ29tcG9uZW50LFxuICAgIEVsZW1lbnRSZWYsXG4gICAgSG9zdEJpbmRpbmcsXG4gICAgSG9zdExpc3RlbmVyLFxuICAgIElucHV0LFxuICAgIFZpZXdDaGlsZCxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJR3JvdXBCeVJlY29yZCB9IGZyb20gJy4uLy4uL2RhdGEtb3BlcmF0aW9ucy9ncm91cGJ5LXJlY29yZC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgR3JpZEJhc2VBUElTZXJ2aWNlIH0gZnJvbSAnLi4vYXBpLnNlcnZpY2UnO1xuaW1wb3J0IHsgSWd4R3JpZEJhc2VDb21wb25lbnQsIElHcmlkRGF0YUJpbmRhYmxlIH0gZnJvbSAnLi4vZ3JpZC1iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hHcmlkU2VsZWN0aW9uU2VydmljZSB9IGZyb20gJy4uLy4uL2NvcmUvZ3JpZC1zZWxlY3Rpb24nO1xuaW1wb3J0IHsgUk9XX0NPTExBUFNFX0tFWVMsIFJPV19FWFBBTkRfS0VZUywgU1VQUE9SVEVEX0tFWVMgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWxzJztcblxuQENvbXBvbmVudCh7XG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2UsXG4gICAgc2VsZWN0b3I6ICdpZ3gtZ3JpZC1ncm91cGJ5LXJvdycsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2dyb3VwYnktcm93LmNvbXBvbmVudC5odG1sJ1xufSlcbmV4cG9ydCBjbGFzcyBJZ3hHcmlkR3JvdXBCeVJvd0NvbXBvbmVudCB7XG5cbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgZ3JpZEFQSTogR3JpZEJhc2VBUElTZXJ2aWNlPElneEdyaWRCYXNlQ29tcG9uZW50ICYgSUdyaWREYXRhQmluZGFibGU+LFxuICAgICAgICBwcml2YXRlIGdyaWRTZWxlY3Rpb246IElneEdyaWRTZWxlY3Rpb25TZXJ2aWNlLFxuICAgICAgICBwdWJsaWMgZWxlbWVudDogRWxlbWVudFJlZixcbiAgICAgICAgcHVibGljIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYpIHsgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBkZWZhdWx0Q3NzQ2xhc3MgPSAnaWd4LWdyaWRfX2dyb3VwLXJvdyc7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHBhZGRpbmdJbmRlbnRhdGlvbkNzc0NsYXNzID0gJ2lneC1ncmlkX19ncm91cC1yb3ctLXBhZGRpbmctbGV2ZWwnO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHJvdGVjdGVkIGlzRm9jdXNlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSByb3cgaXMgZm9jdXNlZC5cbiAgICAgKiBgYGBcbiAgICAgKiBsZXQgZ3JpZFJvd0ZvY3VzZWQgPSB0aGlzLmdyaWQxLnJvd0xpc3QuZmlyc3QuZm9jdXNlZDtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgZm9jdXNlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNGb2N1c2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIGluZGV4IG9mIHRoZSByb3cuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZC1ncm91cGJ5LXJvdyBbZ3JpZElEXT1cImlkXCIgW2luZGV4XT1cInJvd0luZGV4XCIgW2dyb3VwUm93XT1cInJvd0RhdGFcIiAjcm93PjwvaWd4LWdyaWQtZ3JvdXBieS1yb3c+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaW5kZXg6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIGlkIG9mIHRoZSBncmlkIHRoZSByb3cgYmVsb25ncyB0by5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkLWdyb3VwYnktcm93IFtncmlkSURdPVwiaWRcIiBbaW5kZXhdPVwicm93SW5kZXhcIiBbZ3JvdXBSb3ddPVwicm93RGF0YVwiICNyb3c+PC9pZ3gtZ3JpZC1ncm91cGJ5LXJvdz5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBncmlkSUQ6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNwZWNpZmllcyB0aGUgZ3JvdXAgcmVjb3JkIHRoZSBjb21wb25lbnQgcmVuZGVycyBmb3IuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIDxpZ3gtZ3JpZC1ncm91cGJ5LXJvdyBbZ3JpZElEXT1cImlkXCIgW2luZGV4XT1cInJvd0luZGV4XCIgW2dyb3VwUm93XT1cInJvd0RhdGFcIiAjcm93PjwvaWd4LWdyaWQtZ3JvdXBieS1yb3c+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ3JvdXBSb3c6IElHcm91cEJ5UmVjb3JkO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHJlZmVyZW5jZSBvZiB0aGUgY29udGVudCBvZiB0aGUgZ3JvdXAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGdyb3VwUm93Q29udGVudCA9IHRoaXMuZ3JpZDEucm93TGlzdC5maXJzdC5ncm91cENvbnRlbnQ7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnZ3JvdXBDb250ZW50JylcbiAgICBwdWJsaWMgZ3JvdXBDb250ZW50OiBFbGVtZW50UmVmO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBncm91cCByb3cgaXMgZXhwYW5kZWQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGdyb3VwUm93RXhwYW5kZWQgPSB0aGlzLmdyaWQxLnJvd0xpc3QuZmlyc3QuZXhwYW5kZWQ7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtZXhwYW5kZWQnKVxuICAgIGdldCBleHBhbmRlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5pc0V4cGFuZGVkR3JvdXAodGhpcy5ncm91cFJvdyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci50YWJpbmRleCcpXG4gICAgcHVibGljIHRhYmluZGV4ID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS1kZXNjcmliZWRieScpXG4gICAgZ2V0IGRlc2NyaWJlZEJ5KCk6IHN0cmluZyB7XG4gICAgICAgIGNvbnN0IGdyUm93RXhwciA9IHRoaXMuZ3JvdXBSb3cuZXhwcmVzc2lvbiAhPT0gdW5kZWZpbmVkID8gdGhpcy5ncm91cFJvdy5leHByZXNzaW9uLmZpZWxkTmFtZSA6ICcnO1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkSUQgKyAnXycgKyBnclJvd0V4cHI7XG4gICAgfVxuXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmRhdGEtcm93SW5kZXgnKVxuICAgIGdldCBkYXRhUm93SW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIHVuZGVybHlpbmcgSFRNTCBlbGVtZW50LlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBncm91cFJvd0VsZW1lbnQgPSB0aGlzLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IG5hdGl2ZUVsZW1lbnQoKTogYW55IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHN0eWxlIGNsYXNzZXMgYXBwbGllZCB0byB0aGUgZ3JvdXAgcm93cy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgZ3JvdXBDc3NTdHlsZXMgPSB0aGlzLmdyaWQxLnJvd0xpc3QuZmlyc3Quc3R5bGVDbGFzc2VzO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MnKVxuICAgIGdldCBzdHlsZUNsYXNzZXMoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuZGVmYXVsdENzc0NsYXNzfSBgICsgYCR7dGhpcy5wYWRkaW5nSW5kZW50YXRpb25Dc3NDbGFzc30tYCArIHRoaXMuZ3JvdXBSb3cubGV2ZWwgK1xuICAgICAgICAgICAgKHRoaXMuZm9jdXNlZCA/IGAgJHt0aGlzLmRlZmF1bHRDc3NDbGFzc30tLWFjdGl2ZWAgOiAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RMaXN0ZW5lcignZm9jdXMnKVxuICAgIHB1YmxpYyBvbkZvY3VzKCkge1xuICAgICAgICB0aGlzLmlzRm9jdXNlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RMaXN0ZW5lcignYmx1cicpXG4gICAgcHVibGljIG9uQmx1cigpIHtcbiAgICAgICAgdGhpcy5pc0ZvY3VzZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSBncm91cCByb3cuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuZ3JpZDEucm93TGlzdC5maXJzdC50b2dnbGUoKVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyB0b2dnbGUoKSB7XG4gICAgICAgIGNvbnN0IGlzVmlydHVhbGl6ZWQgPSAhdGhpcy5ncmlkLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLmRjLmluc3RhbmNlLm5vdFZpcnR1YWw7XG4gICAgICAgIGNvbnN0IGdyb3VwUm93SW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICB0aGlzLmdyaWQudG9nZ2xlR3JvdXAodGhpcy5ncm91cFJvdyk7XG4gICAgICAgIGlmIChpc1ZpcnR1YWxpemVkKSB7XG4gICAgICAgICAgICBjb25zdCBncm91cFJvdyA9IHRoaXMuZ3JpZC5uYXRpdmVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLXJvd0luZGV4PVwiJHtncm91cFJvd0luZGV4fVwiXWApO1xuICAgICAgICAgICAgaWYgKGdyb3VwUm93KSB7XG4gICAgICAgICAgICAgICAgZ3JvdXBSb3cuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdExpc3RlbmVyKCdrZXlkb3duJywgWyckZXZlbnQnXSlcbiAgICBwdWJsaWMgb25LZXlkb3duKGV2ZW50KSB7XG4gICAgICAgIC8vIFRPRE86IFJlZmFjdG9yXG4gICAgICAgIGNvbnN0IGtleSA9IGV2ZW50LmtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIVNVUFBPUlRFRF9LRVlTLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGNvbnN0IGtleWRvd25BcmdzID0geyB0YXJnZXRUeXBlOiAnZ3JvdXBSb3cnLCB0YXJnZXQ6IHRoaXMsIGV2ZW50OiBldmVudCwgY2FuY2VsOiBmYWxzZSB9O1xuICAgICAgICB0aGlzLmdyaWQub25HcmlkS2V5ZG93bi5lbWl0KGtleWRvd25BcmdzKTtcbiAgICAgICAgaWYgKGtleWRvd25BcmdzLmNhbmNlbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzS2V5U3VwcG9ydGVkSW5Hcm91cFJvdyhrZXksIGV2ZW50LnNoaWZ0S2V5LCBldmVudC5hbHRLZXkpIHx8IGV2ZW50LmN0cmxLZXkpIHsgcmV0dXJuOyB9XG5cbiAgICAgICAgaWYgKHRoaXMuaXNUb2dnbGVLZXkoa2V5LCBldmVudC5hbHRLZXkpKSB7XG4gICAgICAgICAgICBpZiAoKHRoaXMuZXhwYW5kZWQgJiYgUk9XX0NPTExBUFNFX0tFWVMuaGFzKGtleSkpIHx8ICghdGhpcy5leHBhbmRlZCAmJiBST1dfRVhQQU5EX0tFWVMuaGFzKGtleSkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b2dnbGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiB0byBiZSBkZWxldGVkIHdoZW4gb25Gb2N1c0NoYW5nZSBldmVudCBpcyByZW1vdmVkICM0MDU0XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB7IGNlbGw6IHRoaXMsIGdyb3VwUm93OiBudWxsLCBldmVudDogZXZlbnQsIGNhbmNlbDogZmFsc2UgfTtcbiAgICAgICAgdGhpcy5ncmlkLm9uRm9jdXNDaGFuZ2UuZW1pdChhcmdzKTtcbiAgICAgICAgaWYgKGFyZ3MuY2FuY2VsKSB7IHJldHVybjsgfVxuXG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuZ3JpZFNlbGVjdGlvbjtcbiAgICAgICAgc2VsZWN0aW9uLmtleWJvYXJkU3RhdGUuc2hpZnQgPSBldmVudC5zaGlmdEtleSAmJiAhKGtleSA9PT0gJ3RhYicpO1xuXG4gICAgICAgIGNvbnN0IHZpc2libGVDb2x1bW5JbmRleCA9IHNlbGVjdGlvbi5hY3RpdmVFbGVtZW50ICYmIHRoaXMuZ3JpZC5jb2x1bW5MaXN0LmZpbHRlcihjb2wgPT4gIWNvbC5oaWRkZW4pLm1hcChjID0+IGMudmlzaWJsZUluZGV4KVxuICAgICAgICAgICAgICAgIC5pbmRleE9mKHNlbGVjdGlvbi5hY3RpdmVFbGVtZW50LmNvbHVtbikgIT09IC0xID8gc2VsZWN0aW9uLmFjdGl2ZUVsZW1lbnQuY29sdW1uIDogMDtcbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Fycm93ZG93bic6XG4gICAgICAgICAgICBjYXNlICdkb3duJzpcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWQubmF2aWdhdGlvbi5uYXZpZ2F0ZURvd24odGhpcy5uYXRpdmVFbGVtZW50LCB0aGlzLmluZGV4LCB2aXNpYmxlQ29sdW1uSW5kZXgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYXJyb3d1cCc6XG4gICAgICAgICAgICBjYXNlICd1cCc6XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkLm5hdmlnYXRpb24ubmF2aWdhdGVVcCh0aGlzLm5hdGl2ZUVsZW1lbnQsIHRoaXMuaW5kZXgsIHZpc2libGVDb2x1bW5JbmRleCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd0YWInOlxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlVGFiS2V5KGV2ZW50LnNoaWZ0S2V5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGBJZ3hHcmlkQ29tcG9uZW50YCB0aGUgYElneEdyaWRHcm91cEJ5Um93Q29tcG9uZW50YCBiZWxvbmdzIHRvLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmdyaWQxLnJvd0xpc3QuZmlyc3QuZ3JpZDtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgZ3JpZCgpOiBhbnkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkQVBJLmdyaWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBkYXRhVHlwZSgpOiBhbnkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkLmdldENvbHVtbkJ5TmFtZSh0aGlzLmdyb3VwUm93LmV4cHJlc3Npb24uZmllbGROYW1lKS5kYXRhVHlwZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhhbmRsZVRhYktleShzaGlmdCkge1xuICAgICAgICBpZiAoc2hpZnQpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5uYXZpZ2F0aW9uLnBlcmZvcm1TaGlmdFRhYktleSh0aGlzLm5hdGl2ZUVsZW1lbnQsIHRoaXMuaW5kZXgsIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggPT09IHRoaXMuZ3JpZC52ZXJ0aWNhbFNjcm9sbENvbnRhaW5lci5pZ3hGb3JPZi5sZW5ndGggLSAxICYmIHRoaXMuZ3JpZC5yb290U3VtbWFyaWVzRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC5uYXZpZ2F0aW9uLm9uS2V5ZG93bkhvbWUoMCwgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC5uYXZpZ2F0aW9uLm5hdmlnYXRlRG93bih0aGlzLm5hdGl2ZUVsZW1lbnQsIHRoaXMuaW5kZXgsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpc0tleVN1cHBvcnRlZEluR3JvdXBSb3coa2V5LCBzaGlmdCA9IGZhbHNlLCBhbHQgPSBmYWxzZSkge1xuICAgICAgICBpZiAoc2hpZnQpIHtcbiAgICAgICAgICAgIHJldHVybiBbJ2Rvd24nLCAndXAnLCAnYXJyb3dkb3duJywgJ2Fycm93dXAnLCAndGFiJ10uaW5kZXhPZihrZXkpICE9PSAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pc1RvZ2dsZUtleShrZXksIGFsdCkgPyB0cnVlIDogWydkb3duJywgJ3VwJywgJ2Fycm93ZG93bicsICdhcnJvd3VwJywgJ3RhYiddLmluZGV4T2Yoa2V5KSAhPT0gLTE7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBpc1RvZ2dsZUtleShrZXksIGFsdEtleSkge1xuICAgICAgICByZXR1cm4gYWx0S2V5ICYmIFsnbGVmdCcsICdyaWdodCcsICd1cCcsICdkb3duJywgJ2Fycm93bGVmdCcsICdhcnJvd3JpZ2h0JywgJ2Fycm93dXAnLCAnYXJyb3dkb3duJ10uaW5kZXhPZihrZXkpICE9PSAtMTtcbiAgICB9XG5cbn1cbiJdfQ==