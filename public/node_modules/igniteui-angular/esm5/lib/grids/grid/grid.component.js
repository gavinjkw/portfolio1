/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Component, ChangeDetectionStrategy, Input, Output, EventEmitter, ContentChild, ViewChildren, QueryList, ViewChild, ElementRef, TemplateRef, NgZone, ChangeDetectorRef, ComponentFactoryResolver, IterableDiffers, ViewContainerRef, Inject, HostBinding, forwardRef, Optional } from '@angular/core';
import { GridBaseAPIService } from '../api.service';
import { IgxGridBaseComponent, IgxGridTransaction, FilterMode } from '../grid-base.component';
import { IgxGridNavigationService } from '../grid-navigation.service';
import { IgxGridAPIService } from './grid-api.service';
import { cloneArray } from '../../core/utils';
import { IgxGroupByRowTemplateDirective } from './grid.directives';
import { IgxGridGroupByRowComponent } from './groupby-row.component';
import { DisplayDensityToken } from '../../core/displayDensity';
import { DataUtil } from '../../data-operations/data-util';
import { IgxSelectionAPIService } from '../../core/selection';
import { DOCUMENT } from '@angular/common';
import { takeUntil } from 'rxjs/operators';
import { IgxFilteringService } from '../filtering/grid-filtering.service';
import { IgxColumnResizingService } from '../grid-column-resizing.service';
import { IgxGridSummaryService } from '../summaries/grid-summary.service';
import { IgxGridSelectionService, IgxGridCRUDService } from '../../core/grid-selection';
import { IgxOverlayService } from '../../services/index';
import { IgxForOfSyncService } from '../../directives/for-of/for_of.sync.service';
import { IgxDragIndicatorIconDirective } from '../row-drag.directive';
/** @type {?} */
var NEXT_ID = 0;
/**
 * @record
 */
export function IGridFocusChangeEventArgs() { }
if (false) {
    /** @type {?} */
    IGridFocusChangeEventArgs.prototype.groupRow;
}
/**
 * @record
 */
export function IGroupingDoneEventArgs() { }
if (false) {
    /** @type {?} */
    IGroupingDoneEventArgs.prototype.expressions;
    /** @type {?} */
    IGroupingDoneEventArgs.prototype.groupedColumns;
    /** @type {?} */
    IGroupingDoneEventArgs.prototype.ungroupedColumns;
}
/**
 * **Ignite UI for Angular Grid** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid.html)
 *
 * The Ignite UI Grid is used for presenting and manipulating tabular data in the simplest way possible.  Once data
 * has been bound, it can be manipulated through filtering, sorting & editing operations.
 *
 * Example:
 * ```html
 * <igx-grid [data]="employeeData" autoGenerate="false">
 *   <igx-column field="first" header="First Name"></igx-column>
 *   <igx-column field="last" header="Last Name"></igx-column>
 *   <igx-column field="role" header="Role"></igx-column>
 * </igx-grid>
 * ```
 */
var IgxGridComponent = /** @class */ (function (_super) {
    tslib_1.__extends(IgxGridComponent, _super);
    function IgxGridComponent(selectionService, crudService, colResizingService, gridAPI, selection, _transactions, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions) {
        var _this = _super.call(this, selectionService, crudService, gridAPI, selection, _transactions, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions) || this;
        _this.colResizingService = colResizingService;
        _this.document = document;
        _this.overlayService = overlayService;
        _this._displayDensityOptions = _displayDensityOptions;
        _this._id = "igx-grid-" + NEXT_ID++;
        /**
         * @hidden
         */
        _this._groupingExpressions = [];
        /**
         * @hidden
         */
        _this._groupingExpandState = [];
        _this._hideGroupedColumns = false;
        _this._dropAreaMessage = null;
        _this._filteredData = null;
        /**
         * An \@Input property that determines whether created groups are rendered expanded or collapsed.
         * The default rendered state is expanded.
         * ```html
         * <igx-grid #grid [data]="Data" [groupsExpanded]="false" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridComponent
         */
        _this.groupsExpanded = true;
        /**
         * A hierarchical representation of the group by records.
         * ```typescript
         * let groupRecords = this.grid.groupsRecords;
         * ```
         * \@memberof IgxGridComponent
         */
        _this.groupsRecords = [];
        /**
         * Emitted when a new `IgxColumnComponent` gets grouped/ungrouped, or multiple columns get
         * grouped/ungrouped at once by using the Group By API.
         * The `onGroupingDone` event would be raised only once if several columns get grouped at once by calling
         * the `groupBy()` or `clearGrouping()` API methods and passing an array as an argument.
         * The event arguments provide the `expressions`, `groupedColumns` and `ungroupedColumns` properties, which contain
         * the `ISortingExpression` and the `IgxColumnComponent` related to the grouping/ungrouping operation.
         * Please note that `groupedColumns` and `ungroupedColumns` show only the **newly** changed columns (affected by the **last**
         * grouping/ungrouping operation), not all columns which are currently grouped/ungrouped.
         * columns.
         * ```typescript
         * groupingDone(event: IGroupingDoneEventArgs){
         *     const expressions = event.expressions;
         *     //the newly grouped columns
         *     const groupedColumns = event.groupedColumns;
         *     //the newly ungrouped columns
         *     const ungroupedColumns = event.ungroupedColumns;
         * }
         * ```
         * ```html
         * <igx-grid #grid [data]="localData" (onGroupingDone)="groupingDone($event)" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridComponent
         */
        _this.onGroupingDone = new EventEmitter();
        _this.onFocusChange = new EventEmitter();
        /**
         * The custom template, if any, that should be used when rendering the row drag indicator icon
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.dragIndicatorIconTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-grid #grid>
         *      ...
         *      <ng-template igxDragIndicatorIcon>
         *          <igx-icon fontSet="material">info</igx-icon>
         *      </ng-template>
         *  </igx-grid>
         * ```
         */
        _this.dragIndicatorIconTemplate = null;
        _this._gridAPI = (/** @type {?} */ (gridAPI));
        return _this;
    }
    Object.defineProperty(IgxGridComponent.prototype, "id", {
        /**
         * An @Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-grid [id]="'igx-grid-1'" [data]="Data" [autoGenerate]="true"></igx-grid>
         * ```
         * @memberof IgxGridComponent
         */
        get: /**
         * An \@Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-grid [id]="'igx-grid-1'" [data]="Data" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */
        function () {
            return this._id;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._id = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridComponent.prototype, "data", {
        /**
         * An @Input property that lets you fill the `IgxGridComponent` with an array of data.
         * ```html
         * <igx-grid [data]="Data" [autoGenerate]="true"></igx-grid>
         * ```
         * @memberof IgxGridBaseComponent
        */
        get: /**
         * An \@Input property that lets you fill the `IgxGridComponent` with an array of data.
         * ```html
         * <igx-grid [data]="Data" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this._data;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._data = value;
            if (this._ngAfterViewInitPassed &&
                this.calcHeight === null &&
                this.isPercentHeight) {
                /* the body should be auto-sized in this case before igxFor renders the whole data */
                /** @type {?} */
                var bodyHeight = this.defaultTargetBodyHeight;
                this.calcHeight = bodyHeight > 0 ? bodyHeight : null;
            }
            this.summaryService.clearSummaryCache();
            if (this.shouldGenerate) {
                this.setupColumns();
                this.reflow();
            }
            this.cdr.markForCheck();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridComponent.prototype, "filteredData", {
        /**
         * Returns an array of objects containing the filtered data in the `IgxGridComponent`.
         * ```typescript
         * let filteredData = this.grid.filteredData;
         * ```
         * @memberof IgxGridComponent
         */
        get: /**
         * Returns an array of objects containing the filtered data in the `IgxGridComponent`.
         * ```typescript
         * let filteredData = this.grid.filteredData;
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */
        function () {
            return this._filteredData;
        },
        /**
         * Sets an array of objects containing the filtered data in the `IgxGridComponent`.
         * ```typescript
         * this.grid.filteredData = [{
         *       ID: 1,
         *       Name: "A"
         * }];
         * ```
         * @memberof IgxGridComponent
         */
        set: /**
         * Sets an array of objects containing the filtered data in the `IgxGridComponent`.
         * ```typescript
         * this.grid.filteredData = [{
         *       ID: 1,
         *       Name: "A"
         * }];
         * ```
         * \@memberof IgxGridComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._filteredData = value;
            if (this.rowSelectable) {
                this.updateHeaderCheckboxStatusOnFilter(this._filteredData);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridComponent.prototype, "groupingExpressions", {
        /**
         * Returns the group by state of the `IgxGridComponent`.
         * ```typescript
         * let groupByState = this.grid.groupingExpressions;
         * ```
         * @memberof IgxGridComponent
         */
        get: /**
         * Returns the group by state of the `IgxGridComponent`.
         * ```typescript
         * let groupByState = this.grid.groupingExpressions;
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */
        function () {
            return this._groupingExpressions;
        },
        /**
         * Sets the group by state of the `IgxGridComponent` and emits the `onGroupingDone`
         * event with the appropriate arguments.
         * ```typescript
         * this.grid.groupingExpressions = [{
         *     fieldName: "ID",
         *     dir: SortingDirection.Asc,
         *     ignoreCase: false
         * }];
         * ```
         * @memberof IgxGridComponent
         */
        set: /**
         * Sets the group by state of the `IgxGridComponent` and emits the `onGroupingDone`
         * event with the appropriate arguments.
         * ```typescript
         * this.grid.groupingExpressions = [{
         *     fieldName: "ID",
         *     dir: SortingDirection.Asc,
         *     ignoreCase: false
         * }];
         * ```
         * \@memberof IgxGridComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var _this = this;
            if (value && value.length > 10) {
                throw Error('Maximum amount of grouped columns is 10.');
            }
            /** @type {?} */
            var oldExpressions = this.groupingExpressions;
            /** @type {?} */
            var newExpressions = value;
            this._groupingExpressions = cloneArray(value);
            this.chipsGoupingExpressions = cloneArray(value);
            if (this._gridAPI.grid) {
                /* grouping should work in conjunction with sorting
                and without overriding separate sorting expressions */
                this._applyGrouping();
                this._gridAPI.arrange_sorting_expressions();
                this.cdr.markForCheck();
            }
            else {
                // setter called before grid is registered in grid API service
                this.sortingExpressions.unshift.apply(this.sortingExpressions, this._groupingExpressions);
            }
            if (JSON.stringify(oldExpressions) !== JSON.stringify(newExpressions) && this.columnList) {
                /** @type {?} */
                var groupedCols_1 = [];
                /** @type {?} */
                var ungroupedCols_1 = [];
                /** @type {?} */
                var groupedColsArr = newExpressions.filter(function (obj) {
                    return !oldExpressions.some(function (obj2) {
                        return obj.fieldName === obj2.fieldName;
                    });
                });
                groupedColsArr.forEach(function (elem) {
                    groupedCols_1.push(_this.getColumnByName(elem.fieldName));
                }, this);
                /** @type {?} */
                var ungroupedColsArr = oldExpressions.filter(function (obj) {
                    return !newExpressions.some(function (obj2) {
                        return obj.fieldName === obj2.fieldName;
                    });
                });
                ungroupedColsArr.forEach(function (elem) {
                    ungroupedCols_1.push(_this.getColumnByName(elem.fieldName));
                }, this);
                this.cdr.detectChanges();
                /** @type {?} */
                var groupingDoneArgs = {
                    expressions: newExpressions,
                    groupedColumns: groupedCols_1,
                    ungroupedColumns: ungroupedCols_1
                };
                this.onGroupingDone.emit(groupingDoneArgs);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridComponent.prototype, "groupingExpansionState", {
        /**
         * Returns a list of expansion states for group rows.
         * Includes only states that differ from the default one (controlled through groupsExpanded and states that the user has changed.
         * Contains the expansion state (expanded: boolean) and the unique identifier for the group row (Array).
         * ```typescript
         * const groupExpState = this.grid.groupingExpansionState;
         * ```
         * @memberof IgxGridComponent
         */
        get: /**
         * Returns a list of expansion states for group rows.
         * Includes only states that differ from the default one (controlled through groupsExpanded and states that the user has changed.
         * Contains the expansion state (expanded: boolean) and the unique identifier for the group row (Array).
         * ```typescript
         * const groupExpState = this.grid.groupingExpansionState;
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */
        function () {
            return this._groupingExpandState;
        },
        /**
         * Sets a list of expansion states for group rows.
         * ```typescript
         *      this.grid.groupingExpansionState = [{
         *      expanded: false,
         *      hierarchy: [{ fieldName: 'ID', value: 1 }]
         *   }];
         * // You can use DataUtil.getHierarchy(groupRow) to get the group `IgxGridRowComponent` hierarchy.
         * ```
         * @memberof IgxGridComponent
         */
        set: /**
         * Sets a list of expansion states for group rows.
         * ```typescript
         *      this.grid.groupingExpansionState = [{
         *      expanded: false,
         *      hierarchy: [{ fieldName: 'ID', value: 1 }]
         *   }];
         * // You can use DataUtil.getHierarchy(groupRow) to get the group `IgxGridRowComponent` hierarchy.
         * ```
         * \@memberof IgxGridComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._groupingExpandState = cloneArray(value);
            this.cdr.detectChanges();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridComponent.prototype, "hideGroupedColumns", {
        /**
         * An @Input property that sets whether the grouped columns should be hidden as well.
         * The default value is "false"
         * ```html
         * <igx-grid #grid [data]="localData" [hideGroupedColumns]="true" [autoGenerate]="true"></igx-grid>
         * ```
         * @memberof IgxGridComponent
         */
        get: /**
         * An \@Input property that sets whether the grouped columns should be hidden as well.
         * The default value is "false"
         * ```html
         * <igx-grid #grid [data]="localData" [hideGroupedColumns]="true" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */
        function () {
            return this._hideGroupedColumns;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value) {
                this.groupingDiffer = this.differs.find(this.groupingExpressions).create();
            }
            else {
                this.groupingDiffer = null;
            }
            if (this.columnList && this.groupingExpressions) {
                this._setGroupColsVisibility(value);
            }
            this._hideGroupedColumns = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridComponent.prototype, "dropAreaMessage", {
        /**
         * An accessor that returns the message displayed inside the GroupBy drop area where columns can be dragged on.
        */
        get: /**
         * An accessor that returns the message displayed inside the GroupBy drop area where columns can be dragged on.
         * @return {?}
         */
        function () {
            return this._dropAreaMessage || this.resourceStrings.igx_grid_groupByArea_message;
        },
        /**
         * An @Input property that sets the message displayed inside the GroupBy drop area where columns can be dragged on.
         * Note: The grid needs to have at least one groupable column in order the GroupBy area to be displayed.
         * ```html
         * <igx-grid dropAreaMessage="Drop here to group!">
         *      <igx-column [groupable]="true" field="ID"></igx-column>
         * </igx-grid>
         * ```
         * @memberof IgxGridComponent
         */
        set: /**
         * An \@Input property that sets the message displayed inside the GroupBy drop area where columns can be dragged on.
         * Note: The grid needs to have at least one groupable column in order the GroupBy area to be displayed.
         * ```html
         * <igx-grid dropAreaMessage="Drop here to group!">
         *      <igx-column [groupable]="true" field="ID"></igx-column>
         * </igx-grid>
         * ```
         * \@memberof IgxGridComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._dropAreaMessage = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridComponent.prototype, "groupsRowList", {
        /**
         * A list of all group rows.
         * ```typescript
         * const groupList = this.grid.groupsRowList;
         * ```
         * @memberof IgxGridComponent
         */
        get: /**
         * A list of all group rows.
         * ```typescript
         * const groupList = this.grid.groupsRowList;
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */
        function () {
            /** @type {?} */
            var res = new QueryList();
            if (!this._groupsRowList) {
                return res;
            }
            /** @type {?} */
            var rList = this._groupsRowList.filter(function (item) {
                return item.element.nativeElement.parentElement !== null;
            });
            res.reset(rList);
            return res;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridComponent.prototype, "groupAreaHostClass", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.getComponentDensityClass('igx-drop-area');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridComponent.prototype, "groupRowTemplate", {
        /**
         * Returns the template reference of the `IgxGridComponent`'s group row.
         * ```
         * const groupRowTemplate = this.grid.groupRowTemplate;
         * ```
         * @memberof IgxGridComponent
         */
        get: /**
         * Returns the template reference of the `IgxGridComponent`'s group row.
         * ```
         * const groupRowTemplate = this.grid.groupRowTemplate;
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */
        function () {
            return this._groupRowTemplate;
        },
        /**
         * Sets the template reference of the `IgxGridComponent`'s group `IgxGridRowComponent`.
         * ```typescript
         * this.grid.groupRowTemplate = myRowTemplate.
         * ```
         * @memberof IgxGridComponent
         */
        set: /**
         * Sets the template reference of the `IgxGridComponent`'s group `IgxGridRowComponent`.
         * ```typescript
         * this.grid.groupRowTemplate = myRowTemplate.
         * ```
         * \@memberof IgxGridComponent
         * @param {?} template
         * @return {?}
         */
        function (template) {
            this._groupRowTemplate = template;
            this.markForCheck();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridComponent.prototype, "groupAreaTemplate", {
        /**
         * Returns the template reference of the `IgxGridComponent`'s group area.
         * ```typescript
         * const groupAreaTemplate = this.grid.groupAreaTemplate;
         * ```
         * @memberof IgxGridComponent
         */
        get: /**
         * Returns the template reference of the `IgxGridComponent`'s group area.
         * ```typescript
         * const groupAreaTemplate = this.grid.groupAreaTemplate;
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */
        function () {
            return this._groupAreaTemplate;
        },
        /**
         * Sets the template reference of the `IgxGridComponent`'s group area.
         * ```typescript
         * this.grid.groupAreaTemplate = myAreaTemplate.
         * ```
         * @memberof IgxGridComponent
         */
        set: /**
         * Sets the template reference of the `IgxGridComponent`'s group area.
         * ```typescript
         * this.grid.groupAreaTemplate = myAreaTemplate.
         * ```
         * \@memberof IgxGridComponent
         * @param {?} template
         * @return {?}
         */
        function (template) {
            this._groupAreaTemplate = template;
            this.markForCheck();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Groups by a new `IgxColumnComponent` based on the provided expression, or modifies an existing one.
     * Also allows for multiple columns to be grouped at once if an array of `ISortingExpression` is passed.
     * The onGroupingDone event would get raised only **once** if this method gets called multiple times with the same arguments.
     * ```typescript
     * this.grid.groupBy({ fieldName: name, dir: SortingDirection.Asc, ignoreCase: false });
     * this.grid.groupBy([
            { fieldName: name1, dir: SortingDirection.Asc, ignoreCase: false },
            { fieldName: name2, dir: SortingDirection.Desc, ignoreCase: true },
            { fieldName: name3, dir: SortingDirection.Desc, ignoreCase: false }
        ]);
     * ```
     * @memberof IgxGridComponent
     */
    /**
     * Groups by a new `IgxColumnComponent` based on the provided expression, or modifies an existing one.
     * Also allows for multiple columns to be grouped at once if an array of `ISortingExpression` is passed.
     * The onGroupingDone event would get raised only **once** if this method gets called multiple times with the same arguments.
     * ```typescript
     * this.grid.groupBy({ fieldName: name, dir: SortingDirection.Asc, ignoreCase: false });
     * this.grid.groupBy([
     * { fieldName: name1, dir: SortingDirection.Asc, ignoreCase: false },
     * { fieldName: name2, dir: SortingDirection.Desc, ignoreCase: true },
     * { fieldName: name3, dir: SortingDirection.Desc, ignoreCase: false }
     * ]);
     * ```
     * \@memberof IgxGridComponent
     * @param {?} expression
     * @return {?}
     */
    IgxGridComponent.prototype.groupBy = /**
     * Groups by a new `IgxColumnComponent` based on the provided expression, or modifies an existing one.
     * Also allows for multiple columns to be grouped at once if an array of `ISortingExpression` is passed.
     * The onGroupingDone event would get raised only **once** if this method gets called multiple times with the same arguments.
     * ```typescript
     * this.grid.groupBy({ fieldName: name, dir: SortingDirection.Asc, ignoreCase: false });
     * this.grid.groupBy([
     * { fieldName: name1, dir: SortingDirection.Asc, ignoreCase: false },
     * { fieldName: name2, dir: SortingDirection.Desc, ignoreCase: true },
     * { fieldName: name3, dir: SortingDirection.Desc, ignoreCase: false }
     * ]);
     * ```
     * \@memberof IgxGridComponent
     * @param {?} expression
     * @return {?}
     */
    function (expression) {
        this.endEdit(true);
        this._gridAPI.submit_value();
        if (expression instanceof Array) {
            this._gridAPI.groupBy_multiple(expression);
        }
        else {
            this._gridAPI.groupBy(expression);
        }
        this.cdr.detectChanges();
        this.calculateGridSizes();
    };
    /**
     * Clears all grouping in the grid, if no parameter is passed.
     * If a parameter is provided, clears grouping for a particular column or an array of columns.
     * ```typescript
     * this.grid.clearGrouping(); //clears all grouping
     * this.grid.clearGrouping("ID"); //ungroups a single column
     * this.grid.clearGrouping(["ID", "Column1", "Column2"]); //ungroups multiple columns
     * ```
     *
     */
    /**
     * Clears all grouping in the grid, if no parameter is passed.
     * If a parameter is provided, clears grouping for a particular column or an array of columns.
     * ```typescript
     * this.grid.clearGrouping(); //clears all grouping
     * this.grid.clearGrouping("ID"); //ungroups a single column
     * this.grid.clearGrouping(["ID", "Column1", "Column2"]); //ungroups multiple columns
     * ```
     *
     * @param {?=} name
     * @return {?}
     */
    IgxGridComponent.prototype.clearGrouping = /**
     * Clears all grouping in the grid, if no parameter is passed.
     * If a parameter is provided, clears grouping for a particular column or an array of columns.
     * ```typescript
     * this.grid.clearGrouping(); //clears all grouping
     * this.grid.clearGrouping("ID"); //ungroups a single column
     * this.grid.clearGrouping(["ID", "Column1", "Column2"]); //ungroups multiple columns
     * ```
     *
     * @param {?=} name
     * @return {?}
     */
    function (name) {
        this._gridAPI.clear_groupby(name);
        this.calculateGridSizes();
    };
    /**
     * Returns if a group is expanded or not.
     * ```typescript
     * public groupRow: IGroupByRecord;
     * const expandedGroup = this.grid.isExpandedGroup(this.groupRow);
     * ```
     * @memberof IgxGridComponent
     */
    /**
     * Returns if a group is expanded or not.
     * ```typescript
     * public groupRow: IGroupByRecord;
     * const expandedGroup = this.grid.isExpandedGroup(this.groupRow);
     * ```
     * \@memberof IgxGridComponent
     * @param {?} group
     * @return {?}
     */
    IgxGridComponent.prototype.isExpandedGroup = /**
     * Returns if a group is expanded or not.
     * ```typescript
     * public groupRow: IGroupByRecord;
     * const expandedGroup = this.grid.isExpandedGroup(this.groupRow);
     * ```
     * \@memberof IgxGridComponent
     * @param {?} group
     * @return {?}
     */
    function (group) {
        /** @type {?} */
        var state = this._getStateForGroupRow(group);
        return state ? state.expanded : this.groupsExpanded;
    };
    /**
     * Toggles the expansion state of a group.
     * ```typescript
     * public groupRow: IGroupByRecord;
     * const toggleExpGroup = this.grid.toggleGroup(this.groupRow);
     * ```
     * @memberof IgxGridComponent
     */
    /**
     * Toggles the expansion state of a group.
     * ```typescript
     * public groupRow: IGroupByRecord;
     * const toggleExpGroup = this.grid.toggleGroup(this.groupRow);
     * ```
     * \@memberof IgxGridComponent
     * @param {?} groupRow
     * @return {?}
     */
    IgxGridComponent.prototype.toggleGroup = /**
     * Toggles the expansion state of a group.
     * ```typescript
     * public groupRow: IGroupByRecord;
     * const toggleExpGroup = this.grid.toggleGroup(this.groupRow);
     * ```
     * \@memberof IgxGridComponent
     * @param {?} groupRow
     * @return {?}
     */
    function (groupRow) {
        this._toggleGroup(groupRow);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} record
     * @return {?}
     */
    IgxGridComponent.prototype.isGroupByRecord = /**
     * @hidden
     * @param {?} record
     * @return {?}
     */
    function (record) {
        // return record.records instance of GroupedRecords fails under Webpack
        return record.records && record.records.length;
    };
    /**
     * Toggles the expansion state of all group rows recursively.
     * ```typescript
     * this.grid.toggleAllGroupRows;
     * ```
     * @memberof IgxGridComponent
     */
    /**
     * Toggles the expansion state of all group rows recursively.
     * ```typescript
     * this.grid.toggleAllGroupRows;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    IgxGridComponent.prototype.toggleAllGroupRows = /**
     * Toggles the expansion state of all group rows recursively.
     * ```typescript
     * this.grid.toggleAllGroupRows;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    function () {
        this.groupingExpansionState = [];
        this.groupsExpanded = !this.groupsExpanded;
        this.cdr.detectChanges();
    };
    Object.defineProperty(IgxGridComponent.prototype, "hasGroupableColumns", {
        /**
         * Returns if the `IgxGridComponent` has groupable columns.
         * ```typescript
         * const groupableGrid = this.grid.hasGroupableColumns;
         * ```
         * @memberof IgxGridComponent
         */
        get: /**
         * Returns if the `IgxGridComponent` has groupable columns.
         * ```typescript
         * const groupableGrid = this.grid.hasGroupableColumns;
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */
        function () {
            return this.columnList.some(function (col) { return col.groupable && !col.columnGroup; });
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    IgxGridComponent.prototype._setGroupColsVisibility = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        var _this = this;
        this.groupingExpressions.forEach(function (expr) {
            /** @type {?} */
            var col = _this.getColumnByName(expr.fieldName);
            col.hidden = value;
        });
    };
    Object.defineProperty(IgxGridComponent.prototype, "dropAreaVisible", {
        /**
         * Returns if the grid's group by drop area is visible.
         * ```typescript
         * const dropVisible = this.grid.dropAreaVisible;
         * ```
         * @memberof IgxGridComponent
         */
        get: /**
         * Returns if the grid's group by drop area is visible.
         * ```typescript
         * const dropVisible = this.grid.dropAreaVisible;
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */
        function () {
            return (this.draggedColumn && this.draggedColumn.groupable) ||
                !this.chipsGoupingExpressions.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} groupRow
     * @return {?}
     */
    IgxGridComponent.prototype._getStateForGroupRow = /**
     * @hidden
     * @protected
     * @param {?} groupRow
     * @return {?}
     */
    function (groupRow) {
        return this._gridAPI.groupBy_get_expanded_for_group(groupRow);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} groupRow
     * @return {?}
     */
    IgxGridComponent.prototype._toggleGroup = /**
     * @hidden
     * @protected
     * @param {?} groupRow
     * @return {?}
     */
    function (groupRow) {
        this._gridAPI.groupBy_toggle_group(groupRow);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    IgxGridComponent.prototype._applyGrouping = /**
     * @hidden
     * @protected
     * @return {?}
     */
    function () {
        this._gridAPI.sort_multiple(this._groupingExpressions);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} fieldName
     * @return {?}
     */
    IgxGridComponent.prototype.isColumnGrouped = /**
     * @hidden
     * @param {?} fieldName
     * @return {?}
     */
    function (fieldName) {
        return this.groupingExpressions.find(function (exp) { return exp.fieldName === fieldName; }) ? true : false;
    };
    /**
    * @hidden
    */
    /**
     * @hidden
     * @param {?} rowData
     * @param {?} rowIndex
     * @return {?}
     */
    IgxGridComponent.prototype.getContext = /**
     * @hidden
     * @param {?} rowData
     * @param {?} rowIndex
     * @return {?}
     */
    function (rowData, rowIndex) {
        return {
            $implicit: rowData,
            index: rowIndex,
            templateID: this.isGroupByRecord(rowData) ? 'groupRow' : this.isSummaryRow(rowData) ? 'summaryRow' : 'dataRow'
        };
    };
    Object.defineProperty(IgxGridComponent.prototype, "template", {
        /**
        * @hidden
        */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            if (this.filteredData && this.filteredData.length === 0) {
                return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyFilteredGridTemplate;
            }
            if (this.isLoading && (!this.data || this.dataLength === 0)) {
                return this.loadingGridTemplate ? this.loadingGridTemplate : this.loadingGridDefaultTemplate;
            }
            if (this.dataLength === 0) {
                return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyGridDefaultTemplate;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    IgxGridComponent.prototype.getGroupByRecords = /**
     * @hidden
     * @protected
     * @return {?}
     */
    function () {
        if (this.groupingExpressions && this.groupingExpressions.length) {
            /** @type {?} */
            var state = {
                expressions: this.groupingExpressions,
                expansion: this.groupingExpansionState,
                defaultExpanded: this.groupsExpanded
            };
            return DataUtil.group(cloneArray(this.filteredSortedData), state, this).metadata;
        }
        else {
            return null;
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxGridComponent.prototype.onChipRemoved = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.clearGrouping(event.owner.id);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxGridComponent.prototype.chipsOrderChanged = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var newGrouping = [];
        var _loop_1 = function (i) {
            /** @type {?} */
            var expr = this_1.groupingExpressions.filter(function (item) {
                return item.fieldName === event.chipsArray[i].id;
            })[0];
            if (!this_1.getColumnByName(expr.fieldName).groupable) {
                return { value: void 0 };
            }
            newGrouping.push(expr);
        };
        var this_1 = this;
        for (var i = 0; i < event.chipsArray.length; i++) {
            var state_1 = _loop_1(i);
            if (typeof state_1 === "object")
                return state_1.value;
        }
        this.groupingExpansionState = [];
        this.chipsGoupingExpressions = newGrouping;
        if (event.originalEvent instanceof KeyboardEvent) {
            // When reordered using keyboard navigation, we don't have `onMoveEnd` event.
            this.groupingExpressions = this.chipsGoupingExpressions;
        }
        this.markForCheck();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxGridComponent.prototype.chipsMovingEnded = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.groupingExpressions = this.chipsGoupingExpressions;
        this.markForCheck();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxGridComponent.prototype.onChipClicked = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var sortingExpr = this.sortingExpressions;
        /** @type {?} */
        var columnExpr = sortingExpr.find(function (expr) { return expr.fieldName === event.owner.id; });
        columnExpr.dir = 3 - columnExpr.dir;
        this.sort(columnExpr);
        this.markForCheck();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxGridComponent.prototype.onChipKeyDown = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.originalEvent.key === ' ' || event.originalEvent.key === 'Spacebar' || event.originalEvent.key === 'Enter') {
            /** @type {?} */
            var sortingExpr = this.sortingExpressions;
            /** @type {?} */
            var columnExpr = sortingExpr.find(function (expr) { return expr.fieldName === event.owner.id; });
            columnExpr.dir = 3 - columnExpr.dir;
            this.sort(columnExpr);
            this.markForCheck();
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    IgxGridComponent.prototype.getGroupAreaHeight = /**
     * @hidden
     * @protected
     * @return {?}
     */
    function () {
        return this.groupArea ? this.groupArea.nativeElement.offsetHeight : 0;
    };
    /**
     * @hidden
     * Gets the combined width of the columns that are specific to the enabled grid features. They are fixed.
     * TODO: Remove for Angular 8. Calling parent class getter using super is not supported for now.
     */
    /**
     * @hidden
     * Gets the combined width of the columns that are specific to the enabled grid features. They are fixed.
     * TODO: Remove for Angular 8. Calling parent class getter using super is not supported for now.
     * @return {?}
     */
    IgxGridComponent.prototype.getFeatureColumnsWidth = /**
     * @hidden
     * Gets the combined width of the columns that are specific to the enabled grid features. They are fixed.
     * TODO: Remove for Angular 8. Calling parent class getter using super is not supported for now.
     * @return {?}
     */
    function () {
        /** @type {?} */
        var width = _super.prototype.getFeatureColumnsWidth.call(this);
        if (this.groupingExpressions.length && this.headerGroupContainer) {
            width += this.headerGroupContainer.nativeElement.offsetWidth;
        }
        return width;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} row
     * @param {?} column
     * @return {?}
     */
    IgxGridComponent.prototype.scrollTo = /**
     * @hidden
     * @protected
     * @param {?} row
     * @param {?} column
     * @return {?}
     */
    function (row, column) {
        if (this.groupingExpressions && this.groupingExpressions.length
            && typeof (row) !== 'number') {
            /** @type {?} */
            var groupByRecords = this.getGroupByRecords();
            /** @type {?} */
            var rowIndex = this.filteredSortedData.indexOf(row);
            /** @type {?} */
            var groupByRecord = groupByRecords[rowIndex];
            if (groupByRecord && !this.isExpandedGroup(groupByRecord)) {
                this.toggleGroup(groupByRecord);
            }
        }
        _super.prototype.scrollTo.call(this, row, column);
    };
    Object.defineProperty(IgxGridComponent.prototype, "dropAreaTemplateResolved", {
        /**
        * @hidden
        */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            if (this.dropAreaTemplate) {
                return this.dropAreaTemplate;
            }
            else {
                return this.defaultDropAreaTemplate;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} expression
     * @return {?}
     */
    IgxGridComponent.prototype.getGroupByChipTitle = /**
     * @hidden
     * @param {?} expression
     * @return {?}
     */
    function (expression) {
        return this.getColumnByName(expression.fieldName).header || expression.fieldName;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxGridComponent.prototype.ngAfterContentInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (this.allowFiltering && this.hasColumnLayouts) {
            this.filterMode = FilterMode.excelStyleFilter;
        }
        if (this.groupTemplate) {
            this._groupRowTemplate = this.groupTemplate.template;
        }
        _super.prototype.ngAfterContentInit.call(this);
        if (this.hideGroupedColumns && this.columnList && this.groupingExpressions) {
            this._setGroupColsVisibility(this.hideGroupedColumns);
        }
    };
    /**
     * @return {?}
     */
    IgxGridComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        _super.prototype.ngOnInit.call(this);
        this.onGroupingDone.pipe(takeUntil(this.destroy$)).subscribe(function (args) {
            _this.endEdit(true);
            _this.summaryService.updateSummaryCache(args);
        });
    };
    /**
     * @return {?}
     */
    IgxGridComponent.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
        var _this = this;
        _super.prototype.ngDoCheck.call(this);
        if (this.groupingDiffer) {
            /** @type {?} */
            var changes = this.groupingDiffer.diff(this.groupingExpressions);
            if (changes && this.columnList) {
                changes.forEachAddedItem(function (rec) {
                    /** @type {?} */
                    var col = _this.getColumnByName(rec.item.fieldName);
                    col.hidden = true;
                });
                changes.forEachRemovedItem(function (rec) {
                    /** @type {?} */
                    var col = _this.getColumnByName(rec.item.fieldName);
                    col.hidden = false;
                });
            }
        }
    };
    /**
     * @return {?}
     */
    IgxGridComponent.prototype.getSelectedData = /**
     * @return {?}
     */
    function () {
        if (this.groupingExpressions.length) {
            /** @type {?} */
            var source_1 = [];
            /** @type {?} */
            var process = function (record) {
                if (record.expression || record.summaries) {
                    source_1.push(null);
                    return;
                }
                source_1.push(record);
            };
            this.verticalScrollContainer.igxForOf.forEach(process);
            return this.extractDataFromSelection(source_1);
        }
        else {
            return _super.prototype.getSelectedData.call(this);
        }
    };
    IgxGridComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    providers: [IgxGridNavigationService, IgxGridSummaryService, IgxGridSelectionService, IgxGridCRUDService,
                        { provide: GridBaseAPIService, useClass: IgxGridAPIService },
                        { provide: IgxGridBaseComponent, useExisting: forwardRef(function () { return IgxGridComponent; }) },
                        IgxFilteringService, IgxColumnResizingService, IgxForOfSyncService
                    ],
                    selector: 'igx-grid',
                    template: "<igx-grid-toolbar [style.width.px]=\"outerWidth\" role=\"rowgroup\" *ngIf=\"showToolbar\" [gridID]=\"id\" [displayDensity]=\"displayDensity\" #toolbar>\n</igx-grid-toolbar>\n\n<ng-template #defaultPager let-api>\n    <button [disabled]=\"api.isFirstPage\" (click)=\"api.paginate(0)\" igxButton=\"icon\" igxRipple igxRippleCentered=\"true\">\n        <igx-icon fontSet=\"material\">first_page</igx-icon>\n    </button>\n    <button [disabled]=\"api.isFirstPage\" (click)=\"api.previousPage()\" igxButton=\"icon\" igxRipple igxRippleCentered=\"true\">\n        <igx-icon fontSet=\"material\">chevron_left</igx-icon>\n    </button>\n    <span>{{ api.page + 1 }} of {{ api.totalPages }}</span>\n    <button [disabled]=\"api.isLastPage\" (click)=\"api.nextPage()\" igxRipple igxRippleCentered=\"true\" igxButton=\"icon\">\n        <igx-icon fontSet=\"material\">chevron_right</igx-icon>\n    </button>\n        <button [disabled]=\"api.isLastPage\" (click)=\"api.paginate(api.totalPages - 1)\" igxButton=\"icon\" igxRipple igxRippleCentered=\"true\">\n        <igx-icon fontSet=\"material\">last_page</igx-icon>\n    </button>\n    <select style=\"margin-left: 1rem;\" (change)=\"api.perPage = $event.target.value\">\n            <option [value]=\"val\" [selected]=\"api.perPage == val\" *ngFor=\"let val of [5, 10, 15, 25, 50, 100, 500]\">{{ val }}</option>\n    </select>\n</ng-template>\n\n<div [style.width.px]='outerWidth' class=\"igx-grid__grouparea\" *ngIf=\"groupingExpressions.length > 0 || hasGroupableColumns\" #groupArea>\n    <igx-chips-area (onReorder)=\"chipsOrderChanged($event)\" (onMoveEnd)=\"chipsMovingEnded()\">\n        <ng-container *ngFor=\"let expr of chipsGoupingExpressions; let last = last;\">\n            <igx-chip [id]=\"expr.fieldName\" [attr.title]=\"getGroupByChipTitle(expr)\" [removable]=\"getColumnByName(expr.fieldName).groupable\" [draggable]=\"getColumnByName(expr.fieldName).groupable\" [displayDensity]=\"displayDensity\"\n                    (onKeyDown)=\"onChipKeyDown($event)\" (onRemove)=\"onChipRemoved($event)\" (onClick)=\"getColumnByName(expr.fieldName).groupable ? onChipClicked($event): null\" [disabled]='!getColumnByName(expr.fieldName).groupable'>\n                    <span>{{ getGroupByChipTitle(expr) }}</span>\n                    <igx-icon igxSuffix>{{ expr.dir == 1 ? 'arrow_upward' : 'arrow_downward' }}</igx-icon>\n            </igx-chip>\n            <span class=\"igx-grid__grouparea-connector\">\n                <igx-icon [style.visibility]=\"(!last || dropAreaVisible) ? 'visible' : 'hidden'\" >arrow_forward</igx-icon>\n            </span>\n        </ng-container>\n        <div igxGroupAreaDrop [style.visibility]=\"dropAreaVisible ? 'visible' : 'hidden'\" [class]=\"groupAreaHostClass\" [attr.gridId]='this.id'>\n            <ng-container *ngTemplateOutlet=\"dropAreaTemplateResolved\"></ng-container>\n        </div>\n    </igx-chips-area>\n</div>\n\n<div class=\"igx-grid__thead\">\n    <div class=\"igx-grid__thead-wrapper\" [class.igx-grid__tr--mrl]='hasColumnLayouts' role=\"rowgroup\" [style.width.px]='calcWidth + 1' #theadRow>\n        <div class=\"igx-grid__tr\" role=\"row\" [style.width.px]='calcWidth + 1'>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"left\" class=\"igx-grid__scroll-on-drag-left\" [style.left.px]=\"featureColumnsWidth\"></span>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"left\" class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n            <ng-container *ngIf=\"groupingExpressions.length > 0\">\n                <div class=\"igx-grid__header-indentation igx-grid__row-indentation--level-{{groupingExpressions.length}}\" [ngClass]=\"{\n                    'igx-grid__header-indentation--no-border': rowSelectable || rowDraggable\n                }\" #headerGroupContainer>\n                    <igx-icon *ngIf=\"groupsExpanded\" role=\"button\" class=\"igx-grid__group-expand-btn\" (click)=\"toggleAllGroupRows()\" [ngClass]=\"{\n                        'igx-grid__group-expand-btn--push': filteringService.isFilterRowVisible\n                    }\">unfold_less</igx-icon>\n                    <igx-icon *ngIf=\"!groupsExpanded\" role=\"button\" class=\"igx-grid__group-expand-btn\" (click)=\"toggleAllGroupRows()\"[ngClass]=\"{\n                        'igx-grid__group-expand-btn--push': filteringService.isFilterRowVisible\n                    }\">unfold_more</igx-icon>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"rowDraggable\">\n                <div class=\"igx-grid__drag-indicator\" [ngClass]=\"{\n                    'igx-grid__drag-indicator--header': !rowSelectable\n                }\" #headerDragContainer>\n                    <div style=\"visibility: hidden;\">\n                        <ng-container *ngTemplateOutlet=\"this.dragIndicatorIconTemplate ? this.dragIndicatorIconTemplate : this.dragIndicatorIconBase\"></ng-container>\n                    </div>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"showRowCheckboxes\">\n                <div class=\"igx-grid__cbx-selection\" #headerCheckboxContainer [ngClass]=\"{\n                    'igx-grid__cbx-selection--push': filteringService.isFilterRowVisible\n                }\">\n                    <igx-checkbox [checked]=\"allRowsSelected\" (change)=\"onHeaderCheckboxClick($event, filteredData)\" disableRipple=\"true\" [aria-label]=\"headerCheckboxAriaLabel\" #headerCheckbox></igx-checkbox>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"pinnedColumns.length > 0\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width.px]=\"getHeaderGroupWidth(col)\" [style.flex-basis.px]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n            <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\" [igxForScrollOrientation]=\"'horizontal'\" [igxForScrollContainer]=\"parentVirtDir\"\n                [igxForContainerSize]='unpinnedWidth' [igxForTrackBy]='trackColumnChanges'  [igxForSizePropName]='\"calcWidth\"' #headerContainer>\n                <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width.px]=\"getHeaderGroupWidth(col)\" [style.flex-basis.px]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n            </ng-template>\n            </div>\n            <igx-grid-filtering-row #filteringRow [style.width.px]='calcWidth' *ngIf=\"filteringService.isFilterRowVisible\" [column]=\"filteringService.filteredColumn\"></igx-grid-filtering-row>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div class=\"igx-grid__thead-thumb\" [hidden]='!hasVerticalSroll()' [style.width.px]=\"scrollWidth\"></div>\n</div>\n\n<div igxGridBody class=\"igx-grid__tbody\">\n    <div class=\"igx-grid__tbody-content\" role=\"rowgroup\" (onDragStop)=\"selectionService.dragMode = $event\" (onDragScroll)=\"dragScroll($event)\" [igxGridDragSelect]=\"selectionService.dragMode\" [style.height.px]='calcHeight' [style.width.px]='calcWidth + 1' #tbody (scroll)='scrollHandler($event)' (wheel)=\"wheelHandler()\">\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"left\" class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"left\" class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n        <ng-template igxGridFor let-rowData [igxGridForOf]=\"data\n        | gridTransaction:id:pipeTrigger\n        | gridFiltering:filteringExpressionsTree:id:pipeTrigger\n        | gridSort:sortingExpressions:id:pipeTrigger\n        | gridPreGroupBy:groupingExpressions:groupingExpansionState:groupsExpanded:id:groupsRecords:pipeTrigger\n        | gridPaging:page:perPage:id:pipeTrigger\n        | gridPostGroupBy:groupingExpressions:groupingExpansionState:groupsExpanded:id:pipeTrigger\n        | gridSummary:hasSummarizedColumns:summaryCalculationMode:summaryPosition:id:pipeTrigger:summaryPipeTrigger\"\n        let-rowIndex=\"index\" [igxForScrollOrientation]=\"'vertical'\"  [igxForScrollContainer]='verticalScroll'\n        [igxForContainerSize]='calcHeight' [igxForItemSize]=\"hasColumnLayouts ? rowHeight * multiRowLayoutRowSize : rowHeight\" #verticalScrollContainer (onChunkPreload)=\"dataLoading($event)\">\n            <ng-template #record_template>\n                <igx-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [rowData]=\"rowData\" #row>\n                </igx-grid-row>\n            </ng-template>\n            <ng-template #group_template>\n                <igx-grid-groupby-row [gridID]=\"id\" [index]=\"rowIndex\" [groupRow]=\"rowData\" #row>\n                </igx-grid-groupby-row>\n            </ng-template>\n            <ng-template #summary_template>\n                <igx-grid-summary-row [gridID]=\"id\" [summaries]=\"rowData.summaries\" [indentation]=\"groupingExpressions.length\" [index]=\"rowIndex\" class=\"igx-grid__summaries--body\" #summaryRow>\n                </igx-grid-summary-row>\n            </ng-template>\n            <ng-template [igxTemplateOutlet]='isGroupByRecord(rowData) ? group_template : isSummaryRow(rowData) ? summary_template : record_template'\n                [igxTemplateOutletContext]='getContext(rowData, rowIndex)'\n                (onCachedViewLoaded)='cachedViewLoaded($event)'>\n            </ng-template>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"template\"></ng-container>\n        <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div [hidden]='!hasVerticalSroll()' class=\"igx-grid__tbody-scrollbar\" [style.width.px]=\"scrollWidth\" [style.height.px]='calcHeight'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #verticalScrollHolder ></ng-template>\n    </div>\n</div>\n\n\n<div class=\"igx-grid__tfoot\" role=\"rowgroup\" [style.height.px]='summariesHeight' #tfoot>\n    <igx-grid-summary-row [style.width.px]='calcWidth' [style.height.px]='summariesHeight' *ngIf=\"hasSummarizedColumns && rootSummariesEnabled\" [gridID]=\"id\" [summaries]=\"id | igxGridSummaryDataPipe:summaryService.retriggerRootPipe\" [indentation]=\"groupingExpressions.length\" [index]=\"0\" class=\"igx-grid__summaries\"  #summaryRow>\n    </igx-grid-summary-row>\n    <div class=\"igx-grid__tfoot-thumb\" [hidden]='!hasVerticalSroll()' [style.height.px]='summariesHeight' [style.width.px]=\"scrollWidth\"></div>\n</div>\n\n<div class=\"igx-grid__scroll\" [style.height]=\"'18px'\" #scr [hidden]=\"unpinnedWidth - totalWidth >= 0\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]='pinnedWidth' [hidden]=\"pinnedWidth === 0\"></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]='unpinnedWidth'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #scrollContainer>\n        </ng-template>\n    </div>\n</div>\n\n<div class=\"igx-paginator igx-grid-paginator\" *ngIf=\"paging && totalRecords\" #paginator>\n    <ng-container *ngTemplateOutlet=\"paginationTemplate ? paginationTemplate : defaultPager; context: { $implicit: this }\">\n    </ng-container>\n</div>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyFilteredGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultLoadingGrid>\n    <div class=\"igx-grid__loading\">\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n</ng-template>\n\n<ng-template #defaultDropArea>\n    <igx-icon fontSet=\"material\" class=\"igx-drop-area__icon\">group_work</igx-icon>\n    <span class=\"igx-drop-area__text\">{{dropAreaMessage}}</span>\n</ng-template>\n\n<div *ngIf=\"rowEditable\" igxToggle>\n    <div [className]=\"bannerClass\">\n        <ng-container *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: endEdit.bind(this) }\"></ng-container>\n    </div>\n</div>\n\n<ng-template #defaultRowEditText>\n    You have {{ rowChangesCount }} changes in this row\n</ng-template>\n\n<ng-template #defaultRowEditActions>\n    <button igxButton igxRowEditTabStop (click)=\"endEdit(false, $event)\">Cancel</button>\n    <button igxButton igxRowEditTabStop (click)=\"endEdit(true, $event)\">Done</button>\n</ng-template>\n\n<ng-template #defaultRowEditTemplate>\n    <div class=\"igx-banner__message\">\n        <span class=\"igx-banner__text\">\n            <ng-container *ngTemplateOutlet=\"rowEditText ? rowEditText : defaultRowEditText; context: { $implicit: rowChangesCount }\"></ng-container>\n        </span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <ng-container *ngTemplateOutlet=\"rowEditActions ? rowEditActions : defaultRowEditActions; context: { $implicit: endEdit.bind(this) }\"></ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #dragIndicatorIconBase>\n    <igx-icon fontSet=\"material\">drag_indicator</igx-icon>\n</ng-template>\n\n<igx-grid-column-resizer *ngIf=\"colResizingService.showResizer\"></igx-grid-column-resizer>\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet></div>\n"
                }] }
    ];
    /** @nocollapse */
    IgxGridComponent.ctorParameters = function () { return [
        { type: IgxGridSelectionService },
        { type: IgxGridCRUDService },
        { type: IgxColumnResizingService },
        { type: GridBaseAPIService },
        { type: IgxSelectionAPIService },
        { type: undefined, decorators: [{ type: Inject, args: [IgxGridTransaction,] }] },
        { type: ElementRef },
        { type: NgZone },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: ChangeDetectorRef },
        { type: ComponentFactoryResolver },
        { type: IterableDiffers },
        { type: ViewContainerRef },
        { type: IgxGridNavigationService },
        { type: IgxFilteringService },
        { type: IgxOverlayService, decorators: [{ type: Inject, args: [IgxOverlayService,] }] },
        { type: IgxGridSummaryService },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
    ]; };
    IgxGridComponent.propDecorators = {
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        data: [{ type: Input }],
        groupingExpressions: [{ type: Input }],
        groupingExpansionState: [{ type: Input }],
        groupsExpanded: [{ type: Input }],
        hideGroupedColumns: [{ type: Input }],
        dropAreaMessage: [{ type: Input }],
        dropAreaTemplate: [{ type: Input }],
        onGroupingDone: [{ type: Output }],
        onFocusChange: [{ type: Output }],
        groupTemplate: [{ type: ContentChild, args: [IgxGroupByRowTemplateDirective, { read: IgxGroupByRowTemplateDirective },] }],
        dragIndicatorIconTemplate: [{ type: ContentChild, args: [IgxDragIndicatorIconDirective, { read: TemplateRef },] }],
        _groupsRowList: [{ type: ViewChildren, args: [IgxGridGroupByRowComponent, { read: IgxGridGroupByRowComponent },] }],
        defaultDropAreaTemplate: [{ type: ViewChild, args: ['defaultDropArea', { read: TemplateRef },] }],
        groupArea: [{ type: ViewChild, args: ['groupArea',] }]
    };
    return IgxGridComponent;
}(IgxGridBaseComponent));
export { IgxGridComponent };
if (false) {
    /**
     * @type {?}
     * @private
     */
    IgxGridComponent.prototype._id;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxGridComponent.prototype._groupingExpressions;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxGridComponent.prototype._groupingExpandState;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxGridComponent.prototype._groupRowTemplate;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxGridComponent.prototype._groupAreaTemplate;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxGridComponent.prototype.groupingDiffer;
    /**
     * @type {?}
     * @private
     */
    IgxGridComponent.prototype._data;
    /**
     * @type {?}
     * @private
     */
    IgxGridComponent.prototype._hideGroupedColumns;
    /**
     * @type {?}
     * @private
     */
    IgxGridComponent.prototype._dropAreaMessage;
    /**
     * @type {?}
     * @private
     */
    IgxGridComponent.prototype._gridAPI;
    /**
     * @type {?}
     * @private
     */
    IgxGridComponent.prototype._filteredData;
    /**
     * An \@Input property that determines whether created groups are rendered expanded or collapsed.
     * The default rendered state is expanded.
     * ```html
     * <igx-grid #grid [data]="Data" [groupsExpanded]="false" [autoGenerate]="true"></igx-grid>
     * ```
     * \@memberof IgxGridComponent
     * @type {?}
     */
    IgxGridComponent.prototype.groupsExpanded;
    /**
     * A hierarchical representation of the group by records.
     * ```typescript
     * let groupRecords = this.grid.groupsRecords;
     * ```
     * \@memberof IgxGridComponent
     * @type {?}
     */
    IgxGridComponent.prototype.groupsRecords;
    /**
     * An \@Input property that sets the template that will be rendered as a GroupBy drop area.
     * Note: The grid needs to have at least one groupable column in order the GroupBy area to be displayed.
     * ```html
     * <igx-grid [dropAreaTemplate]="dropAreaRef">
     *      <igx-column [groupable]="true" field="ID"></igx-column>
     * </igx-grid>
     *
     * <ng-template #myDropArea>
     *      <span> Custom drop area! </span>
     * </ng-template>
     * ```
     * ```ts
     * \@ViewChild('myDropArea', { read: TemplateRef })
     * public dropAreaRef: TemplateRef<any>;
     * ```
     * \@memberof IgxGridComponent
     * @type {?}
     */
    IgxGridComponent.prototype.dropAreaTemplate;
    /**
     * Emitted when a new `IgxColumnComponent` gets grouped/ungrouped, or multiple columns get
     * grouped/ungrouped at once by using the Group By API.
     * The `onGroupingDone` event would be raised only once if several columns get grouped at once by calling
     * the `groupBy()` or `clearGrouping()` API methods and passing an array as an argument.
     * The event arguments provide the `expressions`, `groupedColumns` and `ungroupedColumns` properties, which contain
     * the `ISortingExpression` and the `IgxColumnComponent` related to the grouping/ungrouping operation.
     * Please note that `groupedColumns` and `ungroupedColumns` show only the **newly** changed columns (affected by the **last**
     * grouping/ungrouping operation), not all columns which are currently grouped/ungrouped.
     * columns.
     * ```typescript
     * groupingDone(event: IGroupingDoneEventArgs){
     *     const expressions = event.expressions;
     *     //the newly grouped columns
     *     const groupedColumns = event.groupedColumns;
     *     //the newly ungrouped columns
     *     const ungroupedColumns = event.ungroupedColumns;
     * }
     * ```
     * ```html
     * <igx-grid #grid [data]="localData" (onGroupingDone)="groupingDone($event)" [autoGenerate]="true"></igx-grid>
     * ```
     * \@memberof IgxGridComponent
     * @type {?}
     */
    IgxGridComponent.prototype.onGroupingDone;
    /** @type {?} */
    IgxGridComponent.prototype.onFocusChange;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxGridComponent.prototype.groupTemplate;
    /**
     * The custom template, if any, that should be used when rendering the row drag indicator icon
     *
     * ```typescript
     * // Set in typescript
     * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
     * myComponent.dragIndicatorIconTemplate = myCustomTemplate;
     * ```
     * ```html
     * <!-- Set in markup -->
     *  <igx-grid #grid>
     *      ...
     *      <ng-template igxDragIndicatorIcon>
     *          <igx-icon fontSet="material">info</igx-icon>
     *      </ng-template>
     *  </igx-grid>
     * ```
     * @type {?}
     */
    IgxGridComponent.prototype.dragIndicatorIconTemplate;
    /**
     * @type {?}
     * @private
     */
    IgxGridComponent.prototype._groupsRowList;
    /**
     * @hidden
     * @type {?}
     */
    IgxGridComponent.prototype.defaultDropAreaTemplate;
    /**
     * @hidden
     * @type {?}
     */
    IgxGridComponent.prototype.groupArea;
    /** @type {?} */
    IgxGridComponent.prototype.colResizingService;
    /** @type {?} */
    IgxGridComponent.prototype.document;
    /**
     * @type {?}
     * @protected
     */
    IgxGridComponent.prototype.overlayService;
    /**
     * @type {?}
     * @protected
     */
    IgxGridComponent.prototype._displayDensityOptions;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL2dyaWRzL2dyaWQvZ3JpZC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQ0gsU0FBUyxFQUFFLHVCQUF1QixFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQzNGLFNBQVMsRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBVyxNQUFNLEVBQUUsaUJBQWlCLEVBQUUsd0JBQXdCLEVBQzNHLGVBQWUsRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLEVBQW9CLFdBQVcsRUFBRSxVQUFVLEVBQVUsUUFBUSxFQUN6RyxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNwRCxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsa0JBQWtCLEVBQTRDLFVBQVUsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQ3hJLE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQ3RFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBRXZELE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUU5QyxPQUFPLEVBQUUsOEJBQThCLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNuRSxPQUFPLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUNyRSxPQUFPLEVBQTBCLG1CQUFtQixFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFJeEYsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGlDQUFpQyxDQUFDO0FBQzNELE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBRTlELE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFB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aUIsRUFBRSxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUU7NEJBeUJsRCxTQUFTLFNBQUMsV0FBVzs7SUErYTFCLHVCQUFDO0NBQUEsQUFoMUJELENBV3NDLG9CQUFvQixHQXEwQnpEO1NBcjBCWSxnQkFBZ0I7Ozs7OztJQUN6QiwrQkFBc0M7Ozs7OztJQUl0QyxnREFBMkQ7Ozs7OztJQUkzRCxnREFBMkQ7Ozs7OztJQUkzRCw2Q0FBOEM7Ozs7OztJQUk5Qyw4Q0FBK0M7Ozs7OztJQUkvQywwQ0FBeUI7Ozs7O0lBQ3pCLGlDQUFjOzs7OztJQUNkLCtDQUFvQzs7Ozs7SUFDcEMsNENBQWdDOzs7OztJQTRFaEMsb0NBQW9DOzs7OztJQUNwQyx5Q0FBNkI7Ozs7Ozs7Ozs7SUF3STdCLDBDQUM2Qjs7Ozs7Ozs7O0lBUzdCLHlDQUE0Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFvRTVDLDRDQUMwQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUEwQjFDLDBDQUNtRTs7SUFFbkUseUNBQ3FFOzs7Ozs7SUFLckUseUNBQ3dEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQW9CeEQscURBQzBEOzs7OztJQUUxRCwwQ0FDOEQ7Ozs7O0lBSzlELG1EQUNpRDs7Ozs7SUF3QmpELHFDQUM2Qjs7SUE3U3pCLDhDQUFtRDs7SUFNbkQsb0NBQWlDOzs7OztJQU9qQywwQ0FBc0U7Ozs7O0lBRXRFLGtEQUFpRyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ29tcG9uZW50LCBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyLCBDb250ZW50Q2hpbGQsIFZpZXdDaGlsZHJlbixcbiAgICBRdWVyeUxpc3QsIFZpZXdDaGlsZCwgRWxlbWVudFJlZiwgVGVtcGxhdGVSZWYsIERvQ2hlY2ssIE5nWm9uZSwgQ2hhbmdlRGV0ZWN0b3JSZWYsIENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICBJdGVyYWJsZURpZmZlcnMsIFZpZXdDb250YWluZXJSZWYsIEluamVjdCwgQWZ0ZXJDb250ZW50SW5pdCwgSG9zdEJpbmRpbmcsIGZvcndhcmRSZWYsIE9uSW5pdCwgT3B0aW9uYWxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBHcmlkQmFzZUFQSVNlcnZpY2UgfSBmcm9tICcuLi9hcGkuc2VydmljZSc7XG5pbXBvcnQgeyBJZ3hHcmlkQmFzZUNvbXBvbmVudCwgSWd4R3JpZFRyYW5zYWN0aW9uLCBJRm9jdXNDaGFuZ2VFdmVudEFyZ3MsIElHcmlkRGF0YUJpbmRhYmxlLCBGaWx0ZXJNb2RlIH0gZnJvbSAnLi4vZ3JpZC1iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hHcmlkTmF2aWdhdGlvblNlcnZpY2UgfSBmcm9tICcuLi9ncmlkLW5hdmlnYXRpb24uc2VydmljZSc7XG5pbXBvcnQgeyBJZ3hHcmlkQVBJU2VydmljZSB9IGZyb20gJy4vZ3JpZC1hcGkuc2VydmljZSc7XG5pbXBvcnQgeyBJU29ydGluZ0V4cHJlc3Npb24gfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvc29ydGluZy1leHByZXNzaW9uLmludGVyZmFjZSc7XG5pbXBvcnQgeyBjbG9uZUFycmF5IH0gZnJvbSAnLi4vLi4vY29yZS91dGlscyc7XG5pbXBvcnQgeyBJR3JvdXBCeVJlY29yZCB9IGZyb20gJy4uLy4uL2RhdGEtb3BlcmF0aW9ucy9ncm91cGJ5LXJlY29yZC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSWd4R3JvdXBCeVJvd1RlbXBsYXRlRGlyZWN0aXZlIH0gZnJvbSAnLi9ncmlkLmRpcmVjdGl2ZXMnO1xuaW1wb3J0IHsgSWd4R3JpZEdyb3VwQnlSb3dDb21wb25lbnQgfSBmcm9tICcuL2dyb3VwYnktcm93LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJRGlzcGxheURlbnNpdHlPcHRpb25zLCBEaXNwbGF5RGVuc2l0eVRva2VuIH0gZnJvbSAnLi4vLi4vY29yZS9kaXNwbGF5RGVuc2l0eSc7XG5pbXBvcnQgeyBJR3JvdXBCeUV4cGFuZFN0YXRlIH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL2dyb3VwYnktZXhwYW5kLXN0YXRlLmludGVyZmFjZSc7XG5pbXBvcnQgeyBJQmFzZUNoaXBFdmVudEFyZ3MsIElDaGlwQ2xpY2tFdmVudEFyZ3MsIElDaGlwS2V5RG93bkV2ZW50QXJncyB9IGZyb20gJy4uLy4uL2NoaXBzL2NoaXAuY29tcG9uZW50JztcbmltcG9ydCB7IElDaGlwc0FyZWFSZW9yZGVyRXZlbnRBcmdzIH0gZnJvbSAnLi4vLi4vY2hpcHMvY2hpcHMtYXJlYS5jb21wb25lbnQnO1xuaW1wb3J0IHsgRGF0YVV0aWwgfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvZGF0YS11dGlsJztcbmltcG9ydCB7IElneFNlbGVjdGlvbkFQSVNlcnZpY2UgfSBmcm9tICcuLi8uLi9jb3JlL3NlbGVjdGlvbic7XG5pbXBvcnQgeyBUcmFuc2FjdGlvblNlcnZpY2UsIFRyYW5zYWN0aW9uLCBTdGF0ZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL3RyYW5zYWN0aW9uL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IElneENvbHVtbkNvbXBvbmVudCB9IGZyb20gJy4uL2NvbHVtbi5jb21wb25lbnQnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgSWd4RmlsdGVyaW5nU2VydmljZSB9IGZyb20gJy4uL2ZpbHRlcmluZy9ncmlkLWZpbHRlcmluZy5zZXJ2aWNlJztcbmltcG9ydCB7IElHcm91cGluZ0V4cHJlc3Npb24gfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvZ3JvdXBpbmctZXhwcmVzc2lvbi5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSWd4Q29sdW1uUmVzaXppbmdTZXJ2aWNlIH0gZnJvbSAnLi4vZ3JpZC1jb2x1bW4tcmVzaXppbmcuc2VydmljZSc7XG5pbXBvcnQgeyBJZ3hHcmlkU3VtbWFyeVNlcnZpY2UgfSBmcm9tICcuLi9zdW1tYXJpZXMvZ3JpZC1zdW1tYXJ5LnNlcnZpY2UnO1xuaW1wb3J0IHsgSWd4R3JpZFNlbGVjdGlvblNlcnZpY2UsIElneEdyaWRDUlVEU2VydmljZSB9IGZyb20gJy4uLy4uL2NvcmUvZ3JpZC1zZWxlY3Rpb24nO1xuaW1wb3J0IHsgSWd4T3ZlcmxheVNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9pbmRleCc7XG5pbXBvcnQgeyBJZ3hGb3JPZlN5bmNTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9mb3Itb2YvZm9yX29mLnN5bmMuc2VydmljZSc7XG5pbXBvcnQgeyBJZ3hEcmFnSW5kaWNhdG9ySWNvbkRpcmVjdGl2ZSB9IGZyb20gJy4uL3Jvdy1kcmFnLmRpcmVjdGl2ZSc7XG5cbmxldCBORVhUX0lEID0gMDtcblxuZXhwb3J0IGludGVyZmFjZSBJR3JpZEZvY3VzQ2hhbmdlRXZlbnRBcmdzIGV4dGVuZHMgSUZvY3VzQ2hhbmdlRXZlbnRBcmdzIHtcbiAgICBncm91cFJvdzogSWd4R3JpZEdyb3VwQnlSb3dDb21wb25lbnQ7XG59XG5leHBvcnQgaW50ZXJmYWNlIElHcm91cGluZ0RvbmVFdmVudEFyZ3Mge1xuICAgIGV4cHJlc3Npb25zOiBBcnJheTxJU29ydGluZ0V4cHJlc3Npb24+IHwgSVNvcnRpbmdFeHByZXNzaW9uO1xuICAgIGdyb3VwZWRDb2x1bW5zOiBBcnJheTxJZ3hDb2x1bW5Db21wb25lbnQ+IHwgSWd4Q29sdW1uQ29tcG9uZW50O1xuICAgIHVuZ3JvdXBlZENvbHVtbnM6IEFycmF5PElneENvbHVtbkNvbXBvbmVudD4gfCBJZ3hDb2x1bW5Db21wb25lbnQ7XG59XG5cbi8qKlxuICogKipJZ25pdGUgVUkgZm9yIEFuZ3VsYXIgR3JpZCoqIC1cbiAqIFtEb2N1bWVudGF0aW9uXShodHRwczovL3d3dy5pbmZyYWdpc3RpY3MuY29tL3Byb2R1Y3RzL2lnbml0ZS11aS1hbmd1bGFyL2FuZ3VsYXIvY29tcG9uZW50cy9ncmlkLmh0bWwpXG4gKlxuICogVGhlIElnbml0ZSBVSSBHcmlkIGlzIHVzZWQgZm9yIHByZXNlbnRpbmcgYW5kIG1hbmlwdWxhdGluZyB0YWJ1bGFyIGRhdGEgaW4gdGhlIHNpbXBsZXN0IHdheSBwb3NzaWJsZS4gIE9uY2UgZGF0YVxuICogaGFzIGJlZW4gYm91bmQsIGl0IGNhbiBiZSBtYW5pcHVsYXRlZCB0aHJvdWdoIGZpbHRlcmluZywgc29ydGluZyAmIGVkaXRpbmcgb3BlcmF0aW9ucy5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgaHRtbFxuICogPGlneC1ncmlkIFtkYXRhXT1cImVtcGxveWVlRGF0YVwiIGF1dG9HZW5lcmF0ZT1cImZhbHNlXCI+XG4gKiAgIDxpZ3gtY29sdW1uIGZpZWxkPVwiZmlyc3RcIiBoZWFkZXI9XCJGaXJzdCBOYW1lXCI+PC9pZ3gtY29sdW1uPlxuICogICA8aWd4LWNvbHVtbiBmaWVsZD1cImxhc3RcIiBoZWFkZXI9XCJMYXN0IE5hbWVcIj48L2lneC1jb2x1bW4+XG4gKiAgIDxpZ3gtY29sdW1uIGZpZWxkPVwicm9sZVwiIGhlYWRlcj1cIlJvbGVcIj48L2lneC1jb2x1bW4+XG4gKiA8L2lneC1ncmlkPlxuICogYGBgXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgIHByZXNlcnZlV2hpdGVzcGFjZXM6IGZhbHNlLFxuICAgIHByb3ZpZGVyczogW0lneEdyaWROYXZpZ2F0aW9uU2VydmljZSwgSWd4R3JpZFN1bW1hcnlTZXJ2aWNlLCBJZ3hHcmlkU2VsZWN0aW9uU2VydmljZSwgSWd4R3JpZENSVURTZXJ2aWNlLFxuICAgICAgICB7IHByb3ZpZGU6IEdyaWRCYXNlQVBJU2VydmljZSwgdXNlQ2xhc3M6IElneEdyaWRBUElTZXJ2aWNlIH0sXG4gICAgICAgIHsgcHJvdmlkZTogSWd4R3JpZEJhc2VDb21wb25lbnQsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IElneEdyaWRDb21wb25lbnQpIH0sXG4gICAgICAgIElneEZpbHRlcmluZ1NlcnZpY2UsIElneENvbHVtblJlc2l6aW5nU2VydmljZSwgSWd4Rm9yT2ZTeW5jU2VydmljZVxuICAgIF0sXG4gICAgc2VsZWN0b3I6ICdpZ3gtZ3JpZCcsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2dyaWQuY29tcG9uZW50Lmh0bWwnXG59KVxuZXhwb3J0IGNsYXNzIElneEdyaWRDb21wb25lbnQgZXh0ZW5kcyBJZ3hHcmlkQmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIElHcmlkRGF0YUJpbmRhYmxlLCBPbkluaXQsIERvQ2hlY2ssIEFmdGVyQ29udGVudEluaXQge1xuICAgIHByaXZhdGUgX2lkID0gYGlneC1ncmlkLSR7TkVYVF9JRCsrfWA7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfZ3JvdXBpbmdFeHByZXNzaW9uczogSUdyb3VwaW5nRXhwcmVzc2lvbltdID0gW107XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfZ3JvdXBpbmdFeHBhbmRTdGF0ZTogSUdyb3VwQnlFeHBhbmRTdGF0ZVtdID0gW107XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfZ3JvdXBSb3dUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9ncm91cEFyZWFUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdyb3VwaW5nRGlmZmVyO1xuICAgIHByaXZhdGUgX2RhdGE7XG4gICAgcHJpdmF0ZSBfaGlkZUdyb3VwZWRDb2x1bW5zID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBfZHJvcEFyZWFNZXNzYWdlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIHZhbHVlIG9mIHRoZSBgaWRgIGF0dHJpYnV0ZS4gSWYgbm90IHByb3ZpZGVkIGl0IHdpbGwgYmUgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCBbaWRdPVwiJ2lneC1ncmlkLTEnXCIgW2RhdGFdPVwiRGF0YVwiIFthdXRvR2VuZXJhdGVdPVwidHJ1ZVwiPjwvaWd4LWdyaWQ+XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmlkJylcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgaWQoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IGlkKHZhbHVlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5faWQgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBsZXRzIHlvdSBmaWxsIHRoZSBgSWd4R3JpZENvbXBvbmVudGAgd2l0aCBhbiBhcnJheSBvZiBkYXRhLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgW2RhdGFdPVwiRGF0YVwiIFthdXRvR2VuZXJhdGVdPVwidHJ1ZVwiPjwvaWd4LWdyaWQ+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneEdyaWRCYXNlQ29tcG9uZW50XG4gICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgZGF0YSgpOiBhbnlbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgZGF0YSh2YWx1ZTogYW55W10pIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IHZhbHVlO1xuICAgICAgICBpZiAodGhpcy5fbmdBZnRlclZpZXdJbml0UGFzc2VkICYmXG4gICAgICAgICAgICB0aGlzLmNhbGNIZWlnaHQgPT09IG51bGwgJiZcbiAgICAgICAgICAgIHRoaXMuaXNQZXJjZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICAvKiB0aGUgYm9keSBzaG91bGQgYmUgYXV0by1zaXplZCBpbiB0aGlzIGNhc2UgYmVmb3JlIGlneEZvciByZW5kZXJzIHRoZSB3aG9sZSBkYXRhICovXG4gICAgICAgICAgICBjb25zdCBib2R5SGVpZ2h0ID0gdGhpcy5kZWZhdWx0VGFyZ2V0Qm9keUhlaWdodDtcbiAgICAgICAgICAgIHRoaXMuY2FsY0hlaWdodCA9IGJvZHlIZWlnaHQgPiAwID8gYm9keUhlaWdodCA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdW1tYXJ5U2VydmljZS5jbGVhclN1bW1hcnlDYWNoZSgpO1xuICAgICAgICBpZiAodGhpcy5zaG91bGRHZW5lcmF0ZSkge1xuICAgICAgICAgICAgdGhpcy5zZXR1cENvbHVtbnMoKTtcbiAgICAgICAgICAgIHRoaXMucmVmbG93KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBvYmplY3RzIGNvbnRhaW5pbmcgdGhlIGZpbHRlcmVkIGRhdGEgaW4gdGhlIGBJZ3hHcmlkQ29tcG9uZW50YC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGZpbHRlcmVkRGF0YSA9IHRoaXMuZ3JpZC5maWx0ZXJlZERhdGE7XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IGZpbHRlcmVkRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlcmVkRGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGFuIGFycmF5IG9mIG9iamVjdHMgY29udGFpbmluZyB0aGUgZmlsdGVyZWQgZGF0YSBpbiB0aGUgYElneEdyaWRDb21wb25lbnRgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmdyaWQuZmlsdGVyZWREYXRhID0gW3tcbiAgICAgKiAgICAgICBJRDogMSxcbiAgICAgKiAgICAgICBOYW1lOiBcIkFcIlxuICAgICAqIH1dO1xuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4R3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHNldCBmaWx0ZXJlZERhdGEodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZmlsdGVyZWREYXRhID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKHRoaXMucm93U2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVIZWFkZXJDaGVja2JveFN0YXR1c09uRmlsdGVyKHRoaXMuX2ZpbHRlcmVkRGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIF9ncmlkQVBJOiBJZ3hHcmlkQVBJU2VydmljZTtcbiAgICBwcml2YXRlIF9maWx0ZXJlZERhdGEgPSBudWxsO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHNlbGVjdGlvblNlcnZpY2U6IElneEdyaWRTZWxlY3Rpb25TZXJ2aWNlLFxuICAgICAgICBjcnVkU2VydmljZTogSWd4R3JpZENSVURTZXJ2aWNlLFxuICAgICAgICBwdWJsaWMgY29sUmVzaXppbmdTZXJ2aWNlOiBJZ3hDb2x1bW5SZXNpemluZ1NlcnZpY2UsXG4gICAgICAgIGdyaWRBUEk6IEdyaWRCYXNlQVBJU2VydmljZTxJZ3hHcmlkQmFzZUNvbXBvbmVudCAmIElHcmlkRGF0YUJpbmRhYmxlPixcbiAgICAgICAgc2VsZWN0aW9uOiBJZ3hTZWxlY3Rpb25BUElTZXJ2aWNlLFxuICAgICAgICBASW5qZWN0KElneEdyaWRUcmFuc2FjdGlvbikgX3RyYW5zYWN0aW9uczogVHJhbnNhY3Rpb25TZXJ2aWNlPFRyYW5zYWN0aW9uLCBTdGF0ZT4sXG4gICAgICAgIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgICAgIHpvbmU6IE5nWm9uZSxcbiAgICAgICAgQEluamVjdChET0NVTUVOVCkgcHVibGljIGRvY3VtZW50LFxuICAgICAgICBjZHI6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICByZXNvbHZlcjogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxuICAgICAgICBkaWZmZXJzOiBJdGVyYWJsZURpZmZlcnMsXG4gICAgICAgIHZpZXdSZWY6IFZpZXdDb250YWluZXJSZWYsXG4gICAgICAgIG5hdmlnYXRpb246IElneEdyaWROYXZpZ2F0aW9uU2VydmljZSxcbiAgICAgICAgZmlsdGVyaW5nU2VydmljZTogSWd4RmlsdGVyaW5nU2VydmljZSxcbiAgICAgICAgQEluamVjdChJZ3hPdmVybGF5U2VydmljZSkgcHJvdGVjdGVkIG92ZXJsYXlTZXJ2aWNlOiBJZ3hPdmVybGF5U2VydmljZSxcbiAgICAgICAgc3VtbWFyeVNlcnZpY2U6IElneEdyaWRTdW1tYXJ5U2VydmljZSxcbiAgICAgICAgQE9wdGlvbmFsKCkgQEluamVjdChEaXNwbGF5RGVuc2l0eVRva2VuKSBwcm90ZWN0ZWQgX2Rpc3BsYXlEZW5zaXR5T3B0aW9uczogSURpc3BsYXlEZW5zaXR5T3B0aW9ucykge1xuICAgICAgICAgICAgc3VwZXIoc2VsZWN0aW9uU2VydmljZSxcbiAgICAgICAgICAgICAgICAgIGNydWRTZXJ2aWNlLCBncmlkQVBJLCBzZWxlY3Rpb24sIF90cmFuc2FjdGlvbnMsIGVsZW1lbnRSZWYsIHpvbmUsIGRvY3VtZW50LCBjZHIsIHJlc29sdmVyLCBkaWZmZXJzLCB2aWV3UmVmLCBuYXZpZ2F0aW9uLFxuICAgICAgICAgICAgICAgICAgZmlsdGVyaW5nU2VydmljZSwgb3ZlcmxheVNlcnZpY2UsIHN1bW1hcnlTZXJ2aWNlLCBfZGlzcGxheURlbnNpdHlPcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuX2dyaWRBUEkgPSA8SWd4R3JpZEFQSVNlcnZpY2U+Z3JpZEFQSTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBncm91cCBieSBzdGF0ZSBvZiB0aGUgYElneEdyaWRDb21wb25lbnRgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgZ3JvdXBCeVN0YXRlID0gdGhpcy5ncmlkLmdyb3VwaW5nRXhwcmVzc2lvbnM7XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBnZXQgZ3JvdXBpbmdFeHByZXNzaW9ucygpOiBJR3JvdXBpbmdFeHByZXNzaW9uW10ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBpbmdFeHByZXNzaW9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBncm91cCBieSBzdGF0ZSBvZiB0aGUgYElneEdyaWRDb21wb25lbnRgIGFuZCBlbWl0cyB0aGUgYG9uR3JvdXBpbmdEb25lYFxuICAgICAqIGV2ZW50IHdpdGggdGhlIGFwcHJvcHJpYXRlIGFyZ3VtZW50cy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5ncmlkLmdyb3VwaW5nRXhwcmVzc2lvbnMgPSBbe1xuICAgICAqICAgICBmaWVsZE5hbWU6IFwiSURcIixcbiAgICAgKiAgICAgZGlyOiBTb3J0aW5nRGlyZWN0aW9uLkFzYyxcbiAgICAgKiAgICAgaWdub3JlQ2FzZTogZmFsc2VcbiAgICAgKiB9XTtcbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneEdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBzZXQgZ3JvdXBpbmdFeHByZXNzaW9ucyh2YWx1ZTogSUdyb3VwaW5nRXhwcmVzc2lvbltdKSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5sZW5ndGggPiAxMCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ01heGltdW0gYW1vdW50IG9mIGdyb3VwZWQgY29sdW1ucyBpcyAxMC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRFeHByZXNzaW9uczogSUdyb3VwaW5nRXhwcmVzc2lvbltdID0gdGhpcy5ncm91cGluZ0V4cHJlc3Npb25zO1xuICAgICAgICBjb25zdCBuZXdFeHByZXNzaW9uczogSUdyb3VwaW5nRXhwcmVzc2lvbltdID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX2dyb3VwaW5nRXhwcmVzc2lvbnMgPSBjbG9uZUFycmF5KHZhbHVlKTtcbiAgICAgICAgdGhpcy5jaGlwc0dvdXBpbmdFeHByZXNzaW9ucyA9IGNsb25lQXJyYXkodmFsdWUpO1xuICAgICAgICBpZiAodGhpcy5fZ3JpZEFQSS5ncmlkKSB7XG4gICAgICAgICAgICAvKiBncm91cGluZyBzaG91bGQgd29yayBpbiBjb25qdW5jdGlvbiB3aXRoIHNvcnRpbmdcbiAgICAgICAgICAgIGFuZCB3aXRob3V0IG92ZXJyaWRpbmcgc2VwYXJhdGUgc29ydGluZyBleHByZXNzaW9ucyAqL1xuICAgICAgICAgICAgdGhpcy5fYXBwbHlHcm91cGluZygpO1xuICAgICAgICAgICAgdGhpcy5fZ3JpZEFQSS5hcnJhbmdlX3NvcnRpbmdfZXhwcmVzc2lvbnMoKTtcbiAgICAgICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gc2V0dGVyIGNhbGxlZCBiZWZvcmUgZ3JpZCBpcyByZWdpc3RlcmVkIGluIGdyaWQgQVBJIHNlcnZpY2VcbiAgICAgICAgICAgIHRoaXMuc29ydGluZ0V4cHJlc3Npb25zLnVuc2hpZnQuYXBwbHkodGhpcy5zb3J0aW5nRXhwcmVzc2lvbnMsIHRoaXMuX2dyb3VwaW5nRXhwcmVzc2lvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChKU09OLnN0cmluZ2lmeShvbGRFeHByZXNzaW9ucykgIT09IEpTT04uc3RyaW5naWZ5KG5ld0V4cHJlc3Npb25zKSAmJiB0aGlzLmNvbHVtbkxpc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwZWRDb2xzOiBJZ3hDb2x1bW5Db21wb25lbnRbXSA9IFtdO1xuICAgICAgICAgICAgY29uc3QgdW5ncm91cGVkQ29sczogSWd4Q29sdW1uQ29tcG9uZW50W10gPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwZWRDb2xzQXJyID0gbmV3RXhwcmVzc2lvbnMuZmlsdGVyKChvYmopID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIW9sZEV4cHJlc3Npb25zLnNvbWUoKG9iajIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iai5maWVsZE5hbWUgPT09IG9iajIuZmllbGROYW1lO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBncm91cGVkQ29sc0Fyci5mb3JFYWNoKChlbGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgZ3JvdXBlZENvbHMucHVzaCh0aGlzLmdldENvbHVtbkJ5TmFtZShlbGVtLmZpZWxkTmFtZSkpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICBjb25zdCB1bmdyb3VwZWRDb2xzQXJyID0gb2xkRXhwcmVzc2lvbnMuZmlsdGVyKChvYmopID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIW5ld0V4cHJlc3Npb25zLnNvbWUoKG9iajIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iai5maWVsZE5hbWUgPT09IG9iajIuZmllbGROYW1lO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB1bmdyb3VwZWRDb2xzQXJyLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgICAgICAgICAgICB1bmdyb3VwZWRDb2xzLnB1c2godGhpcy5nZXRDb2x1bW5CeU5hbWUoZWxlbS5maWVsZE5hbWUpKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgY29uc3QgZ3JvdXBpbmdEb25lQXJnczogSUdyb3VwaW5nRG9uZUV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgICAgICBleHByZXNzaW9uczogbmV3RXhwcmVzc2lvbnMsXG4gICAgICAgICAgICAgICAgZ3JvdXBlZENvbHVtbnM6IGdyb3VwZWRDb2xzLFxuICAgICAgICAgICAgICAgIHVuZ3JvdXBlZENvbHVtbnM6IHVuZ3JvdXBlZENvbHNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLm9uR3JvdXBpbmdEb25lLmVtaXQoZ3JvdXBpbmdEb25lQXJncyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBleHBhbnNpb24gc3RhdGVzIGZvciBncm91cCByb3dzLlxuICAgICAqIEluY2x1ZGVzIG9ubHkgc3RhdGVzIHRoYXQgZGlmZmVyIGZyb20gdGhlIGRlZmF1bHQgb25lIChjb250cm9sbGVkIHRocm91Z2ggZ3JvdXBzRXhwYW5kZWQgYW5kIHN0YXRlcyB0aGF0IHRoZSB1c2VyIGhhcyBjaGFuZ2VkLlxuICAgICAqIENvbnRhaW5zIHRoZSBleHBhbnNpb24gc3RhdGUgKGV4cGFuZGVkOiBib29sZWFuKSBhbmQgdGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgZ3JvdXAgcm93IChBcnJheSkuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGdyb3VwRXhwU3RhdGUgPSB0aGlzLmdyaWQuZ3JvdXBpbmdFeHBhbnNpb25TdGF0ZTtcbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneEdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCBncm91cGluZ0V4cGFuc2lvblN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBpbmdFeHBhbmRTdGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbGlzdCBvZiBleHBhbnNpb24gc3RhdGVzIGZvciBncm91cCByb3dzLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAgICAgIHRoaXMuZ3JpZC5ncm91cGluZ0V4cGFuc2lvblN0YXRlID0gW3tcbiAgICAgKiAgICAgIGV4cGFuZGVkOiBmYWxzZSxcbiAgICAgKiAgICAgIGhpZXJhcmNoeTogW3sgZmllbGROYW1lOiAnSUQnLCB2YWx1ZTogMSB9XVxuICAgICAqICAgfV07XG4gICAgICogLy8gWW91IGNhbiB1c2UgRGF0YVV0aWwuZ2V0SGllcmFyY2h5KGdyb3VwUm93KSB0byBnZXQgdGhlIGdyb3VwIGBJZ3hHcmlkUm93Q29tcG9uZW50YCBoaWVyYXJjaHkuXG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgc2V0IGdyb3VwaW5nRXhwYW5zaW9uU3RhdGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZ3JvdXBpbmdFeHBhbmRTdGF0ZSA9IGNsb25lQXJyYXkodmFsdWUpO1xuICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIGNyZWF0ZWQgZ3JvdXBzIGFyZSByZW5kZXJlZCBleHBhbmRlZCBvciBjb2xsYXBzZWQuXG4gICAgICogVGhlIGRlZmF1bHQgcmVuZGVyZWQgc3RhdGUgaXMgZXhwYW5kZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCAjZ3JpZCBbZGF0YV09XCJEYXRhXCIgW2dyb3Vwc0V4cGFuZGVkXT1cImZhbHNlXCIgW2F1dG9HZW5lcmF0ZV09XCJ0cnVlXCI+PC9pZ3gtZ3JpZD5cbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneEdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBncm91cHNFeHBhbmRlZCA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBBIGhpZXJhcmNoaWNhbCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ3JvdXAgYnkgcmVjb3Jkcy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IGdyb3VwUmVjb3JkcyA9IHRoaXMuZ3JpZC5ncm91cHNSZWNvcmRzO1xuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4R3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBncm91cHNSZWNvcmRzOiBJR3JvdXBCeVJlY29yZFtdID0gW107XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHdoZXRoZXIgdGhlIGdyb3VwZWQgY29sdW1ucyBzaG91bGQgYmUgaGlkZGVuIGFzIHdlbGwuXG4gICAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgXCJmYWxzZVwiXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCAjZ3JpZCBbZGF0YV09XCJsb2NhbERhdGFcIiBbaGlkZUdyb3VwZWRDb2x1bW5zXT1cInRydWVcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4R3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBoaWRlR3JvdXBlZENvbHVtbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oaWRlR3JvdXBlZENvbHVtbnM7XG4gICAgfVxuXG4gICAgcHVibGljIHNldCBoaWRlR3JvdXBlZENvbHVtbnModmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3VwaW5nRGlmZmVyID0gdGhpcy5kaWZmZXJzLmZpbmQodGhpcy5ncm91cGluZ0V4cHJlc3Npb25zKS5jcmVhdGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXBpbmdEaWZmZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbkxpc3QgJiYgdGhpcy5ncm91cGluZ0V4cHJlc3Npb25zKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRHcm91cENvbHNWaXNpYmlsaXR5KHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2hpZGVHcm91cGVkQ29sdW1ucyA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIG1lc3NhZ2UgZGlzcGxheWVkIGluc2lkZSB0aGUgR3JvdXBCeSBkcm9wIGFyZWEgd2hlcmUgY29sdW1ucyBjYW4gYmUgZHJhZ2dlZCBvbi5cbiAgICAgKiBOb3RlOiBUaGUgZ3JpZCBuZWVkcyB0byBoYXZlIGF0IGxlYXN0IG9uZSBncm91cGFibGUgY29sdW1uIGluIG9yZGVyIHRoZSBHcm91cEJ5IGFyZWEgdG8gYmUgZGlzcGxheWVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWdyaWQgZHJvcEFyZWFNZXNzYWdlPVwiRHJvcCBoZXJlIHRvIGdyb3VwIVwiPlxuICAgICAqICAgICAgPGlneC1jb2x1bW4gW2dyb3VwYWJsZV09XCJ0cnVlXCIgZmllbGQ9XCJJRFwiPjwvaWd4LWNvbHVtbj5cbiAgICAgKiA8L2lneC1ncmlkPlxuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4R3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2V0IGRyb3BBcmVhTWVzc2FnZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX2Ryb3BBcmVhTWVzc2FnZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIGFjY2Vzc29yIHRoYXQgcmV0dXJucyB0aGUgbWVzc2FnZSBkaXNwbGF5ZWQgaW5zaWRlIHRoZSBHcm91cEJ5IGRyb3AgYXJlYSB3aGVyZSBjb2x1bW5zIGNhbiBiZSBkcmFnZ2VkIG9uLlxuICAgICovXG4gICAgZ2V0IGRyb3BBcmVhTWVzc2FnZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5fZHJvcEFyZWFNZXNzYWdlIHx8IHRoaXMucmVzb3VyY2VTdHJpbmdzLmlneF9ncmlkX2dyb3VwQnlBcmVhX21lc3NhZ2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgdGVtcGxhdGUgdGhhdCB3aWxsIGJlIHJlbmRlcmVkIGFzIGEgR3JvdXBCeSBkcm9wIGFyZWEuXG4gICAgICogTm90ZTogVGhlIGdyaWQgbmVlZHMgdG8gaGF2ZSBhdCBsZWFzdCBvbmUgZ3JvdXBhYmxlIGNvbHVtbiBpbiBvcmRlciB0aGUgR3JvdXBCeSBhcmVhIHRvIGJlIGRpc3BsYXllZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1ncmlkIFtkcm9wQXJlYVRlbXBsYXRlXT1cImRyb3BBcmVhUmVmXCI+XG4gICAgICogICAgICA8aWd4LWNvbHVtbiBbZ3JvdXBhYmxlXT1cInRydWVcIiBmaWVsZD1cIklEXCI+PC9pZ3gtY29sdW1uPlxuICAgICAqIDwvaWd4LWdyaWQ+XG4gICAgICpcbiAgICAgKiA8bmctdGVtcGxhdGUgI215RHJvcEFyZWE+XG4gICAgICogICAgICA8c3Bhbj4gQ3VzdG9tIGRyb3AgYXJlYSEgPC9zcGFuPlxuICAgICAqIDwvbmctdGVtcGxhdGU+XG4gICAgICogYGBgXG4gICAgICogYGBgdHNcbiAgICAgKiBAVmlld0NoaWxkKCdteURyb3BBcmVhJywgeyByZWFkOiBUZW1wbGF0ZVJlZiB9KVxuICAgICAqIHB1YmxpYyBkcm9wQXJlYVJlZjogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneEdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBkcm9wQXJlYVRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIGEgbmV3IGBJZ3hDb2x1bW5Db21wb25lbnRgIGdldHMgZ3JvdXBlZC91bmdyb3VwZWQsIG9yIG11bHRpcGxlIGNvbHVtbnMgZ2V0XG4gICAgICogZ3JvdXBlZC91bmdyb3VwZWQgYXQgb25jZSBieSB1c2luZyB0aGUgR3JvdXAgQnkgQVBJLlxuICAgICAqIFRoZSBgb25Hcm91cGluZ0RvbmVgIGV2ZW50IHdvdWxkIGJlIHJhaXNlZCBvbmx5IG9uY2UgaWYgc2V2ZXJhbCBjb2x1bW5zIGdldCBncm91cGVkIGF0IG9uY2UgYnkgY2FsbGluZ1xuICAgICAqIHRoZSBgZ3JvdXBCeSgpYCBvciBgY2xlYXJHcm91cGluZygpYCBBUEkgbWV0aG9kcyBhbmQgcGFzc2luZyBhbiBhcnJheSBhcyBhbiBhcmd1bWVudC5cbiAgICAgKiBUaGUgZXZlbnQgYXJndW1lbnRzIHByb3ZpZGUgdGhlIGBleHByZXNzaW9uc2AsIGBncm91cGVkQ29sdW1uc2AgYW5kIGB1bmdyb3VwZWRDb2x1bW5zYCBwcm9wZXJ0aWVzLCB3aGljaCBjb250YWluXG4gICAgICogdGhlIGBJU29ydGluZ0V4cHJlc3Npb25gIGFuZCB0aGUgYElneENvbHVtbkNvbXBvbmVudGAgcmVsYXRlZCB0byB0aGUgZ3JvdXBpbmcvdW5ncm91cGluZyBvcGVyYXRpb24uXG4gICAgICogUGxlYXNlIG5vdGUgdGhhdCBgZ3JvdXBlZENvbHVtbnNgIGFuZCBgdW5ncm91cGVkQ29sdW1uc2Agc2hvdyBvbmx5IHRoZSAqKm5ld2x5KiogY2hhbmdlZCBjb2x1bW5zIChhZmZlY3RlZCBieSB0aGUgKipsYXN0KipcbiAgICAgKiBncm91cGluZy91bmdyb3VwaW5nIG9wZXJhdGlvbiksIG5vdCBhbGwgY29sdW1ucyB3aGljaCBhcmUgY3VycmVudGx5IGdyb3VwZWQvdW5ncm91cGVkLlxuICAgICAqIGNvbHVtbnMuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGdyb3VwaW5nRG9uZShldmVudDogSUdyb3VwaW5nRG9uZUV2ZW50QXJncyl7XG4gICAgICogICAgIGNvbnN0IGV4cHJlc3Npb25zID0gZXZlbnQuZXhwcmVzc2lvbnM7XG4gICAgICogICAgIC8vdGhlIG5ld2x5IGdyb3VwZWQgY29sdW1uc1xuICAgICAqICAgICBjb25zdCBncm91cGVkQ29sdW1ucyA9IGV2ZW50Lmdyb3VwZWRDb2x1bW5zO1xuICAgICAqICAgICAvL3RoZSBuZXdseSB1bmdyb3VwZWQgY29sdW1uc1xuICAgICAqICAgICBjb25zdCB1bmdyb3VwZWRDb2x1bW5zID0gZXZlbnQudW5ncm91cGVkQ29sdW1ucztcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtZ3JpZCAjZ3JpZCBbZGF0YV09XCJsb2NhbERhdGFcIiAob25Hcm91cGluZ0RvbmUpPVwiZ3JvdXBpbmdEb25lKCRldmVudClcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIj48L2lneC1ncmlkPlxuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4R3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBvbkdyb3VwaW5nRG9uZSA9IG5ldyBFdmVudEVtaXR0ZXI8SUdyb3VwaW5nRG9uZUV2ZW50QXJncz4oKTtcblxuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBvbkZvY3VzQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxJR3JpZEZvY3VzQ2hhbmdlRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoSWd4R3JvdXBCeVJvd1RlbXBsYXRlRGlyZWN0aXZlLCB7IHJlYWQ6IElneEdyb3VwQnlSb3dUZW1wbGF0ZURpcmVjdGl2ZSB9KVxuICAgIHByb3RlY3RlZCBncm91cFRlbXBsYXRlOiBJZ3hHcm91cEJ5Um93VGVtcGxhdGVEaXJlY3RpdmU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3VzdG9tIHRlbXBsYXRlLCBpZiBhbnksIHRoYXQgc2hvdWxkIGJlIHVzZWQgd2hlbiByZW5kZXJpbmcgdGhlIHJvdyBkcmFnIGluZGljYXRvciBpY29uXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gU2V0IGluIHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBteUN1c3RvbVRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+ID0gbXlDb21wb25lbnQuY3VzdG9tVGVtcGxhdGU7XG4gICAgICogbXlDb21wb25lbnQuZHJhZ0luZGljYXRvckljb25UZW1wbGF0ZSA9IG15Q3VzdG9tVGVtcGxhdGU7XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDwhLS0gU2V0IGluIG1hcmt1cCAtLT5cbiAgICAgKiAgPGlneC1ncmlkICNncmlkPlxuICAgICAqICAgICAgLi4uXG4gICAgICogICAgICA8bmctdGVtcGxhdGUgaWd4RHJhZ0luZGljYXRvckljb24+XG4gICAgICogICAgICAgICAgPGlneC1pY29uIGZvbnRTZXQ9XCJtYXRlcmlhbFwiPmluZm88L2lneC1pY29uPlxuICAgICAqICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgKiAgPC9pZ3gtZ3JpZD5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKElneERyYWdJbmRpY2F0b3JJY29uRGlyZWN0aXZlLCB7IHJlYWQ6IFRlbXBsYXRlUmVmIH0pXG4gICAgcHVibGljIGRyYWdJbmRpY2F0b3JJY29uVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4gPSBudWxsO1xuXG4gICAgQFZpZXdDaGlsZHJlbihJZ3hHcmlkR3JvdXBCeVJvd0NvbXBvbmVudCwgeyByZWFkOiBJZ3hHcmlkR3JvdXBCeVJvd0NvbXBvbmVudCB9KVxuICAgIHByaXZhdGUgX2dyb3Vwc1Jvd0xpc3Q6IFF1ZXJ5TGlzdDxJZ3hHcmlkR3JvdXBCeVJvd0NvbXBvbmVudD47XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnZGVmYXVsdERyb3BBcmVhJywgeyByZWFkOiBUZW1wbGF0ZVJlZiB9KVxuICAgIHB1YmxpYyBkZWZhdWx0RHJvcEFyZWFUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqIEEgbGlzdCBvZiBhbGwgZ3JvdXAgcm93cy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgZ3JvdXBMaXN0ID0gdGhpcy5ncmlkLmdyb3Vwc1Jvd0xpc3Q7XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIGdldCBncm91cHNSb3dMaXN0KCkge1xuICAgICAgICBjb25zdCByZXMgPSBuZXcgUXVlcnlMaXN0PGFueT4oKTtcbiAgICAgICAgaWYgKCF0aGlzLl9ncm91cHNSb3dMaXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJMaXN0ID0gdGhpcy5fZ3JvdXBzUm93TGlzdC5maWx0ZXIoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmVsZW1lbnQubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50ICE9PSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzLnJlc2V0KHJMaXN0KTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnZ3JvdXBBcmVhJylcbiAgICBwdWJsaWMgZ3JvdXBBcmVhOiBFbGVtZW50UmVmO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBncm91cEFyZWFIb3N0Q2xhc3MoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50RGVuc2l0eUNsYXNzKCdpZ3gtZHJvcC1hcmVhJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdGVtcGxhdGUgcmVmZXJlbmNlIG9mIHRoZSBgSWd4R3JpZENvbXBvbmVudGAncyBncm91cCByb3cuXG4gICAgICogYGBgXG4gICAgICogY29uc3QgZ3JvdXBSb3dUZW1wbGF0ZSA9IHRoaXMuZ3JpZC5ncm91cFJvd1RlbXBsYXRlO1xuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4R3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIGdldCBncm91cFJvd1RlbXBsYXRlKCk6IFRlbXBsYXRlUmVmPGFueT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBSb3dUZW1wbGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB0ZW1wbGF0ZSByZWZlcmVuY2Ugb2YgdGhlIGBJZ3hHcmlkQ29tcG9uZW50YCdzIGdyb3VwIGBJZ3hHcmlkUm93Q29tcG9uZW50YC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5ncmlkLmdyb3VwUm93VGVtcGxhdGUgPSBteVJvd1RlbXBsYXRlLlxuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4R3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHNldCBncm91cFJvd1RlbXBsYXRlKHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+KSB7XG4gICAgICAgIHRoaXMuX2dyb3VwUm93VGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgICAgdGhpcy5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRlbXBsYXRlIHJlZmVyZW5jZSBvZiB0aGUgYElneEdyaWRDb21wb25lbnRgJ3MgZ3JvdXAgYXJlYS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgZ3JvdXBBcmVhVGVtcGxhdGUgPSB0aGlzLmdyaWQuZ3JvdXBBcmVhVGVtcGxhdGU7XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IGdyb3VwQXJlYVRlbXBsYXRlKCk6IFRlbXBsYXRlUmVmPGFueT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ3JvdXBBcmVhVGVtcGxhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdGVtcGxhdGUgcmVmZXJlbmNlIG9mIHRoZSBgSWd4R3JpZENvbXBvbmVudGAncyBncm91cCBhcmVhLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmdyaWQuZ3JvdXBBcmVhVGVtcGxhdGUgPSBteUFyZWFUZW1wbGF0ZS5cbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneEdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBzZXQgZ3JvdXBBcmVhVGVtcGxhdGUodGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4pIHtcbiAgICAgICAgdGhpcy5fZ3JvdXBBcmVhVGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgICAgdGhpcy5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHcm91cHMgYnkgYSBuZXcgYElneENvbHVtbkNvbXBvbmVudGAgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGV4cHJlc3Npb24sIG9yIG1vZGlmaWVzIGFuIGV4aXN0aW5nIG9uZS5cbiAgICAgKiBBbHNvIGFsbG93cyBmb3IgbXVsdGlwbGUgY29sdW1ucyB0byBiZSBncm91cGVkIGF0IG9uY2UgaWYgYW4gYXJyYXkgb2YgYElTb3J0aW5nRXhwcmVzc2lvbmAgaXMgcGFzc2VkLlxuICAgICAqIFRoZSBvbkdyb3VwaW5nRG9uZSBldmVudCB3b3VsZCBnZXQgcmFpc2VkIG9ubHkgKipvbmNlKiogaWYgdGhpcyBtZXRob2QgZ2V0cyBjYWxsZWQgbXVsdGlwbGUgdGltZXMgd2l0aCB0aGUgc2FtZSBhcmd1bWVudHMuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuZ3JpZC5ncm91cEJ5KHsgZmllbGROYW1lOiBuYW1lLCBkaXI6IFNvcnRpbmdEaXJlY3Rpb24uQXNjLCBpZ25vcmVDYXNlOiBmYWxzZSB9KTtcbiAgICAgKiB0aGlzLmdyaWQuZ3JvdXBCeShbXG4gICAgICAgICAgICB7IGZpZWxkTmFtZTogbmFtZTEsIGRpcjogU29ydGluZ0RpcmVjdGlvbi5Bc2MsIGlnbm9yZUNhc2U6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IGZpZWxkTmFtZTogbmFtZTIsIGRpcjogU29ydGluZ0RpcmVjdGlvbi5EZXNjLCBpZ25vcmVDYXNlOiB0cnVlIH0sXG4gICAgICAgICAgICB7IGZpZWxkTmFtZTogbmFtZTMsIGRpcjogU29ydGluZ0RpcmVjdGlvbi5EZXNjLCBpZ25vcmVDYXNlOiBmYWxzZSB9XG4gICAgICAgIF0pO1xuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4R3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyBncm91cEJ5KGV4cHJlc3Npb246IElHcm91cGluZ0V4cHJlc3Npb24gfCBBcnJheTxJR3JvdXBpbmdFeHByZXNzaW9uPik6IHZvaWQge1xuICAgICAgICB0aGlzLmVuZEVkaXQodHJ1ZSk7XG4gICAgICAgIHRoaXMuX2dyaWRBUEkuc3VibWl0X3ZhbHVlKCk7XG4gICAgICAgIGlmIChleHByZXNzaW9uIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHRoaXMuX2dyaWRBUEkuZ3JvdXBCeV9tdWx0aXBsZShleHByZXNzaW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2dyaWRBUEkuZ3JvdXBCeShleHByZXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlR3JpZFNpemVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFsbCBncm91cGluZyBpbiB0aGUgZ3JpZCwgaWYgbm8gcGFyYW1ldGVyIGlzIHBhc3NlZC5cbiAgICAgKiBJZiBhIHBhcmFtZXRlciBpcyBwcm92aWRlZCwgY2xlYXJzIGdyb3VwaW5nIGZvciBhIHBhcnRpY3VsYXIgY29sdW1uIG9yIGFuIGFycmF5IG9mIGNvbHVtbnMuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuZ3JpZC5jbGVhckdyb3VwaW5nKCk7IC8vY2xlYXJzIGFsbCBncm91cGluZ1xuICAgICAqIHRoaXMuZ3JpZC5jbGVhckdyb3VwaW5nKFwiSURcIik7IC8vdW5ncm91cHMgYSBzaW5nbGUgY29sdW1uXG4gICAgICogdGhpcy5ncmlkLmNsZWFyR3JvdXBpbmcoW1wiSURcIiwgXCJDb2x1bW4xXCIsIFwiQ29sdW1uMlwiXSk7IC8vdW5ncm91cHMgbXVsdGlwbGUgY29sdW1uc1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICovXG4gICAgcHVibGljIGNsZWFyR3JvdXBpbmcobmFtZT86IHN0cmluZyB8IEFycmF5PHN0cmluZz4pOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fZ3JpZEFQSS5jbGVhcl9ncm91cGJ5KG5hbWUpO1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZUdyaWRTaXplcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgYSBncm91cCBpcyBleHBhbmRlZCBvciBub3QuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBncm91cFJvdzogSUdyb3VwQnlSZWNvcmQ7XG4gICAgICogY29uc3QgZXhwYW5kZWRHcm91cCA9IHRoaXMuZ3JpZC5pc0V4cGFuZGVkR3JvdXAodGhpcy5ncm91cFJvdyk7XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIGlzRXhwYW5kZWRHcm91cChncm91cDogSUdyb3VwQnlSZWNvcmQpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3Qgc3RhdGU6IElHcm91cEJ5RXhwYW5kU3RhdGUgPSB0aGlzLl9nZXRTdGF0ZUZvckdyb3VwUm93KGdyb3VwKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlID8gc3RhdGUuZXhwYW5kZWQgOiB0aGlzLmdyb3Vwc0V4cGFuZGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIGV4cGFuc2lvbiBzdGF0ZSBvZiBhIGdyb3VwLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgZ3JvdXBSb3c6IElHcm91cEJ5UmVjb3JkO1xuICAgICAqIGNvbnN0IHRvZ2dsZUV4cEdyb3VwID0gdGhpcy5ncmlkLnRvZ2dsZUdyb3VwKHRoaXMuZ3JvdXBSb3cpO1xuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4R3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyB0b2dnbGVHcm91cChncm91cFJvdzogSUdyb3VwQnlSZWNvcmQpIHtcbiAgICAgICAgdGhpcy5fdG9nZ2xlR3JvdXAoZ3JvdXBSb3cpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgaXNHcm91cEJ5UmVjb3JkKHJlY29yZDogYW55KTogYm9vbGVhbiB7XG4gICAgICAgIC8vIHJldHVybiByZWNvcmQucmVjb3JkcyBpbnN0YW5jZSBvZiBHcm91cGVkUmVjb3JkcyBmYWlscyB1bmRlciBXZWJwYWNrXG4gICAgICAgIHJldHVybiByZWNvcmQucmVjb3JkcyAmJiByZWNvcmQucmVjb3Jkcy5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgZXhwYW5zaW9uIHN0YXRlIG9mIGFsbCBncm91cCByb3dzIHJlY3Vyc2l2ZWx5LlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmdyaWQudG9nZ2xlQWxsR3JvdXBSb3dzO1xuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4R3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyB0b2dnbGVBbGxHcm91cFJvd3MoKSB7XG4gICAgICAgIHRoaXMuZ3JvdXBpbmdFeHBhbnNpb25TdGF0ZSA9IFtdO1xuICAgICAgICB0aGlzLmdyb3Vwc0V4cGFuZGVkID0gIXRoaXMuZ3JvdXBzRXhwYW5kZWQ7XG4gICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIHRoZSBgSWd4R3JpZENvbXBvbmVudGAgaGFzIGdyb3VwYWJsZSBjb2x1bW5zLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBncm91cGFibGVHcmlkID0gdGhpcy5ncmlkLmhhc0dyb3VwYWJsZUNvbHVtbnM7XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgZ2V0IGhhc0dyb3VwYWJsZUNvbHVtbnMoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbkxpc3Quc29tZSgoY29sKSA9PiBjb2wuZ3JvdXBhYmxlICYmICFjb2wuY29sdW1uR3JvdXApO1xuICAgIH1cblxuICAgIHByaXZhdGUgX3NldEdyb3VwQ29sc1Zpc2liaWxpdHkodmFsdWUpIHtcbiAgICAgICAgdGhpcy5ncm91cGluZ0V4cHJlc3Npb25zLmZvckVhY2goKGV4cHIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuZ2V0Q29sdW1uQnlOYW1lKGV4cHIuZmllbGROYW1lKTtcbiAgICAgICAgICAgIGNvbC5oaWRkZW4gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZiB0aGUgZ3JpZCdzIGdyb3VwIGJ5IGRyb3AgYXJlYSBpcyB2aXNpYmxlLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBkcm9wVmlzaWJsZSA9IHRoaXMuZ3JpZC5kcm9wQXJlYVZpc2libGU7XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIGdldCBkcm9wQXJlYVZpc2libGUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAodGhpcy5kcmFnZ2VkQ29sdW1uICYmIHRoaXMuZHJhZ2dlZENvbHVtbi5ncm91cGFibGUpIHx8XG4gICAgICAgICAgICAhdGhpcy5jaGlwc0dvdXBpbmdFeHByZXNzaW9ucy5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfZ2V0U3RhdGVGb3JHcm91cFJvdyhncm91cFJvdzogSUdyb3VwQnlSZWNvcmQpOiBJR3JvdXBCeUV4cGFuZFN0YXRlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyaWRBUEkuZ3JvdXBCeV9nZXRfZXhwYW5kZWRfZm9yX2dyb3VwKGdyb3VwUm93KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF90b2dnbGVHcm91cChncm91cFJvdzogSUdyb3VwQnlSZWNvcmQpIHtcbiAgICAgICAgdGhpcy5fZ3JpZEFQSS5ncm91cEJ5X3RvZ2dsZV9ncm91cChncm91cFJvdyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfYXBwbHlHcm91cGluZygpIHtcbiAgICAgICAgdGhpcy5fZ3JpZEFQSS5zb3J0X211bHRpcGxlKHRoaXMuX2dyb3VwaW5nRXhwcmVzc2lvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgaXNDb2x1bW5Hcm91cGVkKGZpZWxkTmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyb3VwaW5nRXhwcmVzc2lvbnMuZmluZChleHAgPT4gZXhwLmZpZWxkTmFtZSA9PT0gZmllbGROYW1lKSA/IHRydWUgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqL1xuICAgIHB1YmxpYyBnZXRDb250ZXh0KHJvd0RhdGEsIHJvd0luZGV4KTogYW55IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICRpbXBsaWNpdDogcm93RGF0YSxcbiAgICAgICAgICAgIGluZGV4OiByb3dJbmRleCxcbiAgICAgICAgICAgIHRlbXBsYXRlSUQ6IHRoaXMuaXNHcm91cEJ5UmVjb3JkKHJvd0RhdGEpID8gJ2dyb3VwUm93JyA6IHRoaXMuaXNTdW1tYXJ5Um93KHJvd0RhdGEpID8gJ3N1bW1hcnlSb3cnIDogJ2RhdGFSb3cnXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKi9cbiAgICBwdWJsaWMgZ2V0IHRlbXBsYXRlKCk6IFRlbXBsYXRlUmVmPGFueT4ge1xuICAgICAgICBpZiAodGhpcy5maWx0ZXJlZERhdGEgJiYgdGhpcy5maWx0ZXJlZERhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbXB0eUdyaWRUZW1wbGF0ZSA/IHRoaXMuZW1wdHlHcmlkVGVtcGxhdGUgOiB0aGlzLmVtcHR5RmlsdGVyZWRHcmlkVGVtcGxhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc0xvYWRpbmcgJiYgKCF0aGlzLmRhdGEgfHwgdGhpcy5kYXRhTGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9hZGluZ0dyaWRUZW1wbGF0ZSA/IHRoaXMubG9hZGluZ0dyaWRUZW1wbGF0ZSA6IHRoaXMubG9hZGluZ0dyaWREZWZhdWx0VGVtcGxhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5kYXRhTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbXB0eUdyaWRUZW1wbGF0ZSA/IHRoaXMuZW1wdHlHcmlkVGVtcGxhdGUgOiB0aGlzLmVtcHR5R3JpZERlZmF1bHRUZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0R3JvdXBCeVJlY29yZHMoKTogSUdyb3VwQnlSZWNvcmRbXSB7XG4gICAgICAgIGlmICh0aGlzLmdyb3VwaW5nRXhwcmVzc2lvbnMgJiYgdGhpcy5ncm91cGluZ0V4cHJlc3Npb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbnM6IHRoaXMuZ3JvdXBpbmdFeHByZXNzaW9ucyxcbiAgICAgICAgICAgICAgICBleHBhbnNpb246IHRoaXMuZ3JvdXBpbmdFeHBhbnNpb25TdGF0ZSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0RXhwYW5kZWQ6IHRoaXMuZ3JvdXBzRXhwYW5kZWRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiBEYXRhVXRpbC5ncm91cChjbG9uZUFycmF5KHRoaXMuZmlsdGVyZWRTb3J0ZWREYXRhKSwgc3RhdGUsIHRoaXMpLm1ldGFkYXRhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG9uQ2hpcFJlbW92ZWQoZXZlbnQ6IElCYXNlQ2hpcEV2ZW50QXJncykge1xuICAgICAgICB0aGlzLmNsZWFyR3JvdXBpbmcoZXZlbnQub3duZXIuaWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgY2hpcHNPcmRlckNoYW5nZWQoZXZlbnQ6IElDaGlwc0FyZWFSZW9yZGVyRXZlbnRBcmdzKSB7XG4gICAgICAgIGNvbnN0IG5ld0dyb3VwaW5nID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnQuY2hpcHNBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZXhwciA9IHRoaXMuZ3JvdXBpbmdFeHByZXNzaW9ucy5maWx0ZXIoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5maWVsZE5hbWUgPT09IGV2ZW50LmNoaXBzQXJyYXlbaV0uaWQ7XG4gICAgICAgICAgICB9KVswXTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLmdldENvbHVtbkJ5TmFtZShleHByLmZpZWxkTmFtZSkuZ3JvdXBhYmxlKSB7XG4gICAgICAgICAgICAgICAgLy8gZGlzYWxsb3cgY2hhbmdpbmcgb3JkZXIgaWYgdGhlcmUgYXJlIGNvbHVtbnMgd2l0aCBncm91cGFibGU6IGZhbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3R3JvdXBpbmcucHVzaChleHByKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdyb3VwaW5nRXhwYW5zaW9uU3RhdGUgPSBbXTtcbiAgICAgICAgdGhpcy5jaGlwc0dvdXBpbmdFeHByZXNzaW9ucyA9IG5ld0dyb3VwaW5nO1xuXG4gICAgICAgIGlmIChldmVudC5vcmlnaW5hbEV2ZW50IGluc3RhbmNlb2YgS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICAgICAgLy8gV2hlbiByZW9yZGVyZWQgdXNpbmcga2V5Ym9hcmQgbmF2aWdhdGlvbiwgd2UgZG9uJ3QgaGF2ZSBgb25Nb3ZlRW5kYCBldmVudC5cbiAgICAgICAgICAgIHRoaXMuZ3JvdXBpbmdFeHByZXNzaW9ucyA9IHRoaXMuY2hpcHNHb3VwaW5nRXhwcmVzc2lvbnM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGNoaXBzTW92aW5nRW5kZWQoKSB7XG4gICAgICAgIHRoaXMuZ3JvdXBpbmdFeHByZXNzaW9ucyA9IHRoaXMuY2hpcHNHb3VwaW5nRXhwcmVzc2lvbnM7XG4gICAgICAgIHRoaXMubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBvbkNoaXBDbGlja2VkKGV2ZW50OiBJQ2hpcENsaWNrRXZlbnRBcmdzKSB7XG4gICAgICAgIGNvbnN0IHNvcnRpbmdFeHByID0gdGhpcy5zb3J0aW5nRXhwcmVzc2lvbnM7XG4gICAgICAgIGNvbnN0IGNvbHVtbkV4cHIgPSBzb3J0aW5nRXhwci5maW5kKChleHByKSA9PiBleHByLmZpZWxkTmFtZSA9PT0gZXZlbnQub3duZXIuaWQpO1xuICAgICAgICBjb2x1bW5FeHByLmRpciA9IDMgLSBjb2x1bW5FeHByLmRpcjtcbiAgICAgICAgdGhpcy5zb3J0KGNvbHVtbkV4cHIpO1xuICAgICAgICB0aGlzLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgb25DaGlwS2V5RG93bihldmVudDogSUNoaXBLZXlEb3duRXZlbnRBcmdzKSB7XG4gICAgICAgIGlmIChldmVudC5vcmlnaW5hbEV2ZW50LmtleSA9PT0gJyAnIHx8IGV2ZW50Lm9yaWdpbmFsRXZlbnQua2V5ID09PSAnU3BhY2ViYXInIHx8IGV2ZW50Lm9yaWdpbmFsRXZlbnQua2V5ID09PSAnRW50ZXInKSB7XG4gICAgICAgICAgICBjb25zdCBzb3J0aW5nRXhwciA9IHRoaXMuc29ydGluZ0V4cHJlc3Npb25zO1xuICAgICAgICAgICAgY29uc3QgY29sdW1uRXhwciA9IHNvcnRpbmdFeHByLmZpbmQoKGV4cHIpID0+IGV4cHIuZmllbGROYW1lID09PSBldmVudC5vd25lci5pZCk7XG4gICAgICAgICAgICBjb2x1bW5FeHByLmRpciA9IDMgLSBjb2x1bW5FeHByLmRpcjtcbiAgICAgICAgICAgIHRoaXMuc29ydChjb2x1bW5FeHByKTtcbiAgICAgICAgICAgIHRoaXMubWFya0ZvckNoZWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdldEdyb3VwQXJlYUhlaWdodCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5ncm91cEFyZWEgPyB0aGlzLmdyb3VwQXJlYS5uYXRpdmVFbGVtZW50Lm9mZnNldEhlaWdodCA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEdldHMgdGhlIGNvbWJpbmVkIHdpZHRoIG9mIHRoZSBjb2x1bW5zIHRoYXQgYXJlIHNwZWNpZmljIHRvIHRoZSBlbmFibGVkIGdyaWQgZmVhdHVyZXMuIFRoZXkgYXJlIGZpeGVkLlxuICAgICAqIFRPRE86IFJlbW92ZSBmb3IgQW5ndWxhciA4LiBDYWxsaW5nIHBhcmVudCBjbGFzcyBnZXR0ZXIgdXNpbmcgc3VwZXIgaXMgbm90IHN1cHBvcnRlZCBmb3Igbm93LlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRGZWF0dXJlQ29sdW1uc1dpZHRoKCkge1xuICAgICAgICBsZXQgd2lkdGggPSBzdXBlci5nZXRGZWF0dXJlQ29sdW1uc1dpZHRoKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZ3JvdXBpbmdFeHByZXNzaW9ucy5sZW5ndGggJiYgdGhpcy5oZWFkZXJHcm91cENvbnRhaW5lcikge1xuICAgICAgICAgICAgd2lkdGggKz0gdGhpcy5oZWFkZXJHcm91cENvbnRhaW5lci5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgc2Nyb2xsVG8ocm93OiBhbnkgfCBudW1iZXIsIGNvbHVtbjogYW55IHwgbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmdyb3VwaW5nRXhwcmVzc2lvbnMgJiYgdGhpcy5ncm91cGluZ0V4cHJlc3Npb25zLmxlbmd0aFxuICAgICAgICAgICAgJiYgdHlwZW9mKHJvdykgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBjb25zdCBncm91cEJ5UmVjb3JkcyA9IHRoaXMuZ2V0R3JvdXBCeVJlY29yZHMoKTtcbiAgICAgICAgICAgIGNvbnN0IHJvd0luZGV4ID0gdGhpcy5maWx0ZXJlZFNvcnRlZERhdGEuaW5kZXhPZihyb3cpO1xuICAgICAgICAgICAgY29uc3QgZ3JvdXBCeVJlY29yZCA9IGdyb3VwQnlSZWNvcmRzW3Jvd0luZGV4XTtcblxuICAgICAgICAgICAgaWYgKGdyb3VwQnlSZWNvcmQgJiYgIXRoaXMuaXNFeHBhbmRlZEdyb3VwKGdyb3VwQnlSZWNvcmQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b2dnbGVHcm91cChncm91cEJ5UmVjb3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN1cGVyLnNjcm9sbFRvKHJvdywgY29sdW1uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqL1xuICAgIHB1YmxpYyBnZXQgZHJvcEFyZWFUZW1wbGF0ZVJlc29sdmVkKCk6IFRlbXBsYXRlUmVmPGFueT4ge1xuICAgICAgICBpZiAodGhpcy5kcm9wQXJlYVRlbXBsYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kcm9wQXJlYVRlbXBsYXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdERyb3BBcmVhVGVtcGxhdGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldEdyb3VwQnlDaGlwVGl0bGUoZXhwcmVzc2lvbjogSUdyb3VwaW5nRXhwcmVzc2lvbik6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbHVtbkJ5TmFtZShleHByZXNzaW9uLmZpZWxkTmFtZSkuaGVhZGVyIHx8IGV4cHJlc3Npb24uZmllbGROYW1lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICBpZiAodGhpcy5hbGxvd0ZpbHRlcmluZyAmJiB0aGlzLmhhc0NvbHVtbkxheW91dHMpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyTW9kZSA9IEZpbHRlck1vZGUuZXhjZWxTdHlsZUZpbHRlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ncm91cFRlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9ncm91cFJvd1RlbXBsYXRlID0gdGhpcy5ncm91cFRlbXBsYXRlLnRlbXBsYXRlO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLm5nQWZ0ZXJDb250ZW50SW5pdCgpO1xuXG4gICAgICAgIGlmICh0aGlzLmhpZGVHcm91cGVkQ29sdW1ucyAmJiB0aGlzLmNvbHVtbkxpc3QgJiYgdGhpcy5ncm91cGluZ0V4cHJlc3Npb25zKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRHcm91cENvbHNWaXNpYmlsaXR5KHRoaXMuaGlkZUdyb3VwZWRDb2x1bW5zKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBuZ09uSW5pdCgpIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICAgICAgdGhpcy5vbkdyb3VwaW5nRG9uZS5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSkuc3Vic2NyaWJlKChhcmdzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVuZEVkaXQodHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnN1bW1hcnlTZXJ2aWNlLnVwZGF0ZVN1bW1hcnlDYWNoZShhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHVibGljIG5nRG9DaGVjaygpOiB2b2lkIHtcbiAgICAgICAgc3VwZXIubmdEb0NoZWNrKCk7XG4gICAgICAgIGlmICh0aGlzLmdyb3VwaW5nRGlmZmVyKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy5ncm91cGluZ0RpZmZlci5kaWZmKHRoaXMuZ3JvdXBpbmdFeHByZXNzaW9ucyk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlcyAmJiB0aGlzLmNvbHVtbkxpc3QpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLmZvckVhY2hBZGRlZEl0ZW0oKHJlYykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2wgPSB0aGlzLmdldENvbHVtbkJ5TmFtZShyZWMuaXRlbS5maWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb2wuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLmZvckVhY2hSZW1vdmVkSXRlbSgocmVjKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuZ2V0Q29sdW1uQnlOYW1lKHJlYy5pdGVtLmZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbC5oaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldFNlbGVjdGVkRGF0YSgpOiBhbnlbXSB7XG4gICAgICAgIGlmICh0aGlzLmdyb3VwaW5nRXhwcmVzc2lvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBbXTtcblxuICAgICAgICAgICAgY29uc3QgcHJvY2VzcyA9IChyZWNvcmQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkLmV4cHJlc3Npb24gfHwgcmVjb3JkLnN1bW1hcmllcykge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2UucHVzaChudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzb3VyY2UucHVzaChyZWNvcmQpO1xuXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLmlneEZvck9mLmZvckVhY2gocHJvY2Vzcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5leHRyYWN0RGF0YUZyb21TZWxlY3Rpb24oc291cmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5nZXRTZWxlY3RlZERhdGEoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdfQ==