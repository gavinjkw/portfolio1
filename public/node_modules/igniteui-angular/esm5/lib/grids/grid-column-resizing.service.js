/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable, NgZone } from '@angular/core';
/**
 * @hidden
 */
var IgxColumnResizingService = /** @class */ (function () {
    function IgxColumnResizingService(zone) {
        this.zone = zone;
        /**
         * @hidden
         */
        this.resizeCursor = null;
        /**
         * @hidden
         */
        this.showResizer = false;
    }
    Object.defineProperty(IgxColumnResizingService.prototype, "resizerHeight", {
        /**
         *@hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            /** @type {?} */
            var height = this.column.grid.getVisibleContentHeight();
            // Column height multiplier in case there are Column Layouts. The resizer height need to take into account rowStart.
            /** @type {?} */
            var columnHeightMultiplier = 1;
            if (this.column.parent && this.column.parent.columnLayout) {
                columnHeightMultiplier = this.column.grid.multiRowLayoutRowSize - this.column.rowStart + 1;
            }
            if (this.column.level !== 0) {
                height -= this.column.topLevelParent.headerGroup.height - this.column.headerGroup.height * columnHeightMultiplier;
            }
            return height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnResizingService.prototype, "restrictResizeMin", {
        /**
         * Returns the minimal possible width to which the column can be resized.
         */
        get: /**
         * Returns the minimal possible width to which the column can be resized.
         * @return {?}
         */
        function () {
            /** @type {?} */
            var columnLayoutMultiplier = this.column.grid.hasColumnLayouts ? this.column.gridColumnSpan : 1;
            /** @type {?} */
            var actualMinWidth = parseFloat(this.column.minWidth);
            /** @type {?} */
            var defaultMinWidth = parseFloat(this.column.defaultMinWidth) * columnLayoutMultiplier;
            /** @type {?} */
            var minWidth = Number.isNaN(actualMinWidth) || actualMinWidth < defaultMinWidth ? defaultMinWidth : actualMinWidth;
            minWidth = minWidth < parseFloat(this.column.width) ? minWidth : parseFloat(this.column.width);
            return this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width - minWidth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnResizingService.prototype, "restrictResizeMax", {
        /**
         * Returns the maximal possible width to which the column can be resized.
         */
        get: /**
         * Returns the maximal possible width to which the column can be resized.
         * @return {?}
         */
        function () {
            /** @type {?} */
            var actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
            if (this.column.pinned) {
                /** @type {?} */
                var pinnedMaxWidth = this.pinnedMaxWidth =
                    this.column.grid.calcPinnedContainerMaxWidth - this.column.grid.getPinnedWidth(true) + actualWidth;
                if (this.column.maxWidth && parseFloat(this.column.maxWidth) < pinnedMaxWidth) {
                    this.pinnedMaxWidth = this.column.maxWidth;
                    return parseFloat(this.column.maxWidth) - actualWidth;
                }
                else {
                    return pinnedMaxWidth - actualWidth;
                }
            }
            else {
                if (this.column.maxWidth) {
                    return parseFloat(this.column.maxWidth) - actualWidth;
                }
                else {
                    return Number.MAX_SAFE_INTEGER;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Autosizes the column to the longest currently visible cell value, including the header cell.
     * If the column has a predifined maxWidth and the autosized column width will become bigger than it,
     * then the column is sized to its maxWidth.
     * If the column is pinned and the autosized column width will cause the pinned area to become bigger
     * than the maximum allowed pinned area width (80% of the total grid width), autosizing will be deismissed.
     */
    /**
     * Autosizes the column to the longest currently visible cell value, including the header cell.
     * If the column has a predifined maxWidth and the autosized column width will become bigger than it,
     * then the column is sized to its maxWidth.
     * If the column is pinned and the autosized column width will cause the pinned area to become bigger
     * than the maximum allowed pinned area width (80% of the total grid width), autosizing will be deismissed.
     * @return {?}
     */
    IgxColumnResizingService.prototype.autosizeColumnOnDblClick = /**
     * Autosizes the column to the longest currently visible cell value, including the header cell.
     * If the column has a predifined maxWidth and the autosized column width will become bigger than it,
     * then the column is sized to its maxWidth.
     * If the column is pinned and the autosized column width will cause the pinned area to become bigger
     * than the maximum allowed pinned area width (80% of the total grid width), autosizing will be deismissed.
     * @return {?}
     */
    function () {
        /** @type {?} */
        var currentColWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        /** @type {?} */
        var size = this.column.getLargestCellWidth();
        if (this.column.pinned) {
            /** @type {?} */
            var newPinnedWidth = this.column.grid.getPinnedWidth(true) - currentColWidth + parseFloat(size);
            if (newPinnedWidth <= this.column.grid.calcPinnedContainerMaxWidth) {
                this.column.width = size;
            }
        }
        else if (this.column.maxWidth && (parseFloat(size) > parseFloat(this.column.maxWidth))) {
            this.column.width = parseFloat(this.column.maxWidth) + 'px';
        }
        else if (parseFloat(size) < parseFloat(this.column.defaultMinWidth)) {
            this.column.width = this.column.defaultMinWidth + 'px';
        }
        else {
            this.column.width = size;
        }
        this.zone.run(function () { });
        this.column.grid.reflow();
        this.column.grid.onColumnResized.emit({
            column: this.column,
            prevWidth: currentColWidth.toString(),
            newWidth: this.column.width
        });
    };
    /**
     * Resizes the column regaridng to the column minWidth and maxWidth.
     */
    /**
     * Resizes the column regaridng to the column minWidth and maxWidth.
     * @param {?} event
     * @return {?}
     */
    IgxColumnResizingService.prototype.resizeColumn = /**
     * Resizes the column regaridng to the column minWidth and maxWidth.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.showResizer = false;
        /** @type {?} */
        var diff = event.clientX - this.startResizePos;
        /** @type {?} */
        var currentColWidth = parseFloat(this.column.width);
        /** @type {?} */
        var actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        currentColWidth = Number.isNaN(currentColWidth) || (currentColWidth < actualWidth) ? actualWidth : currentColWidth;
        /** @type {?} */
        var colMinWidth = this.getColMinWidth(this.column);
        /** @type {?} */
        var colMaxWidth = this.getColMaxWidth(this.column);
        if (this.column.grid.hasColumnLayouts) {
            this.resizeColumnLayoutFor(this.column, diff);
        }
        else {
            if (currentColWidth + diff < colMinWidth) {
                this.column.width = colMinWidth + 'px';
            }
            else if (colMaxWidth && (currentColWidth + diff > colMaxWidth)) {
                this.column.width = colMaxWidth + 'px';
            }
            else {
                this.column.width = (currentColWidth + diff) + 'px';
            }
        }
        this.zone.run(function () { });
        this.column.grid.reflow();
        if (currentColWidth !== parseFloat(this.column.width)) {
            this.column.grid.onColumnResized.emit({
                column: this.column,
                prevWidth: currentColWidth.toString(),
                newWidth: this.column.width
            });
        }
        this.isColumnResizing = false;
    };
    /**
     * @protected
     * @param {?} column
     * @return {?}
     */
    IgxColumnResizingService.prototype.getColMinWidth = /**
     * @protected
     * @param {?} column
     * @return {?}
     */
    function (column) {
        /** @type {?} */
        var currentColWidth = parseFloat(column.width);
        /** @type {?} */
        var actualWidth = column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        currentColWidth = Number.isNaN(currentColWidth) || (currentColWidth < actualWidth) ? actualWidth : currentColWidth;
        /** @type {?} */
        var columnLayoutMultiplier = column.grid.hasColumnLayouts ? column.gridColumnSpan : 1;
        /** @type {?} */
        var actualMinWidth = parseFloat(column.minWidth);
        /** @type {?} */
        var defaultMinWidth = parseFloat(column.defaultMinWidth) * columnLayoutMultiplier;
        /** @type {?} */
        var colMinWidth = Number.isNaN(actualMinWidth) || actualMinWidth < defaultMinWidth ? defaultMinWidth : actualMinWidth;
        return colMinWidth < currentColWidth ? colMinWidth : currentColWidth;
    };
    /**
     * @protected
     * @param {?} column
     * @return {?}
     */
    IgxColumnResizingService.prototype.getColMaxWidth = /**
     * @protected
     * @param {?} column
     * @return {?}
     */
    function (column) {
        return column.pinned ? parseFloat(this.pinnedMaxWidth) : parseFloat(column.maxWidth);
    };
    /**
     * @protected
     * @param {?} column
     * @param {?} diff
     * @return {?}
     */
    IgxColumnResizingService.prototype.resizeColumnLayoutFor = /**
     * @protected
     * @param {?} column
     * @param {?} diff
     * @return {?}
     */
    function (column, diff) {
        var _this = this;
        /** @type {?} */
        var relativeColumns = column.getResizableColUnderEnd();
        /** @type {?} */
        var combinedSpan = relativeColumns.reduce(function (acc, col) { return acc + col.spanUsed; }, 0);
        if (column.pinned) {
            /** @type {?} */
            var pinnedWidth = this.column.grid.getPinnedWidth(true);
            /** @type {?} */
            var maxPinnedWidth = this.column.grid.calcPinnedContainerMaxWidth;
            if (pinnedWidth + diff > maxPinnedWidth) {
                diff = maxPinnedWidth - pinnedWidth;
            }
        }
        // Resize first those who might reach min/max width
        /** @type {?} */
        var columnsToResize = tslib_1.__spread(relativeColumns);
        /** @type {?} */
        var updatedDiff = diff;
        /** @type {?} */
        var updatedCombinedSpan = combinedSpan;
        /** @type {?} */
        var setMinMaxCols = false;
        var _loop_1 = function () {
            // Cycle them until there are not ones that reach min/max size, because the diff accumulates after each cycle.
            // This is because we can have at first 2 cols reaching min width and then after
            // recalculating the diff there might be 1 more that reaches min width.
            setMinMaxCols = false;
            /** @type {?} */
            var newCombinedSpan = updatedCombinedSpan;
            /** @type {?} */
            var newColsToResize = [];
            columnsToResize.forEach(function (col) {
                /** @type {?} */
                var currentResizeWidth = parseFloat(col.target.calcWidth);
                /** @type {?} */
                var resizeScaled = (diff / updatedCombinedSpan) * col.target.gridColumnSpan;
                /** @type {?} */
                var minWidth = _this.getColMinWidth(col.target);
                /** @type {?} */
                var maxWidth = _this.getColMaxWidth(col.target);
                if (currentResizeWidth + resizeScaled < minWidth) {
                    col.target.width = minWidth + 'px';
                    updatedDiff += (currentResizeWidth - minWidth);
                    newCombinedSpan -= col.spanUsed;
                    setMinMaxCols = true;
                }
                else if (maxWidth && (currentResizeWidth + resizeScaled > maxWidth)) {
                    col.target.width = maxWidth + 'px';
                    updatedDiff -= (maxWidth - currentResizeWidth);
                    newCombinedSpan -= col.spanUsed;
                    setMinMaxCols = true;
                }
                else {
                    // Save new ones that can be resized
                    newColsToResize.push(col);
                }
            });
            updatedCombinedSpan = newCombinedSpan;
            columnsToResize = newColsToResize;
        };
        do {
            _loop_1();
        } while (setMinMaxCols);
        // Those left that don't reach min/max size resize them normally.
        columnsToResize.forEach(function (col) {
            /** @type {?} */
            var currentResizeWidth = parseFloat(col.target.calcWidth);
            /** @type {?} */
            var resizeScaled = (updatedDiff / updatedCombinedSpan) * col.target.gridColumnSpan;
            col.target.width = (currentResizeWidth + resizeScaled) + 'px';
        });
    };
    IgxColumnResizingService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    IgxColumnResizingService.ctorParameters = function () { return [
        { type: NgZone }
    ]; };
    return IgxColumnResizingService;
}());
export { IgxColumnResizingService };
if (false) {
    /**
     * @type {?}
     * @private
     */
    IgxColumnResizingService.prototype.pinnedMaxWidth;
    /**
     * @hidden
     * @type {?}
     */
    IgxColumnResizingService.prototype.startResizePos;
    /**
     * Indicates that a column is currently being resized.
     * @type {?}
     */
    IgxColumnResizingService.prototype.isColumnResizing;
    /**
     * @hidden
     * @type {?}
     */
    IgxColumnResizingService.prototype.resizeCursor;
    /**
     * @hidden
     * @type {?}
     */
    IgxColumnResizingService.prototype.showResizer;
    /**
     * The column being resized.
     * @type {?}
     */
    IgxColumnResizingService.prototype.column;
    /**
     * @type {?}
     * @private
     */
    IgxColumnResizingService.prototype.zone;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZC1jb2x1bW4tcmVzaXppbmcuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvZ3JpZHMvZ3JpZC1jb2x1bW4tcmVzaXppbmcuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDOzs7O0FBSW5EO0lBMEJJLGtDQUFvQixJQUFZO1FBQVosU0FBSSxHQUFKLElBQUksQ0FBUTs7OztRQVZ6QixpQkFBWSxHQUFXLElBQUksQ0FBQzs7OztRQUk1QixnQkFBVyxHQUFHLEtBQUssQ0FBQztJQU1TLENBQUM7SUFLckMsc0JBQUksbURBQWE7UUFIakI7O1dBRUc7Ozs7O1FBQ0g7O2dCQUNRLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyx1QkFBdUIsRUFBRTs7O2dCQUduRCxzQkFBc0IsR0FBRyxDQUFDO1lBQzlCLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsWUFBWSxFQUFFO2dCQUN2RCxzQkFBc0IsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxxQkFBcUIsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUM7YUFDOUY7WUFFRCxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxLQUFLLENBQUMsRUFBRTtnQkFDekIsTUFBTSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsY0FBYyxDQUFDLFdBQVcsQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsTUFBTSxHQUFHLHNCQUFzQixDQUFDO2FBQ3JIO1lBRUQsT0FBTyxNQUFNLENBQUM7UUFDbEIsQ0FBQzs7O09BQUE7SUFLRCxzQkFBSSx1REFBaUI7UUFIckI7O1dB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LENBQUMsQ0FBQztZQUVILG1CQUFtQixHQUFHLGVBQWUsQ0FBQztZQUN0QyxlQUFlLEdBQUcsZUFBZSxDQUFDOztRQTlCdEM7O2lCQStCUyxhQUFhLEVBQUU7UUFFeEIsaUVBQWlFO1FBQ2pFLGVBQWUsQ0FBQyxPQUFPLENBQUMsVUFBQyxHQUFHOztnQkFDbEIsa0JBQWtCLEdBQUcsVUFBVSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDOztnQkFDckQsWUFBWSxHQUFHLENBQUMsV0FBVyxHQUFHLG1CQUFtQixDQUFDLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxjQUFjO1lBQ3BGLEdBQUcsQ0FBQyxNQUFNLENBQUMsS0FBSyxHQUFHLENBQUMsa0JBQWtCLEdBQUcsWUFBWSxDQUFDLEdBQUcsSUFBSSxDQUFDO1FBQ2xFLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQzs7Z0JBM09KLFVBQVU7Ozs7Z0JBSlUsTUFBTTs7SUFnUDNCLCtCQUFDO0NBQUEsQUE1T0QsSUE0T0M7U0EzT1ksd0JBQXdCOzs7Ozs7SUFFakMsa0RBQStCOzs7OztJQUsvQixrREFBOEI7Ozs7O0lBSTlCLG9EQUFpQzs7Ozs7SUFJakMsZ0RBQW1DOzs7OztJQUluQywrQ0FBMkI7Ozs7O0lBSTNCLDBDQUFrQzs7Ozs7SUFFdEIsd0NBQW9CIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJZ3hDb2x1bW5Db21wb25lbnQgfSBmcm9tICcuL2NvbHVtbi5jb21wb25lbnQnO1xuXG4vKiogQGhpZGRlbiAqL1xuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIElneENvbHVtblJlc2l6aW5nU2VydmljZSB7XG5cbiAgICBwcml2YXRlIHBpbm5lZE1heFdpZHRoOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKkBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhcnRSZXNpemVQb3M6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhhdCBhIGNvbHVtbiBpcyBjdXJyZW50bHkgYmVpbmcgcmVzaXplZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgaXNDb2x1bW5SZXNpemluZzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKkBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVzaXplQ3Vyc29yOiBzdHJpbmcgPSBudWxsO1xuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBzaG93UmVzaXplciA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFRoZSBjb2x1bW4gYmVpbmcgcmVzaXplZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgY29sdW1uOiBJZ3hDb2x1bW5Db21wb25lbnQ7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHpvbmU6IE5nWm9uZSkgeyB9XG5cbiAgICAvKipcbiAgICAgKkBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgcmVzaXplckhlaWdodCgpOiBudW1iZXIge1xuICAgICAgICBsZXQgaGVpZ2h0ID0gdGhpcy5jb2x1bW4uZ3JpZC5nZXRWaXNpYmxlQ29udGVudEhlaWdodCgpO1xuXG4gICAgICAgIC8vIENvbHVtbiBoZWlnaHQgbXVsdGlwbGllciBpbiBjYXNlIHRoZXJlIGFyZSBDb2x1bW4gTGF5b3V0cy4gVGhlIHJlc2l6ZXIgaGVpZ2h0IG5lZWQgdG8gdGFrZSBpbnRvIGFjY291bnQgcm93U3RhcnQuXG4gICAgICAgIGxldCBjb2x1bW5IZWlnaHRNdWx0aXBsaWVyID0gMTtcbiAgICAgICAgaWYgKHRoaXMuY29sdW1uLnBhcmVudCAmJiB0aGlzLmNvbHVtbi5wYXJlbnQuY29sdW1uTGF5b3V0KSB7XG4gICAgICAgICAgICBjb2x1bW5IZWlnaHRNdWx0aXBsaWVyID0gdGhpcy5jb2x1bW4uZ3JpZC5tdWx0aVJvd0xheW91dFJvd1NpemUgLSB0aGlzLmNvbHVtbi5yb3dTdGFydCArIDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jb2x1bW4ubGV2ZWwgIT09IDApIHtcbiAgICAgICAgICAgIGhlaWdodCAtPSB0aGlzLmNvbHVtbi50b3BMZXZlbFBhcmVudC5oZWFkZXJHcm91cC5oZWlnaHQgLSB0aGlzLmNvbHVtbi5oZWFkZXJHcm91cC5oZWlnaHQgKiBjb2x1bW5IZWlnaHRNdWx0aXBsaWVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtaW5pbWFsIHBvc3NpYmxlIHdpZHRoIHRvIHdoaWNoIHRoZSBjb2x1bW4gY2FuIGJlIHJlc2l6ZWQuXG4gICAgICovXG4gICAgZ2V0IHJlc3RyaWN0UmVzaXplTWluKCk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IGNvbHVtbkxheW91dE11bHRpcGxpZXIgPSB0aGlzLmNvbHVtbi5ncmlkLmhhc0NvbHVtbkxheW91dHMgPyB0aGlzLmNvbHVtbi5ncmlkQ29sdW1uU3BhbiA6IDE7XG4gICAgICAgIGNvbnN0IGFjdHVhbE1pbldpZHRoID0gcGFyc2VGbG9hdCh0aGlzLmNvbHVtbi5taW5XaWR0aCk7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRNaW5XaWR0aCA9IHBhcnNlRmxvYXQodGhpcy5jb2x1bW4uZGVmYXVsdE1pbldpZHRoKSAqIGNvbHVtbkxheW91dE11bHRpcGxpZXI7XG5cbiAgICAgICAgbGV0IG1pbldpZHRoID0gTnVtYmVyLmlzTmFOKGFjdHVhbE1pbldpZHRoKSB8fCBhY3R1YWxNaW5XaWR0aCA8IGRlZmF1bHRNaW5XaWR0aCA/IGRlZmF1bHRNaW5XaWR0aCA6IGFjdHVhbE1pbldpZHRoO1xuICAgICAgICBtaW5XaWR0aCA9IG1pbldpZHRoIDwgcGFyc2VGbG9hdCh0aGlzLmNvbHVtbi53aWR0aCkgPyBtaW5XaWR0aCA6IHBhcnNlRmxvYXQodGhpcy5jb2x1bW4ud2lkdGgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbi5oZWFkZXJDZWxsLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAtIG1pbldpZHRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1heGltYWwgcG9zc2libGUgd2lkdGggdG8gd2hpY2ggdGhlIGNvbHVtbiBjYW4gYmUgcmVzaXplZC5cbiAgICAgKi9cbiAgICBnZXQgcmVzdHJpY3RSZXNpemVNYXgoKTogbnVtYmVyIHtcbiAgICAgICAgY29uc3QgYWN0dWFsV2lkdGggPSB0aGlzLmNvbHVtbi5oZWFkZXJDZWxsLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcblxuICAgICAgICBpZiAodGhpcy5jb2x1bW4ucGlubmVkKSB7XG4gICAgICAgICAgICBjb25zdCBwaW5uZWRNYXhXaWR0aCA9IHRoaXMucGlubmVkTWF4V2lkdGggPVxuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uLmdyaWQuY2FsY1Bpbm5lZENvbnRhaW5lck1heFdpZHRoIC0gdGhpcy5jb2x1bW4uZ3JpZC5nZXRQaW5uZWRXaWR0aCh0cnVlKSArIGFjdHVhbFdpZHRoO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5jb2x1bW4ubWF4V2lkdGggJiYgcGFyc2VGbG9hdCh0aGlzLmNvbHVtbi5tYXhXaWR0aCkgPCBwaW5uZWRNYXhXaWR0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGlubmVkTWF4V2lkdGggPSB0aGlzLmNvbHVtbi5tYXhXaWR0aDtcblxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHRoaXMuY29sdW1uLm1heFdpZHRoKSAtIGFjdHVhbFdpZHRoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGlubmVkTWF4V2lkdGggLSBhY3R1YWxXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbHVtbi5tYXhXaWR0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHRoaXMuY29sdW1uLm1heFdpZHRoKSAtIGFjdHVhbFdpZHRoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBdXRvc2l6ZXMgdGhlIGNvbHVtbiB0byB0aGUgbG9uZ2VzdCBjdXJyZW50bHkgdmlzaWJsZSBjZWxsIHZhbHVlLCBpbmNsdWRpbmcgdGhlIGhlYWRlciBjZWxsLlxuICAgICAqIElmIHRoZSBjb2x1bW4gaGFzIGEgcHJlZGlmaW5lZCBtYXhXaWR0aCBhbmQgdGhlIGF1dG9zaXplZCBjb2x1bW4gd2lkdGggd2lsbCBiZWNvbWUgYmlnZ2VyIHRoYW4gaXQsXG4gICAgICogdGhlbiB0aGUgY29sdW1uIGlzIHNpemVkIHRvIGl0cyBtYXhXaWR0aC5cbiAgICAgKiBJZiB0aGUgY29sdW1uIGlzIHBpbm5lZCBhbmQgdGhlIGF1dG9zaXplZCBjb2x1bW4gd2lkdGggd2lsbCBjYXVzZSB0aGUgcGlubmVkIGFyZWEgdG8gYmVjb21lIGJpZ2dlclxuICAgICAqIHRoYW4gdGhlIG1heGltdW0gYWxsb3dlZCBwaW5uZWQgYXJlYSB3aWR0aCAoODAlIG9mIHRoZSB0b3RhbCBncmlkIHdpZHRoKSwgYXV0b3NpemluZyB3aWxsIGJlIGRlaXNtaXNzZWQuXG4gICAgICovXG4gICAgcHVibGljIGF1dG9zaXplQ29sdW1uT25EYmxDbGljaygpIHtcbiAgICAgICAgY29uc3QgY3VycmVudENvbFdpZHRoID0gdGhpcy5jb2x1bW4uaGVhZGVyQ2VsbC5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG5cbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuY29sdW1uLmdldExhcmdlc3RDZWxsV2lkdGgoKTtcblxuICAgICAgICBpZiAodGhpcy5jb2x1bW4ucGlubmVkKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdQaW5uZWRXaWR0aCA9IHRoaXMuY29sdW1uLmdyaWQuZ2V0UGlubmVkV2lkdGgodHJ1ZSkgLSBjdXJyZW50Q29sV2lkdGggKyBwYXJzZUZsb2F0KHNpemUpO1xuXG4gICAgICAgICAgICBpZiAobmV3UGlubmVkV2lkdGggPD0gdGhpcy5jb2x1bW4uZ3JpZC5jYWxjUGlubmVkQ29udGFpbmVyTWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbi53aWR0aCA9IHNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jb2x1bW4ubWF4V2lkdGggJiYgKHBhcnNlRmxvYXQoc2l6ZSkgPiBwYXJzZUZsb2F0KHRoaXMuY29sdW1uLm1heFdpZHRoKSkpIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uLndpZHRoID0gcGFyc2VGbG9hdCh0aGlzLmNvbHVtbi5tYXhXaWR0aCkgKyAncHgnO1xuICAgICAgICB9IGVsc2UgaWYgKHBhcnNlRmxvYXQoc2l6ZSkgPCBwYXJzZUZsb2F0KHRoaXMuY29sdW1uLmRlZmF1bHRNaW5XaWR0aCkpIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uLndpZHRoID0gdGhpcy5jb2x1bW4uZGVmYXVsdE1pbldpZHRoICsgJ3B4JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uLndpZHRoID0gc2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge30pO1xuXG4gICAgICAgIHRoaXMuY29sdW1uLmdyaWQucmVmbG93KCk7XG4gICAgICAgIHRoaXMuY29sdW1uLmdyaWQub25Db2x1bW5SZXNpemVkLmVtaXQoe1xuICAgICAgICAgICAgY29sdW1uOiB0aGlzLmNvbHVtbixcbiAgICAgICAgICAgIHByZXZXaWR0aDogY3VycmVudENvbFdpZHRoLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBuZXdXaWR0aDogdGhpcy5jb2x1bW4ud2lkdGhcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzaXplcyB0aGUgY29sdW1uIHJlZ2FyaWRuZyB0byB0aGUgY29sdW1uIG1pbldpZHRoIGFuZCBtYXhXaWR0aC5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVzaXplQ29sdW1uKGV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgICAgIHRoaXMuc2hvd1Jlc2l6ZXIgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgZGlmZiA9IGV2ZW50LmNsaWVudFggLSB0aGlzLnN0YXJ0UmVzaXplUG9zO1xuXG4gICAgICAgIGxldCBjdXJyZW50Q29sV2lkdGggPSBwYXJzZUZsb2F0KHRoaXMuY29sdW1uLndpZHRoKTtcbiAgICAgICAgY29uc3QgYWN0dWFsV2lkdGggPSB0aGlzLmNvbHVtbi5oZWFkZXJDZWxsLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgICAgY3VycmVudENvbFdpZHRoID0gTnVtYmVyLmlzTmFOKGN1cnJlbnRDb2xXaWR0aCkgfHwgKGN1cnJlbnRDb2xXaWR0aCA8IGFjdHVhbFdpZHRoKSA/IGFjdHVhbFdpZHRoIDogY3VycmVudENvbFdpZHRoO1xuXG4gICAgICAgIGNvbnN0IGNvbE1pbldpZHRoID0gdGhpcy5nZXRDb2xNaW5XaWR0aCh0aGlzLmNvbHVtbik7XG4gICAgICAgIGNvbnN0IGNvbE1heFdpZHRoID0gdGhpcy5nZXRDb2xNYXhXaWR0aCh0aGlzLmNvbHVtbik7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbi5ncmlkLmhhc0NvbHVtbkxheW91dHMpIHtcbiAgICAgICAgICAgIHRoaXMucmVzaXplQ29sdW1uTGF5b3V0Rm9yKHRoaXMuY29sdW1uLCBkaWZmKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q29sV2lkdGggKyBkaWZmIDwgY29sTWluV2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbi53aWR0aCA9IGNvbE1pbldpZHRoICsgJ3B4JztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29sTWF4V2lkdGggJiYgKGN1cnJlbnRDb2xXaWR0aCArIGRpZmYgPiBjb2xNYXhXaWR0aCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbi53aWR0aCA9IGNvbE1heFdpZHRoICsgJ3B4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2x1bW4ud2lkdGggPSAoY3VycmVudENvbFdpZHRoICsgZGlmZikgKyAncHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7fSk7XG4gICAgICAgIHRoaXMuY29sdW1uLmdyaWQucmVmbG93KCk7XG5cbiAgICAgICAgaWYgKGN1cnJlbnRDb2xXaWR0aCAhPT0gcGFyc2VGbG9hdCh0aGlzLmNvbHVtbi53aWR0aCkpIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uLmdyaWQub25Db2x1bW5SZXNpemVkLmVtaXQoe1xuICAgICAgICAgICAgICAgIGNvbHVtbjogdGhpcy5jb2x1bW4sXG4gICAgICAgICAgICAgICAgcHJldldpZHRoOiBjdXJyZW50Q29sV2lkdGgudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBuZXdXaWR0aDogdGhpcy5jb2x1bW4ud2lkdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc0NvbHVtblJlc2l6aW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldENvbE1pbldpZHRoKGNvbHVtbjogSWd4Q29sdW1uQ29tcG9uZW50KSB7XG4gICAgICAgIGxldCBjdXJyZW50Q29sV2lkdGggPSBwYXJzZUZsb2F0KGNvbHVtbi53aWR0aCk7XG4gICAgICAgIGNvbnN0IGFjdHVhbFdpZHRoID0gY29sdW1uLmhlYWRlckNlbGwuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgICBjdXJyZW50Q29sV2lkdGggPSBOdW1iZXIuaXNOYU4oY3VycmVudENvbFdpZHRoKSB8fCAoY3VycmVudENvbFdpZHRoIDwgYWN0dWFsV2lkdGgpID8gYWN0dWFsV2lkdGggOiBjdXJyZW50Q29sV2lkdGg7XG5cbiAgICAgICAgY29uc3QgY29sdW1uTGF5b3V0TXVsdGlwbGllciA9IGNvbHVtbi5ncmlkLmhhc0NvbHVtbkxheW91dHMgPyBjb2x1bW4uZ3JpZENvbHVtblNwYW4gOiAxO1xuICAgICAgICBjb25zdCBhY3R1YWxNaW5XaWR0aCA9IHBhcnNlRmxvYXQoY29sdW1uLm1pbldpZHRoKTtcbiAgICAgICAgY29uc3QgZGVmYXVsdE1pbldpZHRoID0gcGFyc2VGbG9hdChjb2x1bW4uZGVmYXVsdE1pbldpZHRoKSAqIGNvbHVtbkxheW91dE11bHRpcGxpZXI7XG4gICAgICAgIGNvbnN0IGNvbE1pbldpZHRoID0gTnVtYmVyLmlzTmFOKGFjdHVhbE1pbldpZHRoKSB8fCBhY3R1YWxNaW5XaWR0aCA8IGRlZmF1bHRNaW5XaWR0aCA/IGRlZmF1bHRNaW5XaWR0aCA6IGFjdHVhbE1pbldpZHRoO1xuICAgICAgICByZXR1cm4gY29sTWluV2lkdGggPCBjdXJyZW50Q29sV2lkdGggPyBjb2xNaW5XaWR0aCA6IGN1cnJlbnRDb2xXaWR0aDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0Q29sTWF4V2lkdGgoY29sdW1uOiBJZ3hDb2x1bW5Db21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbHVtbi5waW5uZWQgPyBwYXJzZUZsb2F0KHRoaXMucGlubmVkTWF4V2lkdGgpIDogcGFyc2VGbG9hdChjb2x1bW4ubWF4V2lkdGgpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCByZXNpemVDb2x1bW5MYXlvdXRGb3IoY29sdW1uOiBJZ3hDb2x1bW5Db21wb25lbnQsIGRpZmY6IG51bWJlcikge1xuICAgICAgICBjb25zdCByZWxhdGl2ZUNvbHVtbnMgPSBjb2x1bW4uZ2V0UmVzaXphYmxlQ29sVW5kZXJFbmQoKTtcbiAgICAgICAgY29uc3QgY29tYmluZWRTcGFuID0gcmVsYXRpdmVDb2x1bW5zLnJlZHVjZSgoYWNjLCBjb2wpID0+ICBhY2MgKyBjb2wuc3BhblVzZWQsIDApO1xuXG4gICAgICAgIGlmIChjb2x1bW4ucGlubmVkKSB7XG4gICAgICAgICAgICBjb25zdCBwaW5uZWRXaWR0aCA9IHRoaXMuY29sdW1uLmdyaWQuZ2V0UGlubmVkV2lkdGgodHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBtYXhQaW5uZWRXaWR0aCA9IHRoaXMuY29sdW1uLmdyaWQuY2FsY1Bpbm5lZENvbnRhaW5lck1heFdpZHRoO1xuXG4gICAgICAgICAgICBpZiAocGlubmVkV2lkdGggKyBkaWZmID4gbWF4UGlubmVkV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBkaWZmID0gbWF4UGlubmVkV2lkdGggLSBwaW5uZWRXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlc2l6ZSBmaXJzdCB0aG9zZSB3aG8gbWlnaHQgcmVhY2ggbWluL21heCB3aWR0aFxuICAgICAgICBsZXQgY29sdW1uc1RvUmVzaXplID0gWy4uLnJlbGF0aXZlQ29sdW1uc107XG4gICAgICAgIGxldCB1cGRhdGVkRGlmZiA9IGRpZmY7XG4gICAgICAgIGxldCB1cGRhdGVkQ29tYmluZWRTcGFuID0gY29tYmluZWRTcGFuO1xuICAgICAgICBsZXQgc2V0TWluTWF4Q29scyA9IGZhbHNlO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICAvLyBDeWNsZSB0aGVtIHVudGlsIHRoZXJlIGFyZSBub3Qgb25lcyB0aGF0IHJlYWNoIG1pbi9tYXggc2l6ZSwgYmVjYXVzZSB0aGUgZGlmZiBhY2N1bXVsYXRlcyBhZnRlciBlYWNoIGN5Y2xlLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIHdlIGNhbiBoYXZlIGF0IGZpcnN0IDIgY29scyByZWFjaGluZyBtaW4gd2lkdGggYW5kIHRoZW4gYWZ0ZXJcbiAgICAgICAgICAgIC8vIHJlY2FsY3VsYXRpbmcgdGhlIGRpZmYgdGhlcmUgbWlnaHQgYmUgMSBtb3JlIHRoYXQgcmVhY2hlcyBtaW4gd2lkdGguXG4gICAgICAgICAgICBzZXRNaW5NYXhDb2xzID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgbmV3Q29tYmluZWRTcGFuID0gdXBkYXRlZENvbWJpbmVkU3BhbjtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvbHNUb1Jlc2l6ZSA9IFtdO1xuICAgICAgICAgICAgY29sdW1uc1RvUmVzaXplLmZvckVhY2goKGNvbCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRSZXNpemVXaWR0aCA9IHBhcnNlRmxvYXQoY29sLnRhcmdldC5jYWxjV2lkdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc2l6ZVNjYWxlZCA9IChkaWZmIC8gdXBkYXRlZENvbWJpbmVkU3BhbikgKiBjb2wudGFyZ2V0LmdyaWRDb2x1bW5TcGFuO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbWluV2lkdGggPSB0aGlzLmdldENvbE1pbldpZHRoKGNvbC50YXJnZXQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heFdpZHRoID0gdGhpcy5nZXRDb2xNYXhXaWR0aChjb2wudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFJlc2l6ZVdpZHRoICsgcmVzaXplU2NhbGVkIDwgbWluV2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29sLnRhcmdldC53aWR0aCA9IG1pbldpZHRoICsgJ3B4JztcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZERpZmYgKz0gKGN1cnJlbnRSZXNpemVXaWR0aCAtIG1pbldpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29tYmluZWRTcGFuIC09IGNvbC5zcGFuVXNlZDtcbiAgICAgICAgICAgICAgICAgICAgc2V0TWluTWF4Q29scyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXhXaWR0aCAmJiAoY3VycmVudFJlc2l6ZVdpZHRoICsgcmVzaXplU2NhbGVkID4gbWF4V2lkdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbC50YXJnZXQud2lkdGggPSBtYXhXaWR0aCArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWREaWZmIC09IChtYXhXaWR0aCAtIGN1cnJlbnRSZXNpemVXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbWJpbmVkU3BhbiAtPSBjb2wuc3BhblVzZWQ7XG4gICAgICAgICAgICAgICAgICAgIHNldE1pbk1heENvbHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgbmV3IG9uZXMgdGhhdCBjYW4gYmUgcmVzaXplZFxuICAgICAgICAgICAgICAgICAgICBuZXdDb2xzVG9SZXNpemUucHVzaChjb2wpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB1cGRhdGVkQ29tYmluZWRTcGFuID0gbmV3Q29tYmluZWRTcGFuO1xuICAgICAgICAgICAgY29sdW1uc1RvUmVzaXplID0gbmV3Q29sc1RvUmVzaXplO1xuICAgICAgICB9IHdoaWxlIChzZXRNaW5NYXhDb2xzKTtcblxuICAgICAgICAvLyBUaG9zZSBsZWZ0IHRoYXQgZG9uJ3QgcmVhY2ggbWluL21heCBzaXplIHJlc2l6ZSB0aGVtIG5vcm1hbGx5LlxuICAgICAgICBjb2x1bW5zVG9SZXNpemUuZm9yRWFjaCgoY29sKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50UmVzaXplV2lkdGggPSBwYXJzZUZsb2F0KGNvbC50YXJnZXQuY2FsY1dpZHRoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc2l6ZVNjYWxlZCA9ICh1cGRhdGVkRGlmZiAvIHVwZGF0ZWRDb21iaW5lZFNwYW4pICogY29sLnRhcmdldC5ncmlkQ29sdW1uU3BhbjtcbiAgICAgICAgICAgIGNvbC50YXJnZXQud2lkdGggPSAoY3VycmVudFJlc2l6ZVdpZHRoICsgcmVzaXplU2NhbGVkKSArICdweCc7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiJdfQ==