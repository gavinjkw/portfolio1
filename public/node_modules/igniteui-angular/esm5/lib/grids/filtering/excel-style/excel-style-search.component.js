/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ChangeDetectionStrategy, Input, ViewChild } from '@angular/core';
import { IgxColumnComponent } from '../../column.component';
import { IgxInputDirective } from '../../../directives/input/input.directive';
import { DisplayDensity } from '../../../core/density';
import { IgxForOfDirective } from '../../../directives/for-of/for_of.directive';
/**
 * @hidden
 */
var IgxExcelStyleSearchComponent = /** @class */ (function () {
    function IgxExcelStyleSearchComponent() {
    }
    /**
     * @return {?}
     */
    IgxExcelStyleSearchComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        requestAnimationFrame(function () {
            _this.virtDir.recalcUpdateSizes();
        });
    };
    /**
     * @return {?}
     */
    IgxExcelStyleSearchComponent.prototype.clearInput = /**
     * @return {?}
     */
    function () {
        this.searchValue = null;
    };
    /**
     * @param {?} eventArgs
     * @return {?}
     */
    IgxExcelStyleSearchComponent.prototype.onCheckboxChange = /**
     * @param {?} eventArgs
     * @return {?}
     */
    function (eventArgs) {
        var _this = this;
        /** @type {?} */
        var selectedIndex = this.data.indexOf(eventArgs.checkbox.value);
        if (selectedIndex === 0) {
            this.data.forEach(function (element) {
                element.isSelected = eventArgs.checked;
                _this.data[0].indeterminate = false;
            });
        }
        else {
            eventArgs.checkbox.value.isSelected = eventArgs.checked;
            if (!this.data.slice(1, this.data.length).find(function (el) { return el.isSelected === false; })) {
                this.data[0].indeterminate = false;
                this.data[0].isSelected = true;
            }
            else if (!this.data.slice(1, this.data.length).find(function (el) { return el.isSelected === true; })) {
                this.data[0].indeterminate = false;
                this.data[0].isSelected = false;
            }
            else {
                this.data[0].indeterminate = true;
            }
        }
        eventArgs.checkbox.nativeCheckbox.nativeElement.blur();
    };
    Object.defineProperty(IgxExcelStyleSearchComponent.prototype, "itemSize", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var itemSize = '48px';
            switch (this.displayDensity) {
                case DisplayDensity.cosy:
                    itemSize = '32px';
                    break;
                case DisplayDensity.compact:
                    itemSize = '28px';
                    break;
                default: break;
            }
            return itemSize;
        },
        enumerable: true,
        configurable: true
    });
    IgxExcelStyleSearchComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-excel-style-search',
                    template: "<igx-input-group\n            type=\"box\"\n            [displayDensity]=\"displayDensity\"\n            [supressInputAutofocus]=\"true\">\n    <igx-icon igxPrefix>search</igx-icon>\n    <input\n        #input\n        igxInput\n        tabindex=\"0\"\n        [(ngModel)]=\"searchValue\"\n        [placeholder]=\"column.grid.resourceStrings.igx_grid_excel_search_placeholder\"\n        autocomplete=\"off\"/>\n    <igx-icon\n        igxSuffix\n        *ngIf=\"searchValue || searchValue === 0\"\n        (click)=\"clearInput()\"\n        tabindex=\"0\">\n        clear\n    </igx-icon>\n</igx-input-group>\n\n        <igx-list [displayDensity]=\"displayDensity\" [style.height.px]=\"250\">\n            <div [style.overflow]=\"'hidden'\" [style.position]=\"'relative'\">\n                <igx-list-item\n                    *igxFor=\"let item of data | excelStyleSearchFilter: searchValue; scrollOrientation : 'vertical'; containerSize: '250px'; itemSize: itemSize\">\n                    <igx-checkbox\n                    [value]=\"item\"\n                    tabindex=\"-1\"\n                    [checked]=\"item.isSelected\"\n                    [disableRipple]=\"true\"\n                    [indeterminate]=\"item.indeterminate\"\n                    [disableTransitions]=\"true\"\n                    (change)=\"onCheckboxChange($event)\">\n                        {{ column.formatter && !item.isSpecial ? column.formatter(item.label) : column.dataType === 'number' ? (item.label | igxdecimal:\n                            column.grid.locale) : column.dataType === 'date' ? (item.label | igxdate: column.grid.locale) : item.label }}\n                    </igx-checkbox>\n                </igx-list-item>\n            </div>\n        </igx-list>\n"
                }] }
    ];
    /** @nocollapse */
    IgxExcelStyleSearchComponent.ctorParameters = function () { return []; };
    IgxExcelStyleSearchComponent.propDecorators = {
        data: [{ type: Input }],
        column: [{ type: Input }],
        searchInput: [{ type: ViewChild, args: ['input', { read: IgxInputDirective },] }],
        displayDensity: [{ type: Input }],
        virtDir: [{ type: ViewChild, args: [IgxForOfDirective,] }]
    };
    return IgxExcelStyleSearchComponent;
}());
export { IgxExcelStyleSearchComponent };
if (false) {
    /** @type {?} */
    IgxExcelStyleSearchComponent.prototype.searchValue;
    /** @type {?} */
    IgxExcelStyleSearchComponent.prototype.data;
    /** @type {?} */
    IgxExcelStyleSearchComponent.prototype.column;
    /** @type {?} */
    IgxExcelStyleSearchComponent.prototype.searchInput;
    /** @type {?} */
    IgxExcelStyleSearchComponent.prototype.displayDensity;
    /**
     * @type {?}
     * @protected
     */
    IgxExcelStyleSearchComponent.prototype.virtDir;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhjZWwtc3R5bGUtc2VhcmNoLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvZ3JpZHMvZmlsdGVyaW5nL2V4Y2VsLXN0eWxlL2V4Y2VsLXN0eWxlLXNlYXJjaC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFFSCxTQUFTLEVBQ1QsdUJBQXVCLEVBQ3ZCLEtBQUssRUFDTCxTQUFTLEVBQ1osTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFHNUQsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sMkNBQTJDLENBQUM7QUFDOUUsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLHVCQUF1QixDQUFDO0FBQ3ZELE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLDZDQUE2QyxDQUFDOzs7O0FBTWhGO0lBeUJJO0lBQWUsQ0FBQzs7OztJQUVULHNEQUFlOzs7SUFBdEI7UUFBQSxpQkFJQztRQUhHLHFCQUFxQixDQUFDO1lBQ2xCLEtBQUksQ0FBQyxPQUFPLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUNyQyxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7Ozs7SUFFTSxpREFBVTs7O0lBQWpCO1FBQ0ksSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUM7SUFDNUIsQ0FBQzs7Ozs7SUFFTSx1REFBZ0I7Ozs7SUFBdkIsVUFBd0IsU0FBbUM7UUFBM0QsaUJBb0JDOztZQW5CUyxhQUFhLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUM7UUFDakUsSUFBSSxhQUFhLEtBQUssQ0FBQyxFQUFFO1lBQ3JCLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFVBQUEsT0FBTztnQkFDckIsT0FBTyxDQUFDLFVBQVUsR0FBRyxTQUFTLENBQUMsT0FBTyxDQUFDO2dCQUN2QyxLQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWEsR0FBRyxLQUFLLENBQUM7WUFDdkMsQ0FBQyxDQUFDLENBQUM7U0FDTjthQUFNO1lBQ0gsU0FBUyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsVUFBVSxHQUFHLFNBQVMsQ0FBQyxPQUFPLENBQUM7WUFDeEQsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFBLEVBQUUsSUFBSSxPQUFBLEVBQUUsQ0FBQyxVQUFVLEtBQUssS0FBSyxFQUF2QixDQUF1QixDQUFDLEVBQUU7Z0JBQzNFLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsYUFBYSxHQUFHLEtBQUssQ0FBQztnQkFDbkMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDO2FBQ2xDO2lCQUFNLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBQSxFQUFFLElBQUksT0FBQSxFQUFFLENBQUMsVUFBVSxLQUFLLElBQUksRUFBdEIsQ0FBc0IsQ0FBQyxFQUFFO2dCQUNqRixJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWEsR0FBRyxLQUFLLENBQUM7Z0JBQ25DLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxHQUFHLEtBQUssQ0FBQzthQUNuQztpQkFBTTtnQkFDSCxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWEsR0FBRyxJQUFJLENBQUM7YUFDckM7U0FDSjtRQUNELFNBQVMsQ0FBQyxRQUFRLENBQUMsY0FBYyxDQUFDLGFBQWEsQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUMzRCxDQUFDO0lBRUQsc0JBQVcsa0RBQVE7Ozs7UUFBbkI7O2dCQUNRLFFBQVEsR0FBRyxNQUFNO1lBQ3JCLFFBQVEsSUFBSSxDQUFDLGNBQWMsRUFBRTtnQkFDekIsS0FBSyxjQUFjLENBQUMsSUFBSTtvQkFBRSxRQUFRLEdBQUcsTUFBTSxDQUFDO29CQUFDLE1BQU07Z0JBQ25ELEtBQUssY0FBYyxDQUFDLE9BQU87b0JBQUUsUUFBUSxHQUFHLE1BQU0sQ0FBQztvQkFBQyxNQUFNO2dCQUN0RCxPQUFPLENBQUMsQ0FBQyxNQUFNO2FBQ2xCO1lBQ0QsT0FBTyxRQUFRLENBQUM7UUFDcEIsQ0FBQzs7O09BQUE7O2dCQW5FSixTQUFTLFNBQUM7b0JBQ1AsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07b0JBQy9DLG1CQUFtQixFQUFFLEtBQUs7b0JBQzFCLFFBQVEsRUFBRSx3QkFBd0I7b0JBQ2xDLHF1REFBa0Q7aUJBQ3JEOzs7Ozt1QkFLSSxLQUFLO3lCQUdMLEtBQUs7OEJBR0wsU0FBUyxTQUFDLE9BQU8sRUFBRSxFQUFFLElBQUksRUFBRSxpQkFBaUIsRUFBRTtpQ0FHOUMsS0FBSzswQkFHTCxTQUFTLFNBQUMsaUJBQWlCOztJQThDaEMsbUNBQUM7Q0FBQSxBQXBFRCxJQW9FQztTQTlEWSw0QkFBNEI7OztJQUVyQyxtREFBd0I7O0lBRXhCLDRDQUM4Qjs7SUFFOUIsOENBQ2tDOztJQUVsQyxtREFDc0M7O0lBRXRDLHNEQUNzQzs7Ozs7SUFFdEMsK0NBQzBDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBBZnRlclZpZXdJbml0LFxuICAgIENvbXBvbmVudCxcbiAgICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgICBJbnB1dCxcbiAgICBWaWV3Q2hpbGRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJZ3hDb2x1bW5Db21wb25lbnQgfSBmcm9tICcuLi8uLi9jb2x1bW4uY29tcG9uZW50JztcbmltcG9ydCB7IElneEZpbHRlck9wdGlvbnMgfSBmcm9tICcuLi8uLi8uLi9kaXJlY3RpdmVzL2ZpbHRlci9maWx0ZXIuZGlyZWN0aXZlJztcbmltcG9ydCB7IElDaGFuZ2VDaGVja2JveEV2ZW50QXJncyB9IGZyb20gJy4uLy4uLy4uL2NoZWNrYm94L2NoZWNrYm94LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hJbnB1dERpcmVjdGl2ZSB9IGZyb20gJy4uLy4uLy4uL2RpcmVjdGl2ZXMvaW5wdXQvaW5wdXQuZGlyZWN0aXZlJztcbmltcG9ydCB7IERpc3BsYXlEZW5zaXR5IH0gZnJvbSAnLi4vLi4vLi4vY29yZS9kZW5zaXR5JztcbmltcG9ydCB7IElneEZvck9mRGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vLi4vZGlyZWN0aXZlcy9mb3Itb2YvZm9yX29mLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBGaWx0ZXJMaXN0SXRlbSB9IGZyb20gJy4vZ3JpZC5leGNlbC1zdHlsZS1maWx0ZXJpbmcuY29tcG9uZW50JztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgIHByZXNlcnZlV2hpdGVzcGFjZXM6IGZhbHNlLFxuICAgIHNlbGVjdG9yOiAnaWd4LWV4Y2VsLXN0eWxlLXNlYXJjaCcsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2V4Y2VsLXN0eWxlLXNlYXJjaC5jb21wb25lbnQuaHRtbCdcbn0pXG5leHBvcnQgY2xhc3MgSWd4RXhjZWxTdHlsZVNlYXJjaENvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQge1xuXG4gICAgcHVibGljIHNlYXJjaFZhbHVlOiBhbnk7XG5cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBkYXRhOiBGaWx0ZXJMaXN0SXRlbVtdO1xuXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgY29sdW1uOiBJZ3hDb2x1bW5Db21wb25lbnQ7XG5cbiAgICBAVmlld0NoaWxkKCdpbnB1dCcsIHsgcmVhZDogSWd4SW5wdXREaXJlY3RpdmUgfSlcbiAgICBwdWJsaWMgc2VhcmNoSW5wdXQ6IElneElucHV0RGlyZWN0aXZlO1xuXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZGlzcGxheURlbnNpdHk6IERpc3BsYXlEZW5zaXR5O1xuXG4gICAgQFZpZXdDaGlsZChJZ3hGb3JPZkRpcmVjdGl2ZSlcbiAgICBwcm90ZWN0ZWQgdmlydERpcjogSWd4Rm9yT2ZEaXJlY3RpdmU8YW55PjtcblxuICAgIGNvbnN0cnVjdG9yKCkge31cblxuICAgIHB1YmxpYyBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnZpcnREaXIucmVjYWxjVXBkYXRlU2l6ZXMoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHVibGljIGNsZWFySW5wdXQoKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoVmFsdWUgPSBudWxsO1xuICAgIH1cblxuICAgIHB1YmxpYyBvbkNoZWNrYm94Q2hhbmdlKGV2ZW50QXJnczogSUNoYW5nZUNoZWNrYm94RXZlbnRBcmdzKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGVkSW5kZXggPSB0aGlzLmRhdGEuaW5kZXhPZihldmVudEFyZ3MuY2hlY2tib3gudmFsdWUpO1xuICAgICAgICBpZiAoc2VsZWN0ZWRJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5pc1NlbGVjdGVkID0gZXZlbnRBcmdzLmNoZWNrZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhWzBdLmluZGV0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXZlbnRBcmdzLmNoZWNrYm94LnZhbHVlLmlzU2VsZWN0ZWQgPSBldmVudEFyZ3MuY2hlY2tlZDtcbiAgICAgICAgICAgIGlmICghdGhpcy5kYXRhLnNsaWNlKDEsIHRoaXMuZGF0YS5sZW5ndGgpLmZpbmQoZWwgPT4gZWwuaXNTZWxlY3RlZCA9PT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhWzBdLmluZGV0ZXJtaW5hdGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFbMF0uaXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmRhdGEuc2xpY2UoMSwgdGhpcy5kYXRhLmxlbmd0aCkuZmluZChlbCA9PiBlbC5pc1NlbGVjdGVkID09PSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVswXS5pbmRldGVybWluYXRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhWzBdLmlzU2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhWzBdLmluZGV0ZXJtaW5hdGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGV2ZW50QXJncy5jaGVja2JveC5uYXRpdmVDaGVja2JveC5uYXRpdmVFbGVtZW50LmJsdXIoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGl0ZW1TaXplKCkge1xuICAgICAgICBsZXQgaXRlbVNpemUgPSAnNDhweCc7XG4gICAgICAgIHN3aXRjaCAodGhpcy5kaXNwbGF5RGVuc2l0eSkge1xuICAgICAgICAgICAgY2FzZSBEaXNwbGF5RGVuc2l0eS5jb3N5OiBpdGVtU2l6ZSA9ICczMnB4JzsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIERpc3BsYXlEZW5zaXR5LmNvbXBhY3Q6IGl0ZW1TaXplID0gJzI4cHgnOyBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtU2l6ZTtcbiAgICB9XG59XG4iXX0=