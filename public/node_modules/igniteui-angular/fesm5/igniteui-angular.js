import * as JSZip from 'jszip/dist/jszip';
import { HttpClient, HttpClientModule } from '@angular/common/http';
import { Subject as Subject$1 } from 'rxjs/internal/Subject';
import { DomSanitizer, ÉµgetDOM, HammerGestureConfig, HAMMER_GESTURE_CONFIG } from '@angular/platform-browser';
import { filter, takeUntil, take, first, throttle, debounce, tap, skipLast, switchMap, map, debounceTime } from 'rxjs/operators';
import { animate, animation, style, keyframes, AnimationBuilder, transition, trigger, useAnimation, state } from '@angular/animations';
import { DOCUMENT, CommonModule, formatDate, DatePipe, DecimalPipe } from '@angular/common';
import { FormControlName, NgModel, NG_VALUE_ACCESSOR, FormsModule, CheckboxRequiredValidator, NG_VALIDATORS, ReactiveFormsModule, NgControl } from '@angular/forms';
import { __extends, __read, __values, __spread, __assign, __decorate, __metadata } from 'tslib';
import { Directive, HostListener, Input, NgModule, Injectable, Pipe, EventEmitter, Output, isDevMode, ApplicationRef, ComponentFactoryResolver, ElementRef, Inject, Injector, NgZone, TemplateRef, HostBinding, ChangeDetectionStrategy, Component, ViewChild, SimpleChange, ChangeDetectorRef, ViewContainerRef, forwardRef, ViewChildren, QueryList, Optional, Self, Renderer2, ContentChild, InjectionToken, ContentChildren, IterableDiffers, SecurityContext, Host, Renderer, defineInjectable, NgModuleRef, LOCALE_ID, inject, INJECTOR } from '@angular/core';
import { fromEvent, Subject, animationFrameScheduler, interval, Subscription, timer } from 'rxjs';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var EaseIn = {
    quad: (/** @type {?} */ ("cubic-bezier(0.550, 0.085, 0.680, 0.530)")),
    cubic: (/** @type {?} */ ("cubic-bezier(0.550, 0.055, 0.675, 0.190)")),
    quart: (/** @type {?} */ ("cubic-bezier(0.895, 0.030, 0.685, 0.220)")),
    quint: (/** @type {?} */ ("cubic-bezier(0.755, 0.050, 0.855, 0.060)")),
    sine: (/** @type {?} */ ("cubic-bezier(0.470, 0.000, 0.745, 0.715)")),
    expo: (/** @type {?} */ ("cubic-bezier(0.950, 0.050, 0.795, 0.035)")),
    circ: (/** @type {?} */ ("cubic-bezier(0.600, 0.040, 0.980, 0.335)")),
    back: (/** @type {?} */ ("cubic-bezier(0.600, -0.280, 0.735, 0.045)")),
};
/** @enum {string} */
var EaseOut = {
    quad: (/** @type {?} */ ("cubic-bezier(0.250, 0.460, 0.450, 0.940)")),
    cubic: (/** @type {?} */ ("cubic-bezier(0.215, 0.610, 0.355, 1.000)")),
    quart: (/** @type {?} */ ("cubic-bezier(0.165, 0.840, 0.440, 1.000)")),
    quint: (/** @type {?} */ ("cubic-bezier(0.230, 1.000, 0.320, 1.000)")),
    sine: (/** @type {?} */ ("cubic-bezier(0.390, 0.575, 0.565, 1.000)")),
    expo: (/** @type {?} */ ("cubic-bezier(0.190, 1.000, 0.220, 1.000)")),
    circ: (/** @type {?} */ ("cubic-bezier(0.075, 0.820, 0.165, 1.000)")),
    back: (/** @type {?} */ ("cubic-bezier(0.175, 0.885, 0.320, 1.275)")),
};
/** @enum {string} */
var EaseInOut = {
    quad: (/** @type {?} */ ("cubic-bezier(0.455, 0.030, 0.515, 0.955)")),
    cubic: (/** @type {?} */ ("cubic-bezier(0.645, 0.045, 0.355, 1.000)")),
    quart: (/** @type {?} */ ("cubic-bezier(0.770, 0.000, 0.175, 1.000)")),
    quint: (/** @type {?} */ ("cubic-bezier(0.860, 0.000, 0.070, 1.000)")),
    sine: (/** @type {?} */ ("cubic-bezier(0.445, 0.050, 0.550, 0.950)")),
    expo: (/** @type {?} */ ("cubic-bezier(1.000, 0.000, 0.000, 1.000)")),
    circ: (/** @type {?} */ ("cubic-bezier(0.785, 0.135, 0.150, 0.860)")),
    back: (/** @type {?} */ ("cubic-bezier(0.680, -0.550, 0.265, 1.550)")),
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var base = [
    style({
        opacity: "{{startOpacity}}"
    }),
    animate("{{duration}} {{delay}} {{easing}}", style({
        opacity: "{{endOpacity}}"
    }))
];
/** @type {?} */
var baseParams = {
    delay: '0s',
    duration: '350ms',
    easing: EaseOut.sine,
    endOpacity: 1,
    startOpacity: 0
};
/** @type {?} */
var fadeIn = animation(base, {
    params: baseParams
});
/** @type {?} */
var fadeOut = animation(base, {
    params: {
        delay: '0s',
        duration: '350ms',
        easing: EaseOut.sine,
        endOpacity: 0,
        startOpacity: 1
    }
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var baseRecipe = [
    style({
        backfaceVisibility: 'hidden',
        transformStyle: 'preserve-3d'
    }),
    animate("{{duration}} {{delay}} {{easing}}", keyframes([
        style({
            offset: 0,
            transform: "translateZ({{startDistance}})\n                rotate3d({{rotateX}}, {{rotateY}}, {{rotateZ}}, {{startAngle}}deg)"
        }),
        style({
            offset: 1,
            transform: "translateZ({{endDistance}})\n                rotate3d({{rotateX}}, {{rotateY}}, {{rotateZ}}, {{endAngle}}deg)"
        })
    ]))
];
/** @type {?} */
var baseParams$1 = {
    delay: '0s',
    duration: '600ms',
    easing: EaseOut.quad,
    endAngle: 180,
    endDistance: '0px',
    rotateX: 1,
    rotateY: 0,
    rotateZ: 0,
    startAngle: 0,
    startDistance: '0px'
};
/** @type {?} */
var flipTop = animation(baseRecipe, {
    params: __assign({}, baseParams$1)
});
/** @type {?} */
var flipBottom = animation(baseRecipe, {
    params: __assign({}, baseParams$1, { endAngle: -180 })
});
/** @type {?} */
var flipLeft = animation(baseRecipe, {
    params: __assign({}, baseParams$1, { rotateX: 0, rotateY: 1 })
});
/** @type {?} */
var flipRight = animation(baseRecipe, {
    params: __assign({}, baseParams$1, { endAngle: -180, rotateX: 0, rotateY: 1 })
});
/** @type {?} */
var flipHorFwd = animation(baseRecipe, {
    params: __assign({}, baseParams$1, { endDistance: '170px' })
});
/** @type {?} */
var flipHorBck = animation(baseRecipe, {
    params: __assign({}, baseParams$1, { endDistance: '-170px' })
});
/** @type {?} */
var flipVerFwd = animation(baseRecipe, {
    params: __assign({}, baseParams$1, { endDistance: '170px', rotateX: 0, rotateY: 1 })
});
/** @type {?} */
var flipVerBck = animation(baseRecipe, {
    params: __assign({}, baseParams$1, { endDistance: '-170px', rotateX: 0, rotateY: 1 })
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var baseRecipe$1 = [
    style({
        opacity: "{{startOpacity}}",
        transform: "rotate3d({{rotateX}},{{rotateY}},{{rotateZ}},{{startAngle}}deg)",
        transformOrigin: "{{xPos}} {{yPos}}"
    }),
    animate("{{duration}} {{delay}} {{easing}}", style({
        offset: 0,
        opacity: "{{endOpacity}}",
        transform: "rotate3d({{rotateX}},{{rotateY}},{{rotateZ}},{{endAngle}}deg)",
        transformOrigin: "{{xPos}} {{yPos}}"
    }))
];
/** @type {?} */
var baseInParams = {
    delay: '0s',
    duration: '600ms',
    easing: EaseOut.quad,
    endAngle: 0,
    endOpacity: 1,
    rotateX: 0,
    rotateY: 0,
    rotateZ: 1,
    startAngle: -360,
    startOpacity: 0,
    xPos: 'center',
    yPos: 'center'
};
/** @type {?} */
var baseOutParams = __assign({}, baseInParams, { easing: EaseIn.quad, endOpacity: 0, startOpacity: 1 });
/** @type {?} */
var rotateInCenter = animation(baseRecipe$1, {
    params: __assign({}, baseInParams)
});
/** @type {?} */
var rotateOutCenter = animation(baseRecipe$1, {
    params: __assign({}, baseOutParams)
});
/** @type {?} */
var rotateInTop = animation(baseRecipe$1, {
    params: __assign({}, baseInParams, { xPos: 'top' })
});
/** @type {?} */
var rotateOutTop = animation(baseRecipe$1, {
    params: __assign({}, baseOutParams, { xPos: 'top' })
});
/** @type {?} */
var rotateInRight = animation(baseRecipe$1, {
    params: __assign({}, baseInParams, { xPos: 'right' })
});
/** @type {?} */
var rotateOutRight = animation(baseRecipe$1, {
    params: __assign({}, baseOutParams, { xPos: 'right' })
});
/** @type {?} */
var rotateInBottom = animation(baseRecipe$1, {
    params: __assign({}, baseInParams, { xPos: 'bottom' })
});
/** @type {?} */
var rotateOutBottom = animation(baseRecipe$1, {
    params: __assign({}, baseOutParams, { xPos: 'bottom' })
});
/** @type {?} */
var rotateInLeft = animation(baseRecipe$1, {
    params: __assign({}, baseInParams, { xPos: 'left' })
});
/** @type {?} */
var rotateOutLeft = animation(baseRecipe$1, {
    params: __assign({}, baseOutParams, { xPos: 'left' })
});
/** @type {?} */
var rotateInTr = animation(baseRecipe$1, {
    params: __assign({}, baseInParams, { xPos: 'right', yPos: 'top' })
});
/** @type {?} */
var rotateOutTr = animation(baseRecipe$1, {
    params: __assign({}, baseOutParams, { xPos: 'right', yPos: 'top' })
});
/** @type {?} */
var rotateInBr = animation(baseRecipe$1, {
    params: __assign({}, baseInParams, { xPos: 'right', yPos: 'bottom' })
});
/** @type {?} */
var rotateOutBr = animation(baseRecipe$1, {
    params: __assign({}, baseOutParams, { xPos: 'right', yPos: 'bottom' })
});
/** @type {?} */
var rotateInBl = animation(baseRecipe$1, {
    params: __assign({}, baseInParams, { xPos: 'left', yPos: 'bottom' })
});
/** @type {?} */
var rotateOutBl = animation(baseRecipe$1, {
    params: __assign({}, baseOutParams, { xPos: 'left', yPos: 'bottom' })
});
/** @type {?} */
var rotateInTl = animation(baseRecipe$1, {
    params: __assign({}, baseInParams, { xPos: 'left', yPos: 'top' })
});
/** @type {?} */
var rotateOutTl = animation(baseRecipe$1, {
    params: __assign({}, baseOutParams, { xPos: 'left', yPos: 'top' })
});
/** @type {?} */
var rotateInDiagonal1 = animation(baseRecipe$1, {
    params: __assign({}, baseInParams, { rotateX: 1, rotateY: 1, rotateZ: 0 })
});
/** @type {?} */
var rotateOutDiagonal1 = animation(baseRecipe$1, {
    params: __assign({}, baseOutParams, { rotateX: 1, rotateY: 1, rotateZ: 0 })
});
/** @type {?} */
var rotateInDiagonal2 = animation(baseRecipe$1, {
    params: __assign({}, baseInParams, { rotateX: -1, rotateY: 1, rotateZ: 0 })
});
/** @type {?} */
var rotateOutDiagonal2 = animation(baseRecipe$1, {
    params: __assign({}, baseOutParams, { rotateX: -1, rotateY: 1, rotateZ: 0 })
});
/** @type {?} */
var rotateInHor = animation(baseRecipe$1, {
    params: __assign({}, baseInParams, { rotateX: 0, rotateY: 1, rotateZ: 0 })
});
/** @type {?} */
var rotateOutHor = animation(baseRecipe$1, {
    params: __assign({}, baseOutParams, { rotateX: 0, rotateY: 1, rotateZ: 0 })
});
/** @type {?} */
var rotateInVer = animation(baseRecipe$1, {
    params: __assign({}, baseInParams, { rotateX: 1, rotateY: 0, rotateZ: 0 })
});
/** @type {?} */
var rotateOutVer = animation(baseRecipe$1, {
    params: __assign({}, baseOutParams, { rotateX: 1, rotateY: 0, rotateZ: 0 })
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var baseRecipe$2 = [
    animate("{{duration}} {{delay}} {{easing}}", keyframes([
        style({
            offset: 0,
            transform: "rotate(0deg) translate{{direction}}(0)",
            transformOrigin: "{{xPos}} {{yPos}}"
        }),
        style({
            offset: 0.1,
            transform: "rotate({{endAngle}}deg) translate{{direction}}(-{{startDistance}})"
        }),
        style({
            offset: 0.2,
            transform: "rotate(-{{startAngle}}deg) translate{{direction}}({{startDistance}})"
        }),
        style({
            offset: 0.3,
            transform: "rotate({{startAngle}}deg) translate{{direction}}(-{{startDistance}})"
        }),
        style({
            offset: 0.4,
            transform: "rotate(-{{startAngle}}deg) translate{{direction}}({{startDistance}})"
        }),
        style({
            offset: 0.5,
            transform: "rotate({{startAngle}}deg) translate{{direction}}(-{{startDistance}})"
        }),
        style({
            offset: 0.6,
            transform: "rotate(-{{startAngle}}deg) translate{{direction}}({{startDistance}})"
        }),
        style({
            offset: 0.7,
            transform: "rotate({{startAngle}}deg) translate{{direction}}(-{{startDistance}})"
        }),
        style({
            offset: 0.8,
            transform: "rotate(-{{endAngle}}deg) translate{{direction}}({{endDistance}})"
        }),
        style({
            offset: 0.9,
            transform: "rotate({{endAngle}}deg) translate{{direction}}(-{{endDistance}})"
        }),
        style({
            offset: 1,
            transform: "rotate(0deg) translate{{direction}}(0)",
            transformOrigin: "{{xPos}} {{yPos}}"
        })
    ]))
];
/** @type {?} */
var baseParams$2 = {
    delay: '0s',
    direction: 'X',
    duration: '800ms',
    easing: EaseInOut.quad,
    endAngle: 0,
    endDistance: '8px',
    startAngle: 0,
    startDistance: '10px',
    xPos: 'center',
    yPos: 'center'
};
/** @type {?} */
var shakeHor = animation(baseRecipe$2, {
    params: __assign({}, baseParams$2, { direction: 'X' })
});
/** @type {?} */
var shakeVer = animation(baseRecipe$2, {
    params: __assign({}, baseParams$2, { direction: 'Y' })
});
/** @type {?} */
var shakeTop = animation(baseRecipe$2, {
    params: __assign({}, baseParams$2, { endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', yPos: 'top' })
});
/** @type {?} */
var shakeBottom = animation(baseRecipe$2, {
    params: __assign({}, baseParams$2, { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', yPos: 'bottom' })
});
/** @type {?} */
var shakeRight = animation(baseRecipe$2, {
    params: __assign({}, baseParams$2, { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'right', yPos: 'center' })
});
/** @type {?} */
var shakeLeft = animation(baseRecipe$2, {
    params: __assign({}, baseParams$2, { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'left', yPos: 'center' })
});
/** @type {?} */
var shakeCenter = animation(baseRecipe$2, {
    params: __assign({}, baseParams$2, { direction: 'Y', endAngle: 8, endDistance: '0', startAngle: 10, startDistance: '0', xPos: 'center', yPos: 'center' })
});
/** @type {?} */
var shakeTr = animation(baseRecipe$2, {
    params: __assign({}, baseParams$2, { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'right', yPos: 'top' })
});
/** @type {?} */
var shakeBr = animation(baseRecipe$2, {
    params: __assign({}, baseParams$2, { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'right', yPos: 'bottom' })
});
/** @type {?} */
var shakeBl = animation(baseRecipe$2, {
    params: __assign({}, baseParams$2, { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'left', yPos: 'bottom' })
});
/** @type {?} */
var shakeTl = animation(baseRecipe$2, {
    params: __assign({}, baseParams$2, { direction: 'Y', endAngle: 2, endDistance: '0', startAngle: 4, startDistance: '0', xPos: 'left', yPos: 'top' })
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var heartbeatBase = [
    style({
        animationTimingFunction: "ease-out",
        transform: "scale(1)",
        transformOrigin: "center center"
    }),
    animate("{{duration}} {{delay}} {{easing}}", keyframes([
        style({
            animationTimingFunction: "ease-in",
            offset: 0.1,
            transform: "scale(0.91)"
        }),
        style({
            animationTimingFunction: "ease-out",
            offset: 0.17,
            transform: "scale(0.98)"
        }),
        style({
            animationTimingFunction: "ease-in",
            offset: 0.33,
            transform: "scale(0.87)"
        }),
        style({
            animationTimingFunction: "ease-out",
            offset: 0.45,
            transform: "scale(1)"
        })
    ]))
];
/** @type {?} */
var heartbeatParams = {
    delay: '0s',
    duration: '1.5s',
    easing: 'ease-in-out'
};
/** @type {?} */
var pulsateBase = [
    animate("{{duration}} {{delay}} {{easing}}", keyframes([
        style({
            offset: 0,
            transform: "scale({{fromScale}})"
        }),
        style({
            offset: 0.5,
            transform: "scale({{toScale}})"
        }),
        style({
            offset: 1,
            transform: "scale({{fromScale}})"
        })
    ]))
];
/** @type {?} */
var pulsateParams = {
    delay: '0s',
    duration: '.5s',
    easing: 'ease-in-out',
    fromScale: 1,
    toScale: 1.1
};
/** @type {?} */
var blinkBase = [
    animate("{{duration}} {{delay}} {{easing}}", keyframes([
        style({
            offset: 0,
            opacity: .8,
            transform: "scale({{fromScale}})"
        }),
        style({
            offset: 0.8,
            opacity: 0,
            transform: "scale({{midScale}})"
        }),
        style({
            offset: 1,
            opacity: 0,
            transform: "scale({{toScale}})"
        })
    ]))
];
/** @type {?} */
var blinkParams = {
    delay: '0s',
    duration: '.8s',
    easing: 'ease-in-out',
    fromScale: .2,
    midScale: 1.2,
    toScale: 2.2
};
/** @type {?} */
var pulsateFwd = animation(pulsateBase, {
    params: __assign({}, pulsateParams)
});
/** @type {?} */
var pulsateBck = animation(pulsateBase, {
    params: __assign({}, pulsateParams, { toScale: .9 })
});
/** @type {?} */
var heartbeat = animation(heartbeatBase, {
    params: __assign({}, heartbeatParams)
});
/** @type {?} */
var blink = animation(blinkBase, {
    params: __assign({}, blinkParams)
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var base$1 = [
    style({
        opacity: "{{startOpacity}}",
        transform: "scale{{direction}}({{fromScale}})",
        transformOrigin: "{{xPos}} {{yPos}}"
    }),
    animate("{{duration}} {{delay}} {{easing}}", style({
        opacity: "{{endOpacity}}",
        transform: "scale{{direction}}({{toScale}})",
        transformOrigin: "{{xPos}} {{yPos}}"
    }))
];
/** @type {?} */
var baseInParams$1 = {
    delay: '0s',
    direction: '',
    duration: '350ms',
    easing: EaseOut.quad,
    endOpacity: 1,
    fromScale: .5,
    startOpacity: 0,
    toScale: 1,
    xPos: '50%',
    yPos: '50%'
};
/** @type {?} */
var baseOutParams$1 = __assign({}, baseInParams$1, { easing: EaseOut.sine, endOpacity: 0, fromScale: 1, startOpacity: 1, toScale: .5 });
/** @type {?} */
var scaleInCenter = animation(base$1, { params: baseInParams$1 });
/** @type {?} */
var scaleInBl = animation(base$1, {
    params: __assign({}, baseInParams$1, { xPos: '0', yPos: '100%' })
});
/** @type {?} */
var scaleInVerCenter = animation(base$1, {
    params: __assign({}, baseInParams$1, { direction: 'Y', fromScale: .4 })
});
/** @type {?} */
var scaleInTop = animation(base$1, {
    params: __assign({}, baseInParams$1, { xPos: '50%', yPos: '0' })
});
/** @type {?} */
var scaleInLeft = animation(base$1, {
    params: __assign({}, baseInParams$1, { xPos: '0', yPos: '50%' })
});
/** @type {?} */
var scaleInVerTop = animation(base$1, {
    params: __assign({}, baseInParams$1, { direction: 'Y', fromScale: .4, xPos: '100%', yPos: '0' })
});
/** @type {?} */
var scaleInTr = animation(base$1, {
    params: __assign({}, baseInParams$1, { xPos: '100%', yPos: '0' })
});
/** @type {?} */
var scaleInTl = animation(base$1, {
    params: __assign({}, baseInParams$1, { xPos: '0', yPos: '0' })
});
/** @type {?} */
var scaleInVerBottom = animation(base$1, {
    params: __assign({}, baseInParams$1, { direction: 'Y', fromScale: .4, xPos: '0', yPos: '100%' })
});
/** @type {?} */
var scaleInRight = animation(base$1, {
    params: __assign({}, baseInParams$1, { xPos: '100%', yPos: '50%' })
});
/** @type {?} */
var scaleInHorCenter = animation(base$1, {
    params: __assign({}, baseInParams$1, { direction: 'X', fromScale: .4 })
});
/** @type {?} */
var scaleInBr = animation(base$1, {
    params: __assign({}, baseInParams$1, { xPos: '100%', yPos: '100%' })
});
/** @type {?} */
var scaleInHorLeft = animation(base$1, {
    params: __assign({}, baseInParams$1, { direction: 'X', fromScale: .4, xPos: '0', yPos: '0' })
});
/** @type {?} */
var scaleInBottom = animation(base$1, {
    params: __assign({}, baseInParams$1, { xPos: '50%', yPos: '100%' })
});
/** @type {?} */
var scaleInHorRight = animation(base$1, {
    params: __assign({}, baseInParams$1, { direction: 'X', fromScale: .4, xPos: '100%', yPos: '100%' })
});
/** @type {?} */
var scaleOutCenter = animation(base$1, { params: baseOutParams$1 });
/** @type {?} */
var scaleOutBl = animation(base$1, {
    params: __assign({}, baseOutParams$1, { xPos: '0', yPos: '100%' })
});
/** @type {?} */
var scaleOutBr = animation(base$1, {
    params: __assign({}, baseOutParams$1, { xPos: '100%', yPos: '100%' })
});
/** @type {?} */
var scaleOutVerCenter = animation(base$1, {
    params: __assign({}, baseOutParams$1, { direction: 'Y', toScale: .3 })
});
/** @type {?} */
var scaleOutVerTop = animation(base$1, {
    params: __assign({}, baseOutParams$1, { direction: 'Y', toScale: .3, xPos: '100%', yPos: '0' })
});
/** @type {?} */
var scaleOutVerBottom = animation(base$1, {
    params: __assign({}, baseOutParams$1, { direction: 'Y', toScale: .3, xPos: '0', yPos: '100%' })
});
/** @type {?} */
var scaleOutTop = animation(base$1, {
    params: __assign({}, baseOutParams$1, { xPos: '50%', yPos: '0' })
});
/** @type {?} */
var scaleOutLeft = animation(base$1, {
    params: __assign({}, baseOutParams$1, { xPos: '0', yPos: '50%' })
});
/** @type {?} */
var scaleOutTr = animation(base$1, {
    params: __assign({}, baseOutParams$1, { xPos: '100%', yPos: '0' })
});
/** @type {?} */
var scaleOutTl = animation(base$1, {
    params: __assign({}, baseOutParams$1, { xPos: '0', yPos: '0' })
});
/** @type {?} */
var scaleOutRight = animation(base$1, {
    params: __assign({}, baseOutParams$1, { xPos: '100%', yPos: '50%' })
});
/** @type {?} */
var scaleOutBottom = animation(base$1, {
    params: __assign({}, baseOutParams$1, { xPos: '50%', yPos: '100%' })
});
/** @type {?} */
var scaleOutHorCenter = animation(base$1, {
    params: __assign({}, baseOutParams$1, { direction: 'X', toScale: .3 })
});
/** @type {?} */
var scaleOutHorLeft = animation(base$1, {
    params: __assign({}, baseOutParams$1, { direction: 'X', toScale: .3, xPos: '0', yPos: '0' })
});
/** @type {?} */
var scaleOutHorRight = animation(base$1, {
    params: __assign({}, baseOutParams$1, { direction: 'X', toScale: .3, xPos: '100%', yPos: '100%' })
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var base$2 = [
    style({
        opacity: "{{startOpacity}}",
        transform: "{{fromPosition}}"
    }),
    animate("{{duration}} {{delay}} {{easing}}", style({
        opacity: "{{endOpacity}}",
        transform: "{{toPosition}}"
    }))
];
/** @type {?} */
var baseInParams$2 = {
    delay: '0s',
    duration: '350ms',
    easing: EaseOut.quad,
    endOpacity: 1,
    fromPosition: 'translateY(-500px)',
    startOpacity: 0,
    toPosition: 'translateY(0)'
};
/** @type {?} */
var baseOutParams$2 = {
    delay: '0s',
    duration: '350ms',
    easing: EaseIn.quad,
    endOpacity: 0,
    fromPosition: 'translateY(0)',
    startOpacity: 1,
    toPosition: 'translateY(-500px)'
};
/** @type {?} */
var slideInTop = animation(base$2, { params: baseInParams$2 });
/** @type {?} */
var slideInLeft = animation(base$2, {
    params: {
        delay: '0s',
        duration: '350ms',
        easing: EaseOut.quad,
        endOpacity: 1,
        fromPosition: 'translateX(-500px)',
        startOpacity: 0,
        toPosition: 'translateY(0)'
    }
});
/** @type {?} */
var slideInRight = animation(base$2, {
    params: {
        delay: '0s',
        duration: '350ms',
        easing: EaseOut.quad,
        endOpacity: 1,
        fromPosition: 'translateX(500px)',
        startOpacity: 0,
        toPosition: 'translateY(0)'
    }
});
/** @type {?} */
var slideInBottom = animation(base$2, {
    params: {
        delay: '0s',
        duration: '350ms',
        easing: EaseOut.quad,
        endOpacity: 1,
        fromPosition: 'translateY(500px)',
        startOpacity: 0,
        toPosition: 'translateY(0)'
    }
});
/** @type {?} */
var slideInTr = animation(base$2, {
    params: __assign({}, baseInParams$2, { fromPosition: 'translateY(-500px) translateX(500px)', toPosition: 'translateY(0) translateX(0)' })
});
/** @type {?} */
var slideInTl = animation(base$2, {
    params: __assign({}, baseInParams$2, { fromPosition: 'translateY(-500px) translateX(-500px)', toPosition: 'translateY(0) translateX(0)' })
});
/** @type {?} */
var slideInBr = animation(base$2, {
    params: __assign({}, baseInParams$2, { fromPosition: 'translateY(500px) translateX(500px)', toPosition: 'translateY(0) translateX(0)' })
});
/** @type {?} */
var slideInBl = animation(base$2, {
    params: __assign({}, baseInParams$2, { fromPosition: 'translateY(500px) translateX(-500px)', toPosition: 'translateY(0) translateX(0)' })
});
/** @type {?} */
var slideOutTop = animation(base$2, { params: baseOutParams$2 });
/** @type {?} */
var slideOutRight = animation(base$2, {
    params: __assign({}, baseOutParams$2, { toPosition: 'translateX(500px)' })
});
/** @type {?} */
var slideOutBottom = animation(base$2, {
    params: {
        delay: '0s',
        duration: '350ms',
        easing: EaseIn.quad,
        endOpacity: 0,
        fromPosition: 'translateY(0)',
        startOpacity: 1,
        toPosition: 'translateY(500px)'
    }
});
/** @type {?} */
var slideOutLeft = animation(base$2, {
    params: __assign({}, baseOutParams$2, { toPosition: 'translateX(-500px)' })
});
/** @type {?} */
var slideOutTr = animation(base$2, {
    params: __assign({}, baseOutParams$2, { fromPosition: 'translateY(0) translateX(0)', toPosition: 'translateY(-500px) translateX(500px)' })
});
/** @type {?} */
var slideOutBr = animation(base$2, {
    params: __assign({}, baseOutParams$2, { fromPosition: 'translateY(0) translateX(0)', toPosition: 'translateY(500px) translateX(500px)' })
});
/** @type {?} */
var slideOutBl = animation(base$2, {
    params: __assign({}, baseOutParams$2, { fromPosition: 'translateY(0) translateX(0)', toPosition: 'translateY(500px) translateX(-500px)' })
});
/** @type {?} */
var slideOutTl = animation(base$2, {
    params: __assign({}, baseOutParams$2, { fromPosition: 'translateY(0) translateX(0)', toPosition: 'translateY(-500px) translateX(-500px)' })
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var swingBase = [
    style({
        opacity: "{{startOpacity}}",
        transform: "rotate{{direction}}({{startAngle}}deg)",
        transformOrigin: "{{xPos}} {{yPos}}"
    }),
    animate("{{duration}} {{delay}} {{easing}}", style({
        opacity: "{{endOpacity}}",
        transform: "rotate{{direction}}({{endAngle}}deg)",
        transformOrigin: "{{xPos}} {{yPos}}"
    }))
];
/** @type {?} */
var swingParams = {
    delay: '0s',
    direction: 'X',
    duration: '.5s',
    easing: EaseOut.back,
    endAngle: 0,
    endOpacity: 1,
    startAngle: -100,
    startOpacity: 0,
    xPos: 'top',
    yPos: 'center'
};
/** @type {?} */
var swingOutParams = __assign({}, swingParams, { duration: '.55s', easing: EaseIn.back, endAngle: 70, endOpacity: 0, startAngle: 0, startOpacity: 1 });
/** @type {?} */
var swingInTopFwd = animation(swingBase, {
    params: __assign({}, swingParams)
});
/** @type {?} */
var swingInRightFwd = animation(swingBase, {
    params: __assign({}, swingParams, { direction: 'Y', xPos: 'center', yPos: 'right' })
});
/** @type {?} */
var swingInBottomFwd = animation(swingBase, {
    params: __assign({}, swingParams, { startAngle: 100, xPos: 'bottom' })
});
/** @type {?} */
var swingInLeftFwd = animation(swingBase, {
    params: __assign({}, swingParams, { direction: 'Y', startAngle: 100, xPos: 'center', yPos: 'left' })
});
/** @type {?} */
var swingInTopBck = animation(swingBase, {
    params: __assign({}, swingParams, { duration: '.6s', startAngle: 70 })
});
/** @type {?} */
var swingInRightBck = animation(swingBase, {
    params: __assign({}, swingParams, { direction: 'Y', duration: '.6s', startAngle: 70, xPos: 'center', yPos: 'right' })
});
/** @type {?} */
var swingInBottomBck = animation(swingBase, {
    params: __assign({}, swingParams, { duration: '.6s', startAngle: -70, xPos: 'bottom' })
});
/** @type {?} */
var swingInLeftBck = animation(swingBase, {
    params: __assign({}, swingParams, { direction: 'Y', duration: '.6s', startAngle: -70, xPos: 'center', yPos: 'left' })
});
/** @type {?} */
var swingOutTopFwd = animation(swingBase, {
    params: __assign({}, swingOutParams)
});
/** @type {?} */
var swingOutRightFwd = animation(swingBase, {
    params: __assign({}, swingOutParams, { direction: 'Y', xPos: 'center', yPos: 'right' })
});
/** @type {?} */
var swingOutBottomFwd = animation(swingBase, {
    params: __assign({}, swingOutParams, { endAngle: -70, xPos: 'bottom' })
});
/** @type {?} */
var swingOutLefttFwd = animation(swingBase, {
    params: __assign({}, swingOutParams, { direction: 'Y', endAngle: -70, xPos: 'center', yPos: 'left' })
});
/** @type {?} */
var swingOutTopBck = animation(swingBase, {
    params: __assign({}, swingOutParams, { duration: '.45s', endAngle: -100 })
});
/** @type {?} */
var swingOutRightBck = animation(swingBase, {
    params: __assign({}, swingOutParams, { direction: 'Y', duration: '.45s', endAngle: -100, xPos: 'center', yPos: 'right' })
});
/** @type {?} */
var swingOutBottomBck = animation(swingBase, {
    params: __assign({}, swingOutParams, { duration: '.45s', endAngle: 100, xPos: 'bottom' })
});
/** @type {?} */
var swingOutLeftBck = animation(swingBase, {
    params: __assign({}, swingOutParams, { direction: 'Y', duration: '.45s', endAngle: 100, xPos: 'center', yPos: 'left' })
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var base$3 = [
    style({
        opacity: "{{ startOpacity }}",
        height: "{{ startHeight }}"
    }),
    animate("{{duration}} {{delay}} {{easing}}", style({
        opacity: "{{ endOpacity }}",
        height: "{{ endHeight }}"
    }))
];
/** @type {?} */
var baseParams$3 = {
    delay: '0s',
    duration: '350ms',
    easing: EaseIn.quad,
    startOpacity: 0,
    endOpacity: 1,
    startHeight: '',
    endHeight: ''
};
/** @type {?} */
var growVerIn = animation(base$3, {
    params: __assign({}, baseParams$3, { easing: EaseOut.quad, startOpacity: 0, endOpacity: 1, startHeight: '0px', endHeight: '*' })
});
/** @type {?} */
var growVerOut = animation(base$3, {
    params: __assign({}, baseParams$3, { easing: EaseOut.quad, startOpacity: 1, endOpacity: 0, startHeight: '*', endHeight: '0px' })
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Common service to be injected between components where those implementing common
 * ToggleView interface can register and toggle directives can call their methods.
 * TODO: Track currently active? Events?
 */
var  /**
 * Common service to be injected between components where those implementing common
 * ToggleView interface can register and toggle directives can call their methods.
 * TODO: Track currently active? Events?
 */
IgxNavigationService = /** @class */ (function () {
    function IgxNavigationService() {
        this.navs = {};
    }
    /**
     * @param {?} id
     * @param {?} navItem
     * @return {?}
     */
    IgxNavigationService.prototype.add = /**
     * @param {?} id
     * @param {?} navItem
     * @return {?}
     */
    function (id, navItem) {
        this.navs[id] = navItem;
    };
    /**
     * @param {?} id
     * @return {?}
     */
    IgxNavigationService.prototype.remove = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
        delete this.navs[id];
    };
    /**
     * @param {?} id
     * @return {?}
     */
    IgxNavigationService.prototype.get = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
        if (id) {
            return this.navs[id];
        }
    };
    /**
     * @param {?} id
     * @param {...?} args
     * @return {?}
     */
    IgxNavigationService.prototype.toggle = /**
     * @param {?} id
     * @param {...?} args
     * @return {?}
     */
    function (id) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var _a;
        if (this.navs[id]) {
            return (_a = this.navs[id]).toggle.apply(_a, __spread(args));
        }
    };
    /**
     * @param {?} id
     * @param {...?} args
     * @return {?}
     */
    IgxNavigationService.prototype.open = /**
     * @param {?} id
     * @param {...?} args
     * @return {?}
     */
    function (id) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var _a;
        if (this.navs[id]) {
            return (_a = this.navs[id]).open.apply(_a, __spread(args));
        }
    };
    /**
     * @param {?} id
     * @param {...?} args
     * @return {?}
     */
    IgxNavigationService.prototype.close = /**
     * @param {?} id
     * @param {...?} args
     * @return {?}
     */
    function (id) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var _a;
        if (this.navs[id]) {
            return (_a = this.navs[id]).close.apply(_a, __spread(args));
        }
    };
    return IgxNavigationService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Directive that can toggle targets through provided NavigationService.
 *
 * Usage:
 * ```
 * <button igxNavToggle="ID"> Toggle </button>
 * ```
 * Where the `ID` matches the ID of compatible `IToggleView` component.
 */
var IgxNavigationToggleDirective = /** @class */ (function () {
    function IgxNavigationToggleDirective(nav) {
        this.state = nav;
    }
    /**
     * @return {?}
     */
    IgxNavigationToggleDirective.prototype.toggleNavigationDrawer = /**
     * @return {?}
     */
    function () {
        this.state.toggle(this.target, true);
    };
    IgxNavigationToggleDirective.decorators = [
        { type: Directive, args: [{ selector: '[igxNavToggle]' },] }
    ];
    /** @nocollapse */
    IgxNavigationToggleDirective.ctorParameters = function () { return [
        { type: IgxNavigationService }
    ]; };
    IgxNavigationToggleDirective.propDecorators = {
        target: [{ type: Input, args: ['igxNavToggle',] }],
        toggleNavigationDrawer: [{ type: HostListener, args: ['click',] }]
    };
    return IgxNavigationToggleDirective;
}());
/**
 * Directive that can close targets through provided NavigationService.
 *
 * Usage:
 * ```
 * <button igxNavClose="ID"> Close </button>
 * ```
 * Where the `ID` matches the ID of compatible `IToggleView` component.
 */
var IgxNavigationCloseDirective = /** @class */ (function () {
    function IgxNavigationCloseDirective(nav) {
        this.state = nav;
    }
    /**
     * @return {?}
     */
    IgxNavigationCloseDirective.prototype.closeNavigationDrawer = /**
     * @return {?}
     */
    function () {
        this.state.close(this.target, true);
    };
    IgxNavigationCloseDirective.decorators = [
        { type: Directive, args: [{ selector: '[igxNavClose]' },] }
    ];
    /** @nocollapse */
    IgxNavigationCloseDirective.ctorParameters = function () { return [
        { type: IgxNavigationService }
    ]; };
    IgxNavigationCloseDirective.propDecorators = {
        target: [{ type: Input, args: ['igxNavClose',] }],
        closeNavigationDrawer: [{ type: HostListener, args: ['click',] }]
    };
    return IgxNavigationCloseDirective;
}());
/**
 * @hidden
 */
var IgxNavigationModule = /** @class */ (function () {
    function IgxNavigationModule() {
    }
    IgxNavigationModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxNavigationCloseDirective, IgxNavigationToggleDirective],
                    exports: [IgxNavigationCloseDirective, IgxNavigationToggleDirective],
                    providers: [IgxNavigationService]
                },] }
    ];
    return IgxNavigationModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 * @param {?} array
 * @param {?=} deep
 * @return {?}
 */
function cloneArray(array, deep) {
    /** @type {?} */
    var arr = [];
    if (!array) {
        return arr;
    }
    /** @type {?} */
    var i = array.length;
    while (i--) {
        arr[i] = deep ? cloneValue(array[i]) : array[i];
    }
    return arr;
}
/**
 * Doesn't clone leaf items
 * @hidden
 * @param {?} array
 * @param {?} childDataKey
 * @return {?}
 */
function cloneHierarchicalArray(array, childDataKey) {
    var e_1, _a;
    /** @type {?} */
    var result = [];
    if (!array) {
        return result;
    }
    try {
        for (var array_1 = __values(array), array_1_1 = array_1.next(); !array_1_1.done; array_1_1 = array_1.next()) {
            var item = array_1_1.value;
            /** @type {?} */
            var clonedItem = cloneValue(item);
            if (Array.isArray(item[childDataKey])) {
                clonedItem[childDataKey] = cloneHierarchicalArray(clonedItem[childDataKey], childDataKey);
            }
            result.push(clonedItem);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (array_1_1 && !array_1_1.done && (_a = array_1.return)) _a.call(array_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return result;
}
/**
 * Deep clones all first level keys of Obj2 and merges them to Obj1
 * @hidden
 * @param {?} obj1 Object to merge into
 * @param {?} obj2 Object to merge from
 * @return {?} Obj1 with merged cloned keys from Obj2
 */
function mergeObjects(obj1, obj2) {
    var e_2, _a;
    if (!isObject(obj1)) {
        throw new Error("Cannot merge into " + obj1 + ". First param must be an object.");
    }
    if (!isObject(obj2)) {
        return obj1;
    }
    try {
        for (var _b = __values(Object.keys(obj2)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var key = _c.value;
            obj1[key] = cloneValue(obj2[key]);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return obj1;
}
/**
 * Creates deep clone of provided value.
 * Supports primitive values, dates and objects.
 * If passed value is array returns shallow copy of the array.
 * @hidden
 * @param {?} value value to clone
 * @return {?} Deep copy of provided value
 */
function cloneValue(value) {
    var e_3, _a;
    if (isDate(value)) {
        return new Date(value.getTime());
    }
    if (Array.isArray(value)) {
        return __spread(value);
    }
    if (value instanceof Map || value instanceof Set) {
        return value;
    }
    if (isObject(value)) {
        /** @type {?} */
        var result = {};
        try {
            for (var _b = __values(Object.keys(value)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                result[key] = cloneValue(value[key]);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return result;
    }
    return value;
}
/**
 * Checks if provided variable is Object
 * @hidden
 * @param {?} value Value to check
 * @return {?} true if provided variable is Object
 */
function isObject(value) {
    return value && value.toString() === '[object Object]';
}
/**
 * Checks if provided variable is Date
 * @hidden
 * @param {?} value Value to check
 * @return {?} true if provided variable is Date
 */
function isDate(value) {
    return Object.prototype.toString.call(value) === '[object Date]';
}
/**
 * Checks if the two passed arguments are equal
 * Currently supports date objects
 * \@returns: `boolean`
 * @hidden
 * @param {?} obj1
 * @param {?} obj2
 * @return {?}
 */
function isEqual(obj1, obj2) {
    if (isDate(obj1) && isDate(obj2)) {
        return obj1.getTime() === obj2.getTime();
    }
    return obj1 === obj2;
}
/**
 * @hidden
 * Returns the actual size of the node content, using Range
 * ```typescript
 * let range = document.createRange();
 * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
 *
 * let size = getNodeSizeViaRange(range, column.cells[0].nativeElement);
 * ```
 * @param {?} range
 * @param {?} node
 * @return {?}
 */
function getNodeSizeViaRange(range, node) {
    /** @type {?} */
    var overflow = null;
    if (isIE() || isEdge()) {
        overflow = node.style.overflow;
        // we need that hack - otherwise content won't be measured correctly in IE/Edge
        node.style.overflow = 'visible';
    }
    range.selectNodeContents(node);
    /** @type {?} */
    var width = range.getBoundingClientRect().width;
    if (isIE() || isEdge()) {
        // we need that hack - otherwise content won't be measured correctly in IE/Edge
        node.style.overflow = overflow;
    }
    return width;
}
/**
 * @hidden
 * @return {?}
 */
function isIE() {
    return navigator.appVersion.indexOf('Trident/') > 0;
}
/**
 * @hidden
 * @return {?}
 */
function isEdge() {
    /** @type {?} */
    var edgeBrowser = /Edge[\/\s](\d+\.\d+)/.test(navigator.userAgent);
    return edgeBrowser;
}
/**
 * @hidden
 * @param {?} key
 * @return {?}
 */
function isNavigationKey(key) {
    return ['down', 'up', 'left', 'right', 'arrowdown', 'arrowup', 'arrowleft', 'arrowright',
        'home', 'end', 'space', 'spacebar', ' '].indexOf(key) !== -1;
}
/**
 * @hidden
 * @param {?} arr
 * @return {?}
 */
function flatten(arr) {
    /** @type {?} */
    var result = [];
    arr.forEach(function (el) {
        result.push(el);
        if (el.children) {
            /** @type {?} */
            var children = Array.isArray(el.children) ? el.children : el.children.toArray();
            result = result.concat(flatten(children));
        }
    });
    return result;
}
/** @type {?} */
var NAVIGATION_KEYS = new Set(['down', 'up', 'left', 'right', 'arrowdown', 'arrowup', 'arrowleft', 'arrowright',
    'home', 'end', 'space', 'spacebar', ' ']);
/** @type {?} */
var ROW_EXPAND_KEYS = new Set('right down arrowright arrowdown'.split(' '));
/** @type {?} */
var ROW_COLLAPSE_KEYS = new Set('left up arrowleft arrowup'.split(' '));
/** @type {?} */
var SUPPORTED_KEYS = new Set(__spread(Array.from(NAVIGATION_KEYS), ['tab', 'enter', 'f2', 'escape', 'esc']));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
var SortingDirection = {
    None: 0,
    Asc: 1,
    Desc: 2,
};
SortingDirection[SortingDirection.None] = 'None';
SortingDirection[SortingDirection.Asc] = 'Asc';
SortingDirection[SortingDirection.Desc] = 'Desc';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DefaultSortingStrategy = /** @class */ (function () {
    function DefaultSortingStrategy() {
    }
    /**
     * @return {?}
     */
    DefaultSortingStrategy.instance = /**
     * @return {?}
     */
    function () {
        return this._instance || (this._instance = new this());
    };
    /**
     * @param {?} data
     * @param {?} fieldName
     * @param {?} dir
     * @param {?} ignoreCase
     * @param {?} valueResolver
     * @return {?}
     */
    DefaultSortingStrategy.prototype.sort = /**
     * @param {?} data
     * @param {?} fieldName
     * @param {?} dir
     * @param {?} ignoreCase
     * @param {?} valueResolver
     * @return {?}
     */
    function (data, fieldName, dir, ignoreCase, valueResolver) {
        var _this = this;
        /** @type {?} */
        var key = fieldName;
        /** @type {?} */
        var reverse = (dir === SortingDirection.Desc ? -1 : 1);
        /** @type {?} */
        var cmpFunc = function (obj1, obj2) {
            return _this.compareObjects(obj1, obj2, key, reverse, ignoreCase, valueResolver);
        };
        return this.arraySort(data, cmpFunc);
    };
    /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    DefaultSortingStrategy.prototype.compareValues = /**
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    function (a, b) {
        /** @type {?} */
        var an = (a === null || a === undefined);
        /** @type {?} */
        var bn = (b === null || b === undefined);
        if (an) {
            if (bn) {
                return 0;
            }
            return -1;
        }
        else if (bn) {
            return 1;
        }
        return a > b ? 1 : a < b ? -1 : 0;
    };
    /**
     * @protected
     * @param {?} obj1
     * @param {?} obj2
     * @param {?} key
     * @param {?} reverse
     * @param {?} ignoreCase
     * @param {?} valueResolver
     * @return {?}
     */
    DefaultSortingStrategy.prototype.compareObjects = /**
     * @protected
     * @param {?} obj1
     * @param {?} obj2
     * @param {?} key
     * @param {?} reverse
     * @param {?} ignoreCase
     * @param {?} valueResolver
     * @return {?}
     */
    function (obj1, obj2, key, reverse, ignoreCase, valueResolver) {
        /** @type {?} */
        var a = valueResolver(obj1, key);
        /** @type {?} */
        var b = valueResolver(obj2, key);
        if (ignoreCase) {
            a = a && a.toLowerCase ? a.toLowerCase() : a;
            b = b && b.toLowerCase ? b.toLowerCase() : b;
        }
        return reverse * this.compareValues(a, b);
    };
    /**
     * @protected
     * @param {?} data
     * @param {?=} compareFn
     * @return {?}
     */
    DefaultSortingStrategy.prototype.arraySort = /**
     * @protected
     * @param {?} data
     * @param {?=} compareFn
     * @return {?}
     */
    function (data, compareFn) {
        return data.sort(compareFn);
    };
    DefaultSortingStrategy._instance = null;
    return DefaultSortingStrategy;
}());
var IgxSorting = /** @class */ (function () {
    function IgxSorting() {
    }
    /**
     * @param {?} data
     * @param {?} expressions
     * @return {?}
     */
    IgxSorting.prototype.sort = /**
     * @param {?} data
     * @param {?} expressions
     * @return {?}
     */
    function (data, expressions) {
        return this.sortDataRecursive(data, expressions);
    };
    /**
     * @private
     * @param {?} data
     * @param {?} index
     * @param {?} expression
     * @return {?}
     */
    IgxSorting.prototype.groupedRecordsByExpression = /**
     * @private
     * @param {?} data
     * @param {?} index
     * @param {?} expression
     * @return {?}
     */
    function (data, index, expression) {
        /** @type {?} */
        var i;
        /** @type {?} */
        var groupval;
        /** @type {?} */
        var res = [];
        /** @type {?} */
        var key = expression.fieldName;
        /** @type {?} */
        var len = data.length;
        res.push(data[index]);
        groupval = this.getFieldValue(data[index], key);
        index++;
        /** @type {?} */
        var comparer = expression.groupingComparer || DefaultSortingStrategy.instance().compareValues;
        for (i = index; i < len; i++) {
            if (comparer(this.getFieldValue(data[i], key), groupval) === 0) {
                res.push(data[i]);
            }
            else {
                break;
            }
        }
        return res;
    };
    /**
     * @private
     * @template T
     * @param {?} data
     * @param {?} expressions
     * @param {?=} expressionIndex
     * @return {?}
     */
    IgxSorting.prototype.sortDataRecursive = /**
     * @private
     * @template T
     * @param {?} data
     * @param {?} expressions
     * @param {?=} expressionIndex
     * @return {?}
     */
    function (data, expressions, expressionIndex) {
        if (expressionIndex === void 0) { expressionIndex = 0; }
        /** @type {?} */
        var i;
        /** @type {?} */
        var j;
        /** @type {?} */
        var expr;
        /** @type {?} */
        var gbData;
        /** @type {?} */
        var gbDataLen;
        /** @type {?} */
        var exprsLen = expressions.length;
        /** @type {?} */
        var dataLen = data.length;
        expressionIndex = expressionIndex || 0;
        if (expressionIndex >= exprsLen || dataLen <= 1) {
            return data;
        }
        expr = expressions[expressionIndex];
        if (!expr.strategy) {
            expr.strategy = DefaultSortingStrategy.instance();
        }
        data = expr.strategy.sort(data, expr.fieldName, expr.dir, expr.ignoreCase, this.getFieldValue);
        if (expressionIndex === exprsLen - 1) {
            return data;
        }
        // in case of multiple sorting
        for (i = 0; i < dataLen; i++) {
            gbData = this.groupedRecordsByExpression(data, i, expr);
            gbDataLen = gbData.length;
            if (gbDataLen > 1) {
                gbData = this.sortDataRecursive(gbData, expressions, expressionIndex + 1);
            }
            for (j = 0; j < gbDataLen; j++) {
                data[i + j] = gbData[j];
            }
            i += gbDataLen - 1;
        }
        return data;
    };
    /**
     * @protected
     * @template T
     * @param {?} data
     * @param {?} expressions
     * @param {?} level
     * @param {?} parent
     * @param {?} metadata
     * @param {?=} grid
     * @param {?=} groupsRecords
     * @return {?}
     */
    IgxSorting.prototype.groupDataRecursive = /**
     * @protected
     * @template T
     * @param {?} data
     * @param {?} expressions
     * @param {?} level
     * @param {?} parent
     * @param {?} metadata
     * @param {?=} grid
     * @param {?=} groupsRecords
     * @return {?}
     */
    function (data, expressions, level, parent, metadata, grid, groupsRecords) {
        if (grid === void 0) { grid = null; }
        if (groupsRecords === void 0) { groupsRecords = []; }
        var e_1, _a;
        /** @type {?} */
        var i = 0;
        /** @type {?} */
        var result = [];
        while (i < data.length) {
            /** @type {?} */
            var group = this.groupedRecordsByExpression(data, i, expressions[level]);
            /** @type {?} */
            var groupRow = {
                expression: expressions[level],
                level: level,
                records: cloneArray(group),
                value: group[0][expressions[level].fieldName],
                groupParent: parent,
                groups: [],
                height: grid ? grid.rowHeight : null
            };
            if (parent) {
                parent.groups.push(groupRow);
            }
            else {
                groupsRecords.push(groupRow);
            }
            if (level < expressions.length - 1) {
                result = result.concat(this.groupDataRecursive(group, expressions, level + 1, groupRow, metadata, grid, groupsRecords));
            }
            else {
                try {
                    for (var group_1 = __values(group), group_1_1 = group_1.next(); !group_1_1.done; group_1_1 = group_1.next()) {
                        var groupItem = group_1_1.value;
                        metadata.push(groupRow);
                        result.push(groupItem);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (group_1_1 && !group_1_1.done && (_a = group_1.return)) _a.call(group_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            i += group.length;
        }
        return result;
    };
    /**
     * @protected
     * @param {?} obj
     * @param {?} key
     * @return {?}
     */
    IgxSorting.prototype.getFieldValue = /**
     * @protected
     * @param {?} obj
     * @param {?} key
     * @return {?}
     */
    function (obj, key) {
        return obj[key];
    };
    return IgxSorting;
}());
var IgxDataRecordSorting = /** @class */ (function (_super) {
    __extends(IgxDataRecordSorting, _super);
    function IgxDataRecordSorting() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @protected
     * @param {?} obj
     * @param {?} key
     * @return {?}
     */
    IgxDataRecordSorting.prototype.getFieldValue = /**
     * @protected
     * @param {?} obj
     * @param {?} key
     * @return {?}
     */
    function (obj, key) {
        return obj.data[key];
    };
    return IgxDataRecordSorting;
}(IgxSorting));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxGrouping = /** @class */ (function (_super) {
    __extends(IgxGrouping, _super);
    function IgxGrouping() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {?} data
     * @param {?} expressions
     * @param {?=} grid
     * @param {?=} groupsRecords
     * @return {?}
     */
    IgxGrouping.prototype.groupBy = /**
     * @param {?} data
     * @param {?} expressions
     * @param {?=} grid
     * @param {?=} groupsRecords
     * @return {?}
     */
    function (data, expressions, grid, groupsRecords) {
        /** @type {?} */
        var metadata = [];
        /** @type {?} */
        var grouping = this.groupDataRecursive(data, expressions, 0, null, metadata, grid, groupsRecords);
        return {
            data: grouping,
            metadata: metadata
        };
    };
    return IgxGrouping;
}(IgxSorting));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
var PagingError = {
    None: 0,
    IncorrectPageIndex: 1,
    IncorrectRecordsPerPage: 2,
};
PagingError[PagingError.None] = 'None';
PagingError[PagingError.IncorrectPageIndex] = 'IncorrectPageIndex';
PagingError[PagingError.IncorrectRecordsPerPage] = 'IncorrectRecordsPerPage';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var FilteringExpressionsTree = /** @class */ (function () {
    function FilteringExpressionsTree(operator, fieldName) {
        /**
         * Sets/gets the filtering operands.
         * ```typescript
         * const gridExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And);
         * const expression = [
         * {
         *   condition: IgxStringFilteringOperand.instance().condition('contains'),
         *   fieldName: 'Column Field',
         *   searchVal: 'Value',
         *   ignoreCase: false
         * }];
         * gridExpressionsTree.filteringOperands.push(expression);
         * this.grid.filteringExpressionsTree = gridExpressionsTree;
         * ```
         * ```typescript
         * let filteringOperands = gridExpressionsTree.filteringOperands;
         * ```
         * \@memberof FilteringExpressionsTree
         */
        this.filteringOperands = [];
        this.operator = operator;
        this.fieldName = fieldName;
    }
    /**
     * Returns the filtering expression for a column with the provided fieldName.
     * ```typescript
     * let filteringExpression = gridExpressionTree.find('Column Field');
     * ```
     * @memberof FilteringExpressionsTree
     */
    /**
     * Returns the filtering expression for a column with the provided fieldName.
     * ```typescript
     * let filteringExpression = gridExpressionTree.find('Column Field');
     * ```
     * \@memberof FilteringExpressionsTree
     * @param {?} fieldName
     * @return {?}
     */
    FilteringExpressionsTree.prototype.find = /**
     * Returns the filtering expression for a column with the provided fieldName.
     * ```typescript
     * let filteringExpression = gridExpressionTree.find('Column Field');
     * ```
     * \@memberof FilteringExpressionsTree
     * @param {?} fieldName
     * @return {?}
     */
    function (fieldName) {
        /** @type {?} */
        var index = this.findIndex(fieldName);
        if (index > -1) {
            return this.filteringOperands[index];
        }
        return null;
    };
    /**
     * Returns the index of the filtering expression for a column with the provided fieldName.
     * ```typescript
     * let filteringExpressionIndex = gridExpressionTree.findIndex('Column Field');
     * ```
     * @memberof FilteringExpressionsTree
     */
    /**
     * Returns the index of the filtering expression for a column with the provided fieldName.
     * ```typescript
     * let filteringExpressionIndex = gridExpressionTree.findIndex('Column Field');
     * ```
     * \@memberof FilteringExpressionsTree
     * @param {?} fieldName
     * @return {?}
     */
    FilteringExpressionsTree.prototype.findIndex = /**
     * Returns the index of the filtering expression for a column with the provided fieldName.
     * ```typescript
     * let filteringExpressionIndex = gridExpressionTree.findIndex('Column Field');
     * ```
     * \@memberof FilteringExpressionsTree
     * @param {?} fieldName
     * @return {?}
     */
    function (fieldName) {
        /** @type {?} */
        var expr;
        for (var i = 0; i < this.filteringOperands.length; i++) {
            expr = this.filteringOperands[i];
            if (expr instanceof FilteringExpressionsTree) {
                if (this.isFilteringExpressionsTreeForColumn(expr, fieldName)) {
                    return i;
                }
            }
            else {
                if (((/** @type {?} */ (expr))).fieldName === fieldName) {
                    return i;
                }
            }
        }
        return -1;
    };
    /**
     * @protected
     * @param {?} expressionsTree
     * @param {?} fieldName
     * @return {?}
     */
    FilteringExpressionsTree.prototype.isFilteringExpressionsTreeForColumn = /**
     * @protected
     * @param {?} expressionsTree
     * @param {?} fieldName
     * @return {?}
     */
    function (expressionsTree, fieldName) {
        if (expressionsTree.fieldName === fieldName) {
            return true;
        }
        /** @type {?} */
        var expr;
        for (var i = 0; i < expressionsTree.filteringOperands.length; i++) {
            expr = expressionsTree.filteringOperands[i];
            if ((expr instanceof FilteringExpressionsTree)) {
                return this.isFilteringExpressionsTreeForColumn(expr, fieldName);
            }
            else {
                return ((/** @type {?} */ (expr))).fieldName === fieldName;
            }
        }
        return false;
    };
    return FilteringExpressionsTree;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var TransactionType = {
    ADD: 'add',
    DELETE: 'delete',
    UPDATE: 'update',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 * @template T
 */
var GridBaseAPIService = /** @class */ (function () {
    function GridBaseAPIService() {
        this.editCellState = new Map();
        this.editRowState = new Map();
        this.destroyMap = new Map();
    }
    /**
     * @param {?} name
     * @return {?}
     */
    GridBaseAPIService.prototype.get_column_by_name = /**
     * @param {?} name
     * @return {?}
     */
    function (name) {
        return this.grid.columnList.find(function (col) { return col.field === name; });
    };
    /**
     * @return {?}
     */
    GridBaseAPIService.prototype.get_summary_data = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var grid = this.grid;
        /** @type {?} */
        var data = grid.filteredData;
        if (!data) {
            if (grid.transactions.enabled) {
                data = DataUtil.mergeTransactions(cloneArray(grid.data), grid.transactions.getAggregatedChanges(true), grid.primaryKey);
                /** @type {?} */
                var deletedRows = grid.transactions.getTransactionLog().filter(function (t) { return t.type === TransactionType.DELETE; }).map(function (t) { return t.id; });
                deletedRows.forEach(function (rowID) {
                    /** @type {?} */
                    var tempData = grid.primaryKey ? data.map(function (rec) { return rec[grid.primaryKey]; }) : data;
                    /** @type {?} */
                    var index = tempData.indexOf(rowID);
                    if (index !== -1) {
                        data.splice(index, 1);
                    }
                });
            }
            else {
                data = grid.data;
            }
        }
        return data;
    };
    /**
     * @hidden
     * @internal
     */
    /**
     * @hidden
     * \@internal
     * @param {?} rowID
     * @return {?}
     */
    GridBaseAPIService.prototype.getRowData = /**
     * @hidden
     * \@internal
     * @param {?} rowID
     * @return {?}
     */
    function (rowID) {
        /** @type {?} */
        var data = this.get_all_data(this.grid.transactions.enabled);
        /** @type {?} */
        var index = this.get_row_index_in_data(rowID);
        return data[index];
    };
    // TODO: Refactor
    // TODO: Refactor
    /**
     * @return {?}
     */
    GridBaseAPIService.prototype.escape_editMode = 
    // TODO: Refactor
    /**
     * @return {?}
     */
    function () {
        this.grid.crudService.end();
        this.grid.refreshSearch();
    };
    // TODO: Refactor
    // TODO: Refactor
    /**
     * @return {?}
     */
    GridBaseAPIService.prototype.get_cell_inEditMode = 
    // TODO: Refactor
    /**
     * @return {?}
     */
    function () {
        return this.grid.crudService.cell;
    };
    /**
     * @param {?} rowID
     * @return {?}
     */
    GridBaseAPIService.prototype.get_row_index_in_data = /**
     * @param {?} rowID
     * @return {?}
     */
    function (rowID) {
        /** @type {?} */
        var grid = (/** @type {?} */ (this.grid));
        if (!grid) {
            return -1;
        }
        /** @type {?} */
        var data = this.get_all_data(grid.transactions.enabled);
        return grid.primaryKey ? data.findIndex(function (record) { return record[grid.primaryKey] === rowID; }) : data.indexOf(rowID);
    };
    /**
     * @param {?} rowSelector
     * @return {?}
     */
    GridBaseAPIService.prototype.get_row_by_key = /**
     * @param {?} rowSelector
     * @return {?}
     */
    function (rowSelector) {
        /** @type {?} */
        var primaryKey = this.grid.primaryKey;
        if (primaryKey !== undefined && primaryKey !== null) {
            return this.grid.dataRowList.find(function (row) { return row.rowData[primaryKey] === rowSelector; });
        }
        else {
            return this.grid.dataRowList.find(function (row) { return row.rowData === rowSelector; });
        }
    };
    /**
     * @param {?} rowIndex
     * @return {?}
     */
    GridBaseAPIService.prototype.get_row_by_index = /**
     * @param {?} rowIndex
     * @return {?}
     */
    function (rowIndex) {
        return this.grid.rowList.find(function (row) { return row.index === rowIndex; });
    };
    /**
     * @param {?} rowSelector
     * @param {?} field
     * @return {?}
     */
    GridBaseAPIService.prototype.get_cell_by_key = /**
     * @param {?} rowSelector
     * @param {?} field
     * @return {?}
     */
    function (rowSelector, field) {
        /** @type {?} */
        var row = this.get_row_by_key(rowSelector);
        if (row && row.cells) {
            return row.cells.find(function (cell) { return cell.column.field === field; });
        }
    };
    /**
     * @param {?} rowIndex
     * @param {?} columnIndex
     * @return {?}
     */
    GridBaseAPIService.prototype.get_cell_by_index = /**
     * @param {?} rowIndex
     * @param {?} columnIndex
     * @return {?}
     */
    function (rowIndex, columnIndex) {
        /** @type {?} */
        var row = this.get_row_by_index(rowIndex);
        if (row && row.cells) {
            return row.cells.find(function (cell) { return cell.columnIndex === columnIndex; });
        }
    };
    /**
     * @param {?} rowIndex
     * @param {?} columnIndex
     * @return {?}
     */
    GridBaseAPIService.prototype.get_cell_by_visible_index = /**
     * @param {?} rowIndex
     * @param {?} columnIndex
     * @return {?}
     */
    function (rowIndex, columnIndex) {
        /** @type {?} */
        var row = this.get_row_by_index(rowIndex);
        if (row && row.cells) {
            return row.cells.find(function (cell) { return cell.visibleColumnIndex === columnIndex; });
        }
    };
    /**
     * @return {?}
     */
    GridBaseAPIService.prototype.submit_value = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var cell = this.grid.crudService.cell;
        if (cell) {
            /** @type {?} */
            var args = this.update_cell(cell, cell.editValue);
            if (args.cancel) {
                return;
            }
            this.escape_editMode();
        }
    };
    /**
     * @param {?} cell
     * @param {?} value
     * @return {?}
     */
    GridBaseAPIService.prototype.update_cell = /**
     * @param {?} cell
     * @param {?} value
     * @return {?}
     */
    function (cell, value) {
        var _a;
        /** @type {?} */
        var data = this.get_all_data(this.grid.transactions.enabled);
        /** @type {?} */
        var index = this.get_row_index_in_data(cell.id.rowID);
        cell.editValue = value;
        /** @type {?} */
        var valueInTransactions = this.grid.transactions.getAggregatedValue(cell.id.rowID, true);
        if (valueInTransactions) {
            cell.value = valueInTransactions[cell.column.field];
            cell.rowData = valueInTransactions;
        }
        /** @type {?} */
        var args = cell.createEditEventArgs();
        this.grid.onCellEdit.emit(args);
        if (args.cancel) {
            return args;
        }
        // Cast to number after emit
        // TODO: Clean up this
        args.newValue = cell.castToNumber(args.newValue);
        if (isEqual(args.oldValue, args.newValue)) {
            return args;
        }
        this.grid.summaryService.clearSummaryCache(args);
        this.updateData(this.grid, cell.id.rowID, data[index], cell.rowData, (_a = {}, _a[cell.column.field] = args.newValue, _a));
        if (this.grid.primaryKey === cell.column.field) {
            if (this.grid.selection.is_item_selected(this.grid.id, cell.id.rowID)) {
                this.grid.selection.deselect_item(this.grid.id, cell.id.rowID);
                this.grid.selection.select_item(this.grid.id, args.newValue);
            }
            if (this.grid.hasSummarizedColumns) {
                this.grid.summaryService.removeSummaries(cell.id.rowID);
            }
        }
        if (!this.grid.rowEditable || !this.grid.crudService.row ||
            this.grid.crudService.row.id !== cell.id.rowID || !this.grid.transactions.enabled) {
            this.grid.summaryService.clearSummaryCache(args);
            ((/** @type {?} */ (this.grid)))._pipeTrigger++;
        }
        return args;
    };
    /**
     * Updates related row of provided grid's data source with provided new row value
     * @param grid Grid to update data for
     * @param rowID ID of the row to update
     * @param rowValueInDataSource Initial value of the row as it is in data source
     * @param rowCurrentValue Current value of the row as it is with applied previous transactions
     * @param rowNewValue New value of the row
     */
    /**
     * Updates related row of provided grid's data source with provided new row value
     * @protected
     * @param {?} grid Grid to update data for
     * @param {?} rowID ID of the row to update
     * @param {?} rowValueInDataSource Initial value of the row as it is in data source
     * @param {?} rowCurrentValue Current value of the row as it is with applied previous transactions
     * @param {?} rowNewValue New value of the row
     * @return {?}
     */
    GridBaseAPIService.prototype.updateData = /**
     * Updates related row of provided grid's data source with provided new row value
     * @protected
     * @param {?} grid Grid to update data for
     * @param {?} rowID ID of the row to update
     * @param {?} rowValueInDataSource Initial value of the row as it is in data source
     * @param {?} rowCurrentValue Current value of the row as it is with applied previous transactions
     * @param {?} rowNewValue New value of the row
     * @return {?}
     */
    function (grid, rowID, rowValueInDataSource, rowCurrentValue, rowNewValue) {
        if (grid.transactions.enabled) {
            /** @type {?} */
            var transaction = {
                id: rowID,
                type: TransactionType.UPDATE,
                newValue: rowNewValue
            };
            grid.transactions.add(transaction, rowCurrentValue);
        }
        else {
            mergeObjects(rowValueInDataSource, rowNewValue);
        }
    };
    /**
     * @param {?} row
     * @param {?=} value
     * @return {?}
     */
    GridBaseAPIService.prototype._update_row = /**
     * @param {?} row
     * @param {?=} value
     * @return {?}
     */
    function (row, value) {
        /** @type {?} */
        var grid = this.grid;
        /** @type {?} */
        var rowInEditMode = grid.crudService.row;
        row.newData = value ? value : grid.transactions.getAggregatedValue(row.id, true);
        if (rowInEditMode && row.id === rowInEditMode.id) {
            row.data = __assign({}, row.data, rowInEditMode.transactionState);
            // TODO: Workaround for updating a row in edit mode through the API
        }
        else if (this.grid.transactions.enabled) {
            /** @type {?} */
            var lastCommitedValue = grid.transactions.getState(row.id) ?
                grid.transactions.getState(row.id).value : null;
            row.data = lastCommitedValue ? Object.assign(row.data, lastCommitedValue) : row.data;
        }
    };
    /**
     * @param {?} row
     * @param {?} value
     * @return {?}
     */
    GridBaseAPIService.prototype.update_row = /**
     * @param {?} row
     * @param {?} value
     * @return {?}
     */
    function (row, value) {
        /** @type {?} */
        var grid = this.grid;
        /** @type {?} */
        var selected = grid.selection.is_item_selected(grid.id, row.id);
        /** @type {?} */
        var rowInEditMode = grid.crudService.row;
        /** @type {?} */
        var data = this.get_all_data(grid.transactions.enabled);
        /** @type {?} */
        var index = this.get_row_index_in_data(row.id);
        /** @type {?} */
        var hasSummarized = grid.hasSummarizedColumns;
        this._update_row(row, value);
        /** @type {?} */
        var args = row.createEditEventArgs();
        // If no valid row is found
        if (index === -1) {
            return args;
        }
        grid.onRowEdit.emit(args);
        if (args.cancel) {
            return args;
        }
        if (rowInEditMode) {
            grid.transactions.endPending(false);
        }
        if (!args.newValue) {
            return args;
        }
        if (hasSummarized) {
            grid.summaryService.removeSummaries(args.rowID);
        }
        this.updateData(grid, row.id, data[index], args.oldValue, args.newValue);
        /** @type {?} */
        var newId = grid.primaryKey ? args.newValue[grid.primaryKey] : args.newValue;
        if (selected) {
            grid.selection.deselect_item(grid.id, row.id);
            grid.selection.select_item(grid.id, newId);
        }
        if (hasSummarized) {
            grid.summaryService.removeSummaries(newId);
        }
        ((/** @type {?} */ (grid)))._pipeTrigger++;
        return args;
    };
    /**
     * @protected
     * @param {?} value
     * @param {?} rowID
     * @param {?} index
     * @return {?}
     */
    GridBaseAPIService.prototype.update_row_in_array = /**
     * @protected
     * @param {?} value
     * @param {?} rowID
     * @param {?} index
     * @return {?}
     */
    function (value, rowID, index) {
        /** @type {?} */
        var grid = this.grid;
        grid.data[index] = value;
    };
    /**
     * @param {?} expression
     * @return {?}
     */
    GridBaseAPIService.prototype.sort = /**
     * @param {?} expression
     * @return {?}
     */
    function (expression) {
        if (expression.dir === SortingDirection.None) {
            this.remove_grouping_expression(expression.fieldName);
        }
        /** @type {?} */
        var sortingState = cloneArray(this.grid.sortingExpressions);
        this.prepare_sorting_expression([sortingState], expression);
        this.grid.sortingExpressions = sortingState;
    };
    /**
     * @param {?} expressions
     * @return {?}
     */
    GridBaseAPIService.prototype.sort_multiple = /**
     * @param {?} expressions
     * @return {?}
     */
    function (expressions) {
        var e_1, _a;
        /** @type {?} */
        var sortingState = cloneArray(this.grid.sortingExpressions);
        try {
            for (var expressions_1 = __values(expressions), expressions_1_1 = expressions_1.next(); !expressions_1_1.done; expressions_1_1 = expressions_1.next()) {
                var each = expressions_1_1.value;
                if (each.dir === SortingDirection.None) {
                    this.remove_grouping_expression(each.fieldName);
                }
                this.prepare_sorting_expression([sortingState], each);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (expressions_1_1 && !expressions_1_1.done && (_a = expressions_1.return)) _a.call(expressions_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        this.grid.sortingExpressions = sortingState;
    };
    /**
     * @param {?} fieldName
     * @param {?} term
     * @param {?} conditionOrExpressionsTree
     * @param {?} ignoreCase
     * @return {?}
     */
    GridBaseAPIService.prototype.filter = /**
     * @param {?} fieldName
     * @param {?} term
     * @param {?} conditionOrExpressionsTree
     * @param {?} ignoreCase
     * @return {?}
     */
    function (fieldName, term, conditionOrExpressionsTree, ignoreCase) {
        /** @type {?} */
        var grid = this.grid;
        /** @type {?} */
        var filteringTree = grid.filteringExpressionsTree;
        grid.endEdit(false);
        if (grid.paging) {
            grid.page = 0;
        }
        /** @type {?} */
        var fieldFilterIndex = filteringTree.findIndex(fieldName);
        if (fieldFilterIndex > -1) {
            filteringTree.filteringOperands.splice(fieldFilterIndex, 1);
        }
        this.prepare_filtering_expression(filteringTree, fieldName, term, conditionOrExpressionsTree, ignoreCase, fieldFilterIndex);
        grid.filteringExpressionsTree = filteringTree;
    };
    /**
     * @param {?} term
     * @param {?} condition
     * @param {?} ignoreCase
     * @return {?}
     */
    GridBaseAPIService.prototype.filter_global = /**
     * @param {?} term
     * @param {?} condition
     * @param {?} ignoreCase
     * @return {?}
     */
    function (term, condition, ignoreCase) {
        var e_2, _a;
        /** @type {?} */
        var grid = this.grid;
        /** @type {?} */
        var filteringTree = grid.filteringExpressionsTree;
        grid.endEdit(false);
        if (grid.paging) {
            grid.page = 0;
        }
        filteringTree.filteringOperands = [];
        if (condition) {
            try {
                for (var _b = __values(grid.columns), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var column = _c.value;
                    this.prepare_filtering_expression(filteringTree, column.field, term, condition, ignoreCase || column.filteringIgnoreCase);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
        grid.filteringExpressionsTree = filteringTree;
    };
    /**
     * @param {?} fieldName
     * @return {?}
     */
    GridBaseAPIService.prototype.clear_filter = /**
     * @param {?} fieldName
     * @return {?}
     */
    function (fieldName) {
        if (fieldName) {
            /** @type {?} */
            var column = this.get_column_by_name(fieldName);
            if (!column) {
                return;
            }
        }
        /** @type {?} */
        var grid = this.grid;
        grid.endEdit(false);
        /** @type {?} */
        var filteringState = grid.filteringExpressionsTree;
        /** @type {?} */
        var index = filteringState.findIndex(fieldName);
        if (index > -1) {
            filteringState.filteringOperands.splice(index, 1);
        }
        else if (!fieldName) {
            filteringState.filteringOperands = [];
        }
        grid.filteringExpressionsTree = filteringState;
    };
    /**
     * @param {?} fieldName
     * @return {?}
     */
    GridBaseAPIService.prototype.clear_sort = /**
     * @param {?} fieldName
     * @return {?}
     */
    function (fieldName) {
        /** @type {?} */
        var sortingState = this.grid.sortingExpressions;
        /** @type {?} */
        var index = sortingState.findIndex(function (expr) { return expr.fieldName === fieldName; });
        if (index > -1) {
            sortingState.splice(index, 1);
            this.grid.sortingExpressions = sortingState;
        }
    };
    /**
     * @protected
     * @param {?} filteringState
     * @param {?} fieldName
     * @param {?} searchVal
     * @param {?} conditionOrExpressionsTree
     * @param {?} ignoreCase
     * @param {?=} insertAtIndex
     * @return {?}
     */
    GridBaseAPIService.prototype.prepare_filtering_expression = /**
     * @protected
     * @param {?} filteringState
     * @param {?} fieldName
     * @param {?} searchVal
     * @param {?} conditionOrExpressionsTree
     * @param {?} ignoreCase
     * @param {?=} insertAtIndex
     * @return {?}
     */
    function (filteringState, fieldName, searchVal, conditionOrExpressionsTree, ignoreCase, insertAtIndex) {
        if (insertAtIndex === void 0) { insertAtIndex = -1; }
        /** @type {?} */
        var newExpressionsTree;
        /** @type {?} */
        var oldExpressionsTreeIndex = filteringState.findIndex(fieldName);
        /** @type {?} */
        var expressionsTree = conditionOrExpressionsTree instanceof FilteringExpressionsTree ?
            (/** @type {?} */ (conditionOrExpressionsTree)) : null;
        /** @type {?} */
        var condition = conditionOrExpressionsTree instanceof FilteringExpressionsTree ?
            null : (/** @type {?} */ (conditionOrExpressionsTree));
        /** @type {?} */
        var newExpression = { fieldName: fieldName, searchVal: searchVal, condition: condition, ignoreCase: ignoreCase };
        if (oldExpressionsTreeIndex === -1) {
            // no expressions tree found for this field
            if (expressionsTree) {
                if (insertAtIndex > -1) {
                    filteringState.filteringOperands.splice(insertAtIndex, 0, expressionsTree);
                }
                else {
                    filteringState.filteringOperands.push(expressionsTree);
                }
            }
            else if (condition) {
                // create expressions tree for this field and add the new expression to it
                newExpressionsTree = new FilteringExpressionsTree(filteringState.operator, fieldName);
                newExpressionsTree.filteringOperands.push(newExpression);
                filteringState.filteringOperands.push(newExpressionsTree);
            }
        }
    };
    /**
     * @protected
     * @param {?} stateCollections
     * @param {?} expression
     * @return {?}
     */
    GridBaseAPIService.prototype.prepare_sorting_expression = /**
     * @protected
     * @param {?} stateCollections
     * @param {?} expression
     * @return {?}
     */
    function (stateCollections, expression) {
        if (expression.dir === SortingDirection.None) {
            stateCollections.forEach(function (state$$1) {
                state$$1.splice(state$$1.findIndex(function (expr) { return expr.fieldName === expression.fieldName; }), 1);
            });
            return;
        }
        /**
         * We need to make sure the states in each collection with same fields point to the same object reference.
         * If the different state collections provided have different sizes we need to get the largest one.
         * That way we can get the state reference from the largest one that has the same fieldName as the expression to prepare.
         * @type {?}
         */
        var maxCollection = stateCollections[0];
        for (var i = 1; i < stateCollections.length; i++) {
            if (maxCollection.length < stateCollections[i].length) {
                maxCollection = stateCollections[i];
            }
        }
        /** @type {?} */
        var maxExpr = maxCollection.find(function (expr) { return expr.fieldName === expression.fieldName; });
        stateCollections.forEach(function (collection) {
            /** @type {?} */
            var myExpr = collection.find(function (expr) { return expr.fieldName === expression.fieldName; });
            if (!myExpr && !maxExpr) {
                // Expression with this fieldName is missing from the current and the max collection.
                collection.push(expression);
            }
            else if (!myExpr && maxExpr) {
                // Expression with this fieldName is missing from the current and but the max collection has.
                collection.push(maxExpr);
                Object.assign(maxExpr, expression);
            }
            else {
                // The current collection has the expression so just update it.
                Object.assign(myExpr, expression);
            }
        });
    };
    /**
     * @protected
     * @param {?} fieldName
     * @return {?}
     */
    GridBaseAPIService.prototype.remove_grouping_expression = /**
     * @protected
     * @param {?} fieldName
     * @return {?}
     */
    function (fieldName) {
    };
    /**
     * @param {?} column
     * @return {?}
     */
    GridBaseAPIService.prototype.should_apply_number_style = /**
     * @param {?} column
     * @return {?}
     */
    function (column) {
        return column.dataType === DataType.Number;
    };
    /**
     * @return {?}
     */
    GridBaseAPIService.prototype.get_data = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var grid = this.grid;
        /** @type {?} */
        var data = grid.data ? grid.data : [];
        return data;
    };
    /**
     * @param {?=} includeTransactions
     * @return {?}
     */
    GridBaseAPIService.prototype.get_all_data = /**
     * @param {?=} includeTransactions
     * @return {?}
     */
    function (includeTransactions) {
        if (includeTransactions === void 0) { includeTransactions = false; }
        /** @type {?} */
        var grid = this.grid;
        /** @type {?} */
        var data = grid.data ? grid.data : [];
        data = includeTransactions ? grid.dataWithAddedInTransactionRows : data;
        return data;
    };
    /**
     * @return {?}
     */
    GridBaseAPIService.prototype.get_filtered_data = /**
     * @return {?}
     */
    function () {
        return this.grid.filteredData;
    };
    /**
     * @protected
     * @param {?} fieldName
     * @return {?}
     */
    GridBaseAPIService.prototype.getSortStrategyPerColumn = /**
     * @protected
     * @param {?} fieldName
     * @return {?}
     */
    function (fieldName) {
        return this.get_column_by_name(fieldName) ?
            this.get_column_by_name(fieldName).sortStrategy : undefined;
    };
    /**
     * @param {?} rowData
     * @return {?}
     */
    GridBaseAPIService.prototype.addRowToData = /**
     * @param {?} rowData
     * @return {?}
     */
    function (rowData) {
        // Add row goes to transactions and if rowEditable is properly implemented, added rows will go to pending transactions
        // If there is a row in edit - > commit and close
        /** @type {?} */
        var grid = this.grid;
        if (grid.transactions.enabled) {
            /** @type {?} */
            var transactionId = grid.primaryKey ? rowData[grid.primaryKey] : rowData;
            /** @type {?} */
            var transaction = { id: transactionId, type: TransactionType.ADD, newValue: rowData };
            grid.transactions.add(transaction);
        }
        else {
            grid.data.push(rowData);
        }
    };
    /**
     * @param {?} rowID
     * @param {?} index
     * @return {?}
     */
    GridBaseAPIService.prototype.deleteRowFromData = /**
     * @param {?} rowID
     * @param {?} index
     * @return {?}
     */
    function (rowID, index) {
        //  if there is a row (index !== 0) delete it
        //  if there is a row in ADD or UPDATE state change it's state to DELETE
        /** @type {?} */
        var grid = this.grid;
        if (index !== -1) {
            if (grid.transactions.enabled) {
                /** @type {?} */
                var transaction = { id: rowID, type: TransactionType.DELETE, newValue: null };
                grid.transactions.add(transaction, grid.data[index]);
            }
            else {
                grid.data.splice(index, 1);
            }
        }
        else {
            /** @type {?} */
            var state$$1 = grid.transactions.getState(rowID);
            grid.transactions.add({ id: rowID, type: TransactionType.DELETE, newValue: null }, state$$1 && state$$1.recordRef);
        }
    };
    /**
     * @param {?} rowId
     * @return {?}
     */
    GridBaseAPIService.prototype.deleteRowById = /**
     * @param {?} rowId
     * @return {?}
     */
    function (rowId) {
        /** @type {?} */
        var index;
        /** @type {?} */
        var grid = this.grid;
        /** @type {?} */
        var data = this.get_all_data();
        if (grid.primaryKey) {
            index = data.map(function (record) { return record[grid.primaryKey]; }).indexOf(rowId);
        }
        else {
            index = data.indexOf(rowId);
        }
        /** @type {?} */
        var state$$1 = grid.transactions.getState(rowId);
        /** @type {?} */
        var hasRowInNonDeletedState = state$$1 && state$$1.type !== TransactionType.DELETE;
        //  if there is a row (index !== -1) and the we have cell in edit mode on same row exit edit mode
        //  if there is no row (index === -1), but there is a row in ADD or UPDATE state do as above
        //  Otherwise just exit - there is nothing to delete
        if (index !== -1 || hasRowInNonDeletedState) {
            // Always exit edit when row is deleted
            grid.endEdit(true);
        }
        else {
            return;
        }
        //  TODO: should we emit this when cascadeOnDelete is true for each row?!?!
        grid.onRowDeleted.emit({ data: data[index] });
        //  first deselect row then delete it
        if (grid.rowSelectable && grid.selection.is_item_selected(grid.id, rowId)) {
            grid.deselectRows([rowId]);
        }
        else {
            grid.checkHeaderCheckboxStatus();
        }
        this.deleteRowFromData(rowId, index);
        ((/** @type {?} */ (grid)))._pipeTrigger++;
        grid.cdr.markForCheck();
        // Data needs to be recalculated if transactions are in place
        // If no transactions, `data` will be a reference to the grid getter, otherwise it will be stale
        /** @type {?} */
        var dataAfterDelete = grid.transactions.enabled ? grid.dataWithAddedInTransactionRows : data;
        grid.refreshSearch();
        if (dataAfterDelete.length % grid.perPage === 0 && dataAfterDelete.length / grid.perPage - 1 < grid.page && grid.page !== 0) {
            grid.page--;
        }
    };
    /**
     * @param {?} rowData
     * @return {?}
     */
    GridBaseAPIService.prototype.get_row_id = /**
     * @param {?} rowData
     * @return {?}
     */
    function (rowData) {
        /** @type {?} */
        var grid = this.grid;
        return grid.primaryKey ? rowData[grid.primaryKey] : rowData;
    };
    /**
     * @param {?} rowID
     * @return {?}
     */
    GridBaseAPIService.prototype.row_deleted_transaction = /**
     * @param {?} rowID
     * @return {?}
     */
    function (rowID) {
        /** @type {?} */
        var grid = this.grid;
        if (!grid) {
            return false;
        }
        if (!grid.transactions.enabled) {
            return false;
        }
        /** @type {?} */
        var state$$1 = grid.transactions.getState(rowID);
        if (state$$1) {
            return state$$1.type === TransactionType.DELETE;
        }
        return false;
    };
    /**
     * @return {?}
     */
    GridBaseAPIService.prototype.atInexistingPage = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var grid = this.grid;
        return grid.data.length % grid.perPage === 0 && grid.isLastPage && grid.page !== 0;
    };
    GridBaseAPIService.decorators = [
        { type: Injectable }
    ];
    return GridBaseAPIService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
var FilteringLogic = {
    And: 0,
    Or: 1,
};
FilteringLogic[FilteringLogic.And] = 'And';
FilteringLogic[FilteringLogic.Or] = 'Or';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var  /**
 * @abstract
 */
BaseFilteringStrategy = /** @class */ (function () {
    function BaseFilteringStrategy() {
    }
    /**
     * @param {?} rec
     * @param {?} expr
     * @return {?}
     */
    BaseFilteringStrategy.prototype.findMatchByExpression = /**
     * @param {?} rec
     * @param {?} expr
     * @return {?}
     */
    function (rec, expr) {
        /** @type {?} */
        var cond = expr.condition;
        /** @type {?} */
        var val = this.getFieldValue(rec, expr.fieldName);
        return cond.logic(val, expr.searchVal, expr.ignoreCase);
    };
    /**
     * @param {?} rec
     * @param {?} expressions
     * @return {?}
     */
    BaseFilteringStrategy.prototype.matchRecord = /**
     * @param {?} rec
     * @param {?} expressions
     * @return {?}
     */
    function (rec, expressions) {
        if (expressions) {
            if (expressions instanceof FilteringExpressionsTree) {
                /** @type {?} */
                var expressionsTree = (/** @type {?} */ (expressions));
                /** @type {?} */
                var operator = (/** @type {?} */ (expressionsTree.operator));
                /** @type {?} */
                var matchOperand = void 0;
                /** @type {?} */
                var operand = void 0;
                if (expressionsTree.filteringOperands && expressionsTree.filteringOperands.length) {
                    for (var i = 0; i < expressionsTree.filteringOperands.length; i++) {
                        operand = expressionsTree.filteringOperands[i];
                        matchOperand = this.matchRecord(rec, operand);
                        // Return false if at least one operand does not match and the filtering logic is And
                        if (!matchOperand && operator === FilteringLogic.And) {
                            return false;
                        }
                        // Return true if at least one operand matches and the filtering logic is Or
                        if (matchOperand && operator === FilteringLogic.Or) {
                            return true;
                        }
                    }
                    return matchOperand;
                }
                return true;
            }
            else {
                /** @type {?} */
                var expression = (/** @type {?} */ (expressions));
                return this.findMatchByExpression(rec, expression);
            }
        }
        return true;
    };
    return BaseFilteringStrategy;
}());
var FilteringStrategy = /** @class */ (function (_super) {
    __extends(FilteringStrategy, _super);
    function FilteringStrategy() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @template T
     * @param {?} data
     * @param {?} expressionsTree
     * @return {?}
     */
    FilteringStrategy.prototype.filter = /**
     * @template T
     * @param {?} data
     * @param {?} expressionsTree
     * @return {?}
     */
    function (data, expressionsTree) {
        /** @type {?} */
        var i;
        /** @type {?} */
        var rec;
        /** @type {?} */
        var len = data.length;
        /** @type {?} */
        var res = [];
        if (!expressionsTree || !expressionsTree.filteringOperands || expressionsTree.filteringOperands.length === 0 || !len) {
            return data;
        }
        for (i = 0; i < len; i++) {
            rec = data[i];
            if (this.matchRecord(rec, expressionsTree)) {
                res.push(rec);
            }
        }
        return res;
    };
    /**
     * @protected
     * @param {?} rec
     * @param {?} fieldName
     * @return {?}
     */
    FilteringStrategy.prototype.getFieldValue = /**
     * @protected
     * @param {?} rec
     * @param {?} fieldName
     * @return {?}
     */
    function (rec, fieldName) {
        return rec[fieldName];
    };
    return FilteringStrategy;
}(BaseFilteringStrategy));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var /**
 * @hidden
 */
TreeGridFilteringStrategy = /** @class */ (function (_super) {
    __extends(TreeGridFilteringStrategy, _super);
    function TreeGridFilteringStrategy() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {?} data
     * @param {?} expressionsTree
     * @return {?}
     */
    TreeGridFilteringStrategy.prototype.filter = /**
     * @param {?} data
     * @param {?} expressionsTree
     * @return {?}
     */
    function (data, expressionsTree) {
        return this.filterImpl(data, expressionsTree, undefined);
    };
    /**
     * @private
     * @param {?} data
     * @param {?} expressionsTree
     * @param {?} parent
     * @return {?}
     */
    TreeGridFilteringStrategy.prototype.filterImpl = /**
     * @private
     * @param {?} data
     * @param {?} expressionsTree
     * @param {?} parent
     * @return {?}
     */
    function (data, expressionsTree, parent) {
        /** @type {?} */
        var i;
        /** @type {?} */
        var rec;
        /** @type {?} */
        var len = data.length;
        /** @type {?} */
        var res = [];
        if (!expressionsTree || !expressionsTree.filteringOperands || expressionsTree.filteringOperands.length === 0 || !len) {
            return data;
        }
        for (i = 0; i < len; i++) {
            rec = DataUtil.cloneTreeGridRecord(data[i]);
            rec.parent = parent;
            if (rec.children) {
                /** @type {?} */
                var filteredChildren = this.filterImpl(rec.children, expressionsTree, rec);
                rec.children = filteredChildren.length > 0 ? filteredChildren : null;
            }
            if (this.matchRecord(rec, expressionsTree)) {
                res.push(rec);
            }
            else if (rec.children && rec.children.length > 0) {
                rec.isFilteredOutParent = true;
                res.push(rec);
            }
        }
        return res;
    };
    /**
     * @protected
     * @param {?} rec
     * @param {?} fieldName
     * @return {?}
     */
    TreeGridFilteringStrategy.prototype.getFieldValue = /**
     * @protected
     * @param {?} rec
     * @param {?} fieldName
     * @return {?}
     */
    function (rec, fieldName) {
        /** @type {?} */
        var hierarchicalRecord = (/** @type {?} */ (rec));
        return hierarchicalRecord.data[fieldName];
    };
    return TreeGridFilteringStrategy;
}(BaseFilteringStrategy));
/**
 * @hidden
 */
var IgxTreeGridFilteringPipe = /** @class */ (function () {
    function IgxTreeGridFilteringPipe(gridAPI) {
        this.gridAPI = (/** @type {?} */ (gridAPI));
    }
    /**
     * @param {?} hierarchyData
     * @param {?} expressionsTree
     * @param {?} id
     * @param {?} pipeTrigger
     * @return {?}
     */
    IgxTreeGridFilteringPipe.prototype.transform = /**
     * @param {?} hierarchyData
     * @param {?} expressionsTree
     * @param {?} id
     * @param {?} pipeTrigger
     * @return {?}
     */
    function (hierarchyData, expressionsTree, id, pipeTrigger) {
        /** @type {?} */
        var grid = this.gridAPI.grid;
        /** @type {?} */
        var state$$1 = {
            expressionsTree: expressionsTree,
            strategy: new TreeGridFilteringStrategy()
        };
        this.resetFilteredOutProperty(grid.records);
        if (!state$$1.expressionsTree ||
            !state$$1.expressionsTree.filteringOperands ||
            state$$1.expressionsTree.filteringOperands.length === 0) {
            grid.filteredData = null;
            return hierarchyData;
        }
        /** @type {?} */
        var result = this.filter(hierarchyData, state$$1);
        /** @type {?} */
        var filteredData = [];
        this.expandAllRecursive(grid, result, grid.expansionStates, filteredData);
        grid.filteredData = filteredData;
        return result;
    };
    /**
     * @private
     * @param {?} map
     * @return {?}
     */
    IgxTreeGridFilteringPipe.prototype.resetFilteredOutProperty = /**
     * @private
     * @param {?} map
     * @return {?}
     */
    function (map$$1) {
        /** @type {?} */
        var keys = Array.from(map$$1.keys());
        for (var i = 0; i < keys.length; i++) {
            map$$1.get(keys[i]).isFilteredOutParent = undefined;
        }
    };
    /**
     * @private
     * @param {?} grid
     * @param {?} data
     * @param {?} expandedStates
     * @param {?} filteredData
     * @return {?}
     */
    IgxTreeGridFilteringPipe.prototype.expandAllRecursive = /**
     * @private
     * @param {?} grid
     * @param {?} data
     * @param {?} expandedStates
     * @param {?} filteredData
     * @return {?}
     */
    function (grid, data, expandedStates, filteredData) {
        for (var i = 0; i < data.length; i++) {
            /** @type {?} */
            var rec = data[i];
            filteredData.push(rec.data);
            this.updateNonProcessedRecord(grid, rec);
            if (rec.children && rec.children.length > 0) {
                expandedStates.set(rec.rowID, true);
                this.expandAllRecursive(grid, rec.children, expandedStates, filteredData);
            }
        }
    };
    /**
     * @private
     * @param {?} grid
     * @param {?} record
     * @return {?}
     */
    IgxTreeGridFilteringPipe.prototype.updateNonProcessedRecord = /**
     * @private
     * @param {?} grid
     * @param {?} record
     * @return {?}
     */
    function (grid, record) {
        /** @type {?} */
        var rec = grid.records.get(record.rowID);
        rec.isFilteredOutParent = record.isFilteredOutParent;
    };
    /**
     * @private
     * @param {?} data
     * @param {?} state
     * @return {?}
     */
    IgxTreeGridFilteringPipe.prototype.filter = /**
     * @private
     * @param {?} data
     * @param {?} state
     * @return {?}
     */
    function (data, state$$1) {
        return state$$1.strategy.filter(data, state$$1.expressionsTree);
    };
    IgxTreeGridFilteringPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'treeGridFiltering',
                    pure: true
                },] }
    ];
    /** @nocollapse */
    IgxTreeGridFilteringPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };
    return IgxTreeGridFilteringPipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var DataType = {
    String: 'string',
    Number: 'number',
    Boolean: 'boolean',
    Date: 'date',
};
/**
 * @hidden
 */
var  /**
 * @hidden
 */
DataUtil = /** @class */ (function () {
    function DataUtil() {
    }
    /**
     * @template T
     * @param {?} data
     * @param {?} expressions
     * @param {?=} sorting
     * @return {?}
     */
    DataUtil.sort = /**
     * @template T
     * @param {?} data
     * @param {?} expressions
     * @param {?=} sorting
     * @return {?}
     */
    function (data, expressions, sorting) {
        if (sorting === void 0) { sorting = new IgxSorting(); }
        return sorting.sort(data, expressions);
    };
    /**
     * @param {?} hierarchicalData
     * @param {?} expressions
     * @param {?=} parent
     * @return {?}
     */
    DataUtil.treeGridSort = /**
     * @param {?} hierarchicalData
     * @param {?} expressions
     * @param {?=} parent
     * @return {?}
     */
    function (hierarchicalData, expressions, parent) {
        /** @type {?} */
        var res = [];
        hierarchicalData.forEach(function (hr) {
            /** @type {?} */
            var rec = DataUtil.cloneTreeGridRecord(hr);
            rec.parent = parent;
            if (rec.children) {
                rec.children = DataUtil.treeGridSort(rec.children, expressions, rec);
            }
            res.push(rec);
        });
        res = DataUtil.sort(res, expressions, new IgxDataRecordSorting());
        return res;
    };
    /**
     * @param {?} hierarchicalRecord
     * @return {?}
     */
    DataUtil.cloneTreeGridRecord = /**
     * @param {?} hierarchicalRecord
     * @return {?}
     */
    function (hierarchicalRecord) {
        /** @type {?} */
        var rec = {
            rowID: hierarchicalRecord.rowID,
            data: hierarchicalRecord.data,
            children: hierarchicalRecord.children,
            isFilteredOutParent: hierarchicalRecord.isFilteredOutParent,
            level: hierarchicalRecord.level,
            expanded: hierarchicalRecord.expanded
        };
        return rec;
    };
    /**
     * @template T
     * @param {?} data
     * @param {?} state
     * @param {?=} grid
     * @param {?=} groupsRecords
     * @return {?}
     */
    DataUtil.group = /**
     * @template T
     * @param {?} data
     * @param {?} state
     * @param {?=} grid
     * @param {?=} groupsRecords
     * @return {?}
     */
    function (data, state$$1, grid, groupsRecords) {
        if (grid === void 0) { grid = null; }
        if (groupsRecords === void 0) { groupsRecords = []; }
        /** @type {?} */
        var grouping = new IgxGrouping();
        groupsRecords.splice(0, groupsRecords.length);
        return grouping.groupBy(data, state$$1.expressions, grid, groupsRecords);
    };
    /**
     * @param {?} groupData
     * @param {?} state
     * @return {?}
     */
    DataUtil.restoreGroups = /**
     * @param {?} groupData
     * @param {?} state
     * @return {?}
     */
    function (groupData, state$$1) {
        if (state$$1.expressions.length === 0) {
            return groupData.data;
        }
        return this.restoreGroupsIterative(groupData, state$$1);
    };
    /**
     * @private
     * @param {?} groupData
     * @param {?} state
     * @return {?}
     */
    DataUtil.restoreGroupsIterative = /**
     * @private
     * @param {?} groupData
     * @param {?} state
     * @return {?}
     */
    function (groupData, state$$1) {
        var _this = this;
        /** @type {?} */
        var metadata = groupData.metadata;
        /** @type {?} */
        var result = [];
        /** @type {?} */
        var added = [];
        /** @type {?} */
        var chain;
        /** @type {?} */
        var i = 0;
        /** @type {?} */
        var j;
        /** @type {?} */
        var pointer;
        /** @type {?} */
        var expanded;
        for (i = 0; i < metadata.length;) {
            chain = [metadata[i]];
            pointer = metadata[i].groupParent;
            // break off if the parent is already added
            while (pointer && added[0] !== pointer) {
                chain.push(pointer);
                if (added[0] && added[0].level === pointer.level) {
                    added.shift();
                }
                pointer = pointer.groupParent;
            }
            var _loop_1 = function () {
                result.push(chain[j]);
                added.unshift(chain[j]);
                /** @type {?} */
                var hierarchy = this_1.getHierarchy(chain[j]);
                /** @type {?} */
                var expandState = state$$1.expansion.find(function (s) {
                    return _this.isHierarchyMatch(s.hierarchy || [{ fieldName: chain[j].expression.fieldName, value: chain[j].value }], hierarchy);
                });
                expanded = expandState ? expandState.expanded : state$$1.defaultExpanded;
                if (!expanded) {
                    return "break";
                }
            };
            var this_1 = this;
            for (j = chain.length - 1; j >= 0; j--) {
                var state_1 = _loop_1();
                if (state_1 === "break")
                    break;
            }
            added.shift();
            j = Math.max(j, 0);
            /** @type {?} */
            var start = chain[j].records.findIndex(function (r) { return r === groupData.data[i]; });
            /** @type {?} */
            var end = Math.min(metadata.length - i + start, chain[j].records.length);
            if (expanded) {
                result.push.apply(result, __spread(chain[j].records.slice(start, end)));
            }
            i += end - start;
        }
        return result;
    };
    /**
     * @template T
     * @param {?} data
     * @param {?} state
     * @return {?}
     */
    DataUtil.page = /**
     * @template T
     * @param {?} data
     * @param {?} state
     * @return {?}
     */
    function (data, state$$1) {
        if (!state$$1) {
            return data;
        }
        /** @type {?} */
        var len = data.length;
        /** @type {?} */
        var index = state$$1.index;
        /** @type {?} */
        var res = [];
        /** @type {?} */
        var recordsPerPage = state$$1.recordsPerPage;
        state$$1.metadata = {
            countPages: 0,
            countRecords: data.length,
            error: PagingError.None
        };
        if (index < 0 || isNaN(index)) {
            state$$1.metadata.error = PagingError.IncorrectPageIndex;
            return res;
        }
        if (recordsPerPage <= 0 || isNaN(recordsPerPage)) {
            state$$1.metadata.error = PagingError.IncorrectRecordsPerPage;
            return res;
        }
        state$$1.metadata.countPages = Math.ceil(len / recordsPerPage);
        if (!len) {
            return data;
        }
        if (index >= state$$1.metadata.countPages) {
            state$$1.metadata.error = PagingError.IncorrectPageIndex;
            return res;
        }
        return data.slice(index * recordsPerPage, (index + 1) * recordsPerPage);
    };
    /**
     * @template T
     * @param {?} data
     * @param {?} state
     * @return {?}
     */
    DataUtil.filter = /**
     * @template T
     * @param {?} data
     * @param {?} state
     * @return {?}
     */
    function (data, state$$1) {
        if (!state$$1.strategy) {
            state$$1.strategy = new FilteringStrategy();
        }
        return state$$1.strategy.filter(data, state$$1.expressionsTree);
    };
    /**
     * @param {?} data
     * @param {?} state
     * @return {?}
     */
    DataUtil.treeGridFilter = /**
     * @param {?} data
     * @param {?} state
     * @return {?}
     */
    function (data, state$$1) {
        if (!state$$1.strategy) {
            state$$1.strategy = new TreeGridFilteringStrategy();
        }
        return state$$1.strategy.filter(data, state$$1.expressionsTree);
    };
    /**
     * @param {?} gRow
     * @return {?}
     */
    DataUtil.getHierarchy = /**
     * @param {?} gRow
     * @return {?}
     */
    function (gRow) {
        /** @type {?} */
        var hierarchy = [];
        if (gRow !== undefined && gRow.expression) {
            hierarchy.push({ fieldName: gRow.expression.fieldName, value: gRow.value });
            while (gRow.groupParent) {
                gRow = gRow.groupParent;
                hierarchy.unshift({ fieldName: gRow.expression.fieldName, value: gRow.value });
            }
        }
        return hierarchy;
    };
    /**
     * @param {?} h1
     * @param {?} h2
     * @return {?}
     */
    DataUtil.isHierarchyMatch = /**
     * @param {?} h1
     * @param {?} h2
     * @return {?}
     */
    function (h1, h2) {
        if (h1.length !== h2.length) {
            return false;
        }
        return h1.every(function (level, index) {
            return level.fieldName === h2[index].fieldName && level.value === h2[index].value;
        });
    };
    /**
     * Merges all changes from provided transactions into provided data collection
     * @param data Collection to merge
     * @param transactions Transactions to merge into data
     * @param primaryKey Primary key of the collection, if any
     * @param deleteRows Should delete rows with DELETE transaction type from data
     * @returns Provided data collections updated with all provided transactions
     */
    /**
     * Merges all changes from provided transactions into provided data collection
     * @template T
     * @param {?} data Collection to merge
     * @param {?} transactions Transactions to merge into data
     * @param {?=} primaryKey Primary key of the collection, if any
     * @param {?=} deleteRows Should delete rows with DELETE transaction type from data
     * @return {?} Provided data collections updated with all provided transactions
     */
    DataUtil.mergeTransactions = /**
     * Merges all changes from provided transactions into provided data collection
     * @template T
     * @param {?} data Collection to merge
     * @param {?} transactions Transactions to merge into data
     * @param {?=} primaryKey Primary key of the collection, if any
     * @param {?=} deleteRows Should delete rows with DELETE transaction type from data
     * @return {?} Provided data collections updated with all provided transactions
     */
    function (data, transactions, primaryKey, deleteRows) {
        if (deleteRows === void 0) { deleteRows = false; }
        data.forEach(function (item, index) {
            /** @type {?} */
            var rowId = primaryKey ? item[primaryKey] : item;
            /** @type {?} */
            var transaction = transactions.find(function (t) { return t.id === rowId; });
            if (transaction && transaction.type === TransactionType.UPDATE) {
                data[index] = transaction.newValue;
            }
        });
        if (deleteRows) {
            transactions
                .filter(function (t) { return t.type === TransactionType.DELETE; })
                .forEach(function (t) {
                /** @type {?} */
                var index = primaryKey ? data.findIndex(function (d) { return d[primaryKey] === t.id; }) : data.findIndex(function (d) { return d === t.id; });
                if (0 <= index && index < data.length) {
                    data.splice(index, 1);
                }
            });
        }
        data.push.apply(data, __spread(transactions
            .filter(function (t) { return t.type === TransactionType.ADD; })
            .map(function (t) { return t.newValue; })));
        return data;
    };
    /**
     * Merges all changes from provided transactions into provided hierarchical data collection
     * @param data Collection to merge
     * @param transactions Transactions to merge into data
     * @param childDataKey Data key of child collections
     * @param primaryKey Primary key of the collection, if any
     * @param deleteRows Should delete rows with DELETE transaction type from data
     * @returns Provided data collections updated with all provided transactions
     */
    /**
     * Merges all changes from provided transactions into provided hierarchical data collection
     * @param {?} data Collection to merge
     * @param {?} transactions Transactions to merge into data
     * @param {?} childDataKey Data key of child collections
     * @param {?=} primaryKey Primary key of the collection, if any
     * @param {?=} deleteRows Should delete rows with DELETE transaction type from data
     * @return {?} Provided data collections updated with all provided transactions
     */
    DataUtil.mergeHierarchicalTransactions = /**
     * Merges all changes from provided transactions into provided hierarchical data collection
     * @param {?} data Collection to merge
     * @param {?} transactions Transactions to merge into data
     * @param {?} childDataKey Data key of child collections
     * @param {?=} primaryKey Primary key of the collection, if any
     * @param {?=} deleteRows Should delete rows with DELETE transaction type from data
     * @return {?} Provided data collections updated with all provided transactions
     */
    function (data, transactions, childDataKey, primaryKey, deleteRows) {
        if (deleteRows === void 0) { deleteRows = false; }
        var e_1, _a;
        var _loop_2 = function (transaction) {
            if (transaction.path) {
                /** @type {?} */
                var parent_1 = this_2.findParentFromPath(data, primaryKey, childDataKey, transaction.path);
                /** @type {?} */
                var collection = parent_1 ? parent_1[childDataKey] : data;
                switch (transaction.type) {
                    case TransactionType.ADD:
                        //  if there is no parent this is ADD row at root level
                        if (parent_1 && !parent_1[childDataKey]) {
                            parent_1[childDataKey] = collection = [];
                        }
                        collection.push(transaction.newValue);
                        break;
                    case TransactionType.UPDATE:
                        /** @type {?} */
                        var updateIndex = collection.findIndex(function (x) { return x[primaryKey] === transaction.id; });
                        if (updateIndex !== -1) {
                            collection[updateIndex] = mergeObjects(cloneValue(collection[updateIndex]), transaction.newValue);
                        }
                        break;
                    case TransactionType.DELETE:
                        if (deleteRows) {
                            /** @type {?} */
                            var deleteIndex = collection.findIndex(function (r) { return r[primaryKey] === transaction.id; });
                            if (deleteIndex !== -1) {
                                collection.splice(deleteIndex, 1);
                            }
                        }
                        break;
                }
            }
            else {
                //  if there is no path this is ADD row in root. Push the newValue to data
                data.push(transaction.newValue);
            }
        };
        var this_2 = this;
        try {
            for (var transactions_1 = __values(transactions), transactions_1_1 = transactions_1.next(); !transactions_1_1.done; transactions_1_1 = transactions_1.next()) {
                var transaction = transactions_1_1.value;
                _loop_2(transaction);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (transactions_1_1 && !transactions_1_1.done && (_a = transactions_1.return)) _a.call(transactions_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return data;
    };
    /**
     * @private
     * @param {?} data
     * @param {?} primaryKey
     * @param {?} childDataKey
     * @param {?} path
     * @return {?}
     */
    DataUtil.findParentFromPath = /**
     * @private
     * @param {?} data
     * @param {?} primaryKey
     * @param {?} childDataKey
     * @param {?} path
     * @return {?}
     */
    function (data, primaryKey, childDataKey, path) {
        var e_2, _a;
        /** @type {?} */
        var collection = data;
        /** @type {?} */
        var result;
        var _loop_3 = function (id) {
            result = collection && collection.find(function (x) { return x[primaryKey] === id; });
            if (!result) {
                return "break";
            }
            collection = result[childDataKey];
        };
        try {
            for (var path_1 = __values(path), path_1_1 = path_1.next(); !path_1_1.done; path_1_1 = path_1.next()) {
                var id = path_1_1.value;
                var state_2 = _loop_3(id);
                if (state_2 === "break")
                    break;
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (path_1_1 && !path_1_1.done && (_a = path_1.return)) _a.call(path_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return result;
    };
    return DataUtil;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var /**
 * @hidden
 */
ExportUtilities = /** @class */ (function () {
    function ExportUtilities() {
    }
    /**
     * @param {?} data
     * @return {?}
     */
    ExportUtilities.getKeysFromData = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        /** @type {?} */
        var length = data.length;
        if (length === 0) {
            return [];
        }
        /** @type {?} */
        var dataEntry = data[0];
        /** @type {?} */
        var dataEntryMiddle = data[Math.floor(length / 2)];
        /** @type {?} */
        var dataEntryLast = data[length - 1];
        /** @type {?} */
        var keys1 = Object.keys(dataEntry);
        /** @type {?} */
        var keys2 = Object.keys(dataEntryMiddle);
        /** @type {?} */
        var keys3 = Object.keys(dataEntryLast);
        /** @type {?} */
        var keys = new Set(keys1.concat(keys2).concat(keys3));
        return !ExportUtilities.isSpecialData(data) ? Array.from(keys) : ['Column 1'];
    };
    /**
     * @param {?} blob
     * @param {?} fileName
     * @return {?}
     */
    ExportUtilities.saveBlobToFile = /**
     * @param {?} blob
     * @param {?} fileName
     * @return {?}
     */
    function (blob, fileName) {
        /** @type {?} */
        var a = document.createElement('a');
        if (window.navigator && window.navigator.msSaveOrOpenBlob) {
            window.navigator.msSaveOrOpenBlob(blob, fileName);
        }
        else {
            /** @type {?} */
            var url = window.URL.createObjectURL(blob);
            a.download = fileName;
            a.href = url;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }
    };
    /**
     * @param {?} s
     * @return {?}
     */
    ExportUtilities.stringToArrayBuffer = /**
     * @param {?} s
     * @return {?}
     */
    function (s) {
        /** @type {?} */
        var buf = new ArrayBuffer(s.length);
        /** @type {?} */
        var view = new Uint8Array(buf);
        for (var i = 0; i !== s.length; ++i) {
            /* tslint:disable no-bitwise */
            view[i] = s.charCodeAt(i) & 0xFF;
            /* tslint:enable no-bitwise */
        }
        return buf;
    };
    /**
     * @param {?} data
     * @return {?}
     */
    ExportUtilities.isSpecialData = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        /** @type {?} */
        var dataEntry = data[0];
        return (typeof dataEntry === 'string' ||
            typeof dataEntry === 'number' ||
            dataEntry instanceof Date);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    ExportUtilities.hasValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return value !== undefined && value !== null;
    };
    /**
     * @param {?} value
     * @return {?}
     */
    ExportUtilities.isNullOrWhitespaces = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return value === undefined || value === null || !value.trim();
    };
    return ExportUtilities;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var IgxBaseExporter = /** @class */ (function () {
    function IgxBaseExporter() {
        this.flatRecords = [];
        this._isTreeGrid = false;
        this._indexOfLastPinnedColumn = -1;
        this._sort = null;
        /**
         * This event is emitted when a row is exported.
         * ```typescript
         * this.exporterService.onRowExport.subscribe((args: IRowExportingEventArgs) => {
         * // put event handler code here
         * });
         * ```
         * \@memberof IgxBaseExporter
         */
        this.onRowExport = new EventEmitter();
        /**
         * This event is emitted when a column is exported.
         * ```typescript
         * this.exporterService.onColumnExport.subscribe((args: IColumnExportingEventArgs) => {
         * // put event handler code here
         * });
         * ```
         * \@memberof IgxBaseExporter
         */
        this.onColumnExport = new EventEmitter();
    }
    /**
     * Method for exporting IgxGrid component's data.
     * ```typescript
     * this.exporterService.export(this.igxGridForExport, this.exportOptions);
     * ```
     * @memberof IgxBaseExporter
     */
    /**
     * Method for exporting IgxGrid component's data.
     * ```typescript
     * this.exporterService.export(this.igxGridForExport, this.exportOptions);
     * ```
     * \@memberof IgxBaseExporter
     * @param {?} grid
     * @param {?} options
     * @return {?}
     */
    IgxBaseExporter.prototype.export = /**
     * Method for exporting IgxGrid component's data.
     * ```typescript
     * this.exporterService.export(this.igxGridForExport, this.exportOptions);
     * ```
     * \@memberof IgxBaseExporter
     * @param {?} grid
     * @param {?} options
     * @return {?}
     */
    function (grid, options) {
        var _this = this;
        if (options === undefined || options === null) {
            throw Error('No options provided!');
        }
        /** @type {?} */
        var columns = grid.columnList.toArray();
        this._columnList = new Array(columns.length);
        /** @type {?} */
        var hiddenColumns = [];
        /** @type {?} */
        var lastVisbleColumnIndex = -1;
        columns.forEach(function (column) {
            /** @type {?} */
            var columnHeader = column.header !== '' ? column.header : column.field;
            /** @type {?} */
            var exportColumn = !column.hidden || options.ignoreColumnsVisibility;
            /** @type {?} */
            var index = options.ignoreColumnsOrder ? column.index : column.visibleIndex;
            /** @type {?} */
            var columnInfo = {
                header: columnHeader,
                field: column.field,
                skip: !exportColumn,
                formatter: column.formatter,
                skipFormatter: false
            };
            if (index !== -1) {
                _this._columnList[index] = columnInfo;
                lastVisbleColumnIndex = Math.max(lastVisbleColumnIndex, index);
            }
            else {
                hiddenColumns.push(columnInfo);
            }
            if (column.pinned && exportColumn) {
                _this._indexOfLastPinnedColumn = index;
            }
        });
        // Append the hidden columns to the end of the list
        hiddenColumns.forEach(function (hiddenColumn) {
            _this._columnList[++lastVisbleColumnIndex] = hiddenColumn;
        });
        /** @type {?} */
        var data = this.prepareData(grid, options);
        this.exportData(data, options);
    };
    /**
     * Method for exporting any kind of array data.
     * ```typescript
     * this.exporterService.exportData(this.arrayForExport, this.exportOptions);
     * ```
     * @memberof IgxBaseExporter
     */
    /**
     * Method for exporting any kind of array data.
     * ```typescript
     * this.exporterService.exportData(this.arrayForExport, this.exportOptions);
     * ```
     * \@memberof IgxBaseExporter
     * @param {?} data
     * @param {?} options
     * @return {?}
     */
    IgxBaseExporter.prototype.exportData = /**
     * Method for exporting any kind of array data.
     * ```typescript
     * this.exporterService.exportData(this.arrayForExport, this.exportOptions);
     * ```
     * \@memberof IgxBaseExporter
     * @param {?} data
     * @param {?} options
     * @return {?}
     */
    function (data, options) {
        var _this = this;
        if (options === undefined || options === null) {
            throw Error('No options provided!');
        }
        if (!this._columnList || this._columnList.length === 0) {
            /** @type {?} */
            var keys = ExportUtilities.getKeysFromData(data);
            this._columnList = keys.map(function (k) { return ({ header: k, field: k, skip: false }); });
        }
        /** @type {?} */
        var skippedPinnedColumnsCount = 0;
        /** @type {?} */
        var columnsWithoutHeaderCount = 1;
        this._columnList.forEach(function (column, index) {
            if (!column.skip) {
                /** @type {?} */
                var columnExportArgs = {
                    header: ExportUtilities.isNullOrWhitespaces(column.header) ?
                        'Column' + columnsWithoutHeaderCount++ : column.header,
                    field: column.field,
                    columnIndex: index,
                    cancel: false,
                    skipFormatter: false
                };
                _this.onColumnExport.emit(columnExportArgs);
                column.header = columnExportArgs.header;
                column.skip = columnExportArgs.cancel;
                column.skipFormatter = columnExportArgs.skipFormatter;
                if (column.skip && index <= _this._indexOfLastPinnedColumn) {
                    skippedPinnedColumnsCount++;
                }
                if (_this._sort && _this._sort.fieldName === column.field) {
                    if (column.skip) {
                        _this._sort = null;
                    }
                    else {
                        _this._sort.fieldName = column.header;
                    }
                }
            }
        });
        this._indexOfLastPinnedColumn -= skippedPinnedColumnsCount;
        /** @type {?} */
        var dataToExport = new Array();
        /** @type {?} */
        var isSpecialData = ExportUtilities.isSpecialData(data);
        data.forEach(function (row, index) {
            _this.exportRow(dataToExport, row, index, isSpecialData);
        });
        this.exportDataImplementation(dataToExport, options);
        this.resetDefaults();
    };
    /**
     * @private
     * @param {?} data
     * @param {?} rowData
     * @param {?} index
     * @param {?} isSpecialData
     * @return {?}
     */
    IgxBaseExporter.prototype.exportRow = /**
     * @private
     * @param {?} data
     * @param {?} rowData
     * @param {?} index
     * @param {?} isSpecialData
     * @return {?}
     */
    function (data, rowData, index, isSpecialData) {
        var _this = this;
        /** @type {?} */
        var row;
        if (!isSpecialData) {
            row = this._columnList.reduce(function (a, e) {
                if (!e.skip) {
                    /** @type {?} */
                    var rawValue = _this._isTreeGrid ? rowData.data[e.field] : rowData[e.field];
                    a[e.header] = e.formatter && !e.skipFormatter ? e.formatter(rawValue) : rawValue;
                }
                return a;
            }, {});
        }
        else {
            row = this._isTreeGrid ? rowData.data : rowData;
        }
        /** @type {?} */
        var rowArgs = {
            rowData: row,
            rowIndex: index,
            cancel: false
        };
        this.onRowExport.emit(rowArgs);
        if (!rowArgs.cancel) {
            data.push({ rowData: rowArgs.rowData, originalRowData: rowData });
        }
    };
    /**
     * @private
     * @param {?} grid
     * @param {?} options
     * @return {?}
     */
    IgxBaseExporter.prototype.prepareData = /**
     * @private
     * @param {?} grid
     * @param {?} options
     * @return {?}
     */
    function (grid, options) {
        this.flatRecords = [];
        /** @type {?} */
        var rootRecords = grid.rootRecords;
        this._isTreeGrid = rootRecords !== undefined;
        if (this._isTreeGrid) {
            this.prepareHierarchicalData(rootRecords);
        }
        /** @type {?} */
        var data = this._isTreeGrid ? this.flatRecords : grid.data;
        if (grid.filteringExpressionsTree &&
            grid.filteringExpressionsTree.filteringOperands.length > 0 &&
            !options.ignoreFiltering) {
            /** @type {?} */
            var filteringState = {
                expressionsTree: grid.filteringExpressionsTree,
                logic: grid.filteringLogic
            };
            if (this._isTreeGrid) {
                this.flatRecords = [];
                rootRecords = DataUtil.treeGridFilter(rootRecords, filteringState);
                this.prepareHierarchicalData(rootRecords);
                data = this.flatRecords;
            }
            else {
                data = DataUtil.filter(data, filteringState);
            }
        }
        if (grid.sortingExpressions &&
            grid.sortingExpressions.length > 0 &&
            !options.ignoreSorting) {
            this._sort = cloneValue(grid.sortingExpressions[0]);
            if (this._isTreeGrid) {
                this.flatRecords = [];
                rootRecords = DataUtil.treeGridSort(rootRecords, grid.sortingExpressions);
                this.prepareHierarchicalData(rootRecords);
                data = this.flatRecords;
            }
            else {
                data = DataUtil.sort(data, grid.sortingExpressions);
            }
        }
        return data;
    };
    /**
     * @private
     * @param {?} records
     * @return {?}
     */
    IgxBaseExporter.prototype.prepareHierarchicalData = /**
     * @private
     * @param {?} records
     * @return {?}
     */
    function (records) {
        if (!records) {
            return;
        }
        for (var i = 0; i < records.length; i++) {
            /** @type {?} */
            var hierarchicalRecord = records[i];
            this.flatRecords.push(hierarchicalRecord);
            this.prepareHierarchicalData(hierarchicalRecord.children);
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxBaseExporter.prototype.resetDefaults = /**
     * @private
     * @return {?}
     */
    function () {
        this._columnList = [];
        this._indexOfLastPinnedColumn = -1;
        this._sort = null;
        this.flatRecords = [];
    };
    IgxBaseExporter.propDecorators = {
        onRowExport: [{ type: Output }],
        onColumnExport: [{ type: Output }]
    };
    return IgxBaseExporter;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var /**
 * @hidden
 */
CharSeparatedValueData = /** @class */ (function () {
    function CharSeparatedValueData(_data, valueDelimiter, _isTreeGridData) {
        if (_isTreeGridData === void 0) { _isTreeGridData = false; }
        this._data = _data;
        this._isTreeGridData = _isTreeGridData;
        this._headerRecord = '';
        this._dataRecords = '';
        this._eor = '\r\n';
        this._escapeCharacters = ['\r', '\n', '\r\n'];
        this._delimiterLength = 1;
        this._isSpecialData = false;
        this.setDelimiter(valueDelimiter);
    }
    /**
     * @return {?}
     */
    CharSeparatedValueData.prototype.prepareData = /**
     * @return {?}
     */
    function () {
        if (!this._data || this._data.length === 0) {
            return '';
        }
        this._data = this._data.map(function (item) { return item.rowData; });
        /** @type {?} */
        var keys = ExportUtilities.getKeysFromData(this._data);
        if (keys.length === 0) {
            return '';
        }
        this._isSpecialData = ExportUtilities.isSpecialData(this._data);
        this._escapeCharacters.push(this._delimiter);
        this._headerRecord = this.processHeaderRecord(keys, this._escapeCharacters);
        this._dataRecords = this.processDataRecords(this._data, keys, this._escapeCharacters);
        return this._headerRecord + this._dataRecords;
    };
    /**
     * @private
     * @param {?} value
     * @param {?} escapeChars
     * @return {?}
     */
    CharSeparatedValueData.prototype.processField = /**
     * @private
     * @param {?} value
     * @param {?} escapeChars
     * @return {?}
     */
    function (value, escapeChars) {
        /** @type {?} */
        var safeValue = ExportUtilities.hasValue(value) ? String(value) : '';
        if (escapeChars.some(function (v) { return safeValue.includes(v); })) {
            safeValue = "\"" + safeValue + "\"";
        }
        return safeValue + this._delimiter;
    };
    /**
     * @private
     * @param {?} keys
     * @param {?} escapeChars
     * @return {?}
     */
    CharSeparatedValueData.prototype.processHeaderRecord = /**
     * @private
     * @param {?} keys
     * @param {?} escapeChars
     * @return {?}
     */
    function (keys, escapeChars) {
        var e_1, _a;
        /** @type {?} */
        var recordData = '';
        try {
            for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
                var keyName = keys_1_1.value;
                recordData += this.processField(keyName, this._escapeCharacters);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return recordData.slice(0, -this._delimiterLength) + this._eor;
    };
    /**
     * @private
     * @param {?} record
     * @param {?} keys
     * @param {?} escapeChars
     * @return {?}
     */
    CharSeparatedValueData.prototype.processRecord = /**
     * @private
     * @param {?} record
     * @param {?} keys
     * @param {?} escapeChars
     * @return {?}
     */
    function (record, keys, escapeChars) {
        var e_2, _a;
        /** @type {?} */
        var recordData = '';
        try {
            for (var keys_2 = __values(keys), keys_2_1 = keys_2.next(); !keys_2_1.done; keys_2_1 = keys_2.next()) {
                var keyName = keys_2_1.value;
                /** @type {?} */
                var value = (record[keyName] !== undefined) ? record[keyName] : this._isSpecialData ? record : '';
                recordData += this.processField(value, this._escapeCharacters);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (keys_2_1 && !keys_2_1.done && (_a = keys_2.return)) _a.call(keys_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return recordData.slice(0, -this._delimiterLength) + this._eor;
    };
    /**
     * @private
     * @param {?} currentData
     * @param {?} keys
     * @param {?} escapeChars
     * @return {?}
     */
    CharSeparatedValueData.prototype.processDataRecords = /**
     * @private
     * @param {?} currentData
     * @param {?} keys
     * @param {?} escapeChars
     * @return {?}
     */
    function (currentData, keys, escapeChars) {
        var e_3, _a;
        /** @type {?} */
        var dataRecords = '';
        try {
            for (var currentData_1 = __values(currentData), currentData_1_1 = currentData_1.next(); !currentData_1_1.done; currentData_1_1 = currentData_1.next()) {
                var row = currentData_1_1.value;
                dataRecords += this.processRecord(row, keys, escapeChars);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (currentData_1_1 && !currentData_1_1.done && (_a = currentData_1.return)) _a.call(currentData_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return dataRecords;
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    CharSeparatedValueData.prototype.setDelimiter = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this._delimiter = value;
        this._delimiterLength = value.length;
    };
    return CharSeparatedValueData;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var  /**
 * @abstract
 */
IgxExporterOptionsBase = /** @class */ (function () {
    function IgxExporterOptionsBase(fileName, _fileExtension) {
        this._fileExtension = _fileExtension;
        /**
         * Specifies whether hidden columns should be exported.
         * ```typescript
         * let ignoreColumnsVisibility = this.exportOptions.ignoreColumnsVisibility;
         * this.exportOptions.ignoreColumnsVisibility = true;
         * ```
         * \@memberof IgxExporterOptionsBase
         */
        this.ignoreColumnsVisibility = false;
        /**
         * Specifies whether filtered out rows should be exported.
         * ```typescript
         * let ignoreFiltering = this.exportOptions.ignoreFiltering;
         * this.exportOptions.ignoreFiltering = true;
         * ```
         * \@memberof IgxExporterOptionsBase
         */
        this.ignoreFiltering = false;
        /**
         * Specifies if the exporter should ignore the current column order in the IgxGrid.
         * ```typescript
         * let ignoreColumnsOrder = this.exportOptions.ignoreColumnsOrder;
         * this.exportOptions.ignoreColumnsOrder = true;
         * ```
         * \@memberof IgxExporterOptionsBase
         */
        this.ignoreColumnsOrder = false;
        /**
         * Specifies whether the exported data should be sorted as in the provided IgxGrid.
         * ```typescript
         * let ignoreSorting = this.exportOptions.ignoreSorting;
         * this.exportOptions.ignoreSorting = true;
         * ```
         * \@memberof IgxExporterOptionsBase
         */
        this.ignoreSorting = false;
        this.setFileName(fileName);
    }
    /**
     * @private
     * @param {?} fileName
     * @return {?}
     */
    IgxExporterOptionsBase.prototype.setFileName = /**
     * @private
     * @param {?} fileName
     * @return {?}
     */
    function (fileName) {
        this._fileName = fileName + (fileName.endsWith(this._fileExtension) === false ? this._fileExtension : '');
    };
    Object.defineProperty(IgxExporterOptionsBase.prototype, "fileName", {
        /**
         * Gets the file name which will be used for the exporting operation.
         * ```typescript
         * let fileName = this.exportOptions.fileName;
         * ```
         * @memberof IgxExporterOptionsBase
         */
        get: /**
         * Gets the file name which will be used for the exporting operation.
         * ```typescript
         * let fileName = this.exportOptions.fileName;
         * ```
         * \@memberof IgxExporterOptionsBase
         * @return {?}
         */
        function () {
            return this._fileName;
        },
        /**
         * Sets the file name which will be used for the exporting operation.
         * ```typescript
         * this.exportOptions.fileName = 'exportedData01';
         * ```
         * @memberof IgxExporterOptionsBase
         */
        set: /**
         * Sets the file name which will be used for the exporting operation.
         * ```typescript
         * this.exportOptions.fileName = 'exportedData01';
         * ```
         * \@memberof IgxExporterOptionsBase
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.setFileName(value);
        },
        enumerable: true,
        configurable: true
    });
    return IgxExporterOptionsBase;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Objects of this class are used to configure the CSV exporting process.
 */
var  /**
 * Objects of this class are used to configure the CSV exporting process.
 */
IgxCsvExporterOptions = /** @class */ (function (_super) {
    __extends(IgxCsvExporterOptions, _super);
    function IgxCsvExporterOptions(fileName, fileType) {
        var _this = _super.call(this, fileName, IgxCsvExporterOptions.getExtensionFromFileType(fileType)) || this;
        _this.setFileType(fileType);
        _this.setDelimiter();
        return _this;
    }
    /**
     * @private
     * @param {?} fType
     * @return {?}
     */
    IgxCsvExporterOptions.getExtensionFromFileType = /**
     * @private
     * @param {?} fType
     * @return {?}
     */
    function (fType) {
        /** @type {?} */
        var extension = '';
        switch (fType) {
            case CsvFileTypes.CSV:
                extension = '.csv';
                break;
            case CsvFileTypes.TSV:
                extension = '.tsv';
                break;
            case CsvFileTypes.TAB:
                extension = '.tab';
                break;
            default:
                throw Error('Unsupported CSV file type!');
        }
        return extension;
    };
    Object.defineProperty(IgxCsvExporterOptions.prototype, "valueDelimiter", {
        /**
         * Gets the value delimiter which will be used for the exporting operation.
         * ```typescript
         * let delimiter = this.exportOptions.valueDelimiter;
         * ```
         * @memberof IgxCsvExporterOptions
         */
        get: /**
         * Gets the value delimiter which will be used for the exporting operation.
         * ```typescript
         * let delimiter = this.exportOptions.valueDelimiter;
         * ```
         * \@memberof IgxCsvExporterOptions
         * @return {?}
         */
        function () {
            return this._valueDelimiter;
        },
        /**
         * Sets a value delimiter which will overwrite the default delimiter of the selected export format.
         * ```typescript
         * this.exportOptions.valueDelimiter = '|';
         * ```
         * @memberof IgxCsvExporterOptions
         */
        set: /**
         * Sets a value delimiter which will overwrite the default delimiter of the selected export format.
         * ```typescript
         * this.exportOptions.valueDelimiter = '|';
         * ```
         * \@memberof IgxCsvExporterOptions
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.setDelimiter(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxCsvExporterOptions.prototype, "fileType", {
        /**
         * Gets the CSV export format.
         * ```typescript
         * let filetype = this.exportOptions.fileType;
         * ```
         * @memberof IgxCsvExporterOptions
         */
        get: /**
         * Gets the CSV export format.
         * ```typescript
         * let filetype = this.exportOptions.fileType;
         * ```
         * \@memberof IgxCsvExporterOptions
         * @return {?}
         */
        function () {
            return this._fileType;
        },
        /**
         * Sets the CSV export format.
         * ```typescript
         * this.exportOptions.fileType = CsvFileTypes.TAB;
         * ```
         * @memberof IgxCsvExporterOptions
         */
        set: /**
         * Sets the CSV export format.
         * ```typescript
         * this.exportOptions.fileType = CsvFileTypes.TAB;
         * ```
         * \@memberof IgxCsvExporterOptions
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.setFileType(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    IgxCsvExporterOptions.prototype.setFileType = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value !== undefined && value !== null && value !== this._fileType) {
            this._fileType = value;
            /** @type {?} */
            var extension = IgxCsvExporterOptions.getExtensionFromFileType(value);
            if (!this.fileName.endsWith(extension)) {
                /** @type {?} */
                var oldExt = '.' + this.fileName.split('.').pop();
                /** @type {?} */
                var newName = this.fileName.replace(oldExt, extension);
                this._fileExtension = extension;
                this.fileName = newName;
            }
        }
    };
    /**
     * @private
     * @param {?=} value
     * @return {?}
     */
    IgxCsvExporterOptions.prototype.setDelimiter = /**
     * @private
     * @param {?=} value
     * @return {?}
     */
    function (value) {
        if (value !== undefined && value !== '' && value !== null) {
            this._valueDelimiter = value;
        }
        else {
            switch (this.fileType) {
                case CsvFileTypes.CSV:
                    this._valueDelimiter = ',';
                    break;
                case CsvFileTypes.TSV:
                case CsvFileTypes.TAB:
                    this._valueDelimiter = '\t';
                    break;
            }
        }
    };
    return IgxCsvExporterOptions;
}(IgxExporterOptionsBase));
/** @enum {number} */
var CsvFileTypes = {
    /**
     * Character Separated Values, default separator is "comma", default file extension is .csv
     */
    CSV: 0,
    /**
     * Tab Separated Values, default separator is tab, default file extension is .tsv
     */
    TSV: 1,
    /**
     * Tab Separated Values, default separator is tab, default file extension is .tab
     */
    TAB: 2,
};
CsvFileTypes[CsvFileTypes.CSV] = 'CSV';
CsvFileTypes[CsvFileTypes.TSV] = 'TSV';
CsvFileTypes[CsvFileTypes.TAB] = 'TAB';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * **Ignite UI for Angular CSV Exporter Service** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/exporter_csv.html)
 *
 * The Ignite UI for Angular CSV Exporter service can export data in a Character Separated Values format from
 * both raw data (array) or from an `IgxGrid`.
 *
 * Example:
 * ```typescript
 * public localData = [
 *   { Name: "Eric Ridley", Age: "26" },
 *   { Name: "Alanis Brook", Age: "22" },
 *   { Name: "Jonathan Morris", Age: "23" }
 * ];
 *
 * constructor(private csvExportService: IgxCsvExporterService) {
 * }
 *
 * const opt: IgxCsvExporterOptions = new IgxCsvExporterOptions("FileName", CsvFileTypes.CSV);
 * this.csvExportService.exportData(this.localData, opt);
 * ```
 */
var IgxCsvExporterService = /** @class */ (function (_super) {
    __extends(IgxCsvExporterService, _super);
    function IgxCsvExporterService() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * This event is emitted when the export process finishes.
         * ```typescript
         * this.exporterService.onExportEnded.subscribe((args: ICsvExportEndedEventArgs) => {
         * // put event handler code here
         * });
         * ```
         * \@memberof IgxCsvExporterService
         */
        _this.onExportEnded = new EventEmitter();
        return _this;
    }
    /**
     * @protected
     * @param {?} data
     * @param {?} options
     * @return {?}
     */
    IgxCsvExporterService.prototype.exportDataImplementation = /**
     * @protected
     * @param {?} data
     * @param {?} options
     * @return {?}
     */
    function (data, options) {
        /** @type {?} */
        var csvData = new CharSeparatedValueData(data, options.valueDelimiter);
        this._stringData = csvData.prepareData();
        this.saveFile(options);
        this.onExportEnded.emit({ csvData: this._stringData });
    };
    /**
     * @private
     * @param {?} options
     * @return {?}
     */
    IgxCsvExporterService.prototype.saveFile = /**
     * @private
     * @param {?} options
     * @return {?}
     */
    function (options) {
        switch (options.fileType) {
            case CsvFileTypes.CSV:
                this.exportFile(this._stringData, options.fileName, 'text/csv;charset=utf-8;');
                break;
            case CsvFileTypes.TSV:
            case CsvFileTypes.TAB:
                this.exportFile(this._stringData, options.fileName, 'text/tab-separated-values;charset=utf-8;');
                break;
        }
    };
    /**
     * @private
     * @param {?} data
     * @param {?} fileName
     * @param {?} fileType
     * @return {?}
     */
    IgxCsvExporterService.prototype.exportFile = /**
     * @private
     * @param {?} data
     * @param {?} fileName
     * @param {?} fileType
     * @return {?}
     */
    function (data, fileName, fileType) {
        /** @type {?} */
        var blob = new Blob(['\ufeff', data], { type: fileType });
        ExportUtilities.saveBlobToFile(blob, fileName);
    };
    IgxCsvExporterService.decorators = [
        { type: Injectable }
    ];
    IgxCsvExporterService.propDecorators = {
        onExportEnded: [{ type: Output }]
    };
    return IgxCsvExporterService;
}(IgxBaseExporter));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
var ExcelFolderTypes = {
    RootExcelFolder: 0,
    RootRelsExcelFolder: 1,
    DocPropsExcelFolder: 2,
    XLExcelFolder: 3,
    XLRelsExcelFolder: 4,
    ThemeExcelFolder: 5,
    WorksheetsExcelFolder: 6,
    WorksheetsRelsExcelFolder: 7,
    TablesExcelFolder: 8,
};
ExcelFolderTypes[ExcelFolderTypes.RootExcelFolder] = 'RootExcelFolder';
ExcelFolderTypes[ExcelFolderTypes.RootRelsExcelFolder] = 'RootRelsExcelFolder';
ExcelFolderTypes[ExcelFolderTypes.DocPropsExcelFolder] = 'DocPropsExcelFolder';
ExcelFolderTypes[ExcelFolderTypes.XLExcelFolder] = 'XLExcelFolder';
ExcelFolderTypes[ExcelFolderTypes.XLRelsExcelFolder] = 'XLRelsExcelFolder';
ExcelFolderTypes[ExcelFolderTypes.ThemeExcelFolder] = 'ThemeExcelFolder';
ExcelFolderTypes[ExcelFolderTypes.WorksheetsExcelFolder] = 'WorksheetsExcelFolder';
ExcelFolderTypes[ExcelFolderTypes.WorksheetsRelsExcelFolder] = 'WorksheetsRelsExcelFolder';
ExcelFolderTypes[ExcelFolderTypes.TablesExcelFolder] = 'TablesExcelFolder';
/** @enum {number} */
var ExcelFileTypes = {
    RootRelsFile: 0,
    AppFile: 1,
    CoreFile: 2,
    WorkbookRelsFile: 3,
    ThemeFile: 4,
    WorksheetFile: 5,
    StyleFile: 6,
    WorkbookFile: 7,
    ContentTypesFile: 8,
    SharedStringsFile: 9,
    WorksheetRelsFile: 10,
    TablesFile: 11,
};
ExcelFileTypes[ExcelFileTypes.RootRelsFile] = 'RootRelsFile';
ExcelFileTypes[ExcelFileTypes.AppFile] = 'AppFile';
ExcelFileTypes[ExcelFileTypes.CoreFile] = 'CoreFile';
ExcelFileTypes[ExcelFileTypes.WorkbookRelsFile] = 'WorkbookRelsFile';
ExcelFileTypes[ExcelFileTypes.ThemeFile] = 'ThemeFile';
ExcelFileTypes[ExcelFileTypes.WorksheetFile] = 'WorksheetFile';
ExcelFileTypes[ExcelFileTypes.StyleFile] = 'StyleFile';
ExcelFileTypes[ExcelFileTypes.WorkbookFile] = 'WorkbookFile';
ExcelFileTypes[ExcelFileTypes.ContentTypesFile] = 'ContentTypesFile';
ExcelFileTypes[ExcelFileTypes.SharedStringsFile] = 'SharedStringsFile';
ExcelFileTypes[ExcelFileTypes.WorksheetRelsFile] = 'WorksheetRelsFile';
ExcelFileTypes[ExcelFileTypes.TablesFile] = 'TablesFile';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var ExcelStrings = /** @class */ (function () {
    function ExcelStrings() {
    }
    /**
     * @return {?}
     */
    ExcelStrings.getRels = /**
     * @return {?}
     */
    function () {
        return ExcelStrings.XML_STRING + '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/></Relationships>';
    };
    /**
     * @return {?}
     */
    ExcelStrings.getApp = /**
     * @return {?}
     */
    function () {
        return ExcelStrings.XML_STRING + '<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties" xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"><Application>Microsoft Excel</Application><DocSecurity>0</DocSecurity><ScaleCrop>false</ScaleCrop><HeadingPairs><vt:vector size="2" baseType="variant"><vt:variant><vt:lpstr>Worksheets</vt:lpstr></vt:variant><vt:variant><vt:i4>1</vt:i4></vt:variant></vt:vector></HeadingPairs><TitlesOfParts><vt:vector size="1" baseType="lpstr"><vt:lpstr>Sheet1</vt:lpstr></vt:vector></TitlesOfParts><Company></Company><LinksUpToDate>false</LinksUpToDate><SharedDoc>false</SharedDoc><HyperlinksChanged>false</HyperlinksChanged><AppVersion>16.0300</AppVersion></Properties>';
    };
    /**
     * @return {?}
     */
    ExcelStrings.getCore = /**
     * @return {?}
     */
    function () {
        return ExcelStrings.XML_STRING + '<cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:dcmitype="http://purl.org/dc/dcmitype/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><dc:creator></dc:creator><cp:lastModifiedBy></cp:lastModifiedBy><dcterms:created xsi:type="dcterms:W3CDTF">2015-06-05T18:17:20Z</dcterms:created><dcterms:modified xsi:type="dcterms:W3CDTF">2015-06-05T18:17:26Z</dcterms:modified></cp:coreProperties>';
    };
    /**
     * @return {?}
     */
    ExcelStrings.getTheme = /**
     * @return {?}
     */
    function () {
        return ExcelStrings.XML_STRING + '<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"><a:themeElements><a:clrScheme name="Office"><a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1><a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1><a:dk2><a:srgbClr val="44546A"/></a:dk2><a:lt2><a:srgbClr val="E7E6E6"/></a:lt2><a:accent1><a:srgbClr val="5B9BD5"/></a:accent1><a:accent2><a:srgbClr val="ED7D31"/></a:accent2><a:accent3><a:srgbClr val="A5A5A5"/></a:accent3><a:accent4><a:srgbClr val="FFC000"/></a:accent4><a:accent5><a:srgbClr val="4472C4"/></a:accent5><a:accent6><a:srgbClr val="70AD47"/></a:accent6><a:hlink><a:srgbClr val="0563C1"/></a:hlink><a:folHlink><a:srgbClr val="954F72"/></a:folHlink></a:clrScheme><a:fontScheme name="Office"><a:majorFont><a:latin typeface="Calibri Light" panose="020F0302020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="æ¸¸ã´ã·ãã¯ Light"/><a:font script="Hang" typeface="ë§ì ê³ ë"/><a:font script="Hans" typeface="ç­çº¿ Light"/><a:font script="Hant" typeface="æ°ç´°æé«"/><a:font script="Arab" typeface="Times New Roman"/><a:font script="Hebr" typeface="Times New Roman"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="MoolBoran"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Times New Roman"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/></a:majorFont><a:minorFont><a:latin typeface="Calibri" panose="020F0502020204030204"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="æ¸¸ã´ã·ãã¯"/><a:font script="Hang" typeface="ë§ì ê³ ë"/><a:font script="Hans" typeface="ç­çº¿"/><a:font script="Hant" typeface="æ°ç´°æé«"/><a:font script="Arab" typeface="Arial"/><a:font script="Hebr" typeface="Arial"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="DaunPenh"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Arial"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/></a:minorFont></a:fontScheme><a:fmtScheme name="Office"><a:fillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:lumMod val="110000"/><a:satMod val="105000"/><a:tint val="67000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="103000"/><a:tint val="73000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="105000"/><a:satMod val="109000"/><a:tint val="81000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:satMod val="103000"/><a:lumMod val="102000"/><a:tint val="94000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:satMod val="110000"/><a:lumMod val="100000"/><a:shade val="100000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:lumMod val="99000"/><a:satMod val="120000"/><a:shade val="78000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:fillStyleLst><a:lnStyleLst><a:ln w="6350" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="12700" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln><a:ln w="19050" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/><a:miter lim="800000"/></a:ln></a:lnStyleLst><a:effectStyleLst><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst/></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="57150" dist="19050" dir="5400000" algn="ctr" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="63000"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle></a:effectStyleLst><a:bgFillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:solidFill><a:schemeClr val="phClr"><a:tint val="95000"/><a:satMod val="170000"/></a:schemeClr></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="93000"/><a:satMod val="150000"/><a:shade val="98000"/><a:lumMod val="102000"/></a:schemeClr></a:gs><a:gs pos="50000"><a:schemeClr val="phClr"><a:tint val="98000"/><a:satMod val="130000"/><a:shade val="90000"/><a:lumMod val="103000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="63000"/><a:satMod val="120000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="5400000" scaled="0"/></a:gradFill></a:bgFillStyleLst></a:fmtScheme></a:themeElements><a:objectDefaults/><a:extraClrSchemeLst/><a:extLst><a:ext uri="{05A4C25C-085E-4340-85A3-A5531E510DB2}"><thm15:themeFamily xmlns:thm15="http://schemas.microsoft.com/office/thememl/2012/main" name="Office Theme" id="{62F939B6-93AF-4DB8-9C6B-D6C7DFDC589F}" vid="{4A3C46E8-61CC-4603-A589-7422A47A8E4A}"/></a:ext></a:extLst></a:theme>';
    };
    /**
     * @param {?} hasNonStringValues
     * @return {?}
     */
    ExcelStrings.getStyles = /**
     * @param {?} hasNonStringValues
     * @return {?}
     */
    function (hasNonStringValues) {
        /** @type {?} */
        var additionalCellXF = '<xf numFmtId="0" fontId="0" fillId="0" borderId="0" xfId="0" applyNumberFormat="1"/>';
        /** @type {?} */
        var cellXFCount = hasNonStringValues ? 2 : 1;
        return ExcelStrings.XML_STRING + '<styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac x16r2" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" xmlns:x16r2="http://schemas.microsoft.com/office/spreadsheetml/2015/02/main"><fonts count="1" x14ac:knownFonts="1"><font><sz val="11"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font></fonts><fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills><borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders><cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs><cellXfs count="' + cellXFCount + '"><xf numFmtId="0" fontId="0" fillId="0" borderId="0" xfId="0"/>' + additionalCellXF + '</cellXfs><cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles><dxfs count="0"/><tableStyles count="0" defaultTableStyle="TableStyleMedium2" defaultPivotStyle="PivotStyleLight16"/><extLst><ext uri="{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}" xmlns:x14="http://schemas.microsoft.com/office/spreadsheetml/2009/9/main"><x14:slicerStyles defaultSlicerStyle="SlicerStyleLight1"/></ext><ext uri="{9260A510-F301-46a8-8635-F512D64BE5F5}" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><x15:timelineStyles defaultTimelineStyle="TimeSlicerStyleLight1"/></ext></extLst></styleSheet>';
    };
    /**
     * @return {?}
     */
    ExcelStrings.getWorkbook = /**
     * @return {?}
     */
    function () {
        return ExcelStrings.XML_STRING + '<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x15" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><fileVersion appName="xl" lastEdited="6" lowestEdited="6" rupBuild="14420"/><workbookPr filterPrivacy="1" defaultThemeVersion="164011"/><bookViews><workbookView xWindow="0" yWindow="0" windowWidth="22260" windowHeight="12645"/></bookViews><sheets><sheet name="Sheet1" sheetId="1" r:id="rId1"/></sheets><calcPr calcId="162913"/><extLst><ext uri="{140A7094-0E35-4892-8432-C4D2E57EDEB5}" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"><x15:workbookPr chartTrackingRefBase="1"/></ext></extLst></workbook>';
    };
    /**
     * @return {?}
     */
    ExcelStrings.getWorksheetRels = /**
     * @return {?}
     */
    function () {
        return ExcelStrings.XML_STRING + "<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\"><Relationship Id=\"rId1\" Type=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships/table\" Target=\"../tables/table1.xml\"/></Relationships>";
    };
    /**
     * @param {?} hasSharedStrings
     * @return {?}
     */
    ExcelStrings.getWorkbookRels = /**
     * @param {?} hasSharedStrings
     * @return {?}
     */
    function (hasSharedStrings) {
        /** @type {?} */
        var retVal = ExcelStrings.XML_STRING + '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme" Target="theme/theme1.xml"/><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet1.xml"/>';
        if (hasSharedStrings) {
            retVal += ExcelStrings.SHARED_STRING_RELATIONSHIP;
        }
        retVal += '</Relationships>';
        return retVal;
    };
    /**
     * @param {?} dimension
     * @param {?} freezePane
     * @param {?} cols
     * @param {?} sheetData
     * @param {?} hasTable
     * @param {?=} hasGroupedRows
     * @param {?=} outlineLevel
     * @return {?}
     */
    ExcelStrings.getSheetXML = /**
     * @param {?} dimension
     * @param {?} freezePane
     * @param {?} cols
     * @param {?} sheetData
     * @param {?} hasTable
     * @param {?=} hasGroupedRows
     * @param {?=} outlineLevel
     * @return {?}
     */
    function (dimension, freezePane, cols, sheetData, hasTable, hasGroupedRows, outlineLevel) {
        if (hasGroupedRows === void 0) { hasGroupedRows = false; }
        if (outlineLevel === void 0) { outlineLevel = 0; }
        /** @type {?} */
        var tableParts = hasTable ? '<tableParts count="1"><tablePart r:id="rId1"/></tableParts>' : '';
        /** @type {?} */
        var sheetOutlineProp = hasGroupedRows ? '<sheetPr><outlinePr summaryBelow="0"/></sheetPr>' : '';
        /** @type {?} */
        var sOutlineLevel = outlineLevel > 0 ? "outlineLevelRow=\"" + outlineLevel + "\"" : '';
        // return ExcelStrings.XML_STRING +
        //     '<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac"><dimension ref="' + dimension + '"/><sheetViews><sheetView tabSelected="1" workbookViewId="0">' + freezePane + '</sheetView></sheetViews><sheetFormatPr defaultRowHeight="15" x14ac:dyDescent="0.25"/>' + cols + sheetData + '<pageMargins left="0.7" right="0.7" top="0.75" bottom="0.75" header="0.3" footer="0.3"/>' + tableParts + '</worksheet>';
        return ExcelStrings.XML_STRING + "\n<worksheet xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" xmlns:r=\"http://schemas.openxmlformats.org/officeDocument/2006/relationships\" xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\" mc:Ignorable=\"x14ac\" xmlns:x14ac=\"http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac\">\n" + sheetOutlineProp + "\n<dimension ref=\"" + dimension + "\"/>\n<sheetViews><sheetView tabSelected=\"1\" workbookViewId=\"0\">" + freezePane + "</sheetView></sheetViews>\n<sheetFormatPr defaultRowHeight=\"15\" " + sOutlineLevel + " x14ac:dyDescent=\"0.25\"/>\n" + cols + "\n" + sheetData + "\n<pageMargins left=\"0.7\" right=\"0.7\" top=\"0.75\" bottom=\"0.75\" header=\"0.3\" footer=\"0.3\"/>\n" + tableParts + "</worksheet>";
    };
    /**
     * @param {?} count
     * @param {?} uniqueCount
     * @param {?} table
     * @return {?}
     */
    ExcelStrings.getSharedStringXML = /**
     * @param {?} count
     * @param {?} uniqueCount
     * @param {?} table
     * @return {?}
     */
    function (count, uniqueCount, table) {
        return ExcelStrings.XML_STRING + '<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="' + count + '" uniqueCount="' + uniqueCount + '">' + table + '</sst>';
    };
    /**
     * @param {?} hasSharedStrings
     * @param {?} hasTable
     * @return {?}
     */
    ExcelStrings.getContentTypesXML = /**
     * @param {?} hasSharedStrings
     * @param {?} hasTable
     * @return {?}
     */
    function (hasSharedStrings, hasTable) {
        /** @type {?} */
        var contentTypes = ExcelStrings.XML_STRING +
            "<Types xmlns=\"http://schemas.openxmlformats.org/package/2006/content-types\">\n            <Default Extension=\"rels\" ContentType=\"application/vnd.openxmlformats-package.relationships+xml\"/>\n            <Default Extension=\"xml\" ContentType=\"application/xml\"/>\n            <Override PartName=\"/xl/workbook.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml\"/>\n            <Override PartName=\"/xl/worksheets/sheet1.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml\"/>\n            <Override PartName=\"/xl/theme/theme1.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.theme+xml\"/>\n            <Override PartName=\"/xl/styles.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml\"/>\n            <Override PartName=\"/docProps/core.xml\" ContentType=\"application/vnd.openxmlformats-package.core-properties+xml\"/>\n            <Override PartName=\"/docProps/app.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.extended-properties+xml\"/>";
        contentTypes += hasSharedStrings ?
            "\t<Override PartName=\"/xl/sharedStrings.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml\"/>" : '';
        contentTypes += hasTable ?
            "<Override PartName=\"/xl/tables/table1.xml\" ContentType=\"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml\"/>" : '';
        contentTypes += "</Types>";
        return contentTypes;
    };
    /**
     * @param {?} dimension
     * @param {?} tableColumns
     * @param {?} sort
     * @return {?}
     */
    ExcelStrings.getTablesXML = /**
     * @param {?} dimension
     * @param {?} tableColumns
     * @param {?} sort
     * @return {?}
     */
    function (dimension, tableColumns, sort) {
        return ExcelStrings.XML_STRING + "<table xmlns=\"http://schemas.openxmlformats.org/spreadsheetml/2006/main\" id=\"1\" name=\"Table1\" displayName=\"Table1\" ref=\"" + dimension + "\" totalsRowShown=\"0\">\n    <autoFilter ref=\"" + dimension + "\"/>" + sort + tableColumns + "<tableStyleInfo name=\"TableStyleMedium2\" showFirstColumn=\"0\" showLastColumn=\"0\" showRowStripes=\"1\" showColumnStripes=\"0\"/>\n</table>";
    };
    /* tslint:enable max-line-length */
    /* tslint:enable max-line-length */
    /**
     * @param {?} index
     * @return {?}
     */
    ExcelStrings.getExcelColumn = /* tslint:enable max-line-length */
    /**
     * @param {?} index
     * @return {?}
     */
    function (index) {
        // Returns the excel column name for given 0-based index
        // For example 27 should return "AB"
        /** @type {?} */
        var returnString = '';
        while (index >= 0) {
            /** @type {?} */
            var char = index % 26;
            returnString = String.fromCharCode(65 + char) + returnString;
            index = Math.floor(index / 26) - 1;
        }
        return returnString;
    };
    /* tslint:disable max-line-length */
    ExcelStrings.XML_STRING = '<?xml version="1.0" encoding="UTF-8"?>\r\n';
    ExcelStrings.SHARED_STRING_RELATIONSHIP = '<Relationship Id="rId4" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings" Target="sharedStrings.xml" />';
    return ExcelStrings;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var /**
 * @hidden
 */
RootRelsFile = /** @class */ (function () {
    function RootRelsFile() {
    }
    /**
     * @param {?} folder
     * @param {?} worksheetData
     * @return {?}
     */
    RootRelsFile.prototype.writeElement = /**
     * @param {?} folder
     * @param {?} worksheetData
     * @return {?}
     */
    function (folder, worksheetData) {
        folder.file('.rels', ExcelStrings.getRels());
    };
    return RootRelsFile;
}());
/**
 * @hidden
 */
var /**
 * @hidden
 */
AppFile = /** @class */ (function () {
    function AppFile() {
    }
    /**
     * @param {?} folder
     * @param {?} worksheetData
     * @return {?}
     */
    AppFile.prototype.writeElement = /**
     * @param {?} folder
     * @param {?} worksheetData
     * @return {?}
     */
    function (folder, worksheetData) {
        folder.file('app.xml', ExcelStrings.getApp());
    };
    return AppFile;
}());
/**
 * @hidden
 */
var /**
 * @hidden
 */
CoreFile = /** @class */ (function () {
    function CoreFile() {
    }
    /**
     * @param {?} folder
     * @param {?} worksheetData
     * @return {?}
     */
    CoreFile.prototype.writeElement = /**
     * @param {?} folder
     * @param {?} worksheetData
     * @return {?}
     */
    function (folder, worksheetData) {
        folder.file('core.xml', ExcelStrings.getCore());
    };
    return CoreFile;
}());
/**
 * @hidden
 */
var /**
 * @hidden
 */
WorkbookRelsFile = /** @class */ (function () {
    function WorkbookRelsFile() {
    }
    /**
     * @param {?} folder
     * @param {?} worksheetData
     * @return {?}
     */
    WorkbookRelsFile.prototype.writeElement = /**
     * @param {?} folder
     * @param {?} worksheetData
     * @return {?}
     */
    function (folder, worksheetData) {
        /** @type {?} */
        var hasSharedStrings = worksheetData.isEmpty === false;
        folder.file('workbook.xml.rels', ExcelStrings.getWorkbookRels(hasSharedStrings));
    };
    return WorkbookRelsFile;
}());
/**
 * @hidden
 */
var /**
 * @hidden
 */
ThemeFile = /** @class */ (function () {
    function ThemeFile() {
    }
    /**
     * @param {?} folder
     * @param {?} worksheetData
     * @return {?}
     */
    ThemeFile.prototype.writeElement = /**
     * @param {?} folder
     * @param {?} worksheetData
     * @return {?}
     */
    function (folder, worksheetData) {
        folder.file('theme1.xml', ExcelStrings.getTheme());
    };
    return ThemeFile;
}());
/**
 * @hidden
 */
var WorksheetFile = /** @class */ (function () {
    function WorksheetFile() {
    }
    /**
     * @param {?} folder
     * @param {?} worksheetData
     * @return {?}
     */
    WorksheetFile.prototype.writeElement = /**
     * @param {?} folder
     * @param {?} worksheetData
     * @return {?}
     */
    function (folder, worksheetData) {
        /** @type {?} */
        var sheetData = [];
        /** @type {?} */
        var cols = [];
        /** @type {?} */
        var dimension;
        /** @type {?} */
        var dictionary = worksheetData.dataDictionary;
        /** @type {?} */
        var freezePane = '';
        /** @type {?} */
        var maxOutlineLevel = 0;
        if (worksheetData.isEmpty) {
            sheetData.push('<sheetData/>');
            dimension = 'A1';
        }
        else {
            sheetData.push('<sheetData>');
            /** @type {?} */
            var height = worksheetData.options.rowHeight;
            /** @type {?} */
            var rowHeight = height ? ' ht="' + height + '" customHeight="1"' : '';
            sheetData.push("<row r=\"1\"" + rowHeight + ">");
            for (var i = 0; i < worksheetData.columnCount; i++) {
                /** @type {?} */
                var column = ExcelStrings.getExcelColumn(i) + 1;
                /** @type {?} */
                var value = dictionary.saveValue(worksheetData.keys[i], i, true);
                sheetData.push("<c r=\"" + column + "\" t=\"s\"><v>" + value + "</v></c>");
            }
            sheetData.push('</row>');
            for (var i = 1; i < worksheetData.rowCount; i++) {
                if (!worksheetData.isTreeGridData) {
                    sheetData.push("<row r=\"" + (i + 1) + "\"" + rowHeight + ">");
                }
                else {
                    /** @type {?} */
                    var rowData = worksheetData.data[i - 1].originalRowData;
                    /** @type {?} */
                    var sCollapsed = (!rowData.expanded) ? '' : (rowData.expanded === true) ? '' : " collapsed=\"1\"";
                    /** @type {?} */
                    var sHidden = (rowData.parent && this.hasCollapsedParent(rowData)) ? " hidden=\"1\"" : '';
                    /** @type {?} */
                    var rowOutlineLevel = rowData.level ? rowData.level : 0;
                    /** @type {?} */
                    var sOutlineLevel = rowOutlineLevel > 0 ? " outlineLevel=\"" + rowOutlineLevel + "\"" : '';
                    maxOutlineLevel = maxOutlineLevel < rowOutlineLevel ? rowOutlineLevel : maxOutlineLevel;
                    sheetData.push("<row r=\"" + (i + 1) + "\"" + rowHeight + sOutlineLevel + sCollapsed + sHidden + ">");
                }
                for (var j = 0; j < worksheetData.columnCount; j++) {
                    /** @type {?} */
                    var cellData = WorksheetFile.getCellData(worksheetData, i, j);
                    sheetData.push(cellData);
                }
                sheetData.push('</row>');
            }
            sheetData.push('</sheetData>');
            dimension = 'A1:' + ExcelStrings.getExcelColumn(worksheetData.columnCount - 1) + worksheetData.rowCount;
            cols.push('<cols>');
            for (var i = 0; i < worksheetData.columnCount; i++) {
                /** @type {?} */
                var width = dictionary.columnWidths[i];
                // Use the width provided in the options if it exists
                /** @type {?} */
                var widthInTwips = worksheetData.options.columnWidth ?
                    worksheetData.options.columnWidth :
                    Math.max(((width / 96) * 14.4), WorksheetFile.MIN_WIDTH);
                cols.push("<col min=\"" + (i + 1) + "\" max=\"" + (i + 1) + "\" width=\"" + widthInTwips + "\" customWidth=\"1\"/>");
            }
            cols.push('</cols>');
            if (worksheetData.indexOfLastPinnedColumn !== -1 &&
                !worksheetData.options.ignorePinning &&
                !worksheetData.options.ignoreColumnsOrder) {
                /** @type {?} */
                var frozenColumnCount = worksheetData.indexOfLastPinnedColumn + 1;
                /** @type {?} */
                var firstCell = ExcelStrings.getExcelColumn(frozenColumnCount) + '1';
                freezePane = "<pane xSplit=\"" + frozenColumnCount + "\" topLeftCell=\"" + firstCell + "\" activePane=\"topRight\" state=\"frozen\"/>";
            }
        }
        /** @type {?} */
        var hasTable = !worksheetData.isEmpty && worksheetData.options.exportAsTable;
        folder.file('sheet1.xml', ExcelStrings.getSheetXML(dimension, freezePane, cols.join(''), sheetData.join(''), hasTable, worksheetData.isTreeGridData, maxOutlineLevel));
    };
    /**
     * @private
     * @param {?} rowData
     * @return {?}
     */
    WorksheetFile.prototype.hasCollapsedParent = /**
     * @private
     * @param {?} rowData
     * @return {?}
     */
    function (rowData) {
        /** @type {?} */
        var result = !rowData.parent.expanded;
        while (rowData.parent) {
            result = result || !rowData.parent.expanded;
            rowData = rowData.parent;
        }
        return result;
    };
    /* tslint:disable member-ordering */
    /* tslint:disable member-ordering */
    /**
     * @private
     * @param {?} worksheetData
     * @param {?} row
     * @param {?} column
     * @return {?}
     */
    WorksheetFile.getCellData = /* tslint:disable member-ordering */
    /**
     * @private
     * @param {?} worksheetData
     * @param {?} row
     * @param {?} column
     * @return {?}
     */
    function (worksheetData, row, column) {
        /** @type {?} */
        var dictionary = worksheetData.dataDictionary;
        /** @type {?} */
        var columnName = ExcelStrings.getExcelColumn(column) + (row + 1);
        /** @type {?} */
        var columnHeader = worksheetData.keys[column];
        /** @type {?} */
        var rowData = worksheetData.data[row - 1].rowData;
        /** @type {?} */
        var cellValue = worksheetData.isSpecialData ? rowData : rowData[columnHeader];
        if (cellValue === undefined || cellValue === null) {
            return "<c r=\"" + columnName + "\" s=\"1\"/>";
        }
        else {
            /** @type {?} */
            var savedValue = dictionary.saveValue(cellValue, column, false);
            /** @type {?} */
            var isSavedAsString = savedValue !== -1;
            /** @type {?} */
            var value = isSavedAsString ? savedValue : cellValue;
            /** @type {?} */
            var type = isSavedAsString ? " t=\"s\"" : '';
            /** @type {?} */
            var format = isSavedAsString ? '' : " s=\"1\"";
            return "<c r=\"" + columnName + "\"" + type + format + "><v>" + value + "</v></c>";
        }
    };
    WorksheetFile.MIN_WIDTH = 8.34;
    return WorksheetFile;
}());
/**
 * @hidden
 */
var /**
 * @hidden
 */
StyleFile = /** @class */ (function () {
    function StyleFile() {
    }
    /**
     * @param {?} folder
     * @param {?} worksheetData
     * @return {?}
     */
    StyleFile.prototype.writeElement = /**
     * @param {?} folder
     * @param {?} worksheetData
     * @return {?}
     */
    function (folder, worksheetData) {
        folder.file('styles.xml', ExcelStrings.getStyles(worksheetData.dataDictionary && worksheetData.dataDictionary.hasNonStringValues));
    };
    return StyleFile;
}());
/**
 * @hidden
 */
var /**
 * @hidden
 */
WorkbookFile = /** @class */ (function () {
    function WorkbookFile() {
    }
    /**
     * @param {?} folder
     * @param {?} worksheetData
     * @return {?}
     */
    WorkbookFile.prototype.writeElement = /**
     * @param {?} folder
     * @param {?} worksheetData
     * @return {?}
     */
    function (folder, worksheetData) {
        folder.file('workbook.xml', ExcelStrings.getWorkbook());
    };
    return WorkbookFile;
}());
/**
 * @hidden
 */
var /**
 * @hidden
 */
ContentTypesFile = /** @class */ (function () {
    function ContentTypesFile() {
    }
    /**
     * @param {?} folder
     * @param {?} worksheetData
     * @return {?}
     */
    ContentTypesFile.prototype.writeElement = /**
     * @param {?} folder
     * @param {?} worksheetData
     * @return {?}
     */
    function (folder, worksheetData) {
        folder.file('[Content_Types].xml', ExcelStrings.getContentTypesXML(!worksheetData.isEmpty, worksheetData.options.exportAsTable));
    };
    return ContentTypesFile;
}());
/**
 * @hidden
 */
var /**
 * @hidden
 */
SharedStringsFile = /** @class */ (function () {
    function SharedStringsFile() {
    }
    /**
     * @param {?} folder
     * @param {?} worksheetData
     * @return {?}
     */
    SharedStringsFile.prototype.writeElement = /**
     * @param {?} folder
     * @param {?} worksheetData
     * @return {?}
     */
    function (folder, worksheetData) {
        var e_1, _a;
        /** @type {?} */
        var dict = worksheetData.dataDictionary;
        /** @type {?} */
        var sortedValues = dict.getKeys();
        /** @type {?} */
        var sharedStrings = new Array(sortedValues.length);
        try {
            for (var sortedValues_1 = __values(sortedValues), sortedValues_1_1 = sortedValues_1.next(); !sortedValues_1_1.done; sortedValues_1_1 = sortedValues_1.next()) {
                var value = sortedValues_1_1.value;
                sharedStrings[dict.getSanitizedValue(value)] = '<si><t>' + value + '</t></si>';
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (sortedValues_1_1 && !sortedValues_1_1.done && (_a = sortedValues_1.return)) _a.call(sortedValues_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        folder.file('sharedStrings.xml', ExcelStrings.getSharedStringXML(dict.stringsCount, sortedValues.length, sharedStrings.join('')));
    };
    return SharedStringsFile;
}());
/**
 * @hidden
 */
var /**
 * @hidden
 */
TablesFile = /** @class */ (function () {
    function TablesFile() {
    }
    /**
     * @param {?} folder
     * @param {?} worksheetData
     * @return {?}
     */
    TablesFile.prototype.writeElement = /**
     * @param {?} folder
     * @param {?} worksheetData
     * @return {?}
     */
    function (folder, worksheetData) {
        /** @type {?} */
        var columnCount = worksheetData.columnCount;
        /** @type {?} */
        var lastColumn = ExcelStrings.getExcelColumn(columnCount - 1) + worksheetData.rowCount;
        /** @type {?} */
        var dimension = 'A1:' + lastColumn;
        /** @type {?} */
        var values = worksheetData.keys;
        /** @type {?} */
        var sortString = '';
        /** @type {?} */
        var tableColumns = '<tableColumns count="' + columnCount + '">';
        for (var i = 0; i < columnCount; i++) {
            /** @type {?} */
            var value = values[i];
            tableColumns += '<tableColumn id="' + (i + 1) + '" name="' + value + '"/>';
        }
        tableColumns += '</tableColumns>';
        if (worksheetData.sort) {
            /** @type {?} */
            var sortingExpression = worksheetData.sort;
            /** @type {?} */
            var sc = ExcelStrings.getExcelColumn(values.indexOf(sortingExpression.fieldName));
            /** @type {?} */
            var dir = sortingExpression.dir - 1;
            sortString = "<sortState ref=\"A2:" + lastColumn + "\"><sortCondition descending=\"" + dir + "\" ref=\"" + sc + "1:" + sc + "15\"/></sortState>";
        }
        folder.file('table1.xml', ExcelStrings.getTablesXML(dimension, tableColumns, sortString));
    };
    return TablesFile;
}());
/**
 * @hidden
 */
var /**
 * @hidden
 */
WorksheetRelsFile = /** @class */ (function () {
    function WorksheetRelsFile() {
    }
    /**
     * @param {?} folder
     * @param {?} worksheetData
     * @return {?}
     */
    WorksheetRelsFile.prototype.writeElement = /**
     * @param {?} folder
     * @param {?} worksheetData
     * @return {?}
     */
    function (folder, worksheetData) {
        folder.file('sheet1.xml.rels', ExcelStrings.getWorksheetRels());
    };
    return WorksheetRelsFile;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var /**
 * @hidden
 */
RootExcelFolder = /** @class */ (function () {
    function RootExcelFolder() {
    }
    Object.defineProperty(RootExcelFolder.prototype, "folderName", {
        get: /**
         * @return {?}
         */
        function () {
            return '';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} data
     * @return {?}
     */
    RootExcelFolder.prototype.childFiles = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        return [ExcelFileTypes.ContentTypesFile];
    };
    /**
     * @param {?} data
     * @return {?}
     */
    RootExcelFolder.prototype.childFolders = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        return [
            ExcelFolderTypes.RootRelsExcelFolder,
            ExcelFolderTypes.DocPropsExcelFolder,
            ExcelFolderTypes.XLExcelFolder
        ];
    };
    return RootExcelFolder;
}());
/**
 * @hidden
 */
var /**
 * @hidden
 */
RootRelsExcelFolder = /** @class */ (function () {
    function RootRelsExcelFolder() {
    }
    Object.defineProperty(RootRelsExcelFolder.prototype, "folderName", {
        get: /**
         * @return {?}
         */
        function () {
            return '_rels';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} data
     * @return {?}
     */
    RootRelsExcelFolder.prototype.childFiles = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        return [ExcelFileTypes.RootRelsFile];
    };
    /**
     * @param {?} data
     * @return {?}
     */
    RootRelsExcelFolder.prototype.childFolders = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        return [];
    };
    return RootRelsExcelFolder;
}());
/**
 * @hidden
 */
var /**
 * @hidden
 */
DocPropsExcelFolder = /** @class */ (function () {
    function DocPropsExcelFolder() {
    }
    Object.defineProperty(DocPropsExcelFolder.prototype, "folderName", {
        get: /**
         * @return {?}
         */
        function () {
            return 'docProps';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} data
     * @return {?}
     */
    DocPropsExcelFolder.prototype.childFiles = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        return [
            ExcelFileTypes.AppFile,
            ExcelFileTypes.CoreFile
        ];
    };
    /**
     * @param {?} data
     * @return {?}
     */
    DocPropsExcelFolder.prototype.childFolders = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        return [];
    };
    return DocPropsExcelFolder;
}());
/**
 * @hidden
 */
var /**
 * @hidden
 */
XLExcelFolder = /** @class */ (function () {
    function XLExcelFolder() {
    }
    Object.defineProperty(XLExcelFolder.prototype, "folderName", {
        get: /**
         * @return {?}
         */
        function () {
            return 'xl';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} data
     * @return {?}
     */
    XLExcelFolder.prototype.childFiles = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        /** @type {?} */
        var retVal = [
            ExcelFileTypes.StyleFile,
            ExcelFileTypes.WorkbookFile
        ];
        if (!data.isEmpty) {
            retVal.push(ExcelFileTypes.SharedStringsFile);
        }
        return retVal;
    };
    /**
     * @param {?} data
     * @return {?}
     */
    XLExcelFolder.prototype.childFolders = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        /** @type {?} */
        var retVal = [
            ExcelFolderTypes.XLRelsExcelFolder,
            ExcelFolderTypes.ThemeExcelFolder,
            ExcelFolderTypes.WorksheetsExcelFolder
        ];
        if (!data.isEmpty && data.options.exportAsTable) {
            retVal.push(ExcelFolderTypes.TablesExcelFolder);
        }
        return retVal;
    };
    return XLExcelFolder;
}());
/**
 * @hidden
 */
var /**
 * @hidden
 */
XLRelsExcelFolder = /** @class */ (function () {
    function XLRelsExcelFolder() {
    }
    Object.defineProperty(XLRelsExcelFolder.prototype, "folderName", {
        get: /**
         * @return {?}
         */
        function () {
            return '_rels';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} data
     * @return {?}
     */
    XLRelsExcelFolder.prototype.childFiles = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        return [ExcelFileTypes.WorkbookRelsFile];
    };
    /**
     * @param {?} data
     * @return {?}
     */
    XLRelsExcelFolder.prototype.childFolders = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        return [];
    };
    return XLRelsExcelFolder;
}());
/**
 * @hidden
 */
var /**
 * @hidden
 */
ThemeExcelFolder = /** @class */ (function () {
    function ThemeExcelFolder() {
    }
    Object.defineProperty(ThemeExcelFolder.prototype, "folderName", {
        get: /**
         * @return {?}
         */
        function () {
            return 'theme';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} data
     * @return {?}
     */
    ThemeExcelFolder.prototype.childFiles = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        return [ExcelFileTypes.ThemeFile];
    };
    /**
     * @param {?} data
     * @return {?}
     */
    ThemeExcelFolder.prototype.childFolders = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        return [];
    };
    return ThemeExcelFolder;
}());
/**
 * @hidden
 */
var /**
 * @hidden
 */
WorksheetsExcelFolder = /** @class */ (function () {
    function WorksheetsExcelFolder() {
    }
    Object.defineProperty(WorksheetsExcelFolder.prototype, "folderName", {
        get: /**
         * @return {?}
         */
        function () {
            return 'worksheets';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} data
     * @return {?}
     */
    WorksheetsExcelFolder.prototype.childFiles = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        return [ExcelFileTypes.WorksheetFile];
    };
    /**
     * @param {?} data
     * @return {?}
     */
    WorksheetsExcelFolder.prototype.childFolders = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        return data.isEmpty || !data.options.exportAsTable ? [] : [ExcelFolderTypes.WorksheetsRelsExcelFolder];
    };
    return WorksheetsExcelFolder;
}());
/**
 * @hidden
 */
var /**
 * @hidden
 */
TablesExcelFolder = /** @class */ (function () {
    function TablesExcelFolder() {
    }
    Object.defineProperty(TablesExcelFolder.prototype, "folderName", {
        get: /**
         * @return {?}
         */
        function () {
            return 'tables';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} data
     * @return {?}
     */
    TablesExcelFolder.prototype.childFiles = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        return [ExcelFileTypes.TablesFile];
    };
    /**
     * @param {?} data
     * @return {?}
     */
    TablesExcelFolder.prototype.childFolders = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        return [];
    };
    return TablesExcelFolder;
}());
/**
 * @hidden
 */
var /**
 * @hidden
 */
WorksheetsRelsExcelFolder = /** @class */ (function () {
    function WorksheetsRelsExcelFolder() {
    }
    Object.defineProperty(WorksheetsRelsExcelFolder.prototype, "folderName", {
        get: /**
         * @return {?}
         */
        function () {
            return '_rels';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} data
     * @return {?}
     */
    WorksheetsRelsExcelFolder.prototype.childFiles = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        return [ExcelFileTypes.WorksheetRelsFile];
    };
    /**
     * @param {?} data
     * @return {?}
     */
    WorksheetsRelsExcelFolder.prototype.childFolders = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        return [];
    };
    return WorksheetsRelsExcelFolder;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var /**
 * @hidden
 */
ExcelElementsFactory = /** @class */ (function () {
    function ExcelElementsFactory() {
    }
    /**
     * @param {?} type
     * @return {?}
     */
    ExcelElementsFactory.getExcelFolder = /**
     * @param {?} type
     * @return {?}
     */
    function (type) {
        switch (type) {
            case ExcelFolderTypes.RootExcelFolder:
                return new RootExcelFolder();
            case ExcelFolderTypes.RootRelsExcelFolder:
                return new RootRelsExcelFolder();
            case ExcelFolderTypes.DocPropsExcelFolder:
                return new DocPropsExcelFolder();
            case ExcelFolderTypes.XLExcelFolder:
                return new XLExcelFolder();
            case ExcelFolderTypes.XLRelsExcelFolder:
                return new XLRelsExcelFolder();
            case ExcelFolderTypes.ThemeExcelFolder:
                return new ThemeExcelFolder();
            case ExcelFolderTypes.WorksheetsExcelFolder:
                return new WorksheetsExcelFolder();
            case ExcelFolderTypes.WorksheetsRelsExcelFolder:
                return new WorksheetsRelsExcelFolder();
            case ExcelFolderTypes.TablesExcelFolder:
                return new TablesExcelFolder();
            default:
                throw new Error('Unknown excel folder type!');
        }
    };
    /**
     * @param {?} type
     * @return {?}
     */
    ExcelElementsFactory.getExcelFile = /**
     * @param {?} type
     * @return {?}
     */
    function (type) {
        switch (type) {
            case ExcelFileTypes.RootRelsFile:
                return new RootRelsFile();
            case ExcelFileTypes.AppFile:
                return new AppFile();
            case ExcelFileTypes.CoreFile:
                return new CoreFile();
            case ExcelFileTypes.WorkbookRelsFile:
                return new WorkbookRelsFile();
            case ExcelFileTypes.ThemeFile:
                return new ThemeFile();
            case ExcelFileTypes.WorksheetFile:
                return new WorksheetFile();
            case ExcelFileTypes.StyleFile:
                return new StyleFile();
            case ExcelFileTypes.WorkbookFile:
                return new WorkbookFile();
            case ExcelFileTypes.ContentTypesFile:
                return new ContentTypesFile();
            case ExcelFileTypes.SharedStringsFile:
                return new SharedStringsFile();
            case ExcelFileTypes.WorksheetRelsFile:
                return new WorksheetRelsFile();
            case ExcelFileTypes.TablesFile:
                return new TablesFile();
            default:
                throw Error('Unknown excel file type!');
        }
    };
    return ExcelElementsFactory;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var WorksheetDataDictionary = /** @class */ (function () {
    function WorksheetDataDictionary(columnCount, columnWidth) {
        this.hasNonStringValues = false;
        this._dictionary = {};
        this._widthsDictionary = {};
        this._counter = 0;
        this.dirtyKeyCollections();
        this._calculateColumnWidth = !columnWidth;
        this._columnWidths = new Array(columnCount);
        this._columnTypeInfo = new Array(columnCount);
        if (!this._calculateColumnWidth) {
            this._columnWidths.fill(columnWidth);
        }
        this.stringsCount = 0;
    }
    Object.defineProperty(WorksheetDataDictionary.prototype, "columnWidths", {
        get: /**
         * @return {?}
         */
        function () {
            return this._columnWidths;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} value
     * @param {?} column
     * @param {?} isHeader
     * @return {?}
     */
    WorksheetDataDictionary.prototype.saveValue = /**
     * @param {?} value
     * @param {?} column
     * @param {?} isHeader
     * @return {?}
     */
    function (value, column, isHeader) {
        if (this._columnTypeInfo[column] === undefined && isHeader === false) {
            this._columnTypeInfo[column] = typeof value === 'string' ||
                typeof value === 'boolean' ||
                value instanceof Date;
        }
        /** @type {?} */
        var sanitizedValue = '';
        /** @type {?} */
        var isSavedAsString = this._columnTypeInfo[column] || isHeader;
        if (isSavedAsString) {
            sanitizedValue = this.sanitizeValue(value);
            if (this._dictionary[sanitizedValue] === undefined) {
                this._dictionary[sanitizedValue] = this._counter++;
                this.dirtyKeyCollections();
            }
            this.stringsCount++;
        }
        else {
            this.hasNonStringValues = true;
        }
        if (this._calculateColumnWidth) {
            /** @type {?} */
            var width = this.getTextWidth(value);
            /** @type {?} */
            var maxWidth = Math.max(this._columnWidths[column] || 0, width);
            this._columnWidths[column] = maxWidth;
        }
        return isSavedAsString ? this.getSanitizedValue(sanitizedValue) : -1;
    };
    /**
     * @param {?} value
     * @return {?}
     */
    WorksheetDataDictionary.prototype.getValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return this.getSanitizedValue(this.sanitizeValue(value));
    };
    /**
     * @param {?} sanitizedValue
     * @return {?}
     */
    WorksheetDataDictionary.prototype.getSanitizedValue = /**
     * @param {?} sanitizedValue
     * @return {?}
     */
    function (sanitizedValue) {
        return this._dictionary[sanitizedValue];
    };
    /**
     * @return {?}
     */
    WorksheetDataDictionary.prototype.getKeys = /**
     * @return {?}
     */
    function () {
        if (!this._keysAreValid) {
            this._keys = Object.keys(this._dictionary);
            this._keysAreValid = true;
        }
        return this._keys;
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    WorksheetDataDictionary.prototype.getTextWidth = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (this._widthsDictionary[value] === undefined) {
            /** @type {?} */
            var context = this.getContext();
            /** @type {?} */
            var metrics = context.measureText(value);
            this._widthsDictionary[value] = metrics.width + WorksheetDataDictionary.TEXT_PADDING;
        }
        return this._widthsDictionary[value];
    };
    /**
     * @private
     * @return {?}
     */
    WorksheetDataDictionary.prototype.getContext = /**
     * @private
     * @return {?}
     */
    function () {
        if (!this._context) {
            /** @type {?} */
            var canvas = document.createElement('canvas');
            this._context = canvas.getContext('2d');
            this._context.font = WorksheetDataDictionary.DEFAULT_FONT;
        }
        return this._context;
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    WorksheetDataDictionary.prototype.sanitizeValue = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (ExportUtilities.hasValue(value) === false) {
            return '';
        }
        else {
            /** @type {?} */
            var stringValue = String(value);
            return stringValue.replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&apos;');
        }
    };
    /**
     * @private
     * @return {?}
     */
    WorksheetDataDictionary.prototype.dirtyKeyCollections = /**
     * @private
     * @return {?}
     */
    function () {
        this._keysAreValid = false;
    };
    WorksheetDataDictionary.DEFAULT_FONT = '11pt Calibri';
    WorksheetDataDictionary.TEXT_PADDING = 5;
    return WorksheetDataDictionary;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var /**
 * @hidden
 */
WorksheetData = /** @class */ (function () {
    function WorksheetData(_data, options, indexOfLastPinnedColumn, sort, isTreeGridData) {
        if (isTreeGridData === void 0) { isTreeGridData = false; }
        this._data = _data;
        this.options = options;
        this.indexOfLastPinnedColumn = indexOfLastPinnedColumn;
        this.sort = sort;
        this.isTreeGridData = isTreeGridData;
        this.initializeData();
    }
    Object.defineProperty(WorksheetData.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () {
            return this._data;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WorksheetData.prototype, "columnCount", {
        get: /**
         * @return {?}
         */
        function () {
            return this._columnCount;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WorksheetData.prototype, "rowCount", {
        get: /**
         * @return {?}
         */
        function () {
            return this._rowCount;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WorksheetData.prototype, "isEmpty", {
        get: /**
         * @return {?}
         */
        function () {
            return !this.rowCount || !this._columnCount;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WorksheetData.prototype, "keys", {
        get: /**
         * @return {?}
         */
        function () {
            return this._keys;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WorksheetData.prototype, "isSpecialData", {
        get: /**
         * @return {?}
         */
        function () {
            return this._isSpecialData;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WorksheetData.prototype, "dataDictionary", {
        get: /**
         * @return {?}
         */
        function () {
            return this._dataDictionary;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @return {?}
     */
    WorksheetData.prototype.initializeData = /**
     * @private
     * @return {?}
     */
    function () {
        if (!this._data || this._data.length === 0) {
            return;
        }
        /** @type {?} */
        var actualData = this._data.map(function (item) { return item.rowData; });
        this._keys = ExportUtilities.getKeysFromData(actualData);
        if (this._keys.length === 0) {
            return;
        }
        this._isSpecialData = ExportUtilities.isSpecialData(actualData);
        this._columnCount = this._keys.length;
        this._rowCount = this._data.length + 1;
        this._dataDictionary = new WorksheetDataDictionary(this._columnCount, this.options.columnWidth);
    };
    return WorksheetData;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * **Ignite UI for Angular Excel Exporter Service** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/exporter_excel.html)
 *
 * The Ignite UI for Angular Excel Exporter service can export data in MicrosoftÂ® ExcelÂ® format from both raw data
 * (array) or from an `IgxGrid`.
 *
 * Example:
 * ```typescript
 * public localData = [
 *   { Name: "Eric Ridley", Age: "26" },
 *   { Name: "Alanis Brook", Age: "22" },
 *   { Name: "Jonathan Morris", Age: "23" }
 * ];
 *
 * constructor(private excelExportService: IgxExcelExporterService) {
 * }
 *
 * this.excelExportService.exportData(this.localData, new IgxExcelExporterOptions("FileName"));
 * ```
 */
var IgxExcelExporterService = /** @class */ (function (_super) {
    __extends(IgxExcelExporterService, _super);
    function IgxExcelExporterService() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * This event is emitted when the export process finishes.
         * ```typescript
         * this.exporterService.onExportEnded.subscribe((args: IExcelExportEndedEventArgs) => {
         * // put event handler code here
         * });
         * ```
         * \@memberof IgxExcelExporterService
         */
        _this.onExportEnded = new EventEmitter();
        return _this;
    }
    /**
     * @private
     * @param {?} folder
     * @param {?} zip
     * @param {?} worksheetData
     * @return {?}
     */
    IgxExcelExporterService.populateFolder = /**
     * @private
     * @param {?} folder
     * @param {?} zip
     * @param {?} worksheetData
     * @return {?}
     */
    function (folder, zip, worksheetData) {
        var e_1, _a, e_2, _b;
        try {
            for (var _c = __values(folder.childFolders(worksheetData)), _d = _c.next(); !_d.done; _d = _c.next()) {
                var childFolder = _d.value;
                /** @type {?} */
                var folderIntance = ExcelElementsFactory.getExcelFolder(childFolder);
                /** @type {?} */
                var zipFolder = zip.folder(folderIntance.folderName);
                IgxExcelExporterService.populateFolder(folderIntance, zipFolder, worksheetData);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        try {
            for (var _e = __values(folder.childFiles(worksheetData)), _f = _e.next(); !_f.done; _f = _e.next()) {
                var childFile = _f.value;
                /** @type {?} */
                var fileInstance = ExcelElementsFactory.getExcelFile(childFile);
                fileInstance.writeElement(zip, worksheetData);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    /**
     * @protected
     * @param {?} data
     * @param {?} options
     * @return {?}
     */
    IgxExcelExporterService.prototype.exportDataImplementation = /**
     * @protected
     * @param {?} data
     * @param {?} options
     * @return {?}
     */
    function (data, options) {
        var _this = this;
        if (this._isTreeGrid) {
            /** @type {?} */
            var maxLevel_1 = 0;
            data.forEach(function (r) {
                maxLevel_1 = Math.max(maxLevel_1, r.originalRowData.level);
            });
            if (maxLevel_1 > 7) {
                throw Error('Can create an outline of up to eight levels!');
            }
        }
        /** @type {?} */
        var worksheetData = new WorksheetData(data, options, this._indexOfLastPinnedColumn, this._sort, this._isTreeGrid);
        this._xlsx = new JSZip();
        /** @type {?} */
        var rootFolder = ExcelElementsFactory.getExcelFolder(ExcelFolderTypes.RootExcelFolder);
        IgxExcelExporterService.populateFolder(rootFolder, this._xlsx, worksheetData);
        this._xlsx.generateAsync(IgxExcelExporterService.ZIP_OPTIONS).then(function (result) {
            _this.saveFile(result, options.fileName);
            _this.onExportEnded.emit({ xlsx: _this._xlsx });
        });
    };
    /**
     * @private
     * @param {?} data
     * @param {?} fileName
     * @return {?}
     */
    IgxExcelExporterService.prototype.saveFile = /**
     * @private
     * @param {?} data
     * @param {?} fileName
     * @return {?}
     */
    function (data, fileName) {
        /** @type {?} */
        var blob = new Blob([ExportUtilities.stringToArrayBuffer(atob(data))], {
            type: ''
        });
        ExportUtilities.saveBlobToFile(blob, fileName);
    };
    IgxExcelExporterService.ZIP_OPTIONS = { compression: 'DEFLATE', type: 'base64' };
    IgxExcelExporterService.decorators = [
        { type: Injectable }
    ];
    IgxExcelExporterService.propDecorators = {
        onExportEnded: [{ type: Output }]
    };
    return IgxExcelExporterService;
}(IgxBaseExporter));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Objects of this class are used to configure the Excel exporting process.
 */
var  /**
 * Objects of this class are used to configure the Excel exporting process.
 */
IgxExcelExporterOptions = /** @class */ (function (_super) {
    __extends(IgxExcelExporterOptions, _super);
    function IgxExcelExporterOptions(fileName) {
        var _this = _super.call(this, fileName, '.xlsx') || this;
        /**
         * Specifies if column pinning should be ignored. If ignoreColumnsOrder is set to true,
         * this option will always be considered as set to true.
         * ```typescript
         * let ignorePinning = this.exportOptions.ignorePinning;
         * this.exportOptions.ignorePinning = true;
         * ```
         * \@memberof IgxExcelExporterOptions
         */
        _this.ignorePinning = false;
        /**
         * Specifies whether the exported data should be formatted as Excel table. (True by default)
         * ```typescript
         * let exportAsTable = this.exportOptions.exportAsTable;
         * this.exportOptions.exportAsTable = false;
         * ```
         * \@memberof IgxExcelExporterOptions
         */
        _this.exportAsTable = true;
        return _this;
    }
    Object.defineProperty(IgxExcelExporterOptions.prototype, "columnWidth", {
        /**
         * Gets the width of the columns in the exported excel file.
         * ```typescript
         * let width = this.exportOptions.columnWidth;
         * ```
         * @memberof IgxExcelExporterOptions
         */
        get: /**
         * Gets the width of the columns in the exported excel file.
         * ```typescript
         * let width = this.exportOptions.columnWidth;
         * ```
         * \@memberof IgxExcelExporterOptions
         * @return {?}
         */
        function () {
            return this._columnWidth;
        },
        /**
         * Sets the width of the columns in the exported excel file. If left unspecified or 0,
         * the width of the largest string in the column will be used.
         * ```typescript
         * this.exportOptions.columnWidth = 55;
         * ```
         * @memberof IgxExcelExporterOptions
         */
        set: /**
         * Sets the width of the columns in the exported excel file. If left unspecified or 0,
         * the width of the largest string in the column will be used.
         * ```typescript
         * this.exportOptions.columnWidth = 55;
         * ```
         * \@memberof IgxExcelExporterOptions
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value < 0) {
                throw Error('Invalid value for column width!');
            }
            this._columnWidth = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxExcelExporterOptions.prototype, "rowHeight", {
        /**
         * Gets the height of the rows in the exported excel file.
         * ```typescript
         * let height = this.exportOptions.rowHeight;
         * ```
         * @memberof IgxExcelExporterOptions
         */
        get: /**
         * Gets the height of the rows in the exported excel file.
         * ```typescript
         * let height = this.exportOptions.rowHeight;
         * ```
         * \@memberof IgxExcelExporterOptions
         * @return {?}
         */
        function () {
            return this._rowHeight;
        },
        /**
         * Sets the height of the rows in the exported excel file. If left unspecified or 0,
         * the default height of the excel rows will be used.
         * ```typescript
         * this.exportOptions.rowHeight = 25;
         * ```
         * @memberof IgxExcelExporterOptions
         */
        set: /**
         * Sets the height of the rows in the exported excel file. If left unspecified or 0,
         * the default height of the excel rows will be used.
         * ```typescript
         * this.exportOptions.rowHeight = 25;
         * ```
         * \@memberof IgxExcelExporterOptions
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value < 0) {
                throw Error('Invalid value for row height!');
            }
            this._rowHeight = value;
        },
        enumerable: true,
        configurable: true
    });
    return IgxExcelExporterOptions;
}(IgxExporterOptionsBase));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
var HorizontalAlignment = {
    Left: -1,
    Center: -0.5,
    Right: 0,
};
HorizontalAlignment[HorizontalAlignment.Left] = 'Left';
HorizontalAlignment[HorizontalAlignment.Center] = 'Center';
HorizontalAlignment[HorizontalAlignment.Right] = 'Right';
/** @enum {number} */
var VerticalAlignment = {
    Top: -1,
    Middle: -0.5,
    Bottom: 0,
};
VerticalAlignment[VerticalAlignment.Top] = 'Top';
VerticalAlignment[VerticalAlignment.Middle] = 'Middle';
VerticalAlignment[VerticalAlignment.Bottom] = 'Bottom';
var Point = /** @class */ (function () {
    function Point(x, y) {
        this.x = x;
        this.y = y;
    }
    return Point;
}());
/**
 * @hidden
 * Calculates the rectangle of target for provided overlay settings. Defaults to 0,0,0,0 rectangle
 * if no target is provided
 * @param {?} settings Overlay settings for which to calculate target rectangle
 * @return {?}
 */
function getTargetRect(settings) {
    /** @type {?} */
    var targetRect = {
        bottom: 0,
        height: 0,
        left: 0,
        right: 0,
        top: 0,
        width: 0
    };
    if (settings.target instanceof HTMLElement) {
        targetRect = ((/** @type {?} */ (settings.target))).getBoundingClientRect();
    }
    else if (settings.target instanceof Point) {
        /** @type {?} */
        var targetPoint = (/** @type {?} */ (settings.target));
        targetRect = {
            bottom: targetPoint.y,
            height: 0,
            left: targetPoint.x,
            right: targetPoint.x,
            top: targetPoint.y,
            width: 0
        };
    }
    return targetRect;
}
/**
 * @hidden \@internal
 * @param {?} document
 * @return {?}
 */
function getViewportRect(document) {
    /** @type {?} */
    var width = document.documentElement.clientWidth;
    /** @type {?} */
    var height = document.documentElement.clientHeight;
    /** @type {?} */
    var scrollPosition = getViewportScrollPosition();
    return {
        top: scrollPosition.y,
        left: scrollPosition.x,
        right: scrollPosition.x + width,
        bottom: scrollPosition.y + height,
        width: width,
        height: height,
    };
}
/**
 * @hidden \@internal
 * @return {?}
 */
function getViewportScrollPosition() {
    /** @type {?} */
    var documentElement = document.documentElement;
    /** @type {?} */
    var documentRect = documentElement.getBoundingClientRect();
    /** @type {?} */
    var horizontalScrollPosition = -documentRect.left || document.body.scrollLeft || window.scrollX || documentElement.scrollLeft || 0;
    /** @type {?} */
    var verticalScrollPosition = -documentRect.top || document.body.scrollTop || window.scrollY || documentElement.scrollTop || 0;
    return new Point(horizontalScrollPosition, verticalScrollPosition);
}
/**
 * @hidden \@internal
 * @param {?} object
 * @return {?}
 */
function cloneInstance(object) {
    /** @type {?} */
    var clonedObj = Object.assign(Object.create(Object.getPrototypeOf(object)), object);
    clonedObj.settings = cloneValue(clonedObj.settings);
    return clonedObj;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Positions the element based on the directions passed in trough PositionSettings.
 * These are Top/Middle/Bottom for verticalDirection and Left/Center/Right for horizontalDirection
 */
var  /**
 * Positions the element based on the directions passed in trough PositionSettings.
 * These are Top/Middle/Bottom for verticalDirection and Left/Center/Right for horizontalDirection
 */
GlobalPositionStrategy = /** @class */ (function () {
    function GlobalPositionStrategy(settings) {
        this._defaultSettings = {
            horizontalDirection: HorizontalAlignment.Center,
            verticalDirection: VerticalAlignment.Middle,
            horizontalStartPoint: HorizontalAlignment.Center,
            verticalStartPoint: VerticalAlignment.Middle,
            openAnimation: fadeIn,
            closeAnimation: fadeOut,
            minSize: { width: 0, height: 0 }
        };
        this.settings = Object.assign({}, this._defaultSettings, settings);
    }
    /**
     * @param {?} contentElement
     * @param {?=} size
     * @param {?=} document
     * @param {?=} initialCall
     * @return {?}
     */
    GlobalPositionStrategy.prototype.position = /**
     * @param {?} contentElement
     * @param {?=} size
     * @param {?=} document
     * @param {?=} initialCall
     * @return {?}
     */
    function (contentElement, size, document, initialCall) {
        contentElement.classList.add('igx-overlay__content--relative');
        contentElement.parentElement.classList.add('igx-overlay__wrapper--flex');
        switch (this.settings.horizontalDirection) {
            case HorizontalAlignment.Left:
                contentElement.parentElement.style.justifyContent = 'flex-start';
                break;
            case HorizontalAlignment.Center:
                contentElement.parentElement.style.justifyContent = 'center';
                break;
            case HorizontalAlignment.Right:
                contentElement.parentElement.style.justifyContent = 'flex-end';
                break;
            default:
                break;
        }
        switch (this.settings.verticalDirection) {
            case VerticalAlignment.Top:
                contentElement.parentElement.style.alignItems = 'flex-start';
                break;
            case VerticalAlignment.Middle:
                contentElement.parentElement.style.alignItems = 'center';
                break;
            case VerticalAlignment.Bottom:
                contentElement.parentElement.style.alignItems = 'flex-end';
                break;
            default:
                break;
        }
    };
    /** @inheritdoc */
    /**
     * \@inheritdoc
     * @return {?}
     */
    GlobalPositionStrategy.prototype.clone = /**
     * \@inheritdoc
     * @return {?}
     */
    function () {
        return cloneInstance(this);
    };
    return GlobalPositionStrategy;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var  /**
 * @abstract
 */
ScrollStrategy = /** @class */ (function () {
    function ScrollStrategy(scrollContainer) {
    }
    return ScrollStrategy;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Empty scroll strategy. Does nothing.
 */
var  /**
 * Empty scroll strategy. Does nothing.
 */
NoOpScrollStrategy = /** @class */ (function (_super) {
    __extends(NoOpScrollStrategy, _super);
    function NoOpScrollStrategy(scrollContainer) {
        return _super.call(this, scrollContainer) || this;
    }
    /** @inheritdoc */
    /**
     * \@inheritdoc
     * @param {?} document
     * @param {?} overlayService
     * @param {?} id
     * @return {?}
     */
    NoOpScrollStrategy.prototype.initialize = /**
     * \@inheritdoc
     * @param {?} document
     * @param {?} overlayService
     * @param {?} id
     * @return {?}
     */
    function (document, overlayService, id) { };
    /** @inheritdoc */
    /**
     * \@inheritdoc
     * @return {?}
     */
    NoOpScrollStrategy.prototype.attach = /**
     * \@inheritdoc
     * @return {?}
     */
    function () { };
    /** @inheritdoc */
    /**
     * \@inheritdoc
     * @return {?}
     */
    NoOpScrollStrategy.prototype.detach = /**
     * \@inheritdoc
     * @return {?}
     */
    function () { };
    return NoOpScrollStrategy;
}(ScrollStrategy));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 * @param {?} message
 * @return {?}
 */
function DeprecateMethod(message) {
    /** @type {?} */
    var isMessageShown = false;
    return function (target, key, descriptor) {
        if (descriptor && descriptor.value) {
            /** @type {?} */
            var originalMethod_1 = descriptor.value;
            descriptor.value = function () {
                /** @type {?} */
                var targetName = typeof target === 'function' ? target.name : target.constructor.name;
                isMessageShown = showMessage(targetName + "." + key + ": " + message, isMessageShown);
                return originalMethod_1.call(this, arguments);
            };
            return descriptor;
        }
    };
}
/**
 * @hidden
 * @param {?} message
 * @return {?}
 */
function DeprecateProperty(message) {
    return function (target, key) {
        /** @type {?} */
        var isMessageShown = false;
        /** @type {?} */
        var messageToDisplay = target.constructor.name + "." + key + ": " + message;
        // if the target already has the property defined
        /** @type {?} */
        var originalDescriptor = Object.getOwnPropertyDescriptor(target, key);
        if (originalDescriptor) {
            /** @type {?} */
            var getter_1;
            /** @type {?} */
            var setter_1;
            getter_1 = originalDescriptor.get;
            setter_1 = originalDescriptor.set;
            if (getter_1) {
                originalDescriptor.get = function () {
                    isMessageShown = showMessage(messageToDisplay, isMessageShown);
                    return getter_1.call(this);
                };
            }
            if (setter_1) {
                originalDescriptor.set = function (value) {
                    isMessageShown = showMessage(messageToDisplay, isMessageShown);
                    setter_1.call(this, value);
                };
            }
            return originalDescriptor;
        }
        // the target doesn't contain a descriptor for that property, so create one
        // use backing field to set/get the value of the property to ensure there won't be infinite recursive calls
        /** @type {?} */
        var newKey = generateUniqueKey(target, key);
        Object.defineProperty(target, key, {
            configurable: true,
            enumerable: true,
            set: function (value) {
                isMessageShown = showMessage(messageToDisplay, isMessageShown);
                this[newKey] = value;
            },
            get: function () {
                isMessageShown = showMessage(messageToDisplay, isMessageShown);
                return this[newKey];
            }
        });
    };
}
/**
 * @hidden
 * @param {?} target
 * @param {?} key
 * @return {?}
 */
function generateUniqueKey(target, key) {
    /** @type {?} */
    var newKey = '_' + key;
    while (target.hasOwnProperty(newKey)) {
        newKey = '_' + newKey;
    }
    return newKey;
}
/**
 * @hidden
 * @param {?} message
 * @param {?} isMessageShown
 * @return {?}
 */
function showMessage(message, isMessageShown) {
    if (!isMessageShown && isDevMode()) {
        console.warn(message);
    }
    return true;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var warningShown = false;
/**
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/overlay_main.html)
 * The overlay service allows users to show components on overlay div above all other elements in the page.
 */
var IgxOverlayService = /** @class */ (function () {
    function IgxOverlayService(_factoryResolver, _appRef, _injector, builder, document, _zone) {
        var _this = this;
        this._factoryResolver = _factoryResolver;
        this._appRef = _appRef;
        this._injector = _injector;
        this.builder = builder;
        this.document = document;
        this._zone = _zone;
        this._componentId = 0;
        this._overlayInfos = [];
        this.destroy$ = new Subject();
        this._defaultSettings = {
            positionStrategy: new GlobalPositionStrategy(),
            scrollStrategy: new NoOpScrollStrategy(),
            modal: true,
            closeOnOutsideClick: true
        };
        /**
         * Emitted before the component is opened.
         * ```typescript
         * onOpening(event: OverlayCancelableEventArgs){
         *     const onOpening = event;
         * }
         * ```
         */
        this.onOpening = new EventEmitter();
        /**
         * Emitted after the component is opened and all animations are finished.
         * ```typescript
         * onOpened(event: OverlayEventArgs){
         *     const onOpened = event;
         * }
         * ```
         */
        this.onOpened = new EventEmitter();
        /**
         * Emitted before the component is closed.
         * ```typescript
         * onClosing(event: OverlayCancelableEventArgs){
         *     const onClosing = event;
         * }
         * ```
         */
        this.onClosing = new EventEmitter();
        /**
         * Emitted after the component is closed and all animations are finished.
         * ```typescript
         * onClosed(event: OverlayEventArgs){
         *     const onClosed = event;
         * }
         * ```
         */
        this.onClosed = new EventEmitter();
        /**
         * Emitted before animation is started
         * ```typescript
         * onAnimation(event: OverlayAnimationEventArgs){
         *     const onAnimation = event;
         * }
         * ```
         */
        this.onAnimation = new EventEmitter();
        this.documentClicked = function (ev) {
            //  if we get to modal overlay just return - we should not close anything under it
            //  if we get to non-modal overlay do the next:
            //   1. Check it has close on outside click. If not go on to next overlay;
            //   2. If true check if click is on the element. If it is on the element we have closed
            //  already all previous non-modal with close on outside click elements, so we return. If
            //  not close the overlay and check next
            for (var i = _this._overlayInfos.length; i--;) {
                /** @type {?} */
                var info = _this._overlayInfos[i];
                if (info.settings.modal) {
                    return;
                }
                if (info.settings.closeOnOutsideClick) {
                    //  if the click is on the element do not close this overlay
                    if (!info.elementRef.nativeElement.contains(ev.target)) {
                        // if we should exclude position target check if the click is over it. If so do not close overlay
                        /** @type {?} */
                        var positionTarget = (/** @type {?} */ (info.settings.positionStrategy.settings.target));
                        /** @type {?} */
                        var clickOnPositionTarget = false;
                        if (positionTarget) {
                            /** @type {?} */
                            var positionTargetRect = positionTarget.getBoundingClientRect();
                            clickOnPositionTarget = ev.clientX >= positionTargetRect.left && ev.clientX <= positionTargetRect.right &&
                                ev.clientY >= positionTargetRect.top && ev.clientY <= positionTargetRect.bottom;
                        }
                        if (!(info.settings.excludePositionTarget && clickOnPositionTarget)) {
                            //  if the click is outside click, but close animation has started do nothing
                            if (!(info.closeAnimationPlayer && info.closeAnimationPlayer.hasStarted())) {
                                _this._hide(info.id, ev);
                            }
                        }
                    }
                    else {
                        //  TODO: should we return here, or continue with next overlays
                        return;
                    }
                }
            }
        };
        /**
         * @hidden
         */
        this.repositionAll = function () {
            for (var i = _this._overlayInfos.length; i--;) {
                _this.reposition(_this._overlayInfos[i].id);
            }
        };
        this._document = (/** @type {?} */ (this.document));
    }
    /**
     * @param {?} component
     * @param {?=} settings
     * @param {?=} moduleRef
     * @return {?}
     */
    IgxOverlayService.prototype.attach = /**
     * @param {?} component
     * @param {?=} settings
     * @param {?=} moduleRef
     * @return {?}
     */
    function (component, settings, moduleRef) {
        /** @type {?} */
        var info;
        info = this.getOverlayInfo(component, moduleRef);
        //  if there is no info most probably wrong type component was provided and we just go out
        if (!info) {
            return null;
        }
        info.id = (this._componentId++).toString();
        settings = Object.assign({}, this._defaultSettings, settings);
        info.settings = settings;
        this._overlayInfos.push(info);
        return info.id;
    };
    /**
     * @param {?} compOrId
     * @param {?=} settings
     * @return {?}
     */
    IgxOverlayService.prototype.show = /**
     * @param {?} compOrId
     * @param {?=} settings
     * @return {?}
     */
    function (compOrId, settings) {
        /** @type {?} */
        var info;
        /** @type {?} */
        var id;
        if (typeof compOrId === 'string') {
            id = compOrId;
            info = this.getOverlayById(compOrId);
            if (!info) {
                console.warn('igxOverlay.show was called with wrong id: ' + compOrId);
                return null;
            }
        }
        else {
            warningShown = showMessage('`show(component, settings?)` overload is deprecated. Use `attach(component)` to obtain an Id.' +
                'Then `show(id, settings?)` with provided Id.', warningShown);
            id = (this._componentId++).toString();
            info = this.getOverlayInfo(compOrId);
            //  if there is no info most probably wrong type component was provided and we just go out
            if (!info) {
                return;
            }
            info.id = id;
        }
        settings = Object.assign({}, this._defaultSettings, info.settings, settings);
        info.settings = settings;
        this._show(info);
        return id;
    };
    /**
     * Hides the component with the ID provided as a parameter.
     * ```typescript
     * this.overlay.hide(id);
     * ```
     */
    /**
     * Hides the component with the ID provided as a parameter.
     * ```typescript
     * this.overlay.hide(id);
     * ```
     * @param {?} id
     * @return {?}
     */
    IgxOverlayService.prototype.hide = /**
     * Hides the component with the ID provided as a parameter.
     * ```typescript
     * this.overlay.hide(id);
     * ```
     * @param {?} id
     * @return {?}
     */
    function (id) {
        this._hide(id);
    };
    /**
     * Hides all the components and the overlay.
     * ```typescript
     * this.overlay.hideAll();
     * ```
     */
    /**
     * Hides all the components and the overlay.
     * ```typescript
     * this.overlay.hideAll();
     * ```
     * @return {?}
     */
    IgxOverlayService.prototype.hideAll = /**
     * Hides all the components and the overlay.
     * ```typescript
     * this.overlay.hideAll();
     * ```
     * @return {?}
     */
    function () {
        // since overlays are removed on animation done, que all hides
        for (var i = this._overlayInfos.length; i--;) {
            this.hide(this._overlayInfos[i].id);
        }
    };
    /**
     * Repositions the component with ID provided as a parameter.
     * ```typescript
     * this.overlay.reposition(id);
     * ```
     */
    /**
     * Repositions the component with ID provided as a parameter.
     * ```typescript
     * this.overlay.reposition(id);
     * ```
     * @param {?} id
     * @return {?}
     */
    IgxOverlayService.prototype.reposition = /**
     * Repositions the component with ID provided as a parameter.
     * ```typescript
     * this.overlay.reposition(id);
     * ```
     * @param {?} id
     * @return {?}
     */
    function (id) {
        /** @type {?} */
        var overlayInfo = this.getOverlayById(id);
        if (!overlayInfo || !overlayInfo.settings) {
            console.error('Wrong id provided in overlay.reposition method. Id: ' + id);
            return;
        }
        /** @type {?} */
        var contentElement = overlayInfo.elementRef.nativeElement.parentElement;
        /** @type {?} */
        var contentElementRect = contentElement.getBoundingClientRect();
        overlayInfo.settings.positionStrategy.position(contentElement, {
            width: contentElementRect.width,
            height: contentElementRect.height
        }, this._document, false);
    };
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    IgxOverlayService.prototype._show = /**
     * @private
     * @param {?} info
     * @return {?}
     */
    function (info) {
        /** @type {?} */
        var eventArgs = { id: info.id, componentRef: info.componentRef, cancel: false };
        this.onOpening.emit(eventArgs);
        if (eventArgs.cancel) {
            if (info.componentRef) {
                this._appRef.detachView(info.componentRef.hostView);
                info.componentRef.destroy();
            }
            return;
        }
        //  if there is no close animation player, or there is one but it is not started yet we are in clear
        //  opening. Otherwise, if there is close animation player playing animation now we should not setup
        //  overlay this is already done
        if (!info.closeAnimationPlayer || (info.closeAnimationPlayer && !info.closeAnimationPlayer.hasStarted())) {
            /** @type {?} */
            var elementRect = info.elementRef.nativeElement.getBoundingClientRect();
            info.initialSize = { width: elementRect.width, height: elementRect.height };
            info.hook = this.placeElementHook(info.elementRef.nativeElement);
            this.moveElementToOverlay(info);
            if (info.componentRef) {
                info.componentRef.changeDetectorRef.detectChanges();
            }
            this.updateSize(info);
            if (this._overlayInfos.indexOf(info) === -1) {
                this._overlayInfos.push(info);
            }
            info.settings.positionStrategy.position(info.elementRef.nativeElement.parentElement, { width: info.initialSize.width, height: info.initialSize.height }, document, true);
            info.settings.scrollStrategy.initialize(this._document, this, info.id);
            info.settings.scrollStrategy.attach();
        }
        this.addOutsideClickListener(info);
        this.addResizeHandler(info.id);
        if (info.settings.modal) {
            this.setupModalWrapper(info);
        }
        if (info.settings.positionStrategy.settings.openAnimation) {
            this.playOpenAnimation(info);
        }
        else {
            //  to eliminate flickering show the element just before onOpened fire
            info.elementRef.nativeElement.parentElement.style.visibility = '';
            this.onOpened.emit({ id: info.id, componentRef: info.componentRef });
        }
    };
    /**
     * @private
     * @param {?} id
     * @param {?=} event
     * @return {?}
     */
    IgxOverlayService.prototype._hide = /**
     * @private
     * @param {?} id
     * @param {?=} event
     * @return {?}
     */
    function (id, event) {
        /** @type {?} */
        var info = this.getOverlayById(id);
        if (!info) {
            console.warn('igxOverlay.hide was called with wrong id: ' + id);
            return;
        }
        /** @type {?} */
        var eventArgs = { id: id, componentRef: info.componentRef, cancel: false, event: event };
        this.onClosing.emit(eventArgs);
        if (eventArgs.cancel) {
            return;
        }
        //  TODO: synchronize where these are added/attached and where removed/detached
        info.settings.scrollStrategy.detach();
        this.removeOutsideClickListener(info);
        this.removeResizeHandler(info.id);
        /** @type {?} */
        var child = info.elementRef.nativeElement;
        if (info.settings.modal) {
            /** @type {?} */
            var parent_1 = (/** @type {?} */ (child.parentNode.parentNode));
            this.applyAnimationParams(parent_1, info.settings.positionStrategy.settings.closeAnimation);
            parent_1.classList.remove('igx-overlay__wrapper--modal');
            parent_1.classList.add('igx-overlay__wrapper');
        }
        if (info.settings.positionStrategy.settings.closeAnimation) {
            this.playCloseAnimation(info);
        }
        else {
            this.onCloseDone(info);
        }
    };
    /**
     * @private
     * @param {?} component
     * @param {?=} moduleRef
     * @return {?}
     */
    IgxOverlayService.prototype.getOverlayInfo = /**
     * @private
     * @param {?} component
     * @param {?=} moduleRef
     * @return {?}
     */
    function (component, moduleRef) {
        /** @type {?} */
        var info = { ngZone: this._zone };
        if (component instanceof ElementRef) {
            info.elementRef = (/** @type {?} */ (component));
        }
        else {
            /** @type {?} */
            var dynamicFactory = void 0;
            /** @type {?} */
            var factoryResolver = moduleRef ? moduleRef.componentFactoryResolver : this._factoryResolver;
            try {
                dynamicFactory = factoryResolver.resolveComponentFactory(component);
            }
            catch (error) {
                console.error(error);
                return null;
            }
            /** @type {?} */
            var injector = moduleRef ? moduleRef.injector : this._injector;
            /** @type {?} */
            var dynamicComponent = dynamicFactory.create(injector);
            this._appRef.attachView(dynamicComponent.hostView);
            // If the element is newly created from a Component, it is wrapped in 'ng-component' tag - we do not want that.
            /** @type {?} */
            var element = dynamicComponent.location.nativeElement;
            info.elementRef = (/** @type {?} */ ({ nativeElement: element }));
            info.componentRef = dynamicComponent;
        }
        return info;
    };
    /**
     * @private
     * @param {?} element
     * @return {?}
     */
    IgxOverlayService.prototype.placeElementHook = /**
     * @private
     * @param {?} element
     * @return {?}
     */
    function (element) {
        if (!element.parentElement) {
            return null;
        }
        /** @type {?} */
        var hook = this._document.createElement('div');
        element.parentElement.insertBefore(hook, element);
        return hook;
    };
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    IgxOverlayService.prototype.moveElementToOverlay = /**
     * @private
     * @param {?} info
     * @return {?}
     */
    function (info) {
        /** @type {?} */
        var wrapperElement = this.getWrapperElement();
        /** @type {?} */
        var contentElement = this.getContentElement(wrapperElement, info.settings.modal);
        this.getOverlayElement(info).appendChild(wrapperElement);
        /** @type {?} */
        var elementScrollTop = info.elementRef.nativeElement.scrollTop;
        contentElement.appendChild(info.elementRef.nativeElement);
        if (elementScrollTop) {
            info.elementRef.nativeElement.scrollTop = elementScrollTop;
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxOverlayService.prototype.getWrapperElement = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var wrapper = this._document.createElement('div');
        wrapper.classList.add('igx-overlay__wrapper');
        return wrapper;
    };
    /**
     * @private
     * @param {?} wrapperElement
     * @param {?} modal
     * @return {?}
     */
    IgxOverlayService.prototype.getContentElement = /**
     * @private
     * @param {?} wrapperElement
     * @param {?} modal
     * @return {?}
     */
    function (wrapperElement, modal) {
        /** @type {?} */
        var content = this._document.createElement('div');
        if (modal) {
            content.classList.add('igx-overlay__content--modal');
            content.addEventListener('click', function (ev) {
                ev.stopPropagation();
            });
        }
        else {
            content.classList.add('igx-overlay__content');
        }
        content.addEventListener('scroll', function (ev) {
            ev.stopPropagation();
        });
        //  hide element to eliminate flickering. Show the element exactly before animation starts
        content.style.visibility = 'hidden';
        wrapperElement.appendChild(content);
        return content;
    };
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    IgxOverlayService.prototype.getOverlayElement = /**
     * @private
     * @param {?} info
     * @return {?}
     */
    function (info) {
        if (info.settings.outlet) {
            return info.settings.outlet.nativeElement;
        }
        if (!this._overlayElement) {
            this._overlayElement = this._document.createElement('div');
            this._overlayElement.classList.add('igx-overlay');
            this._document.body.appendChild(this._overlayElement);
        }
        return this._overlayElement;
    };
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    IgxOverlayService.prototype.updateSize = /**
     * @private
     * @param {?} info
     * @return {?}
     */
    function (info) {
        if (info.componentRef) {
            //  if we are positioning component this is first time it gets visible
            //  and we can finally get its size
            info.initialSize = info.elementRef.nativeElement.getBoundingClientRect();
        }
        // set content div width only if element to show has width
        if (info.initialSize.width !== 0) {
            info.elementRef.nativeElement.parentElement.style.width = info.initialSize.width + 'px';
        }
    };
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    IgxOverlayService.prototype.setupModalWrapper = /**
     * @private
     * @param {?} info
     * @return {?}
     */
    function (info) {
        var _this = this;
        /** @type {?} */
        var wrapperElement = info.elementRef.nativeElement.parentElement.parentElement;
        fromEvent(wrapperElement, 'keydown').pipe(filter(function (ev) { return ev.key === 'Escape' || ev.key === 'Esc'; }), takeUntil(this.destroy$)).subscribe(function () { return _this.hide(info.id); });
        wrapperElement.classList.remove('igx-overlay__wrapper');
        this.applyAnimationParams(wrapperElement, info.settings.positionStrategy.settings.openAnimation);
        wrapperElement.classList.add('igx-overlay__wrapper--modal');
    };
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    IgxOverlayService.prototype.onCloseDone = /**
     * @private
     * @param {?} info
     * @return {?}
     */
    function (info) {
        this.cleanUp(info);
        this.onClosed.emit({ id: info.id, componentRef: info.componentRef });
    };
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    IgxOverlayService.prototype.cleanUp = /**
     * @private
     * @param {?} info
     * @return {?}
     */
    function (info) {
        /** @type {?} */
        var child = info.elementRef.nativeElement;
        /** @type {?} */
        var outlet = this.getOverlayElement(info);
        if (!outlet.contains(child)) {
            console.warn('Component with id:' + info.id + ' is already removed!');
            return;
        }
        outlet.removeChild(child.parentNode.parentNode);
        if (info.componentRef) {
            this._appRef.detachView(info.componentRef.hostView);
            info.componentRef.destroy();
        }
        if (info.hook) {
            info.hook.parentElement.insertBefore(info.elementRef.nativeElement, info.hook);
            info.hook.parentElement.removeChild(info.hook);
        }
        /** @type {?} */
        var index = this._overlayInfos.indexOf(info);
        this._overlayInfos.splice(index, 1);
        // this._overlayElement.parentElement check just for tests that manually delete the element
        if (this._overlayInfos.length === 0 && this._overlayElement && this._overlayElement.parentElement) {
            this._overlayElement.parentElement.removeChild(this._overlayElement);
            this._overlayElement = null;
        }
    };
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    IgxOverlayService.prototype.playOpenAnimation = /**
     * @private
     * @param {?} info
     * @return {?}
     */
    function (info) {
        var _this = this;
        if (!info.openAnimationPlayer) {
            /** @type {?} */
            var animationBuilder = this.builder.build(info.settings.positionStrategy.settings.openAnimation);
            info.openAnimationPlayer = animationBuilder.create(info.elementRef.nativeElement);
            //  AnimationPlayer.getPosition returns always 0. To workaround this we are getting inner WebAnimationPlayer
            //  and then getting the positions from it.
            //  This is logged in Angular here - https://github.com/angular/angular/issues/18891
            //  As soon as this is resolved we can remove this hack
            /** @type {?} */
            var innerRenderer = ((/** @type {?} */ (info.openAnimationPlayer)))._renderer;
            info.openAnimationInnerPlayer = innerRenderer.engine.players[innerRenderer.engine.players.length - 1];
            info.openAnimationPlayer.onDone(function () {
                _this.onOpened.emit({ id: info.id, componentRef: info.componentRef });
                if (info.openAnimationPlayer) {
                    info.openAnimationPlayer.reset();
                    info.openAnimationPlayer = null;
                }
                if (info.closeAnimationPlayer && info.closeAnimationPlayer.hasStarted()) {
                    info.closeAnimationPlayer.reset();
                }
            });
        }
        //  if there is opening animation already started do nothing
        if (info.openAnimationPlayer.hasStarted()) {
            return;
        }
        //  if there is closing animation already started start open animation from where close one has reached
        //  and remove close animation
        if (info.closeAnimationPlayer && info.closeAnimationPlayer.hasStarted()) {
            //  getPosition() returns what part of the animation is passed, e.g. 0.5 if half the animation
            //  is done, 0.75 if 3/4 of the animation is done. As we need to start next animation from where
            //  the previous has finished we need the amount up to 1, therefore we are subtracting what
            //  getPosition() returns from one
            /** @type {?} */
            var position = 1 - info.closeAnimationInnerPlayer.getPosition();
            info.closeAnimationPlayer.reset();
            info.closeAnimationPlayer = null;
            info.openAnimationPlayer.init();
            info.openAnimationPlayer.setPosition(position);
        }
        this.onAnimation.emit({ id: info.id, animationPlayer: info.openAnimationPlayer, animationType: 'open' });
        //  to eliminate flickering show the element just before animation start
        info.elementRef.nativeElement.parentElement.style.visibility = '';
        info.openAnimationPlayer.play();
    };
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    IgxOverlayService.prototype.playCloseAnimation = /**
     * @private
     * @param {?} info
     * @return {?}
     */
    function (info) {
        var _this = this;
        if (!info.closeAnimationPlayer) {
            /** @type {?} */
            var animationBuilder = this.builder.build(info.settings.positionStrategy.settings.closeAnimation);
            info.closeAnimationPlayer = animationBuilder.create(info.elementRef.nativeElement);
            //  AnimationPlayer.getPosition returns always 0. To workaround this we are getting inner WebAnimationPlayer
            //  and then getting the positions from it.
            //  This is logged in Angular here - https://github.com/angular/angular/issues/18891
            //  As soon as this is resolved we can remove this hack
            /** @type {?} */
            var innerRenderer = ((/** @type {?} */ (info.closeAnimationPlayer)))._renderer;
            info.closeAnimationInnerPlayer = innerRenderer.engine.players[innerRenderer.engine.players.length - 1];
            info.closeAnimationPlayer.onDone(function () {
                if (info.closeAnimationPlayer) {
                    info.closeAnimationPlayer.reset();
                    info.closeAnimationPlayer = null;
                }
                if (info.openAnimationPlayer && info.openAnimationPlayer.hasStarted()) {
                    info.openAnimationPlayer.reset();
                }
                _this.onCloseDone(info);
            });
        }
        //  if there is closing animation already started do nothing
        if (info.closeAnimationPlayer.hasStarted()) {
            return;
        }
        //  if there is opening animation already started start close animation from where open one has reached
        //  and remove open animation
        if (info.openAnimationPlayer && info.openAnimationPlayer.hasStarted()) {
            //  getPosition() returns what part of the animation is passed, e.g. 0.5 if half the animation
            //  is done, 0.75 if 3/4 of the animation is done. As we need to start next animation from where
            //  the previous has finished we need the amount up to 1, therefore we are subtracting what
            //  getPosition() returns from one
            /** @type {?} */
            var position = 1 - info.openAnimationInnerPlayer.getPosition();
            info.openAnimationPlayer.reset();
            info.openAnimationPlayer = null;
            info.closeAnimationPlayer.init();
            info.closeAnimationPlayer.setPosition(position);
        }
        this.onAnimation.emit({ id: info.id, animationPlayer: info.closeAnimationPlayer, animationType: 'close' });
        info.closeAnimationPlayer.play();
    };
    //  TODO: check if applyAnimationParams will work with complex animations
    //  TODO: check if applyAnimationParams will work with complex animations
    /**
     * @private
     * @param {?} wrapperElement
     * @param {?} animationOptions
     * @return {?}
     */
    IgxOverlayService.prototype.applyAnimationParams = 
    //  TODO: check if applyAnimationParams will work with complex animations
    /**
     * @private
     * @param {?} wrapperElement
     * @param {?} animationOptions
     * @return {?}
     */
    function (wrapperElement, animationOptions) {
        if (!animationOptions) {
            wrapperElement.style.transitionDuration = '0ms';
            return;
        }
        if (animationOptions.type === 10 /* AnimateRef */) {
            animationOptions = ((/** @type {?} */ (animationOptions))).animation;
        }
        if (!animationOptions.options || !animationOptions.options.params) {
            return;
        }
        /** @type {?} */
        var params = (/** @type {?} */ (animationOptions.options.params));
        if (params.duration) {
            wrapperElement.style.transitionDuration = params.duration;
        }
        if (params.easing) {
            wrapperElement.style.transitionTimingFunction = params.easing;
        }
    };
    /** @hidden @internal */
    /**
     * @hidden \@internal
     * @param {?} id
     * @return {?}
     */
    IgxOverlayService.prototype.getOverlayById = /**
     * @hidden \@internal
     * @param {?} id
     * @return {?}
     */
    function (id) {
        if (!id) {
            return null;
        }
        /** @type {?} */
        var info = this._overlayInfos.find(function (e) { return e.id === id; });
        return info;
    };
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    IgxOverlayService.prototype.addOutsideClickListener = /**
     * @private
     * @param {?} info
     * @return {?}
     */
    function (info) {
        var _this = this;
        if (info.settings.closeOnOutsideClick) {
            if (info.settings.modal) {
                fromEvent(info.elementRef.nativeElement.parentElement.parentElement, 'click')
                    .pipe(takeUntil(this.destroy$))
                    .subscribe(function () { return _this.hide(info.id); });
            }
            else if (
            //  if all overlays minus closing overlays equals one add the handler
            this._overlayInfos.filter(function (x) { return x.settings.closeOnOutsideClick && !x.settings.modal; }).length -
                this._overlayInfos.filter(function (x) { return x.settings.closeOnOutsideClick && !x.settings.modal &&
                    x.closeAnimationPlayer &&
                    x.closeAnimationPlayer.hasStarted(); }).length === 1) {
                this._document.addEventListener('click', this.documentClicked, true);
            }
        }
    };
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    IgxOverlayService.prototype.removeOutsideClickListener = /**
     * @private
     * @param {?} info
     * @return {?}
     */
    function (info) {
        if (info.settings.modal === false) {
            /** @type {?} */
            var shouldRemoveClickEventListener_1 = true;
            this._overlayInfos.forEach(function (o) {
                if (o.settings.modal === false && o.id !== info.id) {
                    shouldRemoveClickEventListener_1 = false;
                }
            });
            if (shouldRemoveClickEventListener_1) {
                this._document.removeEventListener('click', this.documentClicked, true);
            }
        }
    };
    /**
     * @private
     * @param {?} id
     * @return {?}
     */
    IgxOverlayService.prototype.addResizeHandler = /**
     * @private
     * @param {?} id
     * @return {?}
     */
    function (id) {
        /** @type {?} */
        var closingOverlaysCount = this._overlayInfos
            .filter(function (o) { return o.closeAnimationPlayer && o.closeAnimationPlayer.hasStarted(); })
            .length;
        if (this._overlayInfos.length - closingOverlaysCount === 1) {
            this._document.defaultView.addEventListener('resize', this.repositionAll);
        }
    };
    /**
     * @private
     * @param {?} id
     * @return {?}
     */
    IgxOverlayService.prototype.removeResizeHandler = /**
     * @private
     * @param {?} id
     * @return {?}
     */
    function (id) {
        /** @type {?} */
        var closingOverlaysCount = this._overlayInfos
            .filter(function (o) { return o.closeAnimationPlayer && o.closeAnimationPlayer.hasStarted(); })
            .length;
        if (this._overlayInfos.length - closingOverlaysCount === 1) {
            this._document.defaultView.removeEventListener('resize', this.repositionAll);
        }
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxOverlayService.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.destroy$.next(true);
        this.destroy$.complete();
    };
    IgxOverlayService.decorators = [
        { type: Injectable, args: [{ providedIn: 'root' },] }
    ];
    /** @nocollapse */
    IgxOverlayService.ctorParameters = function () { return [
        { type: ComponentFactoryResolver },
        { type: ApplicationRef },
        { type: Injector },
        { type: AnimationBuilder },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: NgZone }
    ]; };
    /** @nocollapse */ IgxOverlayService.ngInjectableDef = defineInjectable({ factory: function IgxOverlayService_Factory() { return new IgxOverlayService(inject(ComponentFactoryResolver), inject(ApplicationRef), inject(INJECTOR), inject(AnimationBuilder), inject(DOCUMENT), inject(NgZone)); }, token: IgxOverlayService, providedIn: "root" });
    return IgxOverlayService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Positions the element based on the directions and start point passed in trough PositionSettings.
 * It is possible to either pass a start point or an HTMLElement as a positioning base.
 */
var  /**
 * Positions the element based on the directions and start point passed in trough PositionSettings.
 * It is possible to either pass a start point or an HTMLElement as a positioning base.
 */
ConnectedPositioningStrategy = /** @class */ (function () {
    function ConnectedPositioningStrategy(settings) {
        this._defaultSettings = {
            // default Point(0, 0) in getPointFromPositionsSettings
            target: null,
            horizontalDirection: HorizontalAlignment.Right,
            verticalDirection: VerticalAlignment.Bottom,
            horizontalStartPoint: HorizontalAlignment.Left,
            verticalStartPoint: VerticalAlignment.Bottom,
            openAnimation: scaleInVerTop,
            closeAnimation: scaleOutVerTop,
            minSize: { width: 0, height: 0 }
        };
        this.settings = Object.assign({}, this._defaultSettings, settings);
    }
    /** @inheritdoc */
    /**
     * \@inheritdoc
     * @param {?} contentElement
     * @param {?} size
     * @param {?=} document
     * @param {?=} initialCall
     * @return {?}
     */
    ConnectedPositioningStrategy.prototype.position = /**
     * \@inheritdoc
     * @param {?} contentElement
     * @param {?} size
     * @param {?=} document
     * @param {?=} initialCall
     * @return {?}
     */
    function (contentElement, size, document, initialCall) {
        /** @type {?} */
        var targetRect = getTargetRect(this.settings);
        /** @type {?} */
        var contentElementRect = contentElement.getBoundingClientRect();
        this.setStyle(contentElement, targetRect, contentElementRect);
    };
    /**
     * @inheritdoc
     * Creates clone of this position strategy
     * @returns clone of this position strategy
     */
    /**
     * \@inheritdoc
     * Creates clone of this position strategy
     * @return {?} clone of this position strategy
     */
    ConnectedPositioningStrategy.prototype.clone = /**
     * \@inheritdoc
     * Creates clone of this position strategy
     * @return {?} clone of this position strategy
     */
    function () {
        return cloneInstance(this);
    };
    /**
     * Sets element's style which effectively positions provided element according
     * to provided position settings
     * @param element Element to position
     * @param targetRect Bounding rectangle of strategy target
     * @param elementRect Bounding rectangle of the element
     */
    /**
     * Sets element's style which effectively positions provided element according
     * to provided position settings
     * @protected
     * @param {?} element Element to position
     * @param {?} targetRect Bounding rectangle of strategy target
     * @param {?} elementRect Bounding rectangle of the element
     * @return {?}
     */
    ConnectedPositioningStrategy.prototype.setStyle = /**
     * Sets element's style which effectively positions provided element according
     * to provided position settings
     * @protected
     * @param {?} element Element to position
     * @param {?} targetRect Bounding rectangle of strategy target
     * @param {?} elementRect Bounding rectangle of the element
     * @return {?}
     */
    function (element, targetRect, elementRect) {
        /** @type {?} */
        var startPoint = {
            x: targetRect.right + targetRect.width * this.settings.horizontalStartPoint,
            y: targetRect.bottom + targetRect.height * this.settings.verticalStartPoint,
        };
        /** @type {?} */
        var wrapperRect = element.parentElement.getBoundingClientRect();
        //  clean up styles - if auto position strategy is chosen we may pass here several times
        element.style.right = '';
        element.style.left = '';
        element.style.bottom = '';
        element.style.top = '';
        switch (this.settings.horizontalDirection) {
            case HorizontalAlignment.Left:
                element.style.right = Math.round(wrapperRect.right - startPoint.x) + "px";
                break;
            case HorizontalAlignment.Center:
                element.style.left = Math.round(startPoint.x - wrapperRect.left - elementRect.width / 2) + "px";
                break;
            case HorizontalAlignment.Right:
                element.style.left = Math.round(startPoint.x - wrapperRect.left) + "px";
                break;
        }
        switch (this.settings.verticalDirection) {
            case VerticalAlignment.Top:
                element.style.bottom = Math.round(wrapperRect.bottom - startPoint.y) + "px";
                break;
            case VerticalAlignment.Middle:
                element.style.top = Math.round(startPoint.y - wrapperRect.top - elementRect.height / 2) + "px";
                break;
            case VerticalAlignment.Bottom:
                element.style.top = Math.round(startPoint.y - wrapperRect.top) + "px";
                break;
        }
    };
    return ConnectedPositioningStrategy;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @abstract
 */
var /**
 * @abstract
 */
BaseFitPositionStrategy = /** @class */ (function (_super) {
    __extends(BaseFitPositionStrategy, _super);
    function BaseFitPositionStrategy() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    /**
     * \@inheritdoc
     * @param {?} contentElement
     * @param {?} size
     * @param {?=} document
     * @param {?=} initialCall
     * @return {?}
     */
    BaseFitPositionStrategy.prototype.position = /**
     * \@inheritdoc
     * @param {?} contentElement
     * @param {?} size
     * @param {?=} document
     * @param {?=} initialCall
     * @return {?}
     */
    function (contentElement, size, document, initialCall) {
        /** @type {?} */
        var targetRect = getTargetRect(this.settings);
        /** @type {?} */
        var contentElementRect = contentElement.getBoundingClientRect();
        if (initialCall) {
            /** @type {?} */
            var connectedFit = {};
            connectedFit.targetRect = targetRect;
            connectedFit.contentElementRect = contentElementRect;
            this._initialSettings = this._initialSettings || Object.assign({}, this.settings);
            this.settings = Object.assign({}, this._initialSettings);
            connectedFit.viewPortRect = getViewportRect(document);
            this.updateViewPortFit(connectedFit);
            if (!connectedFit.fitHorizontal || !connectedFit.fitVertical) {
                this.fitInViewport(contentElement, connectedFit);
            }
        }
        this.setStyle(contentElement, targetRect, contentElementRect);
    };
    /**
     * Checks if element can fit in viewport and updates provided connectedFit
     * with the result
     * @param connectedFit connectedFit to update
     */
    /**
     * Checks if element can fit in viewport and updates provided connectedFit
     * with the result
     * @protected
     * @param {?} connectedFit connectedFit to update
     * @return {?}
     */
    BaseFitPositionStrategy.prototype.updateViewPortFit = /**
     * Checks if element can fit in viewport and updates provided connectedFit
     * with the result
     * @protected
     * @param {?} connectedFit connectedFit to update
     * @return {?}
     */
    function (connectedFit) {
        connectedFit.left = this.calculateLeft(connectedFit.targetRect, connectedFit.contentElementRect, this.settings.horizontalStartPoint, this.settings.horizontalDirection);
        connectedFit.right = connectedFit.left + connectedFit.contentElementRect.width;
        connectedFit.fitHorizontal =
            connectedFit.viewPortRect.left < connectedFit.left && connectedFit.right < connectedFit.viewPortRect.right;
        connectedFit.top = this.calculateTop(connectedFit.targetRect, connectedFit.contentElementRect, this.settings.verticalStartPoint, this.settings.verticalDirection);
        connectedFit.bottom = connectedFit.top + connectedFit.contentElementRect.height;
        connectedFit.fitVertical =
            connectedFit.viewPortRect.top < connectedFit.top && connectedFit.bottom < connectedFit.viewPortRect.bottom;
    };
    /**
     * Calculates the position of the left border of the element if it gets positioned
     * with provided start point and direction
     * @param targetRect Rectangle of the target where element is attached
     * @param elementRect Rectangle of the element
     * @param startPoint Start point of the target
     * @param direction Direction in which to show the element
     */
    /**
     * Calculates the position of the left border of the element if it gets positioned
     * with provided start point and direction
     * @protected
     * @param {?} targetRect Rectangle of the target where element is attached
     * @param {?} elementRect Rectangle of the element
     * @param {?} startPoint Start point of the target
     * @param {?} direction Direction in which to show the element
     * @return {?}
     */
    BaseFitPositionStrategy.prototype.calculateLeft = /**
     * Calculates the position of the left border of the element if it gets positioned
     * with provided start point and direction
     * @protected
     * @param {?} targetRect Rectangle of the target where element is attached
     * @param {?} elementRect Rectangle of the element
     * @param {?} startPoint Start point of the target
     * @param {?} direction Direction in which to show the element
     * @return {?}
     */
    function (targetRect, elementRect, startPoint, direction) {
        return targetRect.right + targetRect.width * startPoint + elementRect.width * direction;
    };
    /**
     * Calculates the position of the top border of the element if it gets positioned
     * with provided position settings related to the target
     * @param targetRect Rectangle of the target where element is attached
     * @param elementRect Rectangle of the element
     * @param startPoint Start point of the target
     * @param direction Direction in which to show the element
     */
    /**
     * Calculates the position of the top border of the element if it gets positioned
     * with provided position settings related to the target
     * @protected
     * @param {?} targetRect Rectangle of the target where element is attached
     * @param {?} elementRect Rectangle of the element
     * @param {?} startPoint Start point of the target
     * @param {?} direction Direction in which to show the element
     * @return {?}
     */
    BaseFitPositionStrategy.prototype.calculateTop = /**
     * Calculates the position of the top border of the element if it gets positioned
     * with provided position settings related to the target
     * @protected
     * @param {?} targetRect Rectangle of the target where element is attached
     * @param {?} elementRect Rectangle of the element
     * @param {?} startPoint Start point of the target
     * @param {?} direction Direction in which to show the element
     * @return {?}
     */
    function (targetRect, elementRect, startPoint, direction) {
        return targetRect.bottom + targetRect.height * startPoint + elementRect.height * direction;
    };
    return BaseFitPositionStrategy;
}(ConnectedPositioningStrategy));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Positions the element as in **Connected** positioning strategy and re-positions the element in
 * the view port (calculating a different start point) in case the element is partially getting out of view
 */
var  /**
 * Positions the element as in **Connected** positioning strategy and re-positions the element in
 * the view port (calculating a different start point) in case the element is partially getting out of view
 */
AutoPositionStrategy = /** @class */ (function (_super) {
    __extends(AutoPositionStrategy, _super);
    function AutoPositionStrategy() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    /**
     * \@inheritdoc
     * @protected
     * @param {?} element
     * @param {?} connectedFit
     * @return {?}
     */
    AutoPositionStrategy.prototype.fitInViewport = /**
     * \@inheritdoc
     * @protected
     * @param {?} element
     * @param {?} connectedFit
     * @return {?}
     */
    function (element, connectedFit) {
        /** @type {?} */
        var transformString = [];
        if (!connectedFit.fitHorizontal) {
            if (this.canFlipHorizontal(connectedFit)) {
                this.flipHorizontal();
            }
            else {
                /** @type {?} */
                var horizontalPush = this.horizontalPush(connectedFit);
                transformString.push("translateX(" + horizontalPush + "px)");
            }
        }
        if (!connectedFit.fitVertical) {
            if (this.canFlipVertical(connectedFit)) {
                this.flipVertical();
            }
            else {
                /** @type {?} */
                var verticalPush = this.verticalPush(connectedFit);
                transformString.push("translateY(" + verticalPush + "px)");
            }
        }
        element.style.transform = transformString.join(' ').trim();
    };
    /**
     * Checks if element can be flipped without get off the viewport
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns true if element can be flipped and stain in viewport
     */
    /**
     * Checks if element can be flipped without get off the viewport
     * @private
     * @param {?} connectedFit connectedFit object containing all necessary parameters
     * @return {?} true if element can be flipped and stain in viewport
     */
    AutoPositionStrategy.prototype.canFlipHorizontal = /**
     * Checks if element can be flipped without get off the viewport
     * @private
     * @param {?} connectedFit connectedFit object containing all necessary parameters
     * @return {?} true if element can be flipped and stain in viewport
     */
    function (connectedFit) {
        //  HorizontalAlignment can be Left = -1; Center = -0.5 or Right = 0.
        //  To virtually flip direction and start point (both are HorizontalAlignment) we can do this:
        //  flippedAlignment = (-1) * (HorizontalAlignment + 1)
        //  this way:
        //  (-1) * (Left + 1) = 0 = Right
        //  (-1) * (Center + 1) = -0.5 = Center
        //  (-1) * (Right + 1) = -1 = Left
        /** @type {?} */
        var flippedStartPoint = (-1) * (this.settings.horizontalStartPoint + 1);
        /** @type {?} */
        var flippedDirection = (-1) * (this.settings.horizontalDirection + 1);
        /** @type {?} */
        var leftBorder = this.calculateLeft(connectedFit.targetRect, connectedFit.contentElementRect, flippedStartPoint, flippedDirection);
        /** @type {?} */
        var rightBorder = leftBorder + connectedFit.contentElementRect.width;
        return connectedFit.viewPortRect.left < leftBorder && rightBorder < connectedFit.viewPortRect.right;
    };
    /**
     * Checks if element can be flipped without get off the viewport
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns true if element can be flipped and stain in viewport
     */
    /**
     * Checks if element can be flipped without get off the viewport
     * @private
     * @param {?} connectedFit connectedFit object containing all necessary parameters
     * @return {?} true if element can be flipped and stain in viewport
     */
    AutoPositionStrategy.prototype.canFlipVertical = /**
     * Checks if element can be flipped without get off the viewport
     * @private
     * @param {?} connectedFit connectedFit object containing all necessary parameters
     * @return {?} true if element can be flipped and stain in viewport
     */
    function (connectedFit) {
        /** @type {?} */
        var flippedStartPoint = (-1) * (this.settings.verticalStartPoint + 1);
        /** @type {?} */
        var flippedDirection = (-1) * (this.settings.verticalDirection + 1);
        /** @type {?} */
        var topBorder = this.calculateTop(connectedFit.targetRect, connectedFit.contentElementRect, flippedStartPoint, flippedDirection);
        /** @type {?} */
        var bottomBorder = topBorder + connectedFit.contentElementRect.height;
        return connectedFit.viewPortRect.top < topBorder && bottomBorder < connectedFit.viewPortRect.bottom;
    };
    /**
     * Flips direction and start point of the position settings
     */
    /**
     * Flips direction and start point of the position settings
     * @private
     * @return {?}
     */
    AutoPositionStrategy.prototype.flipHorizontal = /**
     * Flips direction and start point of the position settings
     * @private
     * @return {?}
     */
    function () {
        switch (this.settings.horizontalDirection) {
            case HorizontalAlignment.Left:
                this.settings.horizontalDirection = HorizontalAlignment.Right;
                break;
            case HorizontalAlignment.Right:
                this.settings.horizontalDirection = HorizontalAlignment.Left;
                break;
        }
        switch (this.settings.horizontalStartPoint) {
            case HorizontalAlignment.Left:
                this.settings.horizontalStartPoint = HorizontalAlignment.Right;
                break;
            case HorizontalAlignment.Right:
                this.settings.horizontalStartPoint = HorizontalAlignment.Left;
                break;
        }
    };
    /**
     * Flips direction and start point of the position settings
     */
    /**
     * Flips direction and start point of the position settings
     * @private
     * @return {?}
     */
    AutoPositionStrategy.prototype.flipVertical = /**
     * Flips direction and start point of the position settings
     * @private
     * @return {?}
     */
    function () {
        switch (this.settings.verticalDirection) {
            case VerticalAlignment.Top:
                this.settings.verticalDirection = VerticalAlignment.Bottom;
                break;
            case VerticalAlignment.Bottom:
                this.settings.verticalDirection = VerticalAlignment.Top;
                break;
        }
        switch (this.settings.verticalStartPoint) {
            case VerticalAlignment.Top:
                this.settings.verticalStartPoint = VerticalAlignment.Bottom;
                break;
            case VerticalAlignment.Bottom:
                this.settings.verticalStartPoint = VerticalAlignment.Top;
                break;
        }
    };
    /**
     * Calculates necessary horizontal push according to provided connectedFit
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns amount of necessary translation which will push the element into viewport
     */
    /**
     * Calculates necessary horizontal push according to provided connectedFit
     * @private
     * @param {?} connectedFit connectedFit object containing all necessary parameters
     * @return {?} amount of necessary translation which will push the element into viewport
     */
    AutoPositionStrategy.prototype.horizontalPush = /**
     * Calculates necessary horizontal push according to provided connectedFit
     * @private
     * @param {?} connectedFit connectedFit object containing all necessary parameters
     * @return {?} amount of necessary translation which will push the element into viewport
     */
    function (connectedFit) {
        /** @type {?} */
        var leftExtend = connectedFit.left;
        /** @type {?} */
        var rightExtend = connectedFit.right - connectedFit.viewPortRect.right;
        //  if leftExtend < 0 overlay goes beyond left end of the screen. We should push it back with exactly
        //  as much as it is beyond the screen.
        //  if rightExtend > 0 overlay goes beyond right end of the screen. We should push it back with the
        //  extend but with amount not bigger than what left between left border of screen and left border of
        //  overlay, e.g. leftExtend
        if (leftExtend < 0) {
            return Math.abs(leftExtend);
        }
        else if (rightExtend > 0) {
            return -Math.min(rightExtend, leftExtend);
        }
        else {
            return 0;
        }
    };
    /**
     * Calculates necessary vertical push according to provided connectedFit
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns amount of necessary translation which will push the element into viewport
     */
    /**
     * Calculates necessary vertical push according to provided connectedFit
     * @private
     * @param {?} connectedFit connectedFit object containing all necessary parameters
     * @return {?} amount of necessary translation which will push the element into viewport
     */
    AutoPositionStrategy.prototype.verticalPush = /**
     * Calculates necessary vertical push according to provided connectedFit
     * @private
     * @param {?} connectedFit connectedFit object containing all necessary parameters
     * @return {?} amount of necessary translation which will push the element into viewport
     */
    function (connectedFit) {
        /** @type {?} */
        var topExtend = connectedFit.top;
        /** @type {?} */
        var bottomExtend = connectedFit.bottom - connectedFit.viewPortRect.bottom;
        if (topExtend < 0) {
            return Math.abs(topExtend);
        }
        else if (bottomExtend > 0) {
            return -Math.min(bottomExtend, topExtend);
        }
        else {
            return 0;
        }
    };
    return AutoPositionStrategy;
}(BaseFitPositionStrategy));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Positions the element as in **Connected** positioning strategy and resize the element
 * to fit in the view port in case the element is partially getting out of view
 */
var  /**
 * Positions the element as in **Connected** positioning strategy and resize the element
 * to fit in the view port in case the element is partially getting out of view
 */
ElasticPositionStrategy = /** @class */ (function (_super) {
    __extends(ElasticPositionStrategy, _super);
    function ElasticPositionStrategy() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    /**
     * \@inheritdoc
     * @protected
     * @param {?} element
     * @param {?} connectedFit
     * @return {?}
     */
    ElasticPositionStrategy.prototype.fitInViewport = /**
     * \@inheritdoc
     * @protected
     * @param {?} element
     * @param {?} connectedFit
     * @return {?}
     */
    function (element, connectedFit) {
        element.classList.add('igx-overlay__content--elastic');
        /** @type {?} */
        var transformString = [];
        if (!connectedFit.fitHorizontal) {
            /** @type {?} */
            var maxReduction = Math.max(0, connectedFit.contentElementRect.width - this.settings.minSize.width);
            /** @type {?} */
            var leftExtend = Math.max(0, connectedFit.viewPortRect.left - connectedFit.left);
            /** @type {?} */
            var rightExtend = Math.max(0, connectedFit.right - connectedFit.viewPortRect.right);
            /** @type {?} */
            var reduction = Math.min(maxReduction, leftExtend + rightExtend);
            element.style.width = connectedFit.contentElementRect.width - reduction + "px";
            //  if direction is center and element goes off the screen in left direction we should push the
            //  element to the right. Prevents left still going out of view when normally positioned
            if (this.settings.horizontalDirection === HorizontalAlignment.Center) {
                //  the amount of translation depends on whether element goes off the screen to the left,
                //  to the right or in both directions, as well as how much it goes of the screen and finally
                //  on the minSize. The translation should be proportional between left and right extend
                //  taken from the reduction
                /** @type {?} */
                var translation = leftExtend * reduction / (leftExtend + rightExtend);
                if (translation > 0) {
                    transformString.push("translateX(" + translation + "px)");
                }
            }
        }
        if (!connectedFit.fitVertical) {
            /** @type {?} */
            var maxReduction = Math.max(0, connectedFit.contentElementRect.height - this.settings.minSize.height);
            /** @type {?} */
            var topExtend = Math.max(0, connectedFit.viewPortRect.top - connectedFit.top);
            /** @type {?} */
            var bottomExtend = Math.max(0, connectedFit.bottom - connectedFit.viewPortRect.bottom);
            /** @type {?} */
            var reduction = Math.min(maxReduction, topExtend + bottomExtend);
            element.style.height = connectedFit.contentElementRect.height - reduction + "px";
            //  if direction is middle and element goes off the screen in top direction we should push the
            //  element to the bottom. Prevents top still going out of view when normally positioned
            if (this.settings.verticalDirection === VerticalAlignment.Middle) {
                //  the amount of translation depends on whether element goes off the screen to the top,
                //  to the bottom or in both directions, as well as how much it goes of the screen and finally
                //  on the minSize. The translation should be proportional between top and bottom extend
                //  taken from the reduction
                /** @type {?} */
                var translation = topExtend * reduction / (topExtend + bottomExtend);
                if (translation > 0) {
                    transformString.push("translateY(" + translation + "px)");
                }
            }
        }
        element.style.transform = transformString.join(' ').trim();
    };
    return ElasticPositionStrategy;
}(BaseFitPositionStrategy));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * On scroll reposition the overlay content.
 */
var  /**
 * On scroll reposition the overlay content.
 */
AbsoluteScrollStrategy = /** @class */ (function (_super) {
    __extends(AbsoluteScrollStrategy, _super);
    function AbsoluteScrollStrategy(scrollContainer) {
        var _this = _super.call(this, scrollContainer) || this;
        _this._initialized = false;
        _this.onScroll = function () {
            _this._overlayService.repositionAll();
        };
        _this._scrollContainer = scrollContainer;
        return _this;
    }
    /** @inheritdoc */
    /**
     * \@inheritdoc
     * @param {?} document
     * @param {?} overlayService
     * @param {?} id
     * @return {?}
     */
    AbsoluteScrollStrategy.prototype.initialize = /**
     * \@inheritdoc
     * @param {?} document
     * @param {?} overlayService
     * @param {?} id
     * @return {?}
     */
    function (document, overlayService, id) {
        if (this._initialized) {
            return;
        }
        this._overlayService = overlayService;
        this._id = id;
        this._document = document;
        this._zone = overlayService.getOverlayById(id).ngZone;
        this._initialized = true;
    };
    /** @inheritdoc */
    /**
     * \@inheritdoc
     * @return {?}
     */
    AbsoluteScrollStrategy.prototype.attach = /**
     * \@inheritdoc
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._zone) {
            this._zone.runOutsideAngular(function () {
                _this.addScrollEventListener();
            });
        }
        else {
            this.addScrollEventListener();
        }
    };
    /** @inheritdoc */
    /**
     * \@inheritdoc
     * @return {?}
     */
    AbsoluteScrollStrategy.prototype.detach = /**
     * \@inheritdoc
     * @return {?}
     */
    function () {
        if (this._scrollContainer) {
            this._scrollContainer.removeEventListener('scroll', this.onScroll, true);
        }
        else {
            this._document.removeEventListener('scroll', this.onScroll, true);
        }
        this._initialized = false;
    };
    /**
     * @private
     * @return {?}
     */
    AbsoluteScrollStrategy.prototype.addScrollEventListener = /**
     * @private
     * @return {?}
     */
    function () {
        if (this._scrollContainer) {
            this._scrollContainer.addEventListener('scroll', this.onScroll, true);
        }
        else {
            this._document.addEventListener('scroll', this.onScroll, true);
        }
    };
    return AbsoluteScrollStrategy;
}(ScrollStrategy));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Prevents scrolling while the overlay content is shown.
 */
var  /**
 * Prevents scrolling while the overlay content is shown.
 */
BlockScrollStrategy = /** @class */ (function (_super) {
    __extends(BlockScrollStrategy, _super);
    function BlockScrollStrategy(scrollContainer) {
        var _this = _super.call(this, scrollContainer) || this;
        _this._initialized = false;
        _this.onScroll = function (ev) {
            ev.preventDefault();
            if (!_this._sourceElement || _this._sourceElement !== ev.srcElement) {
                _this._sourceElement = ev.srcElement;
                _this._initialScrollTop = _this._sourceElement.scrollTop;
                _this._initialScrollLeft = _this._sourceElement.scrollLeft;
            }
            _this._sourceElement.scrollTop = _this._initialScrollTop;
            _this._sourceElement.scrollLeft = _this._initialScrollLeft;
        };
        return _this;
    }
    /** @inheritdoc */
    /**
     * \@inheritdoc
     * @param {?} document
     * @param {?} overlayService
     * @param {?} id
     * @return {?}
     */
    BlockScrollStrategy.prototype.initialize = /**
     * \@inheritdoc
     * @param {?} document
     * @param {?} overlayService
     * @param {?} id
     * @return {?}
     */
    function (document, overlayService, id) {
        if (this._initialized) {
            return;
        }
        this._document = document;
        this._initialized = true;
    };
    /** @inheritdoc */
    /**
     * \@inheritdoc
     * @return {?}
     */
    BlockScrollStrategy.prototype.attach = /**
     * \@inheritdoc
     * @return {?}
     */
    function () {
        this._document.addEventListener('scroll', this.onScroll, true);
        this._document.addEventListener('wheel', this.onWheel, true);
    };
    /** @inheritdoc */
    /**
     * \@inheritdoc
     * @return {?}
     */
    BlockScrollStrategy.prototype.detach = /**
     * \@inheritdoc
     * @return {?}
     */
    function () {
        this._document.removeEventListener('scroll', this.onScroll, true);
        this._document.removeEventListener('wheel', this.onWheel, true);
        this._sourceElement = null;
        this._initialScrollTop = 0;
        this._initialScrollLeft = 0;
        this._initialized = false;
    };
    /**
     * @private
     * @param {?} ev
     * @return {?}
     */
    BlockScrollStrategy.prototype.onWheel = /**
     * @private
     * @param {?} ev
     * @return {?}
     */
    function (ev) {
        ev.stopImmediatePropagation();
        ev.preventDefault();
    };
    return BlockScrollStrategy;
}(ScrollStrategy));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Uses a tolerance and closes the shown component upon scrolling if the tolerance is exceeded
 */
var  /**
 * Uses a tolerance and closes the shown component upon scrolling if the tolerance is exceeded
 */
CloseScrollStrategy = /** @class */ (function (_super) {
    __extends(CloseScrollStrategy, _super);
    function CloseScrollStrategy(scrollContainer) {
        var _this = _super.call(this, scrollContainer) || this;
        _this._initialized = false;
        _this.onScroll = function (ev) {
            if (!_this._sourceElement) {
                return;
            }
            _this.cumulativeScrollTop += _this._sourceElement.scrollTop;
            _this.cumulativeScrollLeft += _this._sourceElement.scrollLeft;
            if (Math.abs(_this.cumulativeScrollTop - _this.initialScrollTop) > _this._threshold ||
                Math.abs(_this.cumulativeScrollLeft - _this.initialScrollLeft) > _this._threshold) {
                _this._document.removeEventListener('scroll', _this.onScroll, true);
                _this._overlayService.hide(_this._id);
            }
        };
        _this._scrollContainer = scrollContainer;
        _this._threshold = 10;
        _this.cumulativeScrollTop = 0;
        _this.cumulativeScrollLeft = 0;
        return _this;
    }
    /** @inheritdoc */
    /**
     * \@inheritdoc
     * @param {?} document
     * @param {?} overlayService
     * @param {?} id
     * @return {?}
     */
    CloseScrollStrategy.prototype.initialize = /**
     * \@inheritdoc
     * @param {?} document
     * @param {?} overlayService
     * @param {?} id
     * @return {?}
     */
    function (document, overlayService, id) {
        if (this._initialized) {
            return;
        }
        this._overlayService = overlayService;
        this._id = id;
        this._document = document;
        this._initialized = true;
    };
    /** @inheritdoc */
    /**
     * \@inheritdoc
     * @return {?}
     */
    CloseScrollStrategy.prototype.attach = /**
     * \@inheritdoc
     * @return {?}
     */
    function () {
        if (this._scrollContainer) {
            this._scrollContainer.addEventListener('scroll', this.onScroll);
            this._sourceElement = this._scrollContainer;
        }
        else {
            this._document.addEventListener('scroll', this.onScroll);
            if (document.documentElement.scrollHeight > document.documentElement.clientHeight) {
                this._sourceElement = (/** @type {?} */ (document.documentElement));
            }
            else if (document.body.scrollHeight > document.body.clientHeight) {
                this._sourceElement = (/** @type {?} */ (document.body));
            }
        }
        if (!this._sourceElement) {
            return;
        }
        this.cumulativeScrollTop = 0;
        this.cumulativeScrollLeft = 0;
        this.initialScrollTop = this._sourceElement.scrollTop;
        this.initialScrollLeft = this._sourceElement.scrollLeft;
    };
    /** @inheritdoc */
    /**
     * \@inheritdoc
     * @return {?}
     */
    CloseScrollStrategy.prototype.detach = /**
     * \@inheritdoc
     * @return {?}
     */
    function () {
        // TODO: check why event listener removes only on first call and remains on each next!!!
        if (this._scrollContainer) {
            this._scrollContainer.removeEventListener('scroll', this.onScroll);
        }
        else {
            this._document.removeEventListener('scroll', this.onScroll);
        }
        this._sourceElement = null;
        this.cumulativeScrollTop = 0;
        this.cumulativeScrollLeft = 0;
        this.initialScrollTop = 0;
        this.initialScrollLeft = 0;
        this._initialized = false;
    };
    return CloseScrollStrategy;
}(ScrollStrategy));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T, S
 */
var IgxBaseTransactionService = /** @class */ (function () {
    function IgxBaseTransactionService() {
        this._isPending = false;
        this._pendingTransactions = [];
        this._pendingStates = new Map();
        /**
         * \@inheritdoc
         */
        this.onStateUpdate = new EventEmitter();
    }
    Object.defineProperty(IgxBaseTransactionService.prototype, "canRedo", {
        /**
         * @inheritdoc
         */
        get: /**
         * \@inheritdoc
         * @return {?}
         */
        function () {
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxBaseTransactionService.prototype, "canUndo", {
        /**
         * @inheritdoc
         */
        get: /**
         * \@inheritdoc
         * @return {?}
         */
        function () {
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxBaseTransactionService.prototype, "enabled", {
        /**
         * @inheritdoc
         */
        get: /**
         * \@inheritdoc
         * @return {?}
         */
        function () {
            return this._isPending;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritdoc
     */
    /**
     * \@inheritdoc
     * @param {?} transaction
     * @param {?=} recordRef
     * @return {?}
     */
    IgxBaseTransactionService.prototype.add = /**
     * \@inheritdoc
     * @param {?} transaction
     * @param {?=} recordRef
     * @return {?}
     */
    function (transaction, recordRef) {
        if (this._isPending) {
            this.updateState(this._pendingStates, transaction, recordRef);
            this._pendingTransactions.push(transaction);
        }
    };
    /**
     * @inheritdoc
     */
    /**
     * \@inheritdoc
     * @param {?=} id
     * @return {?}
     */
    IgxBaseTransactionService.prototype.getTransactionLog = /**
     * \@inheritdoc
     * @param {?=} id
     * @return {?}
     */
    function (id) { return []; };
    /**
     * @inheritdoc
     */
    /**
     * \@inheritdoc
     * @return {?}
     */
    IgxBaseTransactionService.prototype.undo = /**
     * \@inheritdoc
     * @return {?}
     */
    function () { };
    /**
     * @inheritdoc
     */
    /**
     * \@inheritdoc
     * @return {?}
     */
    IgxBaseTransactionService.prototype.redo = /**
     * \@inheritdoc
     * @return {?}
     */
    function () { };
    /**
     * @inheritdoc
     */
    /**
     * \@inheritdoc
     * @param {?} mergeChanges
     * @return {?}
     */
    IgxBaseTransactionService.prototype.getAggregatedChanges = /**
     * \@inheritdoc
     * @param {?} mergeChanges
     * @return {?}
     */
    function (mergeChanges) {
        var _this = this;
        /** @type {?} */
        var result = [];
        this._pendingStates.forEach(function (state$$1, key) {
            /** @type {?} */
            var value = mergeChanges ? _this.getAggregatedValue(key, mergeChanges) : state$$1.value;
            result.push((/** @type {?} */ ({ id: key, newValue: value, type: state$$1.type })));
        });
        return result;
    };
    /**
     * @inheritdoc
     */
    /**
     * \@inheritdoc
     * @param {?} id
     * @return {?}
     */
    IgxBaseTransactionService.prototype.getState = /**
     * \@inheritdoc
     * @param {?} id
     * @return {?}
     */
    function (id) {
        return this._pendingStates.get(id);
    };
    /**
     * @inheritdoc
     */
    /**
     * \@inheritdoc
     * @param {?} id
     * @param {?} mergeChanges
     * @return {?}
     */
    IgxBaseTransactionService.prototype.getAggregatedValue = /**
     * \@inheritdoc
     * @param {?} id
     * @param {?} mergeChanges
     * @return {?}
     */
    function (id, mergeChanges) {
        /** @type {?} */
        var state$$1 = this._pendingStates.get(id);
        if (!state$$1) {
            return null;
        }
        if (mergeChanges) {
            return this.updateValue(state$$1);
        }
        return state$$1.value;
    };
    /**
     * @inheritdoc
     */
    /**
     * \@inheritdoc
     * @param {?} data
     * @return {?}
     */
    IgxBaseTransactionService.prototype.commit = /**
     * \@inheritdoc
     * @param {?} data
     * @return {?}
     */
    function (data) { };
    /**
     * @inheritdoc
     */
    /**
     * \@inheritdoc
     * @return {?}
     */
    IgxBaseTransactionService.prototype.clear = /**
     * \@inheritdoc
     * @return {?}
     */
    function () {
        this._pendingStates.clear();
        this._pendingTransactions = [];
    };
    /**
     * @inheritdoc
     */
    /**
     * \@inheritdoc
     * @return {?}
     */
    IgxBaseTransactionService.prototype.startPending = /**
     * \@inheritdoc
     * @return {?}
     */
    function () {
        this._isPending = true;
    };
    /**
     * @inheritdoc
     */
    /**
     * \@inheritdoc
     * @param {?} commit
     * @return {?}
     */
    IgxBaseTransactionService.prototype.endPending = /**
     * \@inheritdoc
     * @param {?} commit
     * @return {?}
     */
    function (commit) {
        this._isPending = false;
        this._pendingStates.clear();
        this._pendingTransactions = [];
    };
    /**
     * Updates the provided states collection according to passed transaction and recordRef
     * @param states States collection to apply the update to
     * @param transaction Transaction to apply to the current state
     * @param recordRef Reference to the value of the record in data source, if any, where transaction should be applied
     */
    /**
     * Updates the provided states collection according to passed transaction and recordRef
     * @protected
     * @param {?} states States collection to apply the update to
     * @param {?} transaction Transaction to apply to the current state
     * @param {?=} recordRef Reference to the value of the record in data source, if any, where transaction should be applied
     * @return {?}
     */
    IgxBaseTransactionService.prototype.updateState = /**
     * Updates the provided states collection according to passed transaction and recordRef
     * @protected
     * @param {?} states States collection to apply the update to
     * @param {?} transaction Transaction to apply to the current state
     * @param {?=} recordRef Reference to the value of the record in data source, if any, where transaction should be applied
     * @return {?}
     */
    function (states, transaction, recordRef) {
        /** @type {?} */
        var state$$1 = states.get(transaction.id);
        if (state$$1) {
            if (isObject(state$$1.value)) {
                mergeObjects(state$$1.value, transaction.newValue);
            }
            else {
                state$$1.value = transaction.newValue;
            }
        }
        else {
            state$$1 = (/** @type {?} */ ({ value: cloneValue(transaction.newValue), recordRef: recordRef, type: transaction.type }));
            states.set(transaction.id, state$$1);
        }
    };
    /**
     * Updates the recordRef of the provided state with all the changes in the state. Accepts primitive and object value types
     * @param state State to update value for
     * @returns updated value including all the changes in provided state
     */
    /**
     * Updates the recordRef of the provided state with all the changes in the state. Accepts primitive and object value types
     * @protected
     * @param {?} state State to update value for
     * @return {?} updated value including all the changes in provided state
     */
    IgxBaseTransactionService.prototype.updateValue = /**
     * Updates the recordRef of the provided state with all the changes in the state. Accepts primitive and object value types
     * @protected
     * @param {?} state State to update value for
     * @return {?} updated value including all the changes in provided state
     */
    function (state$$1) {
        return this.mergeValues(state$$1.recordRef, state$$1.value);
    };
    /**
     * Merges second values in first value and the result in empty object. If values are primitive type
     * returns second value if exists, or first value.
     * @param first Value to merge into
     * @param second Value to merge
     */
    /**
     * Merges second values in first value and the result in empty object. If values are primitive type
     * returns second value if exists, or first value.
     * @protected
     * @template U
     * @param {?} first Value to merge into
     * @param {?} second Value to merge
     * @return {?}
     */
    IgxBaseTransactionService.prototype.mergeValues = /**
     * Merges second values in first value and the result in empty object. If values are primitive type
     * returns second value if exists, or first value.
     * @protected
     * @template U
     * @param {?} first Value to merge into
     * @param {?} second Value to merge
     * @return {?}
     */
    function (first$$1, second) {
        /** @type {?} */
        var result;
        if (isObject(first$$1) || isObject(second)) {
            result = mergeObjects(mergeObjects({}, first$$1), second);
        }
        else {
            result = second ? second : first$$1;
        }
        return result;
    };
    IgxBaseTransactionService.decorators = [
        { type: Injectable }
    ];
    return IgxBaseTransactionService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T, S
 */
var IgxTransactionService = /** @class */ (function (_super) {
    __extends(IgxTransactionService, _super);
    function IgxTransactionService() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._transactions = [];
        _this._redoStack = [];
        _this._undoStack = [];
        _this._states = new Map();
        /**
         * \@inheritdoc
         */
        _this.onStateUpdate = new EventEmitter();
        return _this;
    }
    Object.defineProperty(IgxTransactionService.prototype, "canUndo", {
        /**
         * @inheritdoc
         */
        get: /**
         * \@inheritdoc
         * @return {?}
         */
        function () {
            return this._undoStack.length > 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTransactionService.prototype, "canRedo", {
        /**
         * @inheritdoc
         */
        get: /**
         * \@inheritdoc
         * @return {?}
         */
        function () {
            return this._redoStack.length > 0;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritdoc
     */
    /**
     * \@inheritdoc
     * @param {?} transaction
     * @param {?=} recordRef
     * @return {?}
     */
    IgxTransactionService.prototype.add = /**
     * \@inheritdoc
     * @param {?} transaction
     * @param {?=} recordRef
     * @return {?}
     */
    function (transaction, recordRef) {
        /** @type {?} */
        var states = this._isPending ? this._pendingStates : this._states;
        this.verifyAddedTransaction(states, transaction, recordRef);
        this.addTransaction(transaction, states, recordRef);
    };
    /**
     * @protected
     * @param {?} transaction
     * @param {?} states
     * @param {?=} recordRef
     * @return {?}
     */
    IgxTransactionService.prototype.addTransaction = /**
     * @protected
     * @param {?} transaction
     * @param {?} states
     * @param {?=} recordRef
     * @return {?}
     */
    function (transaction, states, recordRef) {
        this.updateState(states, transaction, recordRef);
        /** @type {?} */
        var transactions = this._isPending ? this._pendingTransactions : this._transactions;
        transactions.push(transaction);
        if (!this._isPending) {
            this._undoStack.push([{ transaction: transaction, recordRef: recordRef }]);
            this._redoStack = [];
            this.onStateUpdate.emit();
        }
    };
    /**
     * @inheritdoc
     */
    /**
     * \@inheritdoc
     * @param {?=} id
     * @return {?}
     */
    IgxTransactionService.prototype.getTransactionLog = /**
     * \@inheritdoc
     * @param {?=} id
     * @return {?}
     */
    function (id) {
        if (id) {
            return this._transactions.filter(function (t) { return t.id === id; });
        }
        return __spread(this._transactions);
    };
    /**
     * @inheritdoc
     */
    /**
     * \@inheritdoc
     * @param {?} mergeChanges
     * @return {?}
     */
    IgxTransactionService.prototype.getAggregatedChanges = /**
     * \@inheritdoc
     * @param {?} mergeChanges
     * @return {?}
     */
    function (mergeChanges) {
        var _this = this;
        /** @type {?} */
        var result = [];
        this._states.forEach(function (state$$1, key) {
            /** @type {?} */
            var value = mergeChanges ? _this.mergeValues(state$$1.recordRef, state$$1.value) : state$$1.value;
            result.push((/** @type {?} */ ({ id: key, newValue: value, type: state$$1.type })));
        });
        return result;
    };
    /**
     * @inheritdoc
     */
    /**
     * \@inheritdoc
     * @param {?} id
     * @return {?}
     */
    IgxTransactionService.prototype.getState = /**
     * \@inheritdoc
     * @param {?} id
     * @return {?}
     */
    function (id) {
        return this._states.get(id);
    };
    Object.defineProperty(IgxTransactionService.prototype, "enabled", {
        /**
         * @inheritdoc
         */
        get: /**
         * \@inheritdoc
         * @return {?}
         */
        function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritdoc
     */
    /**
     * \@inheritdoc
     * @param {?} id
     * @param {?} mergeChanges
     * @return {?}
     */
    IgxTransactionService.prototype.getAggregatedValue = /**
     * \@inheritdoc
     * @param {?} id
     * @param {?} mergeChanges
     * @return {?}
     */
    function (id, mergeChanges) {
        /** @type {?} */
        var state$$1 = this._states.get(id);
        /** @type {?} */
        var pendingState = _super.prototype.getState.call(this, id);
        //  if there is no state and there is no pending state return null
        if (!state$$1 && !pendingState) {
            return null;
        }
        /** @type {?} */
        var pendingChange = _super.prototype.getAggregatedValue.call(this, id, false);
        /** @type {?} */
        var change = state$$1 && state$$1.value;
        /** @type {?} */
        var aggregatedValue = this.mergeValues(change, pendingChange);
        if (mergeChanges) {
            /** @type {?} */
            var originalValue = state$$1 ? state$$1.recordRef : pendingState.recordRef;
            aggregatedValue = this.mergeValues(originalValue, aggregatedValue);
        }
        return aggregatedValue;
    };
    /**
     * @inheritdoc
     */
    /**
     * \@inheritdoc
     * @param {?} commit
     * @return {?}
     */
    IgxTransactionService.prototype.endPending = /**
     * \@inheritdoc
     * @param {?} commit
     * @return {?}
     */
    function (commit) {
        var e_1, _a;
        this._isPending = false;
        if (commit) {
            /** @type {?} */
            var actions = [];
            try {
                // don't use addTransaction due to custom undo handling
                for (var _b = __values(this._pendingTransactions), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var transaction = _c.value;
                    /** @type {?} */
                    var pendingState = this._pendingStates.get(transaction.id);
                    this._transactions.push(transaction);
                    this.updateState(this._states, transaction, pendingState.recordRef);
                    actions.push({ transaction: transaction, recordRef: pendingState.recordRef });
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            this._undoStack.push(actions);
            this._redoStack = [];
            this.onStateUpdate.emit();
        }
        _super.prototype.endPending.call(this, commit);
    };
    /**
     * @inheritdoc
     */
    /**
     * \@inheritdoc
     * @param {?} data
     * @return {?}
     */
    IgxTransactionService.prototype.commit = /**
     * \@inheritdoc
     * @param {?} data
     * @return {?}
     */
    function (data) {
        var _this = this;
        this._states.forEach(function (s) {
            /** @type {?} */
            var index = data.findIndex(function (i) { return JSON.stringify(i) === JSON.stringify(s.recordRef); });
            switch (s.type) {
                case TransactionType.ADD:
                    data.push(s.value);
                    break;
                case TransactionType.DELETE:
                    if (0 <= index && index < data.length) {
                        data.splice(index, 1);
                    }
                    break;
                case TransactionType.UPDATE:
                    if (0 <= index && index < data.length) {
                        data[index] = _this.updateValue(s);
                    }
                    break;
            }
        });
        this.clear();
    };
    /**
     * @inheritdoc
     */
    /**
     * \@inheritdoc
     * @return {?}
     */
    IgxTransactionService.prototype.clear = /**
     * \@inheritdoc
     * @return {?}
     */
    function () {
        this._transactions = [];
        this._states.clear();
        this._redoStack = [];
        this._undoStack = [];
        this.onStateUpdate.emit();
    };
    /**
     * @inheritdoc
     */
    /**
     * \@inheritdoc
     * @return {?}
     */
    IgxTransactionService.prototype.undo = /**
     * \@inheritdoc
     * @return {?}
     */
    function () {
        var e_2, _a, e_3, _b;
        if (this._undoStack.length <= 0) {
            return;
        }
        /** @type {?} */
        var lastActions = this._undoStack.pop();
        this._transactions.splice(this._transactions.length - lastActions.length);
        this._redoStack.push(lastActions);
        this._states.clear();
        try {
            for (var _c = __values(this._undoStack), _d = _c.next(); !_d.done; _d = _c.next()) {
                var currentActions = _d.value;
                try {
                    for (var currentActions_1 = __values(currentActions), currentActions_1_1 = currentActions_1.next(); !currentActions_1_1.done; currentActions_1_1 = currentActions_1.next()) {
                        var transaction = currentActions_1_1.value;
                        this.updateState(this._states, transaction.transaction, transaction.recordRef);
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (currentActions_1_1 && !currentActions_1_1.done && (_b = currentActions_1.return)) _b.call(currentActions_1);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_2) throw e_2.error; }
        }
        this.onStateUpdate.emit();
    };
    /**
     * @inheritdoc
     */
    /**
     * \@inheritdoc
     * @return {?}
     */
    IgxTransactionService.prototype.redo = /**
     * \@inheritdoc
     * @return {?}
     */
    function () {
        var e_4, _a;
        if (this._redoStack.length > 0) {
            /** @type {?} */
            var actions = void 0;
            actions = this._redoStack.pop();
            try {
                for (var actions_1 = __values(actions), actions_1_1 = actions_1.next(); !actions_1_1.done; actions_1_1 = actions_1.next()) {
                    var action = actions_1_1.value;
                    this.updateState(this._states, action.transaction, action.recordRef);
                    this._transactions.push(action.transaction);
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (actions_1_1 && !actions_1_1.done && (_a = actions_1.return)) _a.call(actions_1);
                }
                finally { if (e_4) throw e_4.error; }
            }
            this._undoStack.push(actions);
            this.onStateUpdate.emit();
        }
    };
    /**
     * Verifies if the passed transaction is correct. If not throws an exception.
     * @param transaction Transaction to be verified
     */
    /**
     * Verifies if the passed transaction is correct. If not throws an exception.
     * @protected
     * @param {?} states
     * @param {?} transaction Transaction to be verified
     * @param {?=} recordRef
     * @return {?}
     */
    IgxTransactionService.prototype.verifyAddedTransaction = /**
     * Verifies if the passed transaction is correct. If not throws an exception.
     * @protected
     * @param {?} states
     * @param {?} transaction Transaction to be verified
     * @param {?=} recordRef
     * @return {?}
     */
    function (states, transaction, recordRef) {
        /** @type {?} */
        var state$$1 = states.get(transaction.id);
        switch (transaction.type) {
            case TransactionType.ADD:
                if (state$$1) {
                    //  cannot add same item twice
                    throw new Error("Cannot add this transaction. Transaction with id: " + transaction.id + " has been already added.");
                }
                break;
            case TransactionType.DELETE:
            case TransactionType.UPDATE:
                if (state$$1 && state$$1.type === TransactionType.DELETE) {
                    //  cannot delete or update deleted items
                    throw new Error("Cannot add this transaction. Transaction with id: " + transaction.id + " has been already deleted.");
                }
                if (!state$$1 && !recordRef && !this._isPending) {
                    //  cannot initially add transaction or delete item with no recordRef
                    throw new Error("Cannot add this transaction. This is first transaction of type " + transaction.type + " " +
                        ("for id " + transaction.id + ". For first transaction of this type recordRef is mandatory."));
                }
                break;
        }
    };
    /**
     * Updates the provided states collection according to passed transaction and recordRef
     * @param states States collection to apply the update to
     * @param transaction Transaction to apply to the current state
     * @param recordRef Reference to the value of the record in data source, if any, where transaction should be applied
     */
    /**
     * Updates the provided states collection according to passed transaction and recordRef
     * @protected
     * @param {?} states States collection to apply the update to
     * @param {?} transaction Transaction to apply to the current state
     * @param {?=} recordRef Reference to the value of the record in data source, if any, where transaction should be applied
     * @return {?}
     */
    IgxTransactionService.prototype.updateState = /**
     * Updates the provided states collection according to passed transaction and recordRef
     * @protected
     * @param {?} states States collection to apply the update to
     * @param {?} transaction Transaction to apply to the current state
     * @param {?=} recordRef Reference to the value of the record in data source, if any, where transaction should be applied
     * @return {?}
     */
    function (states, transaction, recordRef) {
        /** @type {?} */
        var state$$1 = states.get(transaction.id);
        //  if TransactionType is ADD simply add transaction to states;
        //  if TransactionType is DELETE:
        //    - if there is state with this id of type ADD remove it from the states;
        //    - if there is state with this id of type UPDATE change its type to DELETE;
        //    - if there is no state with this id add transaction to states;
        //  if TransactionType is UPDATE:
        //    - if there is state with this id of type ADD merge new value and state recordRef into state new value
        //    - if there is state with this id of type UPDATE merge new value into state new value
        //    - if there is state with this id and state type is DELETE change its type to UPDATE
        //    - if there is no state with this id add transaction to states;
        if (state$$1) {
            switch (transaction.type) {
                case TransactionType.DELETE:
                    if (state$$1.type === TransactionType.ADD) {
                        states.delete(transaction.id);
                    }
                    else if (state$$1.type === TransactionType.UPDATE) {
                        state$$1.value = transaction.newValue;
                        state$$1.type = TransactionType.DELETE;
                    }
                    break;
                case TransactionType.UPDATE:
                    if (isObject(state$$1.value)) {
                        if (state$$1.type === TransactionType.ADD) {
                            state$$1.value = this.mergeValues(state$$1.value, transaction.newValue);
                        }
                        if (state$$1.type === TransactionType.UPDATE) {
                            mergeObjects(state$$1.value, transaction.newValue);
                        }
                    }
                    else {
                        state$$1.value = transaction.newValue;
                    }
            }
        }
        else {
            state$$1 = (/** @type {?} */ ({ value: cloneValue(transaction.newValue), recordRef: recordRef, type: transaction.type }));
            states.set(transaction.id, state$$1);
        }
        //  should not clean pending state. This will happen automatically on endPending call
        if (!this._isPending) {
            this.cleanState(transaction.id, states);
        }
    };
    /**
     * Compares the state with recordRef and clears all duplicated values. If any state ends as
     * empty object removes it from states.
     * @param state State to clean
     */
    /**
     * Compares the state with recordRef and clears all duplicated values. If any state ends as
     * empty object removes it from states.
     * @protected
     * @param {?} id
     * @param {?} states
     * @return {?}
     */
    IgxTransactionService.prototype.cleanState = /**
     * Compares the state with recordRef and clears all duplicated values. If any state ends as
     * empty object removes it from states.
     * @protected
     * @param {?} id
     * @param {?} states
     * @return {?}
     */
    function (id, states) {
        var e_5, _a;
        /** @type {?} */
        var state$$1 = states.get(id);
        //  do nothing if
        //  there is no state, or
        //  there is no state value (e.g. DELETED transaction), or
        //  there is no recordRef (e.g. ADDED transaction)
        if (state$$1 && state$$1.value && state$$1.recordRef) {
            //  if state's value is object compare each key with the ones in recordRef
            //  if values in any key are the same delete it from state's value
            //  if state's value is not object, simply compare with recordRef and remove
            //  the state if they are equal
            if (isObject(state$$1.recordRef)) {
                try {
                    for (var _b = __values(Object.keys(state$$1.value)), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var key = _c.value;
                        if (JSON.stringify(state$$1.recordRef[key]) === JSON.stringify(state$$1.value[key])) {
                            delete state$$1.value[key];
                        }
                    }
                }
                catch (e_5_1) { e_5 = { error: e_5_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_5) throw e_5.error; }
                }
                //  if state's value is empty remove the state from the states, only if state is not DELETE type
                if (state$$1.type !== TransactionType.DELETE && Object.keys(state$$1.value).length === 0) {
                    states.delete(id);
                }
            }
            else {
                if (state$$1.recordRef === state$$1.value) {
                    states.delete(id);
                }
            }
        }
    };
    IgxTransactionService.decorators = [
        { type: Injectable }
    ];
    return IgxTransactionService;
}(IgxBaseTransactionService));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@experimental \@hidden
 * @template T, S
 */
var IgxHierarchicalTransactionService = /** @class */ (function (_super) {
    __extends(IgxHierarchicalTransactionService, _super);
    function IgxHierarchicalTransactionService() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {?} mergeChanges
     * @return {?}
     */
    IgxHierarchicalTransactionService.prototype.getAggregatedChanges = /**
     * @param {?} mergeChanges
     * @return {?}
     */
    function (mergeChanges) {
        var _this = this;
        /** @type {?} */
        var result = [];
        this._states.forEach(function (state$$1, key) {
            /** @type {?} */
            var value = mergeChanges ? _this.mergeValues(state$$1.recordRef, state$$1.value) : cloneValue(state$$1.value);
            _this.clearArraysFromObject(value);
            result.push((/** @type {?} */ ({ id: key, path: state$$1.path, newValue: value, type: state$$1.type })));
        });
        return result;
    };
    /**
     * @protected
     * @param {?} states
     * @param {?} transaction
     * @param {?=} recordRef
     * @return {?}
     */
    IgxHierarchicalTransactionService.prototype.updateState = /**
     * @protected
     * @param {?} states
     * @param {?} transaction
     * @param {?=} recordRef
     * @return {?}
     */
    function (states, transaction, recordRef) {
        _super.prototype.updateState.call(this, states, transaction, recordRef);
        //  if transaction has no path, e.g. flat data source, get out
        if (!transaction.path) {
            return;
        }
        /** @type {?} */
        var currentState = states.get(transaction.id);
        if (currentState) {
            currentState.path = transaction.path;
        }
        //  if transaction has path, Hierarchical data source, and it is DELETE
        //  type transaction for all child rows remove ADD states and update
        //  transaction type and value of UPDATE states
        if (transaction.type === TransactionType.DELETE) {
            states.forEach(function (v, k) {
                if (v.path && v.path.indexOf(transaction.id) !== -1) {
                    switch (v.type) {
                        case TransactionType.ADD:
                            states.delete(k);
                            break;
                        case TransactionType.UPDATE:
                            states.get(k).type = TransactionType.DELETE;
                            states.get(k).value = null;
                    }
                }
            });
        }
    };
    /**
     * @param {?} data
     * @param {?=} primaryKey
     * @param {?=} childDataKey
     * @return {?}
     */
    IgxHierarchicalTransactionService.prototype.commit = /**
     * @param {?} data
     * @param {?=} primaryKey
     * @param {?=} childDataKey
     * @return {?}
     */
    function (data, primaryKey, childDataKey) {
        if (childDataKey) {
            DataUtil.mergeHierarchicalTransactions(data, this.getAggregatedChanges(true), childDataKey, primaryKey, true);
        }
        else {
            _super.prototype.commit.call(this, data);
        }
        this.clear();
    };
    //  TODO: remove this method. Force cloning to strip child arrays when needed instead
    //  TODO: remove this method. Force cloning to strip child arrays when needed instead
    /**
     * @private
     * @param {?} obj
     * @return {?}
     */
    IgxHierarchicalTransactionService.prototype.clearArraysFromObject = 
    //  TODO: remove this method. Force cloning to strip child arrays when needed instead
    /**
     * @private
     * @param {?} obj
     * @return {?}
     */
    function (obj) {
        var e_1, _a;
        if (obj) {
            try {
                for (var _b = __values(Object.keys(obj)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var prop = _c.value;
                    if (Array.isArray(obj[prop])) {
                        delete obj[prop];
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
    };
    IgxHierarchicalTransactionService.decorators = [
        { type: Injectable }
    ];
    return IgxHierarchicalTransactionService;
}(IgxTransactionService));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxToggleDirective = /** @class */ (function () {
    /**
     * @hidden
     */
    function IgxToggleDirective(elementRef, cdr, overlayService, navigationService) {
        var _this = this;
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.overlayService = overlayService;
        this.navigationService = navigationService;
        this.destroy$ = new Subject();
        this._overlaySubFilter = [
            filter(function (x) { return x.id === _this._overlayId; }),
            takeUntil(this.destroy$)
        ];
        /**
         * Emits an event after the toggle container is opened.
         *
         * ```typescript
         * onToggleOpened(event) {
         *    alert("Toggle opened!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onOpened)='onToggleOpened($event)'>
         * </div>
         * ```
         */
        this.onOpened = new EventEmitter();
        /**
         * Emits an event before the toggle container is opened.
         *
         * ```typescript
         * onToggleOpening(event) {
         *  alert("Toggle opening!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onOpening)='onToggleOpening($event)'>
         * </div>
         * ```
         */
        this.onOpening = new EventEmitter();
        /**
         * Emits an event after the toggle container is closed.
         *
         * ```typescript
         * onToggleClosed(event) {
         *  alert("Toggle closed!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onClosed)='onToggleClosed($event)'>
         * </div>
         * ```
         */
        this.onClosed = new EventEmitter();
        /**
         * Emits an event before the toggle container is closed.
         *
         * ```typescript
         * onToggleClosing(event) {
         *  alert("Toggle closing!");
         * }
         * ```
         *
         * ```html
         * <div
         *  igxToggle
         *  (onClosing)='onToggleClosing($event)'>
         * </div>
         * ```
         */
        this.onClosing = new EventEmitter();
        this._collapsed = true;
        this.overlayClosed = function () {
            _this._collapsed = true;
            _this.cdr.detectChanges();
            delete _this._overlayId;
            _this.unsubscribe();
            _this.onClosed.emit();
        };
    }
    Object.defineProperty(IgxToggleDirective.prototype, "collapsed", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._collapsed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxToggleDirective.prototype, "element", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxToggleDirective.prototype, "hiddenClass", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.collapsed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxToggleDirective.prototype, "defaultClass", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return !this.collapsed;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Opens the toggle.
     *
     * ```typescript
     * this.myToggle.open();
     * ```
     */
    /**
     * Opens the toggle.
     *
     * ```typescript
     * this.myToggle.open();
     * ```
     * @param {?=} overlaySettings
     * @return {?}
     */
    IgxToggleDirective.prototype.open = /**
     * Opens the toggle.
     *
     * ```typescript
     * this.myToggle.open();
     * ```
     * @param {?=} overlaySettings
     * @return {?}
     */
    function (overlaySettings) {
        var _this = this;
        var _a, _b, _c;
        //  if there is open animation do nothing
        //  if toggle is not collapsed and there is no close animation do nothing
        /** @type {?} */
        var info = this.overlayService.getOverlayById(this._overlayId);
        /** @type {?} */
        var hasOpenAnimation = info ? info.openAnimationPlayer : false;
        /** @type {?} */
        var hasCloseAnimation = info ? info.closeAnimationPlayer : false;
        if (hasOpenAnimation || !(this._collapsed || hasCloseAnimation)) {
            return;
        }
        if (!info) {
            this._overlayId = this.overlayService.attach(this.elementRef, overlaySettings);
        }
        this._collapsed = false;
        this.cdr.detectChanges();
        /** @type {?} */
        var openEventArgs = { cancel: false };
        this.onOpening.emit(openEventArgs);
        if (openEventArgs.cancel) {
            this._collapsed = true;
            this.cdr.detectChanges();
            return;
        }
        this.overlayService.show(this._overlayId, overlaySettings);
        this.unsubscribe();
        this._overlayOpenedSub = (_a = this.overlayService.onOpened).pipe.apply(_a, __spread(this._overlaySubFilter)).subscribe(function () {
            _this.onOpened.emit();
        });
        this._overlayClosingSub = (_b = this.overlayService
            .onClosing).pipe.apply(_b, __spread(this._overlaySubFilter)).subscribe(function (e) {
            /** @type {?} */
            var eventArgs = { cancel: false, event: e.event };
            _this.onClosing.emit(eventArgs);
            e.cancel = eventArgs.cancel;
            //  in case event is not canceled this will close the toggle and we need to unsubscribe.
            //  Otherwise if for some reason, e.g. close on outside click, close() gets called before
            //  onClosed was fired we will end with calling onClosing more than once
            if (!e.cancel) {
                _this.clearSubscription(_this._overlayClosingSub);
            }
        });
        this._overlayClosedSub = (_c = this.overlayService.onClosed).pipe.apply(_c, __spread(this._overlaySubFilter)).subscribe(this.overlayClosed);
    };
    /**
     * Closes the toggle.
     *
     * ```typescript
     * this.myToggle.close();
     * ```
     */
    /**
     * Closes the toggle.
     *
     * ```typescript
     * this.myToggle.close();
     * ```
     * @return {?}
     */
    IgxToggleDirective.prototype.close = /**
     * Closes the toggle.
     *
     * ```typescript
     * this.myToggle.close();
     * ```
     * @return {?}
     */
    function () {
        //  if toggle is collapsed do nothing
        //  if there is close animation do nothing, toggle will close anyway
        /** @type {?} */
        var info = this.overlayService.getOverlayById(this._overlayId);
        /** @type {?} */
        var hasCloseAnimation = info ? info.closeAnimationPlayer : false;
        if (this._collapsed || hasCloseAnimation) {
            return;
        }
        this.overlayService.hide(this._overlayId);
    };
    /**
     * Opens or closes the toggle, depending on its current state.
     *
     * ```typescript
     * this.myToggle.toggle();
     * ```
     */
    /**
     * Opens or closes the toggle, depending on its current state.
     *
     * ```typescript
     * this.myToggle.toggle();
     * ```
     * @param {?=} overlaySettings
     * @return {?}
     */
    IgxToggleDirective.prototype.toggle = /**
     * Opens or closes the toggle, depending on its current state.
     *
     * ```typescript
     * this.myToggle.toggle();
     * ```
     * @param {?=} overlaySettings
     * @return {?}
     */
    function (overlaySettings) {
        //  if toggle is collapsed call open
        //  if there is close animation call open
        if (this.collapsed || this.isClosing) {
            this.open(overlaySettings);
        }
        else {
            this.close();
        }
    };
    Object.defineProperty(IgxToggleDirective.prototype, "isClosing", {
        /** @hidden @internal */
        get: /**
         * @hidden \@internal
         * @return {?}
         */
        function () {
            /** @type {?} */
            var info = this.overlayService.getOverlayById(this._overlayId);
            return info ? info.closeAnimationPlayer : false;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Repositions the toggle.
     * ```typescript
     * this.myToggle.reposition();
     * ```
     */
    /**
     * Repositions the toggle.
     * ```typescript
     * this.myToggle.reposition();
     * ```
     * @return {?}
     */
    IgxToggleDirective.prototype.reposition = /**
     * Repositions the toggle.
     * ```typescript
     * this.myToggle.reposition();
     * ```
     * @return {?}
     */
    function () {
        this.overlayService.reposition(this._overlayId);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxToggleDirective.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (this.navigationService && this.id) {
            this.navigationService.add(this.id, this);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxToggleDirective.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (this.navigationService && this.id) {
            this.navigationService.remove(this.id);
        }
        if (!this.collapsed && this._overlayId) {
            this.overlayService.hide(this._overlayId);
        }
        this.unsubscribe();
        this.destroy$.next(true);
        this.destroy$.complete();
    };
    /**
     * @private
     * @return {?}
     */
    IgxToggleDirective.prototype.unsubscribe = /**
     * @private
     * @return {?}
     */
    function () {
        this.clearSubscription(this._overlayOpenedSub);
        this.clearSubscription(this._overlayClosingSub);
        this.clearSubscription(this._overlayClosedSub);
    };
    /**
     * @private
     * @param {?} subscription
     * @return {?}
     */
    IgxToggleDirective.prototype.clearSubscription = /**
     * @private
     * @param {?} subscription
     * @return {?}
     */
    function (subscription) {
        if (subscription && !subscription.closed) {
            subscription.unsubscribe();
        }
    };
    IgxToggleDirective.decorators = [
        { type: Directive, args: [{
                    exportAs: 'toggle',
                    selector: '[igxToggle]'
                },] }
    ];
    /** @nocollapse */
    IgxToggleDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ChangeDetectorRef },
        { type: IgxOverlayService, decorators: [{ type: Inject, args: [IgxOverlayService,] }] },
        { type: IgxNavigationService, decorators: [{ type: Optional }] }
    ]; };
    IgxToggleDirective.propDecorators = {
        onOpened: [{ type: Output }],
        onOpening: [{ type: Output }],
        onClosed: [{ type: Output }],
        onClosing: [{ type: Output }],
        id: [{ type: Input }],
        hiddenClass: [{ type: HostBinding, args: ['class.igx-toggle--hidden',] }, { type: HostBinding, args: ['attr.aria-hidden',] }],
        defaultClass: [{ type: HostBinding, args: ['class.igx-toggle',] }]
    };
    return IgxToggleDirective;
}());
var IgxToggleActionDirective = /** @class */ (function () {
    function IgxToggleActionDirective(element, navigationService) {
        this.element = element;
        this.navigationService = navigationService;
    }
    Object.defineProperty(IgxToggleActionDirective.prototype, "closeOnOutsideClick", {
        /**
         * DEPRECATED. Determines whether the toggle should close when you click outside.
         *
         * ```typescript
         * // get
         * let closesOnOutsideClick = this.toggle.closeOnOutsideClick;
         * ```
         */
        get: /**
         * DEPRECATED. Determines whether the toggle should close when you click outside.
         *
         * ```typescript
         * // get
         * let closesOnOutsideClick = this.toggle.closeOnOutsideClick;
         * ```
         * @return {?}
         */
        function () {
            return this._closeOnOutsideClick;
        },
        /**
         * ```html
         * <!--set-->
         * <div igxToggleAction [closeOnOutsideClick]="'true'"></div>
         * ```
         */
        set: /**
         * ```html
         * <!--set-->
         * <div igxToggleAction [closeOnOutsideClick]="'true'"></div>
         * ```
         * @param {?} v
         * @return {?}
         */
        function (v) {
            this._closeOnOutsideClick = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxToggleActionDirective.prototype, "target", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            if (typeof this._target === 'string') {
                return this.navigationService.get(this._target);
            }
            return this._target;
        },
        /**
         * @hidden
         */
        set: /**
         * @hidden
         * @param {?} target
         * @return {?}
         */
        function (target) {
            if (target !== null && target !== '') {
                this._target = target;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxToggleActionDirective.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        this._overlayDefaults = {
            positionStrategy: new ConnectedPositioningStrategy({ target: this.element.nativeElement }),
            scrollStrategy: new AbsoluteScrollStrategy(),
            closeOnOutsideClick: true,
            modal: false,
            excludePositionTarget: true
        };
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxToggleActionDirective.prototype.onClick = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (this._closeOnOutsideClick !== undefined) {
            this._overlayDefaults.closeOnOutsideClick = this._closeOnOutsideClick;
        }
        if (this.outlet) {
            this._overlayDefaults.outlet = this.outlet;
        }
        /** @type {?} */
        var clonedSettings = Object.assign({}, this._overlayDefaults, this.overlaySettings);
        this.updateOverlaySettings(clonedSettings);
        this.target.toggle(clonedSettings);
    };
    /**
     * Updates provided overlay settings
     * @param settings settings to update
     * @returns returns updated copy of provided overlay settings
     */
    /**
     * Updates provided overlay settings
     * @protected
     * @param {?} settings settings to update
     * @return {?} returns updated copy of provided overlay settings
     */
    IgxToggleActionDirective.prototype.updateOverlaySettings = /**
     * Updates provided overlay settings
     * @protected
     * @param {?} settings settings to update
     * @return {?} returns updated copy of provided overlay settings
     */
    function (settings) {
        if (settings && settings.positionStrategy) {
            /** @type {?} */
            var positionStrategyClone = settings.positionStrategy.clone();
            positionStrategyClone.settings.target = this.element.nativeElement;
            settings.positionStrategy = positionStrategyClone;
        }
        return settings;
    };
    IgxToggleActionDirective.decorators = [
        { type: Directive, args: [{
                    exportAs: 'toggle-action',
                    selector: '[igxToggleAction]'
                },] }
    ];
    /** @nocollapse */
    IgxToggleActionDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: IgxNavigationService, decorators: [{ type: Optional }] }
    ]; };
    IgxToggleActionDirective.propDecorators = {
        overlaySettings: [{ type: Input }],
        closeOnOutsideClick: [{ type: Input }],
        outlet: [{ type: Input, args: ['igxToggleOutlet',] }],
        target: [{ type: Input, args: ['igxToggleAction',] }],
        onClick: [{ type: HostListener, args: ['click',] }]
    };
    __decorate([
        DeprecateProperty("igxToggleAction 'closeOnOutsideClick' input is deprecated. Use 'overlaySettings' input object instead."),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], IgxToggleActionDirective.prototype, "closeOnOutsideClick", null);
    return IgxToggleActionDirective;
}());
/**
 * Mark an element as an igxOverlay outlet container.
 * Directive instance is exported as `overlay-outlet` to be assigned to templates variables:
 * ```html
 * <div igxOverlayOutlet #outlet="overlay-outlet"></div>
 * ```
 */
var IgxOverlayOutletDirective = /** @class */ (function () {
    function IgxOverlayOutletDirective(element) {
        this.element = element;
    }
    Object.defineProperty(IgxOverlayOutletDirective.prototype, "nativeElement", {
        /** @hidden */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.element.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    IgxOverlayOutletDirective.decorators = [
        { type: Directive, args: [{
                    exportAs: 'overlay-outlet',
                    selector: '[igxOverlayOutlet]'
                },] }
    ];
    /** @nocollapse */
    IgxOverlayOutletDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    return IgxOverlayOutletDirective;
}());
/**
 * @hidden
 */
var IgxToggleModule = /** @class */ (function () {
    function IgxToggleModule() {
    }
    IgxToggleModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxToggleDirective, IgxToggleActionDirective, IgxOverlayOutletDirective],
                    exports: [IgxToggleDirective, IgxToggleActionDirective, IgxOverlayOutletDirective],
                    providers: [IgxNavigationService]
                },] }
    ];
    return IgxToggleModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
var Navigate = {
    Up: -1,
    Down: 1,
};
Navigate[Navigate.Up] = 'Up';
Navigate[Navigate.Down] = 'Down';
/** @enum {string} */
var DropDownActionKey = {
    ESCAPE: 'escape',
    ENTER: 'enter',
    SPACE: 'space',
};
/** @type {?} */
var IGX_DROPDOWN_BASE = 'IgxDropDownBaseToken';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxSelectionAPIService = /** @class */ (function () {
    function IgxSelectionAPIService() {
        /**
         * If primaryKey is defined, then multiple selection is based on the primaryKey, and it is array of numbers, strings, etc.
         * If the primaryKey is omitted, then selection is based on the item data
         */
        this.selection = new Map();
    }
    /**
     * Get current component selection.
     * @param componentID ID of the component.
     */
    /**
     * Get current component selection.
     * @param {?} componentID ID of the component.
     * @return {?}
     */
    IgxSelectionAPIService.prototype.get = /**
     * Get current component selection.
     * @param {?} componentID ID of the component.
     * @return {?}
     */
    function (componentID) {
        return this.selection.get(componentID);
    };
    /**
     * Set new component selection.
     * @param componentID ID of the component.
     * @param newSelection The new component selection to be set.
     */
    /**
     * Set new component selection.
     * @param {?} componentID ID of the component.
     * @param {?} newSelection The new component selection to be set.
     * @return {?}
     */
    IgxSelectionAPIService.prototype.set = /**
     * Set new component selection.
     * @param {?} componentID ID of the component.
     * @param {?} newSelection The new component selection to be set.
     * @return {?}
     */
    function (componentID, newSelection) {
        if (!componentID) {
            throw Error('Invalid value for component id!');
        }
        this.selection.set(componentID, newSelection);
    };
    /**
     * Clears selection for component.
     * @param componentID ID of the component.
     */
    /**
     * Clears selection for component.
     * @param {?} componentID ID of the component.
     * @return {?}
     */
    IgxSelectionAPIService.prototype.clear = /**
     * Clears selection for component.
     * @param {?} componentID ID of the component.
     * @return {?}
     */
    function (componentID) {
        this.selection.set(componentID, this.get_empty());
    };
    /**
     * Get current component selection length.
     * @param componentID ID of the component.
     */
    /**
     * Get current component selection length.
     * @param {?} componentID ID of the component.
     * @return {?}
     */
    IgxSelectionAPIService.prototype.size = /**
     * Get current component selection length.
     * @param {?} componentID ID of the component.
     * @return {?}
     */
    function (componentID) {
        /** @type {?} */
        var sel = this.get(componentID);
        return sel ? sel.size : 0;
    };
    /**
     * Creates new selection that consist of the new item added to the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the select_item() one.
     * @param componentID ID of the component, which we add new item to.
     * @param itemID ID of the item to add to component selection.
     * @param sel Used internally only by the selection (add_items method) to accumulate selection for multiple items.
     *
     * @returns Selection after the new item is added.
     */
    /**
     * Creates new selection that consist of the new item added to the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the select_item() one.
     * @param {?} componentID ID of the component, which we add new item to.
     * @param {?} itemID ID of the item to add to component selection.
     * @param {?=} sel Used internally only by the selection (add_items method) to accumulate selection for multiple items.
     *
     * @return {?} Selection after the new item is added.
     */
    IgxSelectionAPIService.prototype.add_item = /**
     * Creates new selection that consist of the new item added to the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the select_item() one.
     * @param {?} componentID ID of the component, which we add new item to.
     * @param {?} itemID ID of the item to add to component selection.
     * @param {?=} sel Used internally only by the selection (add_items method) to accumulate selection for multiple items.
     *
     * @return {?} Selection after the new item is added.
     */
    function (componentID, itemID, sel) {
        if (!sel) {
            sel = new Set(this.get(componentID));
        }
        if (sel === undefined) {
            sel = this.get_empty();
        }
        if (!itemID && itemID !== 0) {
            throw Error('Invalid value for item id!');
        }
        sel.add(itemID);
        return sel;
    };
    /**
     * Creates new selection that consist of the new items added to the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the select_items() one.
     * @param componentID ID of the component, which we add new items to.
     * @param itemIDs Array of IDs of the items to add to component selection.
     * @param clearSelection If true it will clear previous selection.
     *
     * @returns Selection after the new items are added.
     */
    /**
     * Creates new selection that consist of the new items added to the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the select_items() one.
     * @param {?} componentID ID of the component, which we add new items to.
     * @param {?} itemIDs Array of IDs of the items to add to component selection.
     * @param {?=} clearSelection If true it will clear previous selection.
     *
     * @return {?} Selection after the new items are added.
     */
    IgxSelectionAPIService.prototype.add_items = /**
     * Creates new selection that consist of the new items added to the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the select_items() one.
     * @param {?} componentID ID of the component, which we add new items to.
     * @param {?} itemIDs Array of IDs of the items to add to component selection.
     * @param {?=} clearSelection If true it will clear previous selection.
     *
     * @return {?} Selection after the new items are added.
     */
    function (componentID, itemIDs, clearSelection) {
        var _this = this;
        /** @type {?} */
        var selection;
        if (clearSelection) {
            selection = this.get_empty();
        }
        else if (itemIDs && itemIDs.length === 0) {
            selection = new Set(this.get(componentID));
        }
        itemIDs.forEach(function (item) { return selection = _this.add_item(componentID, item, selection); });
        return selection;
    };
    /**
     * Add item to the current component selection.
     * @param componentID ID of the component, which we add new item to.
     * @param itemID ID of the item to add to component selection.
     * @param sel Used internally only by the selection (select_items method) to accumulate selection for multiple items.
     */
    /**
     * Add item to the current component selection.
     * @param {?} componentID ID of the component, which we add new item to.
     * @param {?} itemID ID of the item to add to component selection.
     * @param {?=} sel Used internally only by the selection (select_items method) to accumulate selection for multiple items.
     * @return {?}
     */
    IgxSelectionAPIService.prototype.select_item = /**
     * Add item to the current component selection.
     * @param {?} componentID ID of the component, which we add new item to.
     * @param {?} itemID ID of the item to add to component selection.
     * @param {?=} sel Used internally only by the selection (select_items method) to accumulate selection for multiple items.
     * @return {?}
     */
    function (componentID, itemID, sel) {
        this.set(componentID, this.add_item(componentID, itemID, sel));
    };
    /**
     * Add items to the current component selection.
     * @param componentID ID of the component, which we add new items to.
     * @param itemIDs Array of IDs of the items to add to component selection.
     * @param clearSelection If true it will clear previous selection.
     */
    /**
     * Add items to the current component selection.
     * @param {?} componentID ID of the component, which we add new items to.
     * @param {?} itemID
     * @param {?=} clearSelection If true it will clear previous selection.
     * @return {?}
     */
    IgxSelectionAPIService.prototype.select_items = /**
     * Add items to the current component selection.
     * @param {?} componentID ID of the component, which we add new items to.
     * @param {?} itemID
     * @param {?=} clearSelection If true it will clear previous selection.
     * @return {?}
     */
    function (componentID, itemID, clearSelection) {
        this.set(componentID, this.add_items(componentID, itemID, clearSelection));
    };
    /**
     * Creates new selection that consist of the new items excluded from the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the deselect_item() one.
     * @param componentID ID of the component, which we remove items from.
     * @param itemID ID of the item to remove from component selection.
     * @param sel Used internally only by the selection (delete_items method) to accumulate deselected items.
     *
     * @returns Selection after the item is removed.
     */
    /**
     * Creates new selection that consist of the new items excluded from the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the deselect_item() one.
     * @param {?} componentID ID of the component, which we remove items from.
     * @param {?} itemID ID of the item to remove from component selection.
     * @param {?=} sel Used internally only by the selection (delete_items method) to accumulate deselected items.
     *
     * @return {?} Selection after the item is removed.
     */
    IgxSelectionAPIService.prototype.delete_item = /**
     * Creates new selection that consist of the new items excluded from the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the deselect_item() one.
     * @param {?} componentID ID of the component, which we remove items from.
     * @param {?} itemID ID of the item to remove from component selection.
     * @param {?=} sel Used internally only by the selection (delete_items method) to accumulate deselected items.
     *
     * @return {?} Selection after the item is removed.
     */
    function (componentID, itemID, sel) {
        if (!sel) {
            sel = new Set(this.get(componentID));
        }
        if (sel === undefined) {
            return;
        }
        sel.delete(itemID);
        return sel;
    };
    /**
     * Creates new selection that consist of the new items removed to the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the deselect_items() one.
     * @param componentID ID of the component, which we remove items from.
     * @param itemID ID of the items to remove from component selection.
     *
     * @returns Selection after the items are removed.
     */
    /**
     * Creates new selection that consist of the new items removed to the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the deselect_items() one.
     * @param {?} componentID ID of the component, which we remove items from.
     * @param {?} itemIDs
     * @return {?} Selection after the items are removed.
     */
    IgxSelectionAPIService.prototype.delete_items = /**
     * Creates new selection that consist of the new items removed to the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the deselect_items() one.
     * @param {?} componentID ID of the component, which we remove items from.
     * @param {?} itemIDs
     * @return {?} Selection after the items are removed.
     */
    function (componentID, itemIDs) {
        var _this = this;
        /** @type {?} */
        var selection;
        itemIDs.forEach(function (deselectedItem) { return selection = _this.delete_item(componentID, deselectedItem, selection); });
        return selection;
    };
    /**
     * Remove item from the current component selection.
     * @param componentID ID of the component, which we remove item from.
     * @param itemID ID of the item to remove from component selection.
     * @param sel Used internally only by the selection (deselect_items method) to accumulate selection for multiple items.
     */
    /**
     * Remove item from the current component selection.
     * @param {?} componentID ID of the component, which we remove item from.
     * @param {?} itemID ID of the item to remove from component selection.
     * @param {?=} sel Used internally only by the selection (deselect_items method) to accumulate selection for multiple items.
     * @return {?}
     */
    IgxSelectionAPIService.prototype.deselect_item = /**
     * Remove item from the current component selection.
     * @param {?} componentID ID of the component, which we remove item from.
     * @param {?} itemID ID of the item to remove from component selection.
     * @param {?=} sel Used internally only by the selection (deselect_items method) to accumulate selection for multiple items.
     * @return {?}
     */
    function (componentID, itemID, sel) {
        this.set(componentID, this.delete_item(componentID, itemID, sel));
    };
    /**
     * Remove items to the current component selection.
     * @param componentID ID of the component, which we add new items to.
     * @param itemIDs Array of IDs of the items to add to component selection.
     */
    /**
     * Remove items to the current component selection.
     * @param {?} componentID ID of the component, which we add new items to.
     * @param {?} itemID
     * @param {?=} clearSelection
     * @return {?}
     */
    IgxSelectionAPIService.prototype.deselect_items = /**
     * Remove items to the current component selection.
     * @param {?} componentID ID of the component, which we add new items to.
     * @param {?} itemID
     * @param {?=} clearSelection
     * @return {?}
     */
    function (componentID, itemID, clearSelection) {
        this.set(componentID, this.delete_items(componentID, itemID));
    };
    /**
     * Check if the item is selected in the component selection.
     * @param componentID ID of the component.
     * @param itemID ID of the item to search.
     *
     * @returns If item is selected.
     */
    /**
     * Check if the item is selected in the component selection.
     * @param {?} componentID ID of the component.
     * @param {?} itemID ID of the item to search.
     *
     * @return {?} If item is selected.
     */
    IgxSelectionAPIService.prototype.is_item_selected = /**
     * Check if the item is selected in the component selection.
     * @param {?} componentID ID of the component.
     * @param {?} itemID ID of the item to search.
     *
     * @return {?} If item is selected.
     */
    function (componentID, itemID) {
        /** @type {?} */
        var sel = this.get(componentID);
        if (!sel) {
            return false;
        }
        return sel.has(itemID);
    };
    /**
     * Get first element in the selection.
     * This is correct when we have only one item in the collection (for single selection purposes)
     * and the method returns that item.
     * @param componentID ID of the component.
     *
     * @returns First element in the set.
     */
    /**
     * Get first element in the selection.
     * This is correct when we have only one item in the collection (for single selection purposes)
     * and the method returns that item.
     * @param {?} componentID ID of the component.
     *
     * @return {?} First element in the set.
     */
    IgxSelectionAPIService.prototype.first_item = /**
     * Get first element in the selection.
     * This is correct when we have only one item in the collection (for single selection purposes)
     * and the method returns that item.
     * @param {?} componentID ID of the component.
     *
     * @return {?} First element in the set.
     */
    function (componentID) {
        /** @type {?} */
        var sel = this.get(componentID);
        if (sel && sel.size > 0) {
            return sel.values().next().value;
        }
    };
    /**
     * Returns whether all items are selected.
     * @param componentID ID of the component.
     * @param dataCount: number Number of items in the data.
     *
     * @returns If all items are selected.
     */
    /**
     * Returns whether all items are selected.
     * @param {?} componentID ID of the component.
     * @param {?} dataCount
     * @return {?} If all items are selected.
     */
    IgxSelectionAPIService.prototype.are_all_selected = /**
     * Returns whether all items are selected.
     * @param {?} componentID ID of the component.
     * @param {?} dataCount
     * @return {?} If all items are selected.
     */
    function (componentID, dataCount) {
        return dataCount > 0 && dataCount === this.size(componentID);
    };
    /**
     * Returns whether any of the items is selected.
     * @param componentID ID of the component.
     * @param data Entire data array.
     *
     * @returns If there is any item selected.
     */
    /**
     * Returns whether any of the items is selected.
     * @param {?} componentID ID of the component.
     * @return {?} If there is any item selected.
     */
    IgxSelectionAPIService.prototype.are_none_selected = /**
     * Returns whether any of the items is selected.
     * @param {?} componentID ID of the component.
     * @return {?} If there is any item selected.
     */
    function (componentID) {
        return this.size(componentID) === 0;
    };
    /**
     * Get all primary key values from a data array. If there isn't a primary key defined that the entire data is returned instead.
     * @param data Entire data array.
     * @param primaryKey Data primary key.
     *
     * @returns Array of identifiers, either primary key values or the entire data array.
     */
    /**
     * Get all primary key values from a data array. If there isn't a primary key defined that the entire data is returned instead.
     * @param {?} data Entire data array.
     * @param {?=} primaryKey Data primary key.
     *
     * @return {?} Array of identifiers, either primary key values or the entire data array.
     */
    IgxSelectionAPIService.prototype.get_all_ids = /**
     * Get all primary key values from a data array. If there isn't a primary key defined that the entire data is returned instead.
     * @param {?} data Entire data array.
     * @param {?=} primaryKey Data primary key.
     *
     * @return {?} Array of identifiers, either primary key values or the entire data array.
     */
    function (data, primaryKey) {
        return primaryKey ? data.map(function (x) { return x[primaryKey]; }) : data;
    };
    /**
     * Returns empty selection collection.
     * @returns empty set.
    */
    /**
     * Returns empty selection collection.
     * @return {?} empty set.
     */
    IgxSelectionAPIService.prototype.get_empty = /**
     * Returns empty selection collection.
     * @return {?} empty set.
     */
    function () {
        return new Set();
    };
    IgxSelectionAPIService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    /** @nocollapse */ IgxSelectionAPIService.ngInjectableDef = defineInjectable({ factory: function IgxSelectionAPIService_Factory() { return new IgxSelectionAPIService(); }, token: IgxSelectionAPIService, providedIn: "root" });
    return IgxSelectionAPIService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var NEXT_ID = 0;
/**
 * The `<igx-drop-down-item>` is a container intended for row items in
 * a `<igx-drop-down>` container.
 */
var IgxDropDownGroupComponent = /** @class */ (function () {
    function IgxDropDownGroupComponent() {
        this._id = NEXT_ID++;
        /**
         * @hidden \@internal
         */
        this.role = 'group';
        /**
         * @hidden \@internal
         */
        this.groupClass = true;
        /**
         * Sets/gets if the item group is disabled
         *
         * ```typescript
         * const myDropDownGroup: IgxDropDownGroupComponent = this.dropdownGroup;
         * // get
         * ...
         * const groupState: boolean = myDropDownGroup.disabled;
         * ...
         * //set
         * ...
         * myDropDownGroup,disabled = false;
         * ...
         * ```
         *
         * ```html
         * <igx-drop-down-item-group [label]="'My Items'" [disabled]="true">
         *     <igx-drop-down-item *ngFor="let item of items[index]" [value]="item.value">
         *         {{ item.text }}
         *     </igx-drop-down-item>
         * </igx-drop-down-item-group>
         * ```
         *
         * **NOTE:** All items inside of a disabled drop down group will be treated as disabled
         */
        this.disabled = false;
    }
    Object.defineProperty(IgxDropDownGroupComponent.prototype, "labelId", {
        /**
         * @hidden @internal
         */
        get: /**
         * @hidden \@internal
         * @return {?}
         */
        function () {
            return "igx-item-group-label-" + this._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDropDownGroupComponent.prototype, "labelledBy", {
        get: /**
         * @return {?}
         */
        function () {
            return this.labelId;
        },
        enumerable: true,
        configurable: true
    });
    IgxDropDownGroupComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-drop-down-item-group',
                    template: "\n        <label id=\"{{labelId}}\">{{ label }}</label>\n        <ng-content select=\"igx-drop-down-item\"></ng-content>\n    "
                }] }
    ];
    IgxDropDownGroupComponent.propDecorators = {
        labelledBy: [{ type: HostBinding, args: ["attr.aria-labelledby",] }],
        role: [{ type: HostBinding, args: ['attr.role',] }],
        groupClass: [{ type: HostBinding, args: ['class.igx-drop-down__group',] }],
        disabled: [{ type: Input }, { type: HostBinding, args: ["attr.aria-disabled",] }, { type: HostBinding, args: ['class.igx-drop-down__group--disabled',] }],
        label: [{ type: Input }]
    };
    return IgxDropDownGroupComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var NEXT_ID$1 = 0;
/** @type {?} */
var warningShown$1 = false;
/**
 * An abstract class defining a drop-down item:
 * With properties / styles for selection, highlight, height
 * Bindable property for passing data (`value: any`)
 * Parent component (has to be used under a parent with type `IDropDownBase`)
 * Method for handling click on Host()
 * @abstract
 */
var IgxDropDownItemBase = /** @class */ (function () {
    function IgxDropDownItemBase(dropDown, elementRef, group, selection) {
        this.dropDown = dropDown;
        this.elementRef = elementRef;
        this.group = group;
        this.selection = selection;
        /**
         * @hidden
         */
        this._focused = false;
        this._selected = false;
        this._index = null;
        this._disabled = false;
        /**
         * Sets/gets the `id` of the item.
         * ```html
         * <igx-drop-down-item [id] = 'igx-drop-down-item-0'></igx-drop-down-item>
         * ```
         * ```typescript
         * let itemId =  this.item.id;
         * ```
         * \@memberof IgxSelectItemComponent
         */
        this.id = "igx-drop-down-item-" + NEXT_ID$1++;
        /**
         * Gets/sets the `role` attribute of the item. Default is 'option'.
         *
         * ```html
         *  <igx-drop-down-item [role]="customRole"></igx-drop-down-item>
         * ```
         */
        this.role = 'option';
    }
    Object.defineProperty(IgxDropDownItemBase.prototype, "hasIndex", {
        get: /**
         * @protected
         * @return {?}
         */
        function () {
            return this._index !== null && this._index !== undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDropDownItemBase.prototype, "itemID", {
        /**
         * @hidden @internal
         */
        get: /**
         * @hidden \@internal
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
        function () {
            return (/** @type {?} */ (this));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDropDownItemBase.prototype, "index", {
        /**
         * The data index of the dropdown item.
         *
         * ```typescript
         * // get the data index of the selected dropdown item
         * let selectedItemIndex = this.dropdown.selectedItem.index
         * ```
         */
        get: /**
         * The data index of the dropdown item.
         *
         * ```typescript
         * // get the data index of the selected dropdown item
         * let selectedItemIndex = this.dropdown.selectedItem.index
         * ```
         * @return {?}
         */
        function () {
            if (this._index === null) {
                warningShown$1 = showMessage('IgxDropDownItemBase: Automatic index is deprecated.' +
                    'Bind in the template instead using `<igx-drop-down-item [index]="i"` instead.`', warningShown$1);
                return this.itemIndex;
            }
            return this._index;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._index = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDropDownItemBase.prototype, "itemStyle", {
        /**
         * @hidden @internal
         */
        get: /**
         * @hidden \@internal
         * @return {?}
         */
        function () {
            return !this.isHeader;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDropDownItemBase.prototype, "selected", {
        /**
         * Sets/Gets if the item is the currently selected one in the dropdown
         *
         * ```typescript
         *  let mySelectedItem = this.dropdown.selectedItem;
         *  let isMyItemSelected = mySelectedItem.selected; // true
         * ```
         */
        get: /**
         * Sets/Gets if the item is the currently selected one in the dropdown
         *
         * ```typescript
         *  let mySelectedItem = this.dropdown.selectedItem;
         *  let isMyItemSelected = mySelectedItem.selected; // true
         * ```
         * @return {?}
         */
        function () {
            return this._selected;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this.isHeader) {
                return;
            }
            this._selected = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDropDownItemBase.prototype, "isSelected", {
        /**
         * @hidden @internal
         */
        get: /**
         * @hidden \@internal
         * @return {?}
         */
        function () {
            return this.selected;
        },
        /**
         * @hidden @internal
         */
        set: /**
         * @hidden \@internal
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.selected = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDropDownItemBase.prototype, "focused", {
        /**
         * Sets/gets if the given item is focused
         * ```typescript
         *  let mySelectedItem = this.dropdown.selectedItem;
         *  let isMyItemFocused = mySelectedItem.focused;
         * ```
         */
        get: /**
         * Sets/gets if the given item is focused
         * ```typescript
         *  let mySelectedItem = this.dropdown.selectedItem;
         *  let isMyItemFocused = mySelectedItem.focused;
         * ```
         * @return {?}
         */
        function () {
            return (!this.isHeader && !this.disabled) && this._focused;
        },
        /**
         * ```html
         *  <igx-drop-down-item *ngFor="let item of items" focused={{!item.focused}}>
         *      <div>
         *          {{item.field}}
         *      </div>
         *  </igx-drop-down-item>
         * ```
         */
        set: /**
         * ```html
         *  <igx-drop-down-item *ngFor="let item of items" focused={{!item.focused}}>
         *      <div>
         *          {{item.field}}
         *      </div>
         *  </igx-drop-down-item>
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._focused = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDropDownItemBase.prototype, "isFocused", {
        /**
         * @hidden @internal
         */
        get: /**
         * @hidden \@internal
         * @return {?}
         */
        function () {
            return this.focused;
        },
        /**
         * @hidden @internal
         */
        set: /**
         * @hidden \@internal
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.focused = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDropDownItemBase.prototype, "disabled", {
        /**
         * Sets/gets if the given item is disabled
         *
         * ```typescript
         *  // get
         *  let mySelectedItem = this.dropdown.selectedItem;
         *  let myItemIsDisabled = mySelectedItem.disabled;
         * ```
         *
         * ```html
         *  <igx-drop-down-item *ngFor="let item of items" disabled={{!item.disabled}}>
         *      <div>
         *          {{item.field}}
         *      </div>
         *  </igx-drop-down-item>
         * ```
         * **NOTE:** Drop-down items inside of a disabled `IgxDropDownGroup` will always count as disabled
         */
        get: /**
         * Sets/gets if the given item is disabled
         *
         * ```typescript
         *  // get
         *  let mySelectedItem = this.dropdown.selectedItem;
         *  let myItemIsDisabled = mySelectedItem.disabled;
         * ```
         *
         * ```html
         *  <igx-drop-down-item *ngFor="let item of items" disabled={{!item.disabled}}>
         *      <div>
         *          {{item.field}}
         *      </div>
         *  </igx-drop-down-item>
         * ```
         * **NOTE:** Drop-down items inside of a disabled `IgxDropDownGroup` will always count as disabled
         * @return {?}
         */
        function () {
            return this.group ? this.group.disabled || this._disabled : this._disabled;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._disabled = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDropDownItemBase.prototype, "itemIndex", {
        /**
         * Gets item index
         * @hidden @internal
         */
        get: /**
         * Gets item index
         * @hidden \@internal
         * @return {?}
         */
        function () {
            return this.dropDown.items.indexOf(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDropDownItemBase.prototype, "elementHeight", {
        /**
         * Gets item element height
         * @hidden @internal
         */
        get: /**
         * Gets item element height
         * @hidden \@internal
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement.clientHeight;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDropDownItemBase.prototype, "element", {
        /**
         * Get item html element
         * @hidden @internal
         */
        get: /**
         * Get item html element
         * @hidden \@internal
         * @return {?}
         */
        function () {
            return this.elementRef;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    IgxDropDownItemBase.prototype.clicked = /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    function (event) {
    };
    /**
     * @return {?}
     */
    IgxDropDownItemBase.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
        if (this._selected) {
            /** @type {?} */
            var dropDownSelectedItem = this.dropDown.selectedItem;
            if (!dropDownSelectedItem) {
                this.dropDown.selectItem(this);
            }
            else if (this.hasIndex
                ? this._index !== dropDownSelectedItem.index || this.value !== dropDownSelectedItem.value :
                this !== dropDownSelectedItem) {
                this.dropDown.selectItem(this);
            }
        }
    };
    /** @nocollapse */
    IgxDropDownItemBase.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [IGX_DROPDOWN_BASE,] }] },
        { type: ElementRef },
        { type: IgxDropDownGroupComponent, decorators: [{ type: Optional }] },
        { type: IgxSelectionAPIService, decorators: [{ type: Optional }, { type: Inject, args: [IgxSelectionAPIService,] }] }
    ]; };
    IgxDropDownItemBase.propDecorators = {
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        index: [{ type: Input }],
        value: [{ type: Input }],
        itemStyle: [{ type: HostBinding, args: ['class.igx-drop-down__item',] }],
        selected: [{ type: Input }, { type: HostBinding, args: ['attr.aria-selected',] }, { type: HostBinding, args: ['class.igx-drop-down__item--selected',] }],
        isSelected: [{ type: Input }],
        focused: [{ type: HostBinding, args: ['class.igx-drop-down__item--focused',] }],
        isHeader: [{ type: Input }, { type: HostBinding, args: ['class.igx-drop-down__header',] }],
        disabled: [{ type: Input }, { type: HostBinding, args: ['attr.aria-disabled',] }, { type: HostBinding, args: ['class.igx-drop-down__item--disabled',] }],
        role: [{ type: Input }, { type: HostBinding, args: ['attr.role',] }],
        clicked: [{ type: HostListener, args: ['click', ['$event'],] }]
    };
    __decorate([
        DeprecateProperty("IgxDropDownItemBase `isSelected` property is deprecated.\n" +
            "Use `selected` instead."),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], IgxDropDownItemBase.prototype, "isSelected", null);
    __decorate([
        DeprecateProperty("IgxDropDownItemBase `isFocused` property is depracated.\n" +
            "Use `focused` instead."),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], IgxDropDownItemBase.prototype, "isFocused", null);
    return IgxDropDownItemBase;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * The `<igx-drop-down-item>` is a container intended for row items in
 * a `<igx-drop-down>` container.
 */
var IgxDropDownItemComponent = /** @class */ (function (_super) {
    __extends(IgxDropDownItemComponent, _super);
    function IgxDropDownItemComponent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(IgxDropDownItemComponent.prototype, "focused", {
        /**
         * @inheritdoc
         */
        get: /**
         * \@inheritdoc
         * @return {?}
         */
        function () {
            /** @type {?} */
            var focusedState = this._focused;
            if (this.hasIndex) {
                /** @type {?} */
                var focusedItem = this.selection.first_item(this.dropDown.id + "-active");
                /** @type {?} */
                var focusedIndex = focusedItem ? focusedItem.index : -1;
                focusedState = this._index === focusedIndex;
            }
            return !this.isHeader && !this.disabled && focusedState;
        },
        /**
         * @inheritdoc
         */
        set: /**
         * \@inheritdoc
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._focused = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDropDownItemComponent.prototype, "selected", {
        /**
         * @inheritdoc
         */
        get: /**
         * \@inheritdoc
         * @return {?}
         */
        function () {
            if (this.hasIndex) {
                /** @type {?} */
                var item = this.selection.first_item("" + this.dropDown.id);
                return item ? item.index === this._index && item.value === this.value : false;
            }
            return this._selected;
        },
        /**
         * @inheritdoc
         */
        set: /**
         * \@inheritdoc
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this.isHeader) {
                return;
            }
            this._selected = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDropDownItemComponent.prototype, "setTabIndex", {
        /**
         * @hidden @internal
         */
        get: /**
         * @hidden \@internal
         * @return {?}
         */
        function () {
            /** @type {?} */
            var shouldSetTabIndex = this.dropDown.allowItemsFocus && !(this.disabled || this.isHeader);
            if (shouldSetTabIndex) {
                return 0;
            }
            else {
                return null;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    IgxDropDownItemComponent.prototype.clicked = /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.disabled || this.isHeader) {
            /** @type {?} */
            var focusedItem = this.dropDown.items.find(function (item) { return item.focused; });
            if (this.dropDown.allowItemsFocus && focusedItem) {
                focusedItem.element.nativeElement.focus({ preventScroll: true });
            }
            return;
        }
        if (this.selection) {
            this.dropDown.selectItem(this, event);
        }
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    IgxDropDownItemComponent.prototype.mousedownHandler = /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
    };
    IgxDropDownItemComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-drop-down-item',
                    template: "<ng-content></ng-content>"
                }] }
    ];
    IgxDropDownItemComponent.propDecorators = {
        setTabIndex: [{ type: HostBinding, args: ['attr.tabindex',] }],
        clicked: [{ type: HostListener, args: ['click', ['$event'],] }],
        mousedownHandler: [{ type: HostListener, args: ['mousedown', ['$event'],] }]
    };
    return IgxDropDownItemComponent;
}(IgxDropDownItemBase));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var NEXT_ID$2 = 0;
/**
 * An abstract class, defining a drop-down component, with:
 * Properties for display styles and classes
 * A collection items of type `IgxDropDownItemBase`
 * Properties and methods for navigating (highlighting/focusing) items from the collection
 * Properties and methods for selecting items from the collection
 * @abstract
 */
var IgxDropDownBase = /** @class */ (function () {
    function IgxDropDownBase(elementRef, cdr) {
        this.elementRef = elementRef;
        this.cdr = cdr;
        this._focusedItem = null;
        this._id = "igx-drop-down-" + NEXT_ID$2++;
        /**
         * Emitted when item selection is changing, before the selection completes
         *
         * ```html
         * <igx-drop-down (onSelection)='handleSelection()'></igx-drop-down>
         * ```
         */
        this.onSelection = new EventEmitter();
        /**
         * Gets/Sets the drop down's container max height.
         *
         * ```typescript
         * // get
         * let maxHeight = this.dropdown.maxHeight;
         * ```
         * ```html
         * <!--set-->
         * <igx-drop-down [maxHeight]='200px'></igx-drop-down>
         * ```
         */
        this.maxHeight = null;
        /**
         * @hidden \@internal
         */
        this.cssClass = true;
    }
    Object.defineProperty(IgxDropDownBase.prototype, "scrollContainer", {
        /**
         * Get dropdown's html element of it scroll container
         */
        get: /**
         * Get dropdown's html element of it scroll container
         * @protected
         * @return {?}
         */
        function () {
            return this.element;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDropDownBase.prototype, "items", {
        /**
         * Get all non-header items
         *
         * ```typescript
         * let myDropDownItems = this.dropdown.items;
         * ```
         */
        get: /**
         * Get all non-header items
         *
         * ```typescript
         * let myDropDownItems = this.dropdown.items;
         * ```
         * @return {?}
         */
        function () {
            var e_1, _a;
            /** @type {?} */
            var items = [];
            if (this.children !== undefined) {
                try {
                    for (var _b = __values(this.children.toArray()), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var child = _c.value;
                        if (!child.isHeader) {
                            items.push(child);
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            return items;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDropDownBase.prototype, "headers", {
        /**
         * Get all header items
         *
         * ```typescript
         * let myDropDownHeaderItems = this.dropdown.headers;
         * ```
         */
        get: /**
         * Get all header items
         *
         * ```typescript
         * let myDropDownHeaderItems = this.dropdown.headers;
         * ```
         * @return {?}
         */
        function () {
            var e_2, _a;
            /** @type {?} */
            var headers = [];
            if (this.children !== undefined) {
                try {
                    for (var _b = __values(this.children.toArray()), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var child = _c.value;
                        if (child.isHeader) {
                            headers.push(child);
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
            return headers;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDropDownBase.prototype, "element", {
        /**
         * Get dropdown html element
         *
         * ```typescript
         * let myDropDownElement = this.dropdown.element;
         * ```
         */
        get: /**
         * Get dropdown html element
         *
         * ```typescript
         * let myDropDownElement = this.dropdown.element;
         * ```
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    /** Keydown Handler */
    /**
     * Keydown Handler
     * @param {?} key
     * @param {?=} event
     * @return {?}
     */
    IgxDropDownBase.prototype.onItemActionKey = /**
     * Keydown Handler
     * @param {?} key
     * @param {?=} event
     * @return {?}
     */
    function (key, event) {
        switch (key) {
            case DropDownActionKey.ENTER:
            case DropDownActionKey.SPACE:
                this.selectItem(this.focusedItem, event);
                break;
            case DropDownActionKey.ESCAPE:
        }
    };
    /**
     * Emits onSelection with the target item & event
     * @hidden @internal
     * @param newSelection the item selected
     * @param event the event that triggered the call
     */
    /**
     * Emits onSelection with the target item & event
     * @hidden \@internal
     * @param {?=} newSelection the item selected
     * @param {?=} event the event that triggered the call
     * @return {?}
     */
    IgxDropDownBase.prototype.selectItem = /**
     * Emits onSelection with the target item & event
     * @hidden \@internal
     * @param {?=} newSelection the item selected
     * @param {?=} event the event that triggered the call
     * @return {?}
     */
    function (newSelection, event) {
        this.onSelection.emit({
            newSelection: newSelection,
            oldSelection: null,
            cancel: false
        });
    };
    Object.defineProperty(IgxDropDownBase.prototype, "focusedItem", {
        /**
         * @hidden @internal
         */
        get: /**
         * @hidden \@internal
         * @return {?}
         */
        function () {
            return this._focusedItem;
        },
        /**
         * @hidden @internal
         */
        set: /**
         * @hidden \@internal
         * @param {?} item
         * @return {?}
         */
        function (item) {
            this._focusedItem = item;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @protected
     * @param {?} direction
     * @param {?=} currentIndex
     * @return {?}
     */
    IgxDropDownBase.prototype.navigate = /**
     * @protected
     * @param {?} direction
     * @param {?=} currentIndex
     * @return {?}
     */
    function (direction, currentIndex) {
        /** @type {?} */
        var index = -1;
        if (this._focusedItem) {
            index = currentIndex ? currentIndex : this.focusedItem.itemIndex;
        }
        /** @type {?} */
        var newIndex = this.getNearestSiblingFocusableItemIndex(index, direction);
        this.navigateItem(newIndex);
    };
    /**
     * @protected
     * @param {?} startIndex
     * @param {?} direction
     * @return {?}
     */
    IgxDropDownBase.prototype.getNearestSiblingFocusableItemIndex = /**
     * @protected
     * @param {?} startIndex
     * @param {?} direction
     * @return {?}
     */
    function (startIndex, direction) {
        /** @type {?} */
        var index = startIndex;
        /** @type {?} */
        var items = this.items;
        while (items[index + direction] && items[index + direction].disabled) {
            index += direction;
        }
        index += direction;
        if (index >= 0 && index < items.length) {
            return index;
        }
        else {
            return -1;
        }
    };
    /**
     * Navigates to the item on the specified index
     * @param newIndex number - the index of the item in the `items` collection
     */
    /**
     * Navigates to the item on the specified index
     * @param {?} newIndex number - the index of the item in the `items` collection
     * @return {?}
     */
    IgxDropDownBase.prototype.navigateItem = /**
     * Navigates to the item on the specified index
     * @param {?} newIndex number - the index of the item in the `items` collection
     * @return {?}
     */
    function (newIndex) {
        if (newIndex !== -1) {
            /** @type {?} */
            var oldItem = this._focusedItem;
            /** @type {?} */
            var newItem = this.items[newIndex];
            if (oldItem) {
                oldItem.focused = false;
            }
            this.focusedItem = newItem;
            this.scrollToHiddenItem(newItem);
            this.focusedItem.focused = true;
        }
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @return {?}
     */
    IgxDropDownBase.prototype.navigateFirst = /**
     * @hidden \@internal
     * @return {?}
     */
    function () {
        this.navigate(Navigate.Down, -1);
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @return {?}
     */
    IgxDropDownBase.prototype.navigateLast = /**
     * @hidden \@internal
     * @return {?}
     */
    function () {
        this.navigate(Navigate.Up, this.items.length);
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @return {?}
     */
    IgxDropDownBase.prototype.navigateNext = /**
     * @hidden \@internal
     * @return {?}
     */
    function () {
        this.navigate(Navigate.Down);
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @return {?}
     */
    IgxDropDownBase.prototype.navigatePrev = /**
     * @hidden \@internal
     * @return {?}
     */
    function () {
        this.navigate(Navigate.Up);
    };
    /**
     * @protected
     * @param {?} newItem
     * @return {?}
     */
    IgxDropDownBase.prototype.scrollToHiddenItem = /**
     * @protected
     * @param {?} newItem
     * @return {?}
     */
    function (newItem) {
        /** @type {?} */
        var elementRect = newItem.element.nativeElement.getBoundingClientRect();
        /** @type {?} */
        var parentRect = this.scrollContainer.getBoundingClientRect();
        if (parentRect.top > elementRect.top) {
            this.scrollContainer.scrollTop -= (parentRect.top - elementRect.top);
        }
        if (parentRect.bottom < elementRect.bottom) {
            this.scrollContainer.scrollTop += (elementRect.bottom - parentRect.bottom);
        }
    };
    IgxDropDownBase.propDecorators = {
        onSelection: [{ type: Output }],
        width: [{ type: Input }],
        height: [{ type: Input }],
        id: [{ type: Input }],
        maxHeight: [{ type: Input }, { type: HostBinding, args: ['style.maxHeight',] }],
        cssClass: [{ type: HostBinding, args: ['class.igx-drop-down',] }]
    };
    return IgxDropDownBase;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var DisplayContainerComponent = /** @class */ (function () {
    function DisplayContainerComponent(cdr, _viewContainer) {
        this.cdr = cdr;
        this._viewContainer = _viewContainer;
        this.cssClass = 'igx-display-container';
        this.notVirtual = true;
    }
    DisplayContainerComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-display-container',
                    template: "\n        <ng-template\n            #display_container\n            igxScrollInertia\n            [IgxScrollInertiaScrollContainer]=\"scrollContainer\"\n            [IgxScrollInertiaDirection]=\"scrollDirection\">\n        </ng-template>\n    "
                }] }
    ];
    /** @nocollapse */
    DisplayContainerComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ViewContainerRef }
    ]; };
    DisplayContainerComponent.propDecorators = {
        _vcr: [{ type: ViewChild, args: ['display_container', { read: ViewContainerRef },] }],
        cssClass: [{ type: HostBinding, args: ['class',] }],
        notVirtual: [{ type: HostBinding, args: ['class.igx-display-container--inactive',] }]
    };
    return DisplayContainerComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var HVirtualHelperComponent = /** @class */ (function () {
    function HVirtualHelperComponent(elementRef) {
        this.elementRef = elementRef;
        this.cssClasses = 'igx-vhelper--horizontal';
    }
    HVirtualHelperComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-horizontal-virtual-helper',
                    template: '<div #horizontal_container class="igx-vhelper__placeholder-content" [style.width.px]="width"></div>'
                }] }
    ];
    /** @nocollapse */
    HVirtualHelperComponent.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    HVirtualHelperComponent.propDecorators = {
        _vcr: [{ type: ViewChild, args: ['horizontal_container', { read: ViewContainerRef },] }],
        width: [{ type: Input }],
        cssClasses: [{ type: HostBinding, args: ['class',] }]
    };
    return HVirtualHelperComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var VirtualHelperComponent = /** @class */ (function () {
    function VirtualHelperComponent(elementRef, cdr) {
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.cssClasses = 'igx-vhelper--vertical';
    }
    Object.defineProperty(VirtualHelperComponent.prototype, "height", {
        get: /**
         * @return {?}
         */
        function () {
            return this._height;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this.destroyed) {
                return;
            }
            this._height = value;
            this.cdr.detectChanges();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    VirtualHelperComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.destroyed = true;
    };
    VirtualHelperComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-virtual-helper',
                    template: '<div #container class="igx-vhelper__placeholder-content" [style.height.px]="height"></div>'
                }] }
    ];
    /** @nocollapse */
    VirtualHelperComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ChangeDetectorRef }
    ]; };
    VirtualHelperComponent.propDecorators = {
        scrollTop: [{ type: HostBinding, args: ['scrollTop',] }],
        _vcr: [{ type: ViewChild, args: ['container', { read: ViewContainerRef },] }],
        itemsLength: [{ type: Input }],
        cssClasses: [{ type: HostBinding, args: ['class',] }]
    };
    return VirtualHelperComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxScrollInertiaDirective = /** @class */ (function () {
    function IgxScrollInertiaDirective(element, _zone) {
        this.element = element;
        this._zone = _zone;
        this.wheelStep = 50;
        this.inertiaStep = 1.5;
        this.swipeToleranceX = 20;
        this.inertiaDeltaY = 3;
        this.inertiaDeltaX = 2;
        this.inertiaDuration = 0.5;
        this._savedSpeedsX = [];
        this.setPointerCaptureFName = typeof Element.prototype['msSetPointerCapture'] === 'function' ?
            'msSetPointerCapture' :
            'setPointerCapture';
        this.releasePointerCaptureFName = typeof Element.prototype['msReleasePointerCapture'] === 'function' ?
            'msReleasePointerCapture' :
            'releasePointerCapture';
    }
    /**
     * @return {?}
     */
    IgxScrollInertiaDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._zone.runOutsideAngular(function () {
            /** @type {?} */
            var targetElem = _this.element.nativeElement.parentElement || _this.element.nativeElement.parentNode;
            targetElem.addEventListener('wheel', function (evt) { _this.onWheel(evt); });
            targetElem.addEventListener('touchstart', function (evt) { _this.onTouchStart(evt); });
            targetElem.addEventListener('touchmove', function (evt) { _this.onTouchMove(evt); });
            targetElem.addEventListener('touchend', function (evt) { _this.onTouchEnd(evt); });
            targetElem.addEventListener('pointerdown', function (evt) { _this.onPointerDown(evt); });
            targetElem.addEventListener('pointerup', function (evt) { _this.onPointerUp(evt); });
            targetElem.addEventListener('MSGestureStart', function (evt) { _this.onMSGestureStart(evt); });
            targetElem.addEventListener('MSGestureChange', function (evt) { _this.onMSGestureChange(evt); });
        });
    };
    /**
    * @hidden
    * Function that is called when scrolling with the mouse wheel or using touchpad
    */
    /**
     * @hidden
     * Function that is called when scrolling with the mouse wheel or using touchpad
     * @protected
     * @param {?} evt
     * @return {?}
     */
    IgxScrollInertiaDirective.prototype.onWheel = /**
     * @hidden
     * Function that is called when scrolling with the mouse wheel or using touchpad
     * @protected
     * @param {?} evt
     * @return {?}
     */
    function (evt) {
        // if no scrollbar return
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        /** @type {?} */
        var scrollDeltaX;
        /** @type {?} */
        var scrollDeltaY;
        /** @type {?} */
        var scrollStep = this.wheelStep;
        /** @type {?} */
        var minWheelStep = 1 / this.wheelStep;
        this._startX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        this._startY = this.IgxScrollInertiaScrollContainer.scrollTop;
        if (evt.wheelDeltaX) {
            /* Option supported on Chrome, Safari, Opera.
            /* 120 is default for mousewheel on these browsers. Other values are for trackpads */
            scrollDeltaX = -evt.wheelDeltaX / 120;
            if (-minWheelStep < scrollDeltaX && scrollDeltaX < minWheelStep) {
                scrollDeltaX = Math.sign(scrollDeltaX) * minWheelStep;
            }
        }
        else if (evt.deltaX) {
            /* For other browsers that don't provide wheelDelta, use the deltaY to determine direction and pass default values. */
            scrollDeltaX = this.calcAxisCoords(evt.deltaX, -1, 1);
        }
        /** Get delta for the Y axis*/
        if (evt.wheelDeltaY) {
            /* Option supported on Chrome, Safari, Opera.
            /* 120 is default for mousewheel on these browsers. Other values are for trackpads */
            scrollDeltaY = -evt.wheelDeltaY / 120;
            if (-minWheelStep < scrollDeltaY && scrollDeltaY < minWheelStep) {
                scrollDeltaY = Math.sign(scrollDeltaY) * minWheelStep;
            }
        }
        else if (evt.deltaY) {
            /* For other browsers that don't provide wheelDelta, use the deltaY to determine direction and pass default values. */
            scrollDeltaY = this.calcAxisCoords(evt.deltaY, -1, 1);
        }
        if (scrollDeltaX && this.IgxScrollInertiaDirection === 'horizontal') {
            this._scrollToX(this._startX + scrollDeltaX * scrollStep);
            /** @type {?} */
            var curScrollLeft = this.IgxScrollInertiaScrollContainer.scrollLeft;
            /** @type {?} */
            var maxScrollLeft = parseInt(this.IgxScrollInertiaScrollContainer.children[0].style.width, 10);
            if (0 < curScrollLeft && curScrollLeft < maxScrollLeft) {
                // Prevent navigating through pages when scrolling on Mac
                evt.preventDefault();
            }
        }
        else if (scrollDeltaY && this.IgxScrollInertiaDirection === 'vertical') {
            this._scrollToY(this._startY + scrollDeltaY * scrollStep);
            this.preventParentScroll(evt);
        }
    };
    /**
     * @hidden
     * When there is still room to scroll up/down prevent the parent elements from scrolling too.
     */
    /**
     * @hidden
     * When there is still room to scroll up/down prevent the parent elements from scrolling too.
     * @protected
     * @param {?} evt
     * @return {?}
     */
    IgxScrollInertiaDirective.prototype.preventParentScroll = /**
     * @hidden
     * When there is still room to scroll up/down prevent the parent elements from scrolling too.
     * @protected
     * @param {?} evt
     * @return {?}
     */
    function (evt) {
        /** @type {?} */
        var curScrollTop = this.IgxScrollInertiaScrollContainer.scrollTop;
        /** @type {?} */
        var maxScrollTop = this.IgxScrollInertiaScrollContainer.children[0].scrollHeight -
            this.IgxScrollInertiaScrollContainer.offsetHeight;
        if (0 < curScrollTop && curScrollTop < maxScrollTop) {
            evt.preventDefault();
            if (evt.stopPropagation) {
                evt.stopPropagation();
            }
        }
    };
    /**
     * @hidden
     * Function that is called the first moment we start interacting with the content on a touch device
     */
    /**
     * @hidden
     * Function that is called the first moment we start interacting with the content on a touch device
     * @protected
     * @param {?} event
     * @return {?}
     */
    IgxScrollInertiaDirective.prototype.onTouchStart = /**
     * @hidden
     * Function that is called the first moment we start interacting with the content on a touch device
     * @protected
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (typeof MSGesture === 'function' || !this.IgxScrollInertiaScrollContainer) {
            return false;
        }
        // stops any current ongoing inertia
        cancelAnimationFrame(this._touchInertiaAnimID);
        /** @type {?} */
        var touch = event.touches[0];
        this._startX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        this._startY = this.IgxScrollInertiaScrollContainer.scrollTop;
        this._touchStartX = touch.pageX;
        this._touchStartY = touch.pageY;
        this._lastTouchEnd = new Date().getTime();
        this._lastTouchX = touch.pageX;
        this._lastTouchY = touch.pageY;
        this._savedSpeedsX = [];
        this._savedSpeedsY = [];
        // Vars regarding swipe offset
        this._totalMovedX = 0;
        this._offsetRecorded = false;
        this._offsetDirection = 0;
        this._touchPrevented = false;
        if (this.IgxScrollInertiaDirection === 'vertical') {
            this.preventParentScroll(event);
        }
    };
    /**
     * @hidden
     * Function that is called when we need to scroll the content based on touch interactions
     */
    /**
     * @hidden
     * Function that is called when we need to scroll the content based on touch interactions
     * @protected
     * @param {?} event
     * @return {?}
     */
    IgxScrollInertiaDirective.prototype.onTouchMove = /**
     * @hidden
     * Function that is called when we need to scroll the content based on touch interactions
     * @protected
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (typeof MSGesture === 'function') {
            this._touchPrevented = false;
            return false;
        }
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        /** @type {?} */
        var touch = event.touches[0];
        /** @type {?} */
        var destX = this._startX + (this._touchStartX - touch.pageX) * Math.sign(this.inertiaStep);
        /** @type {?} */
        var destY = this._startY + (this._touchStartY - touch.pageY) * Math.sign(this.inertiaStep);
        /* Handle complex touchmoves when swipe stops but the toch doesn't end and then a swipe is initiated again */
        /* **********************************************************/
        /** @type {?} */
        var timeFromLastTouch = (new Date().getTime()) - this._lastTouchEnd;
        if (timeFromLastTouch !== 0 && timeFromLastTouch < 100) {
            /** @type {?} */
            var speedX = (this._lastTouchX - touch.pageX) / timeFromLastTouch;
            /** @type {?} */
            var speedY = (this._lastTouchY - touch.pageY) / timeFromLastTouch;
            // Save the last 5 speeds between two touchmoves on X axis
            if (this._savedSpeedsX.length < 5) {
                this._savedSpeedsX.push(speedX);
            }
            else {
                this._savedSpeedsX.shift();
                this._savedSpeedsX.push(speedX);
            }
            // Save the last 5 speeds between two touchmoves on Y axis
            if (this._savedSpeedsY.length < 5) {
                this._savedSpeedsY.push(speedY);
            }
            else {
                this._savedSpeedsY.shift();
                this._savedSpeedsY.push(speedY);
            }
        }
        this._lastTouchEnd = new Date().getTime();
        this._lastMovedX = this._lastTouchX - touch.pageX;
        this._lastMovedY = this._lastTouchY - touch.pageY;
        this._lastTouchX = touch.pageX;
        this._lastTouchY = touch.pageY;
        this._totalMovedX += this._lastMovedX;
        /** @type {?} */
        var scrolledXY;
        /*	Do not scroll using touch untill out of the swipeToleranceX bounds */
        if (Math.abs(this._totalMovedX) < this.swipeToleranceX && !this._offsetRecorded) {
            scrolledXY = this._scrollTo(this._startX, destY);
        }
        else {
            /*	Record the direction the first time we are out of the swipeToleranceX bounds.
            *	That way we know which direction we apply the offset so it doesn't hickup when moving out of the swipeToleranceX bounds */
            if (!this._offsetRecorded) {
                this._offsetDirection = Math.sign(destX - this._startX);
                this._offsetRecorded = true;
            }
            /*	Scroll with offset ammout of swipeToleranceX in the direction we have exited the bounds and
            don't change it after that ever until touchend and again touchstart */
            scrolledXY = this._scrollTo(destX - this._offsetDirection * this.swipeToleranceX, destY);
        }
        if (scrolledXY.x === 0 && scrolledXY.y === 0) {
            this._touchPrevented = true;
        }
        // On Safari preventing the touchmove would prevent default page scroll behaviour even if there is the element doesn't have overflow
        if (this.IgxScrollInertiaDirection === 'vertical') {
            this.preventParentScroll(event);
        }
    };
    /**
     * @protected
     * @param {?} event
     * @return {?}
     */
    IgxScrollInertiaDirective.prototype.onTouchEnd = /**
     * @protected
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (typeof MSGesture === 'function') {
            return;
        }
        /** @type {?} */
        var speedX = 0;
        /** @type {?} */
        var speedY = 0;
        // savedSpeedsX and savedSpeedsY have same length
        for (var i = 0; i < this._savedSpeedsX.length; i++) {
            speedX += this._savedSpeedsX[i];
            speedY += this._savedSpeedsY[i];
        }
        speedX = this._savedSpeedsX.length ? speedX / this._savedSpeedsX.length : 0;
        speedY = this._savedSpeedsX.length ? speedY / this._savedSpeedsY.length : 0;
        // Use the lastMovedX and lastMovedY to determine if the swipe stops without lifting the finger so we don't start inertia
        if ((Math.abs(speedX) > 0.1 || Math.abs(speedY) > 0.1) &&
            (Math.abs(this._lastMovedX) > 2 || Math.abs(this._lastMovedY) > 2)) {
            this._inertiaInit(speedX, speedY);
        }
        if (this.IgxScrollInertiaDirection === 'vertical') {
            this.preventParentScroll(event);
        }
    };
    /**
     * @hidden
     * Function that is called when we need to detect touch starting on a touch device on IE/Edge
     */
    /**
     * @hidden
     * Function that is called when we need to detect touch starting on a touch device on IE/Edge
     * @protected
     * @param {?} event
     * @return {?}
     */
    IgxScrollInertiaDirective.prototype.onPointerDown = /**
     * @hidden
     * Function that is called when we need to detect touch starting on a touch device on IE/Edge
     * @protected
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!event || (event.pointerType !== 2 && event.pointerType !== 'touch') ||
            typeof MSGesture !== 'function') {
            return true;
        }
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        // setPointerCaptureFName is the name of the function that is supported
        event.target[this.setPointerCaptureFName](this._pointer = event.pointerId);
        // create gestureObject only one time to prevent overlapping during intertia
        if (!this._gestureObject) {
            this._gestureObject = new MSGesture();
            this._gestureObject.target = this.element.nativeElement.parentElement || this.element.nativeElement.parentNode;
        }
        this._gestureObject.addPointer(this._pointer);
    };
    /**
     * @hidden
     * Function that is called when we need to detect touch ending on a touch device on IE/Edge
     */
    /**
     * @hidden
     * Function that is called when we need to detect touch ending on a touch device on IE/Edge
     * @protected
     * @param {?} event
     * @return {?}
     */
    IgxScrollInertiaDirective.prototype.onPointerUp = /**
     * @hidden
     * Function that is called when we need to detect touch ending on a touch device on IE/Edge
     * @protected
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this._pointer) {
            return true;
        }
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        /* releasePointerCaptureFName is the name of the function that is supported */
        event.target[this.releasePointerCaptureFName](this._pointer);
        delete this._pointer;
    };
    /**
     * @hidden
     *  Function that is called when a gesture begins on IE/Edge
     */
    /**
     * @hidden
     *  Function that is called when a gesture begins on IE/Edge
     * @protected
     * @param {?} event
     * @return {?}
     */
    IgxScrollInertiaDirective.prototype.onMSGestureStart = /**
     * @hidden
     *  Function that is called when a gesture begins on IE/Edge
     * @protected
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        this._startX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        this._startY = this.IgxScrollInertiaScrollContainer.scrollTop;
        this._touchStartX = event.screenX;
        this._touchStartY = event.screenY;
        // Vars regarding swipe offset
        this._totalMovedX = 0;
        this._offsetRecorded = false;
        this._offsetDirection = 0;
        return false;
    };
    /**
     * @hidden
     * Function that is called when a we need to scroll based on the gesture performed on IE/Edge
     */
    /**
     * @hidden
     * Function that is called when a we need to scroll based on the gesture performed on IE/Edge
     * @protected
     * @param {?} event
     * @return {?}
     */
    IgxScrollInertiaDirective.prototype.onMSGestureChange = /**
     * @hidden
     * Function that is called when a we need to scroll based on the gesture performed on IE/Edge
     * @protected
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this.IgxScrollInertiaScrollContainer) {
            return;
        }
        /** @type {?} */
        var touchPos = event;
        /** @type {?} */
        var destX = this._startX + this._touchStartX - touchPos.screenX;
        /** @type {?} */
        var destY = this._startY + this._touchStartY - touchPos.screenY;
        /* Logic regarding x tolerance to prevent accidental horizontal scrolling when scrolling vertically */
        this._totalMovedX = this._touchStartX - touchPos.screenX;
        if (Math.abs(this._totalMovedX) < this.swipeToleranceX && !this._offsetRecorded) {
            /* Do not scroll horizontally yet while in the tolerance range */
            this._scrollToY(destY);
        }
        else {
            if (!this._offsetRecorded) {
                this._offsetDirection = Math.sign(destX - this._startX);
                this._offsetRecorded = true;
            }
            /* Once the tolerance is exceeded it can be scrolled horizontally */
            this._scrollTo(destX - this._offsetDirection * this.swipeToleranceX, destY);
        }
        return false;
    };
    /**
     * @private
     * @param {?} target
     * @param {?} min
     * @param {?} max
     * @return {?}
     */
    IgxScrollInertiaDirective.prototype.calcAxisCoords = /**
     * @private
     * @param {?} target
     * @param {?} min
     * @param {?} max
     * @return {?}
     */
    function (target, min, max) {
        if (target === undefined || target < min) {
            target = min;
        }
        else if (target > max) {
            target = max;
        }
        return target;
    };
    /**
     * @private
     * @param {?} destX
     * @param {?} destY
     * @return {?}
     */
    IgxScrollInertiaDirective.prototype._scrollTo = /**
     * @private
     * @param {?} destX
     * @param {?} destY
     * @return {?}
     */
    function (destX, destY) {
        /** @type {?} */
        var curPosX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        /** @type {?} */
        var curPosY = this.IgxScrollInertiaScrollContainer.scrollTop;
        // TODO Trigger scrolling event?
        /** @type {?} */
        var scrolledX = this._scrollToX(destX);
        /** @type {?} */
        var scrolledY = this._scrollToY(destY);
        return { x: scrolledX, y: scrolledY };
    };
    /**
     * @private
     * @param {?} dest
     * @return {?}
     */
    IgxScrollInertiaDirective.prototype._scrollToX = /**
     * @private
     * @param {?} dest
     * @return {?}
     */
    function (dest) {
        this.IgxScrollInertiaScrollContainer.scrollLeft = dest;
    };
    /**
     * @private
     * @param {?} dest
     * @return {?}
     */
    IgxScrollInertiaDirective.prototype._scrollToY = /**
     * @private
     * @param {?} dest
     * @return {?}
     */
    function (dest) {
        this.IgxScrollInertiaScrollContainer.scrollTop = dest;
    };
    /**
     * @protected
     * @param {?} speedX
     * @param {?} speedY
     * @return {?}
     */
    IgxScrollInertiaDirective.prototype._inertiaInit = /**
     * @protected
     * @param {?} speedX
     * @param {?} speedY
     * @return {?}
     */
    function (speedX, speedY) {
        var _this = this;
        /** @type {?} */
        var stepModifer = this.inertiaStep;
        /** @type {?} */
        var inertiaDuration = this.inertiaDuration;
        /** @type {?} */
        var x = 0;
        this._nextX = this.IgxScrollInertiaScrollContainer.scrollLeft;
        this._nextY = this.IgxScrollInertiaScrollContainer.scrollTop;
        // Sets timeout until executing next movement iteration of the inertia
        /** @type {?} */
        var inertiaStep = function () {
            if (x > 6) {
                cancelAnimationFrame(_this._touchInertiaAnimID);
                return;
            }
            if (Math.abs(speedX) > Math.abs(speedY)) {
                x += 0.05 / (1 * inertiaDuration);
            }
            else {
                x += 0.05 / (1 * inertiaDuration);
            }
            if (x <= 1) {
                // We use constant quation to determine the offset without speed falloff befor x reaches 1
                if (Math.abs(speedY) <= Math.abs(speedX) * _this.inertiaDeltaY) {
                    _this._nextX += 1 * speedX * 15 * stepModifer;
                }
                if (Math.abs(speedY) >= Math.abs(speedX) * _this.inertiaDeltaX) {
                    _this._nextY += 1 * speedY * 15 * stepModifer;
                }
            }
            else {
                // We use the quation "y = 2 / (x + 0.55) - 0.3" to determine the offset
                if (Math.abs(speedY) <= Math.abs(speedX) * _this.inertiaDeltaY) {
                    _this._nextX += Math.abs(2 / (x + 0.55) - 0.3) * speedX * 15 * stepModifer;
                }
                if (Math.abs(speedY) >= Math.abs(speedX) * _this.inertiaDeltaX) {
                    _this._nextY += Math.abs(2 / (x + 0.55) - 0.3) * speedY * 15 * stepModifer;
                }
            }
            // If we have mixed environment we use the default behaviour. i.e. touchscreen + mouse
            _this._scrollTo(_this._nextX, _this._nextY);
            _this._touchInertiaAnimID = requestAnimationFrame(inertiaStep);
        };
        // Start inertia and continue it recursively
        this._touchInertiaAnimID = requestAnimationFrame(inertiaStep);
    };
    /**
     * @return {?}
     */
    IgxScrollInertiaDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._zone.runOutsideAngular(function () {
            /** @type {?} */
            var targetElem = _this.element.nativeElement.parentElement || _this.element.nativeElement.parentNode;
            targetElem.removeEventListener('wheel', function (evt) { _this.onWheel(evt); });
            targetElem.removeEventListener('touchstart', function (evt) { _this.onTouchStart(evt); });
            targetElem.removeEventListener('touchmove', function (evt) { _this.onTouchMove(evt); });
            targetElem.removeEventListener('touchend', function (evt) { _this.onTouchEnd(evt); });
            targetElem.removeEventListener('pointerdown', function (evt) { _this.onPointerDown(evt); });
            targetElem.removeEventListener('pointerup', function (evt) { _this.onPointerUp(evt); });
            targetElem.removeEventListener('MSGestureStart', function (evt) { _this.onMSGestureStart(evt); });
            targetElem.removeEventListener('MSGestureChange', function (evt) { _this.onMSGestureChange(evt); });
        });
    };
    IgxScrollInertiaDirective.decorators = [
        { type: Directive, args: [{ selector: '[igxScrollInertia]' },] }
    ];
    /** @nocollapse */
    IgxScrollInertiaDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: NgZone }
    ]; };
    IgxScrollInertiaDirective.propDecorators = {
        IgxScrollInertiaDirection: [{ type: Input }],
        IgxScrollInertiaScrollContainer: [{ type: Input }],
        wheelStep: [{ type: Input }],
        inertiaStep: [{ type: Input }],
        swipeToleranceX: [{ type: Input }],
        inertiaDeltaY: [{ type: Input }],
        inertiaDeltaX: [{ type: Input }],
        inertiaDuration: [{ type: Input }]
    };
    return IgxScrollInertiaDirective;
}());
/**
 * @hidden
 */
var IgxScrollInertiaModule = /** @class */ (function () {
    function IgxScrollInertiaModule() {
    }
    IgxScrollInertiaModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxScrollInertiaDirective],
                    exports: [IgxScrollInertiaDirective],
                    imports: [CommonModule]
                },] }
    ];
    return IgxScrollInertiaModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxForOfSyncService = /** @class */ (function () {
    function IgxForOfSyncService() {
        this._master = new Map();
    }
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} directive
     * @return {?}
     */
    IgxForOfSyncService.prototype.isMaster = /**
     * @hidden
     * @param {?} directive
     * @return {?}
     */
    function (directive) {
        return this._master.get(directive.igxForScrollOrientation) === directive;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} directive
     * @param {?=} forced
     * @return {?}
     */
    IgxForOfSyncService.prototype.setMaster = /**
     * @hidden
     * @param {?} directive
     * @param {?=} forced
     * @return {?}
     */
    function (directive, forced) {
        if (forced === void 0) { forced = false; }
        /** @type {?} */
        var orientation = directive.igxForScrollOrientation;
        if (orientation && (forced || !this._master.has(orientation))) {
            this._master.set(orientation, directive);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxForOfSyncService.prototype.resetMaster = /**
     * @hidden
     * @return {?}
     */
    function () {
        this._master.clear();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} dir
     * @return {?}
     */
    IgxForOfSyncService.prototype.sizesCache = /**
     * @hidden
     * @param {?} dir
     * @return {?}
     */
    function (dir) {
        return this._master.get(dir).sizesCache;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} dir
     * @return {?}
     */
    IgxForOfSyncService.prototype.chunkSize = /**
     * @hidden
     * @param {?} dir
     * @return {?}
     */
    function (dir) {
        return this._master.get(dir).state.chunkSize;
    };
    IgxForOfSyncService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    /** @nocollapse */ IgxForOfSyncService.ngInjectableDef = defineInjectable({ factory: function IgxForOfSyncService_Factory() { return new IgxForOfSyncService(); }, token: IgxForOfSyncService, providedIn: "root" });
    return IgxForOfSyncService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var IgxForOfDirective = /** @class */ (function () {
    function IgxForOfDirective(_viewContainer, _template, _differs, resolver, cdr, _zone) {
        this._viewContainer = _viewContainer;
        this._template = _template;
        this._differs = _differs;
        this.resolver = resolver;
        this.cdr = cdr;
        this._zone = _zone;
        /**
         * The current state of the directive. It contains `startIndex` and `chunkSize`.
         * state.startIndex - The index of the item at which the current visible chunk begins.
         * state.chunkSize - The number of items the current visible chunk holds.
         * These options can be used when implementing remote virtualization as they provide the necessary state information.
         * ```typescript
         * const gridState = this.parentVirtDir.state;
         * ```
         */
        this.state = {
            startIndex: 0,
            chunkSize: 0
        };
        /**
         * The total count of the virtual data items, when using remote service.
         * ```typescript
         * this.parentVirtDir.totalItemCount = data.Count;
         * ```
         */
        this.totalItemCount = null;
        /**
         * An event that is emitted after a new chunk has been loaded.
         * ```html
         * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (onChunkLoad)="chunkLoad($event)"></ng-template>
         * ```
         * ```typescript
         * chunkLoad(e){
         * alert("chunk loaded!");
         * }
         * ```
         */
        this.onChunkLoad = new EventEmitter();
        /**
         * An event that is emitted after data has been changed.
         * ```html
         * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (onDataChanged)="dataChanged($event)"></ng-template>
         * ```
         * ```typescript
         * dataChanged(e){
         * alert("data changed!");
         * }
         * ```
         */
        this.onDataChanged = new EventEmitter();
        this.onBeforeViewDestroyed = new EventEmitter();
        /**
         * An event that is emitted on chunk loading to emit the current state information - startIndex, endIndex, totalCount.
         * Can be used for implementing remote load on demand for the igxFor data.
         * ```html
         * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (onChunkPreload)="chunkPreload($event)"></ng-template>
         * ```
         * ```typescript
         * chunkPreload(e){
         * alert("chunk is loading!");
         * }
         * ```
         */
        this.onChunkPreload = new EventEmitter();
        this._sizesCache = [];
        this._differ = null;
        this.heightCache = [];
        this.MAX_PERF_SCROLL_DIFF = 4;
        /**
         * Height that is being virtualized.
         */
        this._virtHeight = 0;
        /**
         * Ratio for height that's being virtualizaed and the one visible
         * If _virtHeightRatio = 1, the visible height and the virtualized are the same, also _maxHeight > _virtHeight.
         */
        this._virtHeightRatio = 1;
        /**
         * Internal track for scroll top that is being virtualized
         */
        this._virtScrollTop = 0;
        /**
         * If the next onScroll event is triggered due to internal setting of scrollTop
         */
        this._bScrollInternal = false;
        // End properties related to virtual height handling
        this._embeddedViews = [];
    }
    Object.defineProperty(IgxForOfDirective.prototype, "sizesCache", {
        get: /**
         * @protected
         * @return {?}
         */
        function () {
            return this._sizesCache;
        },
        set: /**
         * @protected
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._sizesCache = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxForOfDirective.prototype, "_isScrolledToBottom", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            if (!this.getVerticalScroll()) {
                return true;
            }
            /** @type {?} */
            var scrollTop = this.getVerticalScroll().scrollTop;
            /** @type {?} */
            var scrollHeight = this.getVerticalScroll().scrollHeight;
            // Use === and not >= because `scrollTop + container size` can't be bigger than `scrollHeight`, unless something isn't updated.
            // Also use Math.round because Chrome has some inconsistencies and `scrollTop + container` can be float when zooming the page.
            return Math.round(scrollTop + this.igxForContainerSize) === scrollHeight;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxForOfDirective.prototype, "_isAtBottomIndex", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return this.igxForOf && this.state.startIndex + this.state.chunkSize > this.igxForOf.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxForOfDirective.prototype, "isRemote", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @protected
         * @return {?}
         */
        function () {
            return this.totalItemCount !== null;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    IgxForOfDirective.prototype.removeScrollEventListeners = /**
     * @hidden
     * @protected
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.igxForScrollOrientation === 'horizontal') {
            this._zone.runOutsideAngular(function () {
                return _this.getHorizontalScroll().removeEventListener('scroll', _this.func);
            });
        }
        else {
            /** @type {?} */
            var vertical_1 = this.getVerticalScroll();
            if (vertical_1) {
                this._zone.runOutsideAngular(function () {
                    return vertical_1.removeEventListener('scroll', _this.verticalScrollHandler);
                });
            }
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    IgxForOfDirective.prototype.verticalScrollHandler = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onScroll(event);
    };
    /**
     * @return {?}
     */
    IgxForOfDirective.prototype.isScrollable = /**
     * @return {?}
     */
    function () {
        return this.vh.instance.height > parseInt(this.igxForContainerSize, 10);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxForOfDirective.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var totalSize = 0;
        /** @type {?} */
        var vc = this.igxForScrollContainer ? this.igxForScrollContainer._viewContainer : this._viewContainer;
        this.igxForSizePropName = this.igxForSizePropName || 'width';
        /** @type {?} */
        var dcFactory = this.resolver.resolveComponentFactory(DisplayContainerComponent);
        this.dc = this._viewContainer.createComponent(dcFactory, 0);
        this.dc.instance.scrollDirection = this.igxForScrollOrientation;
        if (typeof MSGesture === 'function') {
            // On Edge and IE when scrolling on touch the page scroll instead of the grid.
            this.dc.instance._viewContainer.element.nativeElement.style.touchAction = 'none';
        }
        if (this.igxForOf && this.igxForOf.length) {
            this.dc.instance.notVirtual = !(this.igxForContainerSize && this.state.chunkSize < this.igxForOf.length);
            totalSize = this.initSizesCache(this.igxForOf);
            this.hScroll = this.getElement(vc, 'igx-horizontal-virtual-helper');
            if (this.hScroll) {
                this.state.startIndex = this.getIndexAt(this.hScroll.scrollLeft, this.sizesCache, 0);
            }
            this.state.chunkSize = this._calculateChunkSize();
            for (var i = 0; i < this.state.chunkSize && this.igxForOf[i] !== undefined; i++) {
                /** @type {?} */
                var input = this.igxForOf[i];
                /** @type {?} */
                var embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, { $implicit: input, index: this.igxForOf.indexOf(input) });
                this._embeddedViews.push(embeddedView);
            }
        }
        if (this.igxForScrollOrientation === 'vertical') {
            this.dc.instance._viewContainer.element.nativeElement.style.top = '0px';
            /** @type {?} */
            var factory = this.resolver.resolveComponentFactory(VirtualHelperComponent);
            this.vh = vc.createComponent(factory);
            this._maxHeight = this._calcMaxBrowserHeight();
            this.vh.instance.height = this.igxForOf ? this._calcHeight() : 0;
            this._zone.runOutsideAngular(function () {
                _this.verticalScrollHandler = _this.verticalScrollHandler.bind(_this);
                _this.vh.instance.elementRef.nativeElement.addEventListener('scroll', _this.verticalScrollHandler);
                _this.dc.instance.scrollContainer = _this.vh.instance.elementRef.nativeElement;
            });
        }
        if (this.igxForScrollOrientation === 'horizontal') {
            this.func = function (evt) { _this.onHScroll(evt); };
            this.hScroll = this.getElement(vc, 'igx-horizontal-virtual-helper');
            if (!this.hScroll) {
                /** @type {?} */
                var hvFactory = this.resolver.resolveComponentFactory(HVirtualHelperComponent);
                this.hvh = vc.createComponent(hvFactory);
                this.hvh.instance.width = totalSize;
                this.hScroll = this.hvh.instance.elementRef.nativeElement;
                this._zone.runOutsideAngular(function () {
                    _this.hvh.instance.elementRef.nativeElement.addEventListener('scroll', _this.func);
                    _this.dc.instance.scrollContainer = _this.hScroll;
                });
            }
            else {
                this._zone.runOutsideAngular(function () {
                    _this.hScroll.addEventListener('scroll', _this.func);
                    _this.dc.instance.scrollContainer = _this.hScroll;
                });
            }
            /** @type {?} */
            var scrollOffset = this.hScroll.scrollLeft -
                (this.sizesCache && this.sizesCache.length ? this.sizesCache[this.state.startIndex] : 0);
            this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxForOfDirective.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.removeScrollEventListeners();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} changes
     * @return {?}
     */
    IgxForOfDirective.prototype.ngOnChanges = /**
     * @hidden
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        /** @type {?} */
        var forOf = 'igxForOf';
        if (forOf in changes) {
            /** @type {?} */
            var value = changes[forOf].currentValue;
            if (!this._differ && value) {
                try {
                    this._differ = this._differs.find(value).create(this.igxForTrackBy);
                }
                catch (e) {
                    throw new Error("Cannot find a differ supporting object \"" + value + "\" of type \"" + getTypeNameForDebugging(value) + "\".\n                     NgFor only supports binding to Iterables such as Arrays.");
                }
            }
        }
        /** @type {?} */
        var defaultItemSize = 'igxForItemSize';
        if (defaultItemSize in changes && !changes[defaultItemSize].firstChange && this.igxForScrollOrientation === 'vertical') {
            // handle default item size changed.
            this.initSizesCache(this.igxForOf);
        }
        /** @type {?} */
        var containerSize = 'igxForContainerSize';
        if (containerSize in changes && !changes[containerSize].firstChange && this.igxForOf) {
            this._recalcOnContainerChange(changes);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxForOfDirective.prototype.ngDoCheck = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._differ) {
            /** @type {?} */
            var changes = this._differ.diff(this.igxForOf);
            if (changes) {
                //  re-init cache.
                if (!this.igxForOf) {
                    return;
                }
                this._updateSizeCache();
                this._zone.run(function () {
                    _this._applyChanges();
                    _this.cdr.markForCheck();
                    _this._updateScrollOffset();
                    _this.onDataChanged.emit();
                });
            }
        }
    };
    /**
     * Shifts the scroll thumb position.
     * ```typescript
     * this.parentVirtDir.addScrollTop(5);
     * ```
     * @param addTop negative value to scroll up and positive to scroll down;
     */
    /**
     * Shifts the scroll thumb position.
     * ```typescript
     * this.parentVirtDir.addScrollTop(5);
     * ```
     * @param {?} addTop negative value to scroll up and positive to scroll down;
     * @return {?}
     */
    IgxForOfDirective.prototype.addScrollTop = /**
     * Shifts the scroll thumb position.
     * ```typescript
     * this.parentVirtDir.addScrollTop(5);
     * ```
     * @param {?} addTop negative value to scroll up and positive to scroll down;
     * @return {?}
     */
    function (addTop) {
        if (addTop === 0 && this.igxForScrollOrientation === 'horizontal') {
            return false;
        }
        /** @type {?} */
        var originalVirtScrollTop = this._virtScrollTop;
        /** @type {?} */
        var containerSize = parseInt(this.igxForContainerSize, 10);
        /** @type {?} */
        var maxVirtScrollTop = this._virtHeight - containerSize;
        this._bScrollInternal = true;
        this._virtScrollTop += addTop;
        this._virtScrollTop = this._virtScrollTop > 0 ?
            (this._virtScrollTop < maxVirtScrollTop ? this._virtScrollTop : maxVirtScrollTop) :
            0;
        this.vh.instance.elementRef.nativeElement.scrollTop += addTop / this._virtHeightRatio;
        if (Math.abs(addTop / this._virtHeightRatio) < 1) {
            // Actual scroll delta that was added is smaller than 1 and onScroll handler doesn't trigger when scrolling < 1px
            /** @type {?} */
            var scrollOffset = this.fixedUpdateAllElements(this._virtScrollTop);
            // scrollOffset = scrollOffset !== parseInt(this.igxForItemSize, 10) ? scrollOffset : 0;
            this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
        }
        /** @type {?} */
        var curScrollTop = this.vh.instance.elementRef.nativeElement.scrollTop;
        /** @type {?} */
        var maxRealScrollTop = this.vh.instance.elementRef.nativeElement.scrollHeight - containerSize;
        if ((this._virtScrollTop > 0 && curScrollTop === 0) ||
            (this._virtScrollTop < maxVirtScrollTop && curScrollTop === maxRealScrollTop)) {
            // Actual scroll position is at the top or bottom, but virtual one is not at the top or bottom (there's more to scroll)
            // Recalculate actual scroll position based on the virtual scroll.
            this.vh.instance.elementRef.nativeElement.scrollTop = this._virtScrollTop / this._virtHeightRatio;
        }
        else if (this._virtScrollTop === 0 && curScrollTop > 0) {
            // Actual scroll position is not at the top, but virtual scroll is. Just update the actual scroll
            this.vh.instance.elementRef.nativeElement.scrollTop = 0;
        }
        else if (this._virtScrollTop === maxVirtScrollTop && curScrollTop < maxRealScrollTop) {
            // Actual scroll position is not at the bottom, but virtual scroll is. Just update the acual scroll
            this.vh.instance.elementRef.nativeElement.scrollTop = maxRealScrollTop;
        }
        return this._virtScrollTop !== originalVirtScrollTop;
    };
    /**
     * Scrolls to the specified index.
     * ```typescript
     * this.parentVirtDir.scrollTo(5);
     * ```
     * @param index
     */
    /**
     * Scrolls to the specified index.
     * ```typescript
     * this.parentVirtDir.scrollTo(5);
     * ```
     * @param {?} index
     * @return {?}
     */
    IgxForOfDirective.prototype.scrollTo = /**
     * Scrolls to the specified index.
     * ```typescript
     * this.parentVirtDir.scrollTo(5);
     * ```
     * @param {?} index
     * @return {?}
     */
    function (index) {
        if (index < 0 || index > (this.isRemote ? this.totalItemCount : this.igxForOf.length) - 1) {
            return;
        }
        /** @type {?} */
        var containerSize = parseInt(this.igxForContainerSize, 10);
        /** @type {?} */
        var scr = this.igxForScrollOrientation === 'horizontal' ?
            this.hScroll.scrollLeft : this.vh.instance.elementRef.nativeElement.scrollTop;
        /** @type {?} */
        var isPrevItem = index < this.state.startIndex || scr > this.sizesCache[index];
        /** @type {?} */
        var nextScroll = isPrevItem ? this.sizesCache[index] : this.sizesCache[index + 1] - containerSize;
        if (nextScroll < 0) {
            return;
        }
        if (this.igxForScrollOrientation === 'horizontal') {
            this.hScroll.scrollLeft = nextScroll;
        }
        else {
            /** @type {?} */
            var maxVirtScrollTop = this._virtHeight - containerSize;
            if (nextScroll > maxVirtScrollTop) {
                nextScroll = maxVirtScrollTop;
            }
            this._bScrollInternal = true;
            this._virtScrollTop = nextScroll;
            this.vh.instance.elementRef.nativeElement.scrollTop = this._virtScrollTop / this._virtHeightRatio;
            this._adjustToIndex = !isPrevItem ? index : null;
        }
    };
    /**
     * Scrolls by one item into the appropriate next direction.
     * For "horizontal" orientation that will be the right column and for "vertical" that is the lower row.
     * ```typescript
     * this.parentVirtDir.scrollNext();
     * ```
     */
    /**
     * Scrolls by one item into the appropriate next direction.
     * For "horizontal" orientation that will be the right column and for "vertical" that is the lower row.
     * ```typescript
     * this.parentVirtDir.scrollNext();
     * ```
     * @return {?}
     */
    IgxForOfDirective.prototype.scrollNext = /**
     * Scrolls by one item into the appropriate next direction.
     * For "horizontal" orientation that will be the right column and for "vertical" that is the lower row.
     * ```typescript
     * this.parentVirtDir.scrollNext();
     * ```
     * @return {?}
     */
    function () {
        /** @type {?} */
        var scr = Math.ceil(this.igxForScrollOrientation === 'horizontal' ?
            this.hScroll.scrollLeft :
            this.vh.instance.elementRef.nativeElement.scrollTop);
        /** @type {?} */
        var endIndex = this.getIndexAt(scr + parseInt(this.igxForContainerSize, 10), this.sizesCache, 0);
        this.scrollTo(endIndex);
    };
    /**
     * Scrolls by one item into the appropriate previous direction.
     * For "horizontal" orientation that will be the left column and for "vertical" that is the upper row.
     * ```typescript
     * this.parentVirtDir.scrollPrev();
     * ```
     */
    /**
     * Scrolls by one item into the appropriate previous direction.
     * For "horizontal" orientation that will be the left column and for "vertical" that is the upper row.
     * ```typescript
     * this.parentVirtDir.scrollPrev();
     * ```
     * @return {?}
     */
    IgxForOfDirective.prototype.scrollPrev = /**
     * Scrolls by one item into the appropriate previous direction.
     * For "horizontal" orientation that will be the left column and for "vertical" that is the upper row.
     * ```typescript
     * this.parentVirtDir.scrollPrev();
     * ```
     * @return {?}
     */
    function () {
        this.scrollTo(this.state.startIndex - 1);
    };
    /**
     * Scrolls by one page into the appropriate next direction.
     * For "horizontal" orientation that will be one view to the right and for "vertical" that is one view to the bottom.
     * ```typescript
     * this.parentVirtDir.scrollNextPage();
     * ```
     */
    /**
     * Scrolls by one page into the appropriate next direction.
     * For "horizontal" orientation that will be one view to the right and for "vertical" that is one view to the bottom.
     * ```typescript
     * this.parentVirtDir.scrollNextPage();
     * ```
     * @return {?}
     */
    IgxForOfDirective.prototype.scrollNextPage = /**
     * Scrolls by one page into the appropriate next direction.
     * For "horizontal" orientation that will be one view to the right and for "vertical" that is one view to the bottom.
     * ```typescript
     * this.parentVirtDir.scrollNextPage();
     * ```
     * @return {?}
     */
    function () {
        if (this.igxForScrollOrientation === 'horizontal') {
            this.hvh.instance.elementRef.nativeElement.scrollLeft += parseInt(this.igxForContainerSize, 10);
        }
        else {
            this.addScrollTop(parseInt(this.igxForContainerSize, 10));
        }
    };
    /**
     * Scrolls by one page into the appropriate previous direction.
     * For "horizontal" orientation that will be one view to the left and for "vertical" that is one view to the top.
     * ```typescript
     * this.parentVirtDir.scrollPrevPage();
     * ```
     */
    /**
     * Scrolls by one page into the appropriate previous direction.
     * For "horizontal" orientation that will be one view to the left and for "vertical" that is one view to the top.
     * ```typescript
     * this.parentVirtDir.scrollPrevPage();
     * ```
     * @return {?}
     */
    IgxForOfDirective.prototype.scrollPrevPage = /**
     * Scrolls by one page into the appropriate previous direction.
     * For "horizontal" orientation that will be one view to the left and for "vertical" that is one view to the top.
     * ```typescript
     * this.parentVirtDir.scrollPrevPage();
     * ```
     * @return {?}
     */
    function () {
        if (this.igxForScrollOrientation === 'horizontal') {
            this.hvh.instance.elementRef.nativeElement.scrollLeft -= parseInt(this.igxForContainerSize, 10);
        }
        else {
            /** @type {?} */
            var containerSize = (parseInt(this.igxForContainerSize, 10));
            this.addScrollTop(-containerSize);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} colIndex
     * @return {?}
     */
    IgxForOfDirective.prototype.getColumnScrollLeft = /**
     * @hidden
     * @param {?} colIndex
     * @return {?}
     */
    function (colIndex) {
        return this.sizesCache[colIndex];
    };
    /**
     * Returns a reference to the vertical scrollbar DOM element.
     * ```typescript
     * this.parentVirtDir.getVerticalScroll();
     * ```
     */
    /**
     * Returns a reference to the vertical scrollbar DOM element.
     * ```typescript
     * this.parentVirtDir.getVerticalScroll();
     * ```
     * @return {?}
     */
    IgxForOfDirective.prototype.getVerticalScroll = /**
     * Returns a reference to the vertical scrollbar DOM element.
     * ```typescript
     * this.parentVirtDir.getVerticalScroll();
     * ```
     * @return {?}
     */
    function () {
        if (this.vh) {
            return this.vh.instance.elementRef.nativeElement;
        }
        return null;
    };
    /**
     * Returns the total number of items that are fully visible.
     * ```typescript
     * this.parentVirtDir.getItemCountInView();
     * ```
     */
    /**
     * Returns the total number of items that are fully visible.
     * ```typescript
     * this.parentVirtDir.getItemCountInView();
     * ```
     * @return {?}
     */
    IgxForOfDirective.prototype.getItemCountInView = /**
     * Returns the total number of items that are fully visible.
     * ```typescript
     * this.parentVirtDir.getItemCountInView();
     * ```
     * @return {?}
     */
    function () {
        /** @type {?} */
        var position = this.igxForScrollOrientation === 'horizontal' ?
            this.hScroll.scrollLeft :
            this.vh.instance.elementRef.nativeElement.scrollTop;
        /** @type {?} */
        var startIndex = this.getIndexAt(position, this.sizesCache, 0);
        if (position - this.sizesCache[startIndex] > 0) {
            // fisrt item is not fully in view
            startIndex++;
        }
        /** @type {?} */
        var endIndex = this.getIndexAt(position + parseInt(this.igxForContainerSize, 10), this.sizesCache, 0);
        return endIndex - startIndex;
    };
    /**
     * Returns a reference to the horizontal scrollbar DOM element.
     * ```typescript
     * this.parentVirtDir.getHorizontalScroll();
     * ```
     */
    /**
     * Returns a reference to the horizontal scrollbar DOM element.
     * ```typescript
     * this.parentVirtDir.getHorizontalScroll();
     * ```
     * @return {?}
     */
    IgxForOfDirective.prototype.getHorizontalScroll = /**
     * Returns a reference to the horizontal scrollbar DOM element.
     * ```typescript
     * this.parentVirtDir.getHorizontalScroll();
     * ```
     * @return {?}
     */
    function () {
        return this.getElement(this._viewContainer, 'igx-horizontal-virtual-helper') || this.hScroll;
    };
    /**
     * Returns the size of the element at the specified index.
     * ```typescript
     * this.parentVirtDir.getSizeAt(1);
     * ```
     */
    /**
     * Returns the size of the element at the specified index.
     * ```typescript
     * this.parentVirtDir.getSizeAt(1);
     * ```
     * @param {?} index
     * @return {?}
     */
    IgxForOfDirective.prototype.getSizeAt = /**
     * Returns the size of the element at the specified index.
     * ```typescript
     * this.parentVirtDir.getSizeAt(1);
     * ```
     * @param {?} index
     * @return {?}
     */
    function (index) {
        return this.sizesCache[index + 1] - this.sizesCache[index];
    };
    /**
     * Returns the scroll offset of the element at the specified index.
     * ```typescript
     * this.parentVirtDir.getScrollForIndex(1);
     * ```
     */
    /**
     * Returns the scroll offset of the element at the specified index.
     * ```typescript
     * this.parentVirtDir.getScrollForIndex(1);
     * ```
     * @param {?} index
     * @param {?=} bottom
     * @return {?}
     */
    IgxForOfDirective.prototype.getScrollForIndex = /**
     * Returns the scroll offset of the element at the specified index.
     * ```typescript
     * this.parentVirtDir.getScrollForIndex(1);
     * ```
     * @param {?} index
     * @param {?=} bottom
     * @return {?}
     */
    function (index, bottom) {
        /** @type {?} */
        var containerSize = parseInt(this.igxForContainerSize, 10);
        /** @type {?} */
        var scroll = bottom ? this.sizesCache[index + 1] - containerSize : this.sizesCache[index];
        return scroll;
    };
    /**
     * @hidden
     * Function that is called when scrolling vertically
     */
    /**
     * @hidden
     * Function that is called when scrolling vertically
     * @protected
     * @param {?} event
     * @return {?}
     */
    IgxForOfDirective.prototype.onScroll = /**
     * @hidden
     * Function that is called when scrolling vertically
     * @protected
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        /* in certain situations this may be called when no scrollbar is visible */
        if (!parseInt(this.vh.instance.elementRef.nativeElement.style.height, 10)) {
            return;
        }
        /** @type {?} */
        var containerSize = parseInt(this.igxForContainerSize, 10);
        /** @type {?} */
        var maxRealScrollTop = event.target.children[0].scrollHeight - containerSize;
        /** @type {?} */
        var realPercentScrolled = event.target.scrollTop / maxRealScrollTop;
        if (!this._bScrollInternal) {
            /** @type {?} */
            var maxVirtScrollTop = this._virtHeight - containerSize;
            this._virtScrollTop = realPercentScrolled * maxVirtScrollTop;
        }
        else {
            this._bScrollInternal = false;
        }
        /** @type {?} */
        var prevStartIndex = this.state.startIndex;
        /** @type {?} */
        var scrollOffset = this.fixedUpdateAllElements(this._virtScrollTop);
        this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
        requestAnimationFrame(function () {
            // check if height/width has changes in views.
            _this.recalcUpdateSizes();
        });
        this.dc.changeDetectorRef.detectChanges();
        if (prevStartIndex !== this.state.startIndex) {
            this.onChunkLoad.emit(this.state);
        }
    };
    /**
     * @hidden
     * Function that recaculates and updates cache sizes.
     */
    /**
     * @hidden
     * Function that recaculates and updates cache sizes.
     * @return {?}
     */
    IgxForOfDirective.prototype.recalcUpdateSizes = /**
     * @hidden
     * Function that recaculates and updates cache sizes.
     * @return {?}
     */
    function () {
        /** @type {?} */
        var dimension = this.igxForScrollOrientation === 'horizontal' ?
            this.igxForSizePropName : 'height';
        /** @type {?} */
        var diffs = [];
        /** @type {?} */
        var totalDiff = 0;
        for (var i = 0; i < this._embeddedViews.length; i++) {
            /** @type {?} */
            var view = this._embeddedViews[i];
            /** @type {?} */
            var rNode = view.rootNodes.find(function (node) { return node.nodeType === Node.ELEMENT_NODE; });
            if (rNode) {
                /** @type {?} */
                var h = rNode.offsetHeight ? rNode.offsetHeight : parseInt(this.igxForItemSize, 10);
                /** @type {?} */
                var index = this.state.startIndex + i;
                if (!this.isRemote && !this.igxForOf[index]) {
                    continue;
                }
                /** @type {?} */
                var oldVal = dimension === 'height' ? this.heightCache[index] : this.igxForOf[index][dimension];
                /** @type {?} */
                var newVal = dimension === 'height' ? h : rNode.clientWidth;
                if (dimension === 'height') {
                    this.heightCache[index] = newVal;
                }
                else {
                    this.igxForOf[index][dimension] = newVal;
                }
                /** @type {?} */
                var currDiff = newVal - oldVal;
                diffs.push(currDiff);
                totalDiff += currDiff;
                this.sizesCache[index + 1] += totalDiff;
            }
        }
        // update cache
        if (Math.abs(totalDiff) > 0) {
            for (var j = this.state.startIndex + this.state.chunkSize + 1; j < this.sizesCache.length; j++) {
                this.sizesCache[j] += totalDiff;
            }
            // update scrBar heights/widths
            if (this.igxForScrollOrientation === 'horizontal') {
                /** @type {?} */
                var totalWidth = parseInt(this.hScroll.children[0].style.width, 10) + totalDiff;
                this.hScroll.children[0].style.width = totalWidth + 'px';
            }
            /** @type {?} */
            var reducer = function (acc, val) { return acc + val; };
            if (this.igxForScrollOrientation === 'vertical') {
                /** @type {?} */
                var scrToBottom = this._isScrolledToBottom && !this.dc.instance.notVirtual;
                /** @type {?} */
                var hSum = this.heightCache.reduce(reducer);
                if (hSum > this._maxHeight) {
                    this._virtHeightRatio = hSum / this._maxHeight;
                }
                this.vh.instance.height = Math.min(this.vh.instance.height + totalDiff, this._maxHeight);
                this._virtHeight = hSum;
                if (!this.vh.instance.destroyed) {
                    this.vh.instance.cdr.detectChanges();
                }
                if (scrToBottom && !this._isAtBottomIndex) {
                    /** @type {?} */
                    var containerSize = parseInt(this.igxForContainerSize, 10);
                    /** @type {?} */
                    var scrollOffset = this.fixedUpdateAllElements(this._virtHeight - containerSize);
                    this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
                    return;
                }
                if (this._adjustToIndex) {
                    // in case scrolled to specific index where after scroll heights are changed
                    // need to adjust the offsets so that item is last in view.
                    /** @type {?} */
                    var updatesToIndex = this._adjustToIndex - this.state.startIndex + 1;
                    /** @type {?} */
                    var sumDiffs = diffs.slice(0, updatesToIndex).reduce(reducer);
                    /** @type {?} */
                    var currOffset = parseInt(this.dc.instance._viewContainer.element.nativeElement.style.top, 10);
                    this.dc.instance._viewContainer.element.nativeElement.style.top = (currOffset - sumDiffs) + 'px';
                    this._adjustToIndex = null;
                }
            }
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} inScrollTop
     * @return {?}
     */
    IgxForOfDirective.prototype.fixedUpdateAllElements = /**
     * @hidden
     * @protected
     * @param {?} inScrollTop
     * @return {?}
     */
    function (inScrollTop) {
        /** @type {?} */
        var count = this.isRemote ? this.totalItemCount : this.igxForOf.length;
        /** @type {?} */
        var newStart = this.getIndexAt(inScrollTop, this.sizesCache, 0);
        if (newStart + this.state.chunkSize > count) {
            newStart = count - this.state.chunkSize;
        }
        /** @type {?} */
        var prevStart = this.state.startIndex;
        /** @type {?} */
        var diff = newStart - this.state.startIndex;
        this.state.startIndex = newStart;
        if (diff) {
            this.onChunkPreload.emit(this.state);
            if (!this.isRemote) {
                /*recalculate and apply page size.*/
                if (diff > 0 && diff <= this.MAX_PERF_SCROLL_DIFF) {
                    this.moveApplyScrollNext(prevStart);
                }
                else if (diff < 0 && Math.abs(diff) <= this.MAX_PERF_SCROLL_DIFF) {
                    this.moveApplyScrollPrev(prevStart);
                }
                else {
                    this.fixedApplyScroll();
                }
            }
        }
        return inScrollTop - this.sizesCache[this.state.startIndex];
    };
    /**
     * @hidden
     * The function applies an optimized state change for scrolling down/right employing context change with view rearrangement
     */
    /**
     * @hidden
     * The function applies an optimized state change for scrolling down/right employing context change with view rearrangement
     * @protected
     * @param {?} prevIndex
     * @return {?}
     */
    IgxForOfDirective.prototype.moveApplyScrollNext = /**
     * @hidden
     * The function applies an optimized state change for scrolling down/right employing context change with view rearrangement
     * @protected
     * @param {?} prevIndex
     * @return {?}
     */
    function (prevIndex) {
        /** @type {?} */
        var start = prevIndex + this.state.chunkSize;
        for (var i = start; i < start + this.state.startIndex - prevIndex && this.igxForOf[i] !== undefined; i++) {
            /** @type {?} */
            var input = this.igxForOf[i];
            /** @type {?} */
            var embView = this._embeddedViews.shift();
            /** @type {?} */
            var cntx = embView.context;
            cntx.$implicit = input;
            cntx.index = this.getContextIndex(input);
            /** @type {?} */
            var view = this.dc.instance._vcr.detach(0);
            this.dc.instance._vcr.insert(view);
            this._embeddedViews.push(embView);
        }
    };
    /**
     * @hidden
     * The function applies an optimized state change for scrolling up/left employing context change with view rearrangement
     */
    /**
     * @hidden
     * The function applies an optimized state change for scrolling up/left employing context change with view rearrangement
     * @protected
     * @param {?} prevIndex
     * @return {?}
     */
    IgxForOfDirective.prototype.moveApplyScrollPrev = /**
     * @hidden
     * The function applies an optimized state change for scrolling up/left employing context change with view rearrangement
     * @protected
     * @param {?} prevIndex
     * @return {?}
     */
    function (prevIndex) {
        for (var i = prevIndex - 1; i >= this.state.startIndex && this.igxForOf[i] !== undefined; i--) {
            /** @type {?} */
            var input = this.igxForOf[i];
            /** @type {?} */
            var embView = this._embeddedViews.pop();
            /** @type {?} */
            var cntx = embView.context;
            cntx.$implicit = input;
            cntx.index = this.getContextIndex(input);
            /** @type {?} */
            var view = this.dc.instance._vcr.detach(this.dc.instance._vcr.length - 1);
            this.dc.instance._vcr.insert(view, 0);
            this._embeddedViews.unshift(embView);
        }
    };
    /**
     * @hidden
    */
    /**
     * @hidden
     * @protected
     * @param {?} input
     * @return {?}
     */
    IgxForOfDirective.prototype.getContextIndex = /**
     * @hidden
     * @protected
     * @param {?} input
     * @return {?}
     */
    function (input) {
        return this.isRemote ? this.state.startIndex + this.igxForOf.indexOf(input) : this.igxForOf.indexOf(input);
    };
    /**
     * @hidden
     * The function applies an optimized state change through context change for each view
     */
    /**
     * @hidden
     * The function applies an optimized state change through context change for each view
     * @protected
     * @return {?}
     */
    IgxForOfDirective.prototype.fixedApplyScroll = /**
     * @hidden
     * The function applies an optimized state change through context change for each view
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var j = 0;
        /** @type {?} */
        var endIndex = this.state.startIndex + this.state.chunkSize;
        for (var i = this.state.startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
            /** @type {?} */
            var input = this.igxForOf[i];
            /** @type {?} */
            var embView = this._embeddedViews[j++];
            /** @type {?} */
            var cntx = ((/** @type {?} */ (embView))).context;
            cntx.$implicit = input;
            cntx.index = this.getContextIndex(input);
        }
    };
    /**
     * @hidden
     * Function that is called when scrolling horizontally
     */
    /**
     * @hidden
     * Function that is called when scrolling horizontally
     * @protected
     * @param {?} event
     * @return {?}
     */
    IgxForOfDirective.prototype.onHScroll = /**
     * @hidden
     * Function that is called when scrolling horizontally
     * @protected
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /* in certain situations this may be called when no scrollbar is visible */
        if (!parseInt(this.hScroll.children[0].style.width, 10)) {
            return;
        }
        /** @type {?} */
        var curScrollLeft = event.target.scrollLeft;
        /** @type {?} */
        var prevStartIndex = this.state.startIndex;
        // Updating horizontal chunks
        /** @type {?} */
        var scrollOffset = this.fixedUpdateAllElements(curScrollLeft);
        this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
        this.dc.changeDetectorRef.detectChanges();
        if (prevStartIndex !== this.state.startIndex) {
            this.onChunkLoad.emit(this.state);
        }
    };
    Object.defineProperty(IgxForOfDirective.prototype, "igxForTrackBy", {
        /**
         * Gets the function used to track changes in the items collection.
         * By default the object references are compared. However this can be optimized if you have unique identifier
         * value that can be used for the comparison instead of the object ref or if you have some other property values
         * in the item object that should be tracked for changes.
         * This option is similar to ngForTrackBy.
         * ```typescript
         * const trackFunc = this.parentVirtDir.igxForTrackBy;
         * ```
         */
        get: /**
         * Gets the function used to track changes in the items collection.
         * By default the object references are compared. However this can be optimized if you have unique identifier
         * value that can be used for the comparison instead of the object ref or if you have some other property values
         * in the item object that should be tracked for changes.
         * This option is similar to ngForTrackBy.
         * ```typescript
         * const trackFunc = this.parentVirtDir.igxForTrackBy;
         * ```
         * @return {?}
         */
        function () { return this._trackByFn; },
        /**
         * Sets the function used to track changes in the items collection.
         * This function can be set in scenarios where you want to optimize or
         * customize the tracking of changes for the items in the collection.
         * The igxForTrackBy function takes the index and the current item as arguments and needs to return the unique identifier for this item.
         * ```typescript
         * this.parentVirtDir.igxForTrackBy = (index, item) => {
         *      return item.id + item.width;
         * };
         * ```
         */
        set: /**
         * Sets the function used to track changes in the items collection.
         * This function can be set in scenarios where you want to optimize or
         * customize the tracking of changes for the items in the collection.
         * The igxForTrackBy function takes the index and the current item as arguments and needs to return the unique identifier for this item.
         * ```typescript
         * this.parentVirtDir.igxForTrackBy = (index, item) => {
         *      return item.id + item.width;
         * };
         * ```
         * @param {?} fn
         * @return {?}
         */
        function (fn) { this._trackByFn = fn; },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    IgxForOfDirective.prototype._applyChanges = /**
     * @hidden
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var prevChunkSize = this.state.chunkSize;
        this.applyChunkSizeChange();
        this._recalcScrollBarSize();
        if (this.igxForOf && this.igxForOf.length && this.dc) {
            /** @type {?} */
            var embeddedViewCopy = Object.assign([], this._embeddedViews);
            /** @type {?} */
            var startIndex = this.state.startIndex;
            /** @type {?} */
            var endIndex = this.state.chunkSize + this.state.startIndex;
            if (this.isRemote) {
                startIndex = 0;
                endIndex = this.igxForOf.length;
            }
            for (var i = startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
                /** @type {?} */
                var input = this.igxForOf[i];
                /** @type {?} */
                var embView = embeddedViewCopy.shift();
                /** @type {?} */
                var cntx = ((/** @type {?} */ (embView))).context;
                cntx.$implicit = input;
                cntx.index = this.getContextIndex(input);
            }
            this.dc.changeDetectorRef.detectChanges();
            if (prevChunkSize !== this.state.chunkSize) {
                this.onChunkLoad.emit(this.state);
            }
            if (this.igxForScrollOrientation === 'vertical') {
                this.recalcUpdateSizes();
            }
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    IgxForOfDirective.prototype._calcMaxBrowserHeight = /**
     * @hidden
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var div = document.createElement('div');
        /** @type {?} */
        var style$$1 = div.style;
        style$$1.position = 'absolute';
        style$$1.top = '9999999999999999px';
        document.body.appendChild(div);
        /** @type {?} */
        var size = Math.abs(div.getBoundingClientRect()['top']);
        document.body.removeChild(div);
        return size;
    };
    /**
     * @hidden
     * Recalculates the chunkSize based on current startIndex and returns the new size.
     * This should be called after this.state.startIndex is updated, not before.
     */
    /**
     * @hidden
     * Recalculates the chunkSize based on current startIndex and returns the new size.
     * This should be called after this.state.startIndex is updated, not before.
     * @protected
     * @return {?}
     */
    IgxForOfDirective.prototype._calculateChunkSize = /**
     * @hidden
     * Recalculates the chunkSize based on current startIndex and returns the new size.
     * This should be called after this.state.startIndex is updated, not before.
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var chunkSize = 0;
        if (this.igxForContainerSize !== null && this.igxForContainerSize !== undefined) {
            if (!this.sizesCache) {
                this.initSizesCache(this.igxForOf);
            }
            chunkSize = this._calcMaxChunkSize();
            if (this.igxForOf && chunkSize > this.igxForOf.length) {
                chunkSize = this.igxForOf.length;
            }
        }
        else {
            if (this.igxForOf) {
                chunkSize = this.igxForOf.length;
            }
        }
        return chunkSize;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} viewref
     * @param {?} nodeName
     * @return {?}
     */
    IgxForOfDirective.prototype.getElement = /**
     * @hidden
     * @protected
     * @param {?} viewref
     * @param {?} nodeName
     * @return {?}
     */
    function (viewref, nodeName) {
        /** @type {?} */
        var elem = viewref.element.nativeElement.parentNode.getElementsByTagName(nodeName);
        return elem.length > 0 ? elem[0] : null;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} items
     * @return {?}
     */
    IgxForOfDirective.prototype.initSizesCache = /**
     * @hidden
     * @protected
     * @param {?} items
     * @return {?}
     */
    function (items) {
        /** @type {?} */
        var totalSize = 0;
        /** @type {?} */
        var size = 0;
        /** @type {?} */
        var dimension = this.igxForScrollOrientation === 'horizontal' ?
            this.igxForSizePropName : 'height';
        /** @type {?} */
        var i = 0;
        this.sizesCache = [];
        this.heightCache = [];
        this.sizesCache.push(0);
        /** @type {?} */
        var count = this.isRemote ? this.totalItemCount : items.length;
        for (i; i < count; i++) {
            if (dimension === 'height') {
                // cols[i][dimension] = parseInt(this.igxForItemSize, 10) || 0;
                size = parseInt(this.igxForItemSize, 10) || 0;
                this.heightCache.push(size);
            }
            else {
                size = this._getItemSize(items[i], dimension);
            }
            totalSize += size;
            this.sizesCache.push(totalSize);
        }
        return totalSize;
    };
    /**
     * @protected
     * @return {?}
     */
    IgxForOfDirective.prototype._updateSizeCache = /**
     * @protected
     * @return {?}
     */
    function () {
        if (this.igxForScrollOrientation === 'horizontal') {
            this.initSizesCache(this.igxForOf);
            return;
        }
        /** @type {?} */
        var scr = this.vh.instance.elementRef.nativeElement;
        /** @type {?} */
        var oldHeight = this.heightCache.length > 0 ? this.heightCache.reduce(function (acc, val) { return acc + val; }) : 0;
        /** @type {?} */
        var newHeight = this.initSizesCache(this.igxForOf);
        /** @type {?} */
        var diff = oldHeight - newHeight;
        // if data has been changed while container is scrolled
        // should update scroll top/left according to change so that same startIndex is in view
        if (Math.abs(diff) > 0 && scr.scrollTop > 0) {
            this.recalcUpdateSizes();
            /** @type {?} */
            var offset = parseInt(this.dc.instance._viewContainer.element.nativeElement.style.top, 10);
            scr.scrollTop = this.sizesCache[this.state.startIndex] - offset;
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    IgxForOfDirective.prototype._calcMaxChunkSize = /**
     * @hidden
     * @protected
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var i = 0;
        /** @type {?} */
        var length = 0;
        /** @type {?} */
        var maxLength = 0;
        /** @type {?} */
        var arr = [];
        /** @type {?} */
        var sum = 0;
        /** @type {?} */
        var availableSize = parseInt(this.igxForContainerSize, 10);
        if (!availableSize) {
            return 0;
        }
        /** @type {?} */
        var dimension = this.igxForScrollOrientation === 'horizontal' ?
            this.igxForSizePropName : 'height';
        /** @type {?} */
        var reducer = function (accumulator, currentItem) { return accumulator + _this._getItemSize(currentItem, dimension); };
        for (i; i < this.igxForOf.length; i++) {
            /** @type {?} */
            var item = this.igxForOf[i];
            if (dimension === 'height') {
                item = { value: this.igxForOf[i], height: this.heightCache[i] };
            }
            /** @type {?} */
            var size = dimension === 'height' ?
                this.heightCache[i] :
                this._getItemSize(item, dimension);
            sum = arr.reduce(reducer, size);
            if (sum < availableSize) {
                arr.push(item);
                length = arr.length;
                if (i === this.igxForOf.length - 1) {
                    // reached end without exceeding
                    // include prev items until size is filled or first item is reached.
                    /** @type {?} */
                    var curItem = dimension === 'height' ? arr[0].value : arr[0];
                    /** @type {?} */
                    var prevIndex = this.igxForOf.indexOf(curItem) - 1;
                    while (prevIndex >= 0 && sum <= availableSize) {
                        curItem = dimension === 'height' ? arr[0].value : arr[0];
                        prevIndex = this.igxForOf.indexOf(curItem) - 1;
                        /** @type {?} */
                        var prevItem = this.igxForOf[prevIndex];
                        /** @type {?} */
                        var prevSize = dimension === 'height' ?
                            this.heightCache[prevIndex] :
                            parseInt(prevItem[dimension], 10);
                        sum = arr.reduce(reducer, prevSize);
                        arr.unshift(prevItem);
                        length = arr.length;
                    }
                }
            }
            else {
                arr.push(item);
                length = arr.length + 1;
                arr.shift();
            }
            if (length > maxLength) {
                maxLength = length;
            }
        }
        return maxLength;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} left
     * @param {?} set
     * @param {?} index
     * @return {?}
     */
    IgxForOfDirective.prototype.getIndexAt = /**
     * @hidden
     * @protected
     * @param {?} left
     * @param {?} set
     * @param {?} index
     * @return {?}
     */
    function (left, set, index) {
        /** @type {?} */
        var start = 0;
        /** @type {?} */
        var end = set.length - 1;
        if (left === 0) {
            return 0;
        }
        while (start <= end) {
            /** @type {?} */
            var midIdx = Math.floor((start + end) / 2);
            /** @type {?} */
            var midLeft = set[midIdx];
            /** @type {?} */
            var cmp = left - midLeft;
            if (cmp > 0) {
                start = midIdx + 1;
            }
            else if (cmp < 0) {
                end = midIdx - 1;
            }
            else {
                return midIdx;
            }
        }
        return end;
    };
    /**
     * @protected
     * @return {?}
     */
    IgxForOfDirective.prototype._recalcScrollBarSize = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var count = this.isRemote ? this.totalItemCount : (this.igxForOf ? this.igxForOf.length : 0);
        this.dc.instance.notVirtual = !(this.igxForContainerSize && this.dc && this.state.chunkSize < count);
        if (this.igxForScrollOrientation === 'horizontal') {
            /** @type {?} */
            var totalWidth = this.igxForContainerSize ? this.initSizesCache(this.igxForOf) : 0;
            this.hScroll.style.width = this.igxForContainerSize + 'px';
            this.hScroll.children[0].style.width = totalWidth + 'px';
        }
        if (this.igxForScrollOrientation === 'vertical') {
            this.vh.instance.elementRef.nativeElement.style.height = parseInt(this.igxForContainerSize, 10) + 'px';
            this.vh.instance.height = this._calcHeight();
        }
    };
    /**
     * @protected
     * @return {?}
     */
    IgxForOfDirective.prototype._calcHeight = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var height;
        if (this.heightCache) {
            height = this.heightCache.reduce(function (acc, val) { return acc + val; }, 0);
        }
        else {
            height = this.initSizesCache(this.igxForOf);
        }
        this._virtHeight = height;
        if (height > this._maxHeight) {
            this._virtHeightRatio = height / this._maxHeight;
            height = this._maxHeight;
        }
        return height;
    };
    /**
     * @protected
     * @param {?} changes
     * @return {?}
     */
    IgxForOfDirective.prototype._recalcOnContainerChange = /**
     * @protected
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        this.dc.instance._viewContainer.element.nativeElement.style.top = '0px';
        this.dc.instance._viewContainer.element.nativeElement.style.left = '0px';
        /** @type {?} */
        var prevChunkSize = this.state.chunkSize;
        this.applyChunkSizeChange();
        this._recalcScrollBarSize();
        if (prevChunkSize !== this.state.chunkSize) {
            this.onChunkLoad.emit(this.state);
        }
        if (this.sizesCache && this.hScroll && this.hScroll.scrollLeft !== 0) {
            // Updating horizontal chunks and offsets based on the new scrollLeft
            /** @type {?} */
            var scrollOffset = this.fixedUpdateAllElements(this.hScroll.scrollLeft);
            this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
        }
    };
    /**
     * @hidden
     * Removes an elemenet from the embedded views and updates chunkSize.
     */
    /**
     * @hidden
     * Removes an elemenet from the embedded views and updates chunkSize.
     * @protected
     * @return {?}
     */
    IgxForOfDirective.prototype.removeLastElem = /**
     * @hidden
     * Removes an elemenet from the embedded views and updates chunkSize.
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var oldElem = this._embeddedViews.pop();
        this.onBeforeViewDestroyed.emit(oldElem);
        oldElem.destroy();
        this.state.chunkSize--;
    };
    /**
     * @hidden
     * If there exists an element that we can create embedded view for creates it, appends it and updates chunkSize
     */
    /**
     * @hidden
     * If there exists an element that we can create embedded view for creates it, appends it and updates chunkSize
     * @protected
     * @return {?}
     */
    IgxForOfDirective.prototype.addLastElem = /**
     * @hidden
     * If there exists an element that we can create embedded view for creates it, appends it and updates chunkSize
     * @protected
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var elemIndex = this.state.startIndex + this.state.chunkSize;
        if (!this.isRemote && !this.igxForOf) {
            return;
        }
        if (elemIndex >= this.igxForOf.length) {
            elemIndex = this.igxForOf.length - this.state.chunkSize;
        }
        /** @type {?} */
        var input = this.igxForOf[elemIndex];
        /** @type {?} */
        var embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, { $implicit: input, index: elemIndex });
        this._embeddedViews.push(embeddedView);
        this.state.chunkSize++;
        this._zone.run(function () {
            _this.cdr.markForCheck();
        });
    };
    /**
     * Recalculates chunkSize and adds/removes elements if need due to the change.
     * this.state.chunkSize is updated in @addLastElem() or @removeLastElem()
     */
    /**
     * Recalculates chunkSize and adds/removes elements if need due to the change.
     * this.state.chunkSize is updated in \@addLastElem() or \@removeLastElem()
     * @protected
     * @return {?}
     */
    IgxForOfDirective.prototype.applyChunkSizeChange = /**
     * Recalculates chunkSize and adds/removes elements if need due to the change.
     * this.state.chunkSize is updated in \@addLastElem() or \@removeLastElem()
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var chunkSize = this.isRemote ? (this.igxForOf ? this.igxForOf.length : 0) : this._calculateChunkSize();
        if (chunkSize > this.state.chunkSize) {
            /** @type {?} */
            var diff = chunkSize - this.state.chunkSize;
            for (var i = 0; i < diff; i++) {
                this.addLastElem();
            }
        }
        else if (chunkSize < this.state.chunkSize) {
            /** @type {?} */
            var diff = this.state.chunkSize - chunkSize;
            for (var i = 0; i < diff; i++) {
                this.removeLastElem();
            }
        }
    };
    /**
     * @protected
     * @return {?}
     */
    IgxForOfDirective.prototype._updateScrollOffset = /**
     * @protected
     * @return {?}
     */
    function () {
        if (this.igxForScrollOrientation === 'horizontal') {
            this._updateHScrollOffset();
        }
        else {
            this._updateVScrollOffset();
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxForOfDirective.prototype._updateVScrollOffset = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var scrollOffset = 0;
        /** @type {?} */
        var vScroll = this.vh.instance.elementRef.nativeElement;
        scrollOffset = vScroll && parseInt(vScroll.style.height, 10) ?
            vScroll.scrollTop - this.sizesCache[this.state.startIndex] : 0;
        this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
    };
    /**
     * @private
     * @return {?}
     */
    IgxForOfDirective.prototype._updateHScrollOffset = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var scrollOffset = 0;
        scrollOffset = this.hScroll && parseInt(this.hScroll.children[0].style.width, 10) ?
            this.hScroll.scrollLeft - this.sizesCache[this.state.startIndex] : 0;
        this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
    };
    /**
     * @private
     * @param {?} item
     * @param {?} dimension
     * @return {?}
     */
    IgxForOfDirective.prototype._getItemSize = /**
     * @private
     * @param {?} item
     * @param {?} dimension
     * @return {?}
     */
    function (item, dimension) {
        /** @type {?} */
        var hasDimension = (item[dimension] !== null && item[dimension] !== undefined);
        return hasDimension ? parseInt(item[dimension], 10) : this.igxForItemSize;
    };
    IgxForOfDirective.decorators = [
        { type: Directive, args: [{ selector: '[igxFor][igxForOf]' },] }
    ];
    /** @nocollapse */
    IgxForOfDirective.ctorParameters = function () { return [
        { type: ViewContainerRef },
        { type: TemplateRef },
        { type: IterableDiffers },
        { type: ComponentFactoryResolver },
        { type: ChangeDetectorRef },
        { type: NgZone }
    ]; };
    IgxForOfDirective.propDecorators = {
        igxForOf: [{ type: Input }],
        igxForSizePropName: [{ type: Input }],
        igxForScrollOrientation: [{ type: Input }],
        igxForScrollContainer: [{ type: Input }],
        igxForContainerSize: [{ type: Input }],
        igxForItemSize: [{ type: Input }],
        onChunkLoad: [{ type: Output }],
        onDataChanged: [{ type: Output }],
        onBeforeViewDestroyed: [{ type: Output }],
        onChunkPreload: [{ type: Output }],
        igxForTrackBy: [{ type: Input }]
    };
    return IgxForOfDirective;
}());
/**
 * @param {?} type
 * @return {?}
 */
function getTypeNameForDebugging(type) {
    /** @type {?} */
    var name = 'name';
    return type[name] || typeof type;
}
/**
 * @template T
 */
var IgxGridForOfDirective = /** @class */ (function (_super) {
    __extends(IgxGridForOfDirective, _super);
    function IgxGridForOfDirective(_viewContainer, _template, _differs, resolver, cdr, _zone, syncService) {
        var _this = _super.call(this, _viewContainer, _template, _differs, resolver, cdr, _zone) || this;
        _this.syncService = syncService;
        return _this;
    }
    Object.defineProperty(IgxGridForOfDirective.prototype, "igxGridForOf", {
        get: /**
         * @return {?}
         */
        function () {
            return this.igxForOf;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.igxForOf = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    IgxGridForOfDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.syncService.setMaster(this);
        _super.prototype.ngOnInit.call(this);
        this.removeScrollEventListeners();
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    IgxGridForOfDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        /** @type {?} */
        var forOf = 'igxGridForOf';
        this.syncService.setMaster(this);
        if (forOf in changes) {
            /** @type {?} */
            var value = changes[forOf].currentValue;
            if (!this._differ && value) {
                try {
                    this._differ = this._differs.find(value).create(this.igxForTrackBy);
                }
                catch (e) {
                    throw new Error("Cannot find a differ supporting object \"" + value + "\" of type \"" + getTypeNameForDebugging(value) + "\".\n                     NgFor only supports binding to Iterables such as Arrays.");
                }
            }
        }
        /** @type {?} */
        var defaultItemSize = 'igxForItemSize';
        if (defaultItemSize in changes && !changes[defaultItemSize].firstChange && this.igxForScrollOrientation === 'vertical') {
            // handle default item size changed.
            this.initSizesCache(this.igxForOf);
        }
        /** @type {?} */
        var containerSize = 'igxForContainerSize';
        if (containerSize in changes && !changes[containerSize].firstChange && this.igxForOf) {
            this._recalcOnContainerChange(changes);
        }
    };
    Object.defineProperty(IgxGridForOfDirective.prototype, "sizesCache", {
        /**
         * @hidden
         * @internal
         */
        get: /**
         * @hidden
         * \@internal
         * @return {?}
         */
        function () {
            if (this.syncService.isMaster(this)) {
                return this._sizesCache;
            }
            return this.syncService.sizesCache(this.igxForScrollOrientation);
        },
        /**
         * @hidden
         * @internal
         */
        set: /**
         * @hidden
         * \@internal
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._sizesCache = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridForOfDirective.prototype, "itemsDimension", {
        get: /**
         * @protected
         * @return {?}
         */
        function () {
            return this.igxForScrollOrientation === 'horizontal' ? this.igxForSizePropName : 'height';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @protected
     * @param {?} item
     * @return {?}
     */
    IgxGridForOfDirective.prototype.getItemSize = /**
     * @protected
     * @param {?} item
     * @return {?}
     */
    function (item) {
        /** @type {?} */
        var size = 0;
        /** @type {?} */
        var dimension = this.igxForScrollOrientation === 'horizontal' ?
            this.igxForSizePropName : 'height';
        if (dimension === 'height') {
            size = parseInt(this.igxForItemSize, 10) || 0;
            if (item && item.summaries) {
                size = item.max;
            }
            else if (item && item.groups && item.height) {
                size = item.height;
            }
        }
        else {
            size = parseInt(item[dimension], 10) || 0;
        }
        return size;
    };
    /**
     * @protected
     * @param {?} items
     * @return {?}
     */
    IgxGridForOfDirective.prototype.initSizesCache = /**
     * @protected
     * @param {?} items
     * @return {?}
     */
    function (items) {
        if (!this.syncService.isMaster(this)) {
            /** @type {?} */
            var masterSizesCache = this.syncService.sizesCache(this.igxForScrollOrientation);
            return masterSizesCache[masterSizesCache.length - 1];
        }
        /** @type {?} */
        var totalSize = 0;
        /** @type {?} */
        var size = 0;
        /** @type {?} */
        var i = 0;
        this.sizesCache = [];
        this.heightCache = [];
        this.sizesCache.push(0);
        /** @type {?} */
        var count = this.isRemote ? this.totalItemCount : items.length;
        for (i; i < count; i++) {
            size = this.getItemSize(items[i]);
            if (this.itemsDimension === 'height') {
                this.heightCache.push(size);
            }
            totalSize += size;
            this.sizesCache.push(totalSize);
        }
        return totalSize;
    };
    /**
     * @protected
     * @param {?=} changes
     * @return {?}
     */
    IgxGridForOfDirective.prototype._updateSizeCache = /**
     * @protected
     * @param {?=} changes
     * @return {?}
     */
    function (changes) {
        var _this = this;
        if (changes === void 0) { changes = null; }
        if (this.igxForScrollOrientation === 'horizontal') {
            this.initSizesCache(this.igxForOf);
            return;
        }
        /** @type {?} */
        var scr = this.vh.instance.elementRef.nativeElement;
        /** @type {?} */
        var oldHeight = this.heightCache.length > 0 ? this.heightCache.reduce(function (acc, val) { return acc + val; }) : 0;
        /** @type {?} */
        var newHeight = oldHeight;
        if (changes && !this.isRemote) {
            newHeight = this.handleCacheChanges(changes);
        }
        else {
            newHeight = this.initSizesCache(this.igxForOf);
        }
        /** @type {?} */
        var diff = oldHeight - newHeight;
        // if data has been changed while container is scrolled
        // should update scroll top/left according to change so that same startIndex is in view
        if (Math.abs(diff) > 0) {
            requestAnimationFrame(function () {
                _this.recalcUpdateSizes();
                /** @type {?} */
                var offset = parseInt(_this.dc.instance._viewContainer.element.nativeElement.style.top, 10);
                if (scr.scrollTop !== 0) {
                    scr.scrollTop = _this.sizesCache[_this.state.startIndex] - offset;
                }
                else {
                    _this._updateScrollOffset();
                }
            });
        }
    };
    /**
     * @protected
     * @param {?} changes
     * @return {?}
     */
    IgxGridForOfDirective.prototype.handleCacheChanges = /**
     * @protected
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        var _this = this;
        /** @type {?} */
        var identityChanges = [];
        /** @type {?} */
        var newHeightCache = [];
        /** @type {?} */
        var newSizesCache = [];
        newSizesCache.push(0);
        /** @type {?} */
        var newHeight = 0;
        // When there are more than one removed items the changes are not reliable so those with identity change should be default size.
        /** @type {?} */
        var numRemovedItems = 0;
        changes.forEachRemovedItem(function () { return numRemovedItems++; });
        // Get the identity changes to determine later if those that have changed their indexes should be assigned default item size.
        changes.forEachIdentityChange(function (item) {
            if (item.currentIndex !== item.previousIndex) {
                // Filter out ones that have not changed their index.
                identityChanges[item.currentIndex] = item;
            }
        });
        // Processing each item that is passed to the igxForOf so far seem to be most reliable. We parse the updated list of items.
        changes.forEachItem(function (item) {
            if (item.previousIndex !== null &&
                (numRemovedItems < 2 || !identityChanges.length || identityChanges[item.currentIndex])) {
                // Reuse cache on those who have previousIndex.
                // When there are more than one removed items currently the changes are not readable so ones with identity change
                // should be racalculated.
                newHeightCache[item.currentIndex] = _this.heightCache[item.previousIndex];
            }
            else {
                // Assign default item size.
                newHeightCache[item.currentIndex] = _this.getItemSize(item.item);
            }
            newSizesCache[item.currentIndex + 1] = newSizesCache[item.currentIndex] + newHeightCache[item.currentIndex];
            newHeight += newHeightCache[item.currentIndex];
        });
        this.heightCache = newHeightCache;
        this.sizesCache = newSizesCache;
        return newHeight;
    };
    /**
     * @hidden
     * @internal
     */
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    IgxGridForOfDirective.prototype.assumeMaster = /**
     * @hidden
     * \@internal
     * @return {?}
     */
    function () {
        this._sizesCache = this.syncService.sizesCache(this.igxForScrollOrientation);
        this.syncService.setMaster(this, true);
    };
    /**
     * @return {?}
     */
    IgxGridForOfDirective.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
        if (this._differ) {
            /** @type {?} */
            var changes = this._differ.diff(this.igxForOf);
            if (changes) {
                //  re-init cache.
                if (!this.igxForOf) {
                    return;
                }
                /* we need to reset the master dir if all rows are removed
                (e.g. because of filtering); if all columns are hidden, rows are
                still rendered empty, so we should not reset master */
                if (!this.igxForOf.length &&
                    this.igxForScrollOrientation === 'vertical') {
                    this.syncService.resetMaster();
                }
                this.syncService.setMaster(this);
                this._updateSizeCache(changes);
                this._applyChanges();
                this._updateScrollOffset();
                this.onDataChanged.emit();
            }
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    IgxGridForOfDirective.prototype.onScroll = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        if (!parseInt(this.vh.instance.elementRef.nativeElement.style.height, 10)) {
            return;
        }
        /** @type {?} */
        var containerSize = parseInt(this.igxForContainerSize, 10);
        /** @type {?} */
        var maxRealScrollTop = event.target.children[0].scrollHeight - containerSize;
        /** @type {?} */
        var realPercentScrolled = event.target.scrollTop / maxRealScrollTop;
        if (!this._bScrollInternal) {
            /** @type {?} */
            var maxVirtScrollTop = this._virtHeight - containerSize;
            this._virtScrollTop = realPercentScrolled * maxVirtScrollTop;
        }
        else {
            this._bScrollInternal = false;
        }
        /** @type {?} */
        var scrollOffset = this.fixedUpdateAllElements(this._virtScrollTop);
        this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
        requestAnimationFrame(function () {
            _this.recalcUpdateSizes();
        });
    };
    /**
     * @param {?} scrollAmount
     * @return {?}
     */
    IgxGridForOfDirective.prototype.onHScroll = /**
     * @param {?} scrollAmount
     * @return {?}
     */
    function (scrollAmount) {
        /* in certain situations this may be called when no scrollbar is visible */
        if (!this.hScroll || !parseInt(this.hScroll.children[0].style.width, 10)) {
            return;
        }
        // Updating horizontal chunks
        /** @type {?} */
        var scrollOffset = this.fixedUpdateAllElements(scrollAmount);
        this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
    };
    /**
     * @protected
     * @return {?}
     */
    IgxGridForOfDirective.prototype.addLastElem = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var elemIndex = this.state.startIndex + this.state.chunkSize;
        if (!this.isRemote && !this.igxForOf) {
            return;
        }
        if (elemIndex >= this.igxForOf.length) {
            elemIndex = this.igxForOf.length - this.state.chunkSize;
        }
        /** @type {?} */
        var input = this.igxForOf[elemIndex];
        /** @type {?} */
        var embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, { $implicit: input, index: elemIndex });
        this._embeddedViews.push(embeddedView);
        this.state.chunkSize++;
    };
    /**
     * @protected
     * @param {?} prevChunkSize
     * @return {?}
     */
    IgxGridForOfDirective.prototype._updateViews = /**
     * @protected
     * @param {?} prevChunkSize
     * @return {?}
     */
    function (prevChunkSize) {
        var _this = this;
        if (this.igxForOf && this.igxForOf.length && this.dc) {
            /** @type {?} */
            var embeddedViewCopy = Object.assign([], this._embeddedViews);
            /** @type {?} */
            var startIndex = void 0;
            /** @type {?} */
            var endIndex = void 0;
            if (this.isRemote) {
                startIndex = 0;
                endIndex = this.igxForOf.length;
            }
            else {
                /** @type {?} */
                var inScrollTop = this.igxForScrollOrientation === 'horizontal' ?
                    this.hScroll.scrollLeft :
                    this.vh.instance.elementRef.nativeElement.scrollTop;
                startIndex = this.getIndexAt(inScrollTop, this.sizesCache, 0);
                if (startIndex + this.state.chunkSize > this.igxForOf.length) {
                    startIndex = this.igxForOf.length - this.state.chunkSize;
                }
                this.state.startIndex = startIndex;
                endIndex = this.state.chunkSize + this.state.startIndex;
            }
            for (var i = startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
                /** @type {?} */
                var input = this.igxForOf[i];
                /** @type {?} */
                var embView = embeddedViewCopy.shift();
                /** @type {?} */
                var cntx = ((/** @type {?} */ (embView))).context;
                cntx.$implicit = input;
                cntx.index = this.getContextIndex(input);
            }
            if (prevChunkSize !== this.state.chunkSize) {
                this.onChunkLoad.emit(this.state);
            }
            if (this.igxForScrollOrientation === 'vertical') {
                requestAnimationFrame(function () {
                    _this.recalcUpdateSizes();
                });
            }
        }
    };
    /**
     * @protected
     * @return {?}
     */
    IgxGridForOfDirective.prototype._applyChanges = /**
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var prevChunkSize = this.state.chunkSize;
        this.applyChunkSizeChange();
        this._recalcScrollBarSize();
        this._updateViews(prevChunkSize);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    IgxGridForOfDirective.prototype._calcMaxChunkSize = /**
     * @hidden
     * @protected
     * @return {?}
     */
    function () {
        if (this.syncService.isMaster(this)) {
            return _super.prototype._calcMaxChunkSize.call(this);
        }
        return this.syncService.chunkSize(this.igxForScrollOrientation);
    };
    IgxGridForOfDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxGridFor][igxGridForOf]'
                },] }
    ];
    /** @nocollapse */
    IgxGridForOfDirective.ctorParameters = function () { return [
        { type: ViewContainerRef },
        { type: TemplateRef },
        { type: IterableDiffers },
        { type: ComponentFactoryResolver },
        { type: ChangeDetectorRef },
        { type: NgZone },
        { type: IgxForOfSyncService }
    ]; };
    IgxGridForOfDirective.propDecorators = {
        igxGridForOf: [{ type: Input }]
    };
    return IgxGridForOfDirective;
}(IgxForOfDirective));
/**
 * @hidden
 */
var IgxForOfModule = /** @class */ (function () {
    function IgxForOfModule() {
    }
    IgxForOfModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxForOfDirective, IgxGridForOfDirective, DisplayContainerComponent, VirtualHelperComponent, HVirtualHelperComponent],
                    entryComponents: [DisplayContainerComponent, VirtualHelperComponent, HVirtualHelperComponent],
                    exports: [IgxForOfDirective, IgxGridForOfDirective],
                    imports: [IgxScrollInertiaModule, CommonModule]
                },] }
    ];
    return IgxForOfModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * **Ignite UI for Angular DropDown** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/drop_down.html)
 *
 * The Ignite UI for Angular Drop Down displays a scrollable list of items which may be visually grouped and
 * supports selection of a single item. Clicking or tapping an item selects it and closes the Drop Down
 *
 * Example:
 * ```html
 * <igx-drop-down>
 *   <igx-drop-down-item *ngFor="let item of items" disabled={{item.disabled}} isHeader={{item.header}}>
 *     {{ item.value }}
 *   </igx-drop-down-item>
 * </igx-drop-down>
 * ```
 */
var IgxDropDownComponent = /** @class */ (function (_super) {
    __extends(IgxDropDownComponent, _super);
    function IgxDropDownComponent(elementRef, cdr, selection) {
        var _this = _super.call(this, elementRef, cdr) || this;
        _this.elementRef = elementRef;
        _this.cdr = cdr;
        _this.selection = selection;
        _this.destroy$ = new Subject();
        /**
         * Emitted before the dropdown is opened
         *
         * ```html
         * <igx-drop-down (onOpening)='handleOpening()'></igx-drop-down>
         * ```
         */
        _this.onOpening = new EventEmitter();
        /**
         * Emitted after the dropdown is opened
         *
         * ```html
         * <igx-drop-down (onOpened)='handleOpened()'></igx-drop-down>
         * ```
         */
        _this.onOpened = new EventEmitter();
        /**
         * Emitted before the dropdown is closed
         *
         * ```html
         * <igx-drop-down (onClosing)='handleClosing()'></igx-drop-down>
         * ```
         */
        _this.onClosing = new EventEmitter();
        /**
         * Emitted after the dropdown is closed
         *
         * ```html
         * <igx-drop-down (onClosed)='handleClosed()'></igx-drop-down>
         * ```
         */
        _this.onClosed = new EventEmitter();
        /**
         * Gets/sets whether items take focus. Disabled by default.
         * When enabled, drop down items gain tab index and are focused when active -
         * this includes activating the selected item when opening the drop down and moving with keyboard navigation.
         *
         * Note: Keep that focus shift in mind when using the igxDropDownItemNavigation directive
         * and ensure it's placed either on each focusable item or a common ancestor to allow it to handle keyboard events.
         *
         * ```typescript
         * // get
         * let dropDownAllowsItemFocus = this.dropdown.allowItemsFocus;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-drop-down [allowItemsFocus]='true'></igx-drop-down>
         * ```
         */
        _this.allowItemsFocus = false;
        return _this;
    }
    Object.defineProperty(IgxDropDownComponent.prototype, "focusedItem", {
        /**
         * @hidden @internal
         */
        get: /**
         * @hidden \@internal
         * @return {?}
         */
        function () {
            var _this = this;
            if (this.virtDir) {
                return this._focusedItem && this._focusedItem.index !== -1 ?
                    (this.children.find(function (e) { return e.index === _this._focusedItem.index; }) || null) :
                    null;
            }
            return this._focusedItem;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (!value) {
                this.selection.clear(this.id + "-active");
                this._focusedItem = null;
                return;
            }
            this._focusedItem = value;
            if (this.virtDir) {
                this._focusedItem = (/** @type {?} */ ({
                    value: value.value,
                    index: value.index
                }));
            }
            this.selection.set(this.id + "-active", new Set([this._focusedItem]));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDropDownComponent.prototype, "id", {
        get: /**
         * @return {?}
         */
        function () {
            return this._id;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.toggleDirective.id = value;
            this.selection.set(value, this.selection.get(this.id));
            this.selection.clear(this.id);
            this.selection.set(value, this.selection.get(this.id + "-active"));
            this.selection.clear(this.id + "-active");
            this._id = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDropDownComponent.prototype, "listId", {
        /** Id of the internal listbox of the drop down */
        get: /**
         * Id of the internal listbox of the drop down
         * @return {?}
         */
        function () {
            return this.id + '-list';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDropDownComponent.prototype, "selectedItem", {
        /**
         * Get currently selected item
         *
         * ```typescript
         * let currentItem = this.dropdown.selectedItem;
         * ```
         */
        get: /**
         * Get currently selected item
         *
         * ```typescript
         * let currentItem = this.dropdown.selectedItem;
         * ```
         * @return {?}
         */
        function () {
            /** @type {?} */
            var selectedItem = this.selection.first_item(this.id);
            if (selectedItem) {
                return selectedItem;
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDropDownComponent.prototype, "collapsed", {
        /**
         * Gets if the dropdown is collapsed
         *
         * ```typescript
         * let isCollapsed = this.dropdown.collapsed;
         * ```
         */
        get: /**
         * Gets if the dropdown is collapsed
         *
         * ```typescript
         * let isCollapsed = this.dropdown.collapsed;
         * ```
         * @return {?}
         */
        function () {
            return this.toggleDirective.collapsed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDropDownComponent.prototype, "scrollContainer", {
        get: /**
         * @protected
         * @return {?}
         */
        function () {
            return this.toggleDirective.element;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDropDownComponent.prototype, "collectionLength", {
        get: /**
         * @protected
         * @return {?}
         */
        function () {
            if (this.virtDir) {
                return this.virtDir.totalItemCount || this.virtDir.igxForOf.length;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Opens the dropdown
     *
     * ```typescript
     * this.dropdown.open();
     * ```
     */
    /**
     * Opens the dropdown
     *
     * ```typescript
     * this.dropdown.open();
     * ```
     * @param {?=} overlaySettings
     * @return {?}
     */
    IgxDropDownComponent.prototype.open = /**
     * Opens the dropdown
     *
     * ```typescript
     * this.dropdown.open();
     * ```
     * @param {?=} overlaySettings
     * @return {?}
     */
    function (overlaySettings) {
        this.toggleDirective.open(overlaySettings);
        this.updateScrollPosition();
    };
    /**
     * Closes the dropdown
     *
     * ```typescript
     * this.dropdown.close();
     * ```
     */
    /**
     * Closes the dropdown
     *
     * ```typescript
     * this.dropdown.close();
     * ```
     * @return {?}
     */
    IgxDropDownComponent.prototype.close = /**
     * Closes the dropdown
     *
     * ```typescript
     * this.dropdown.close();
     * ```
     * @return {?}
     */
    function () {
        this.toggleDirective.close();
    };
    /**
     * Toggles the dropdown
     *
     * ```typescript
     * this.dropdown.toggle();
     * ```
     */
    /**
     * Toggles the dropdown
     *
     * ```typescript
     * this.dropdown.toggle();
     * ```
     * @param {?=} overlaySettings
     * @return {?}
     */
    IgxDropDownComponent.prototype.toggle = /**
     * Toggles the dropdown
     *
     * ```typescript
     * this.dropdown.toggle();
     * ```
     * @param {?=} overlaySettings
     * @return {?}
     */
    function (overlaySettings) {
        if (this.collapsed || this.toggleDirective.isClosing) {
            this.open(overlaySettings);
        }
        else {
            this.close();
        }
    };
    /**
     * Select an item by index
     * @param index of the item to select; If the drop down uses *igxFor, pass the index in data
     */
    /**
     * Select an item by index
     * @param {?} index of the item to select; If the drop down uses *igxFor, pass the index in data
     * @return {?}
     */
    IgxDropDownComponent.prototype.setSelectedItem = /**
     * Select an item by index
     * @param {?} index of the item to select; If the drop down uses *igxFor, pass the index in data
     * @return {?}
     */
    function (index) {
        if (index < 0 || index >= this.items.length) {
            return;
        }
        /** @type {?} */
        var newSelection;
        if (this.virtDir) {
            newSelection = (/** @type {?} */ ({
                value: this.virtDir.igxForOf[index],
                index: index
            }));
        }
        else {
            newSelection = this.items[index];
        }
        this.selectItem(newSelection);
    };
    /**
     * Navigates to the item on the specified index
     * If the data in the drop-down is virtualized, pass the index of the item in the virtualized data.
     * @param newIndex number
     */
    /**
     * Navigates to the item on the specified index
     * If the data in the drop-down is virtualized, pass the index of the item in the virtualized data.
     * @param {?} index
     * @return {?}
     */
    IgxDropDownComponent.prototype.navigateItem = /**
     * Navigates to the item on the specified index
     * If the data in the drop-down is virtualized, pass the index of the item in the virtualized data.
     * @param {?} index
     * @return {?}
     */
    function (index) {
        var _this = this;
        if (this.virtDir) {
            if (index === -1 || index >= this.collectionLength) {
                return;
            }
            /** @type {?} */
            var direction_1 = index > (this.focusedItem ? this.focusedItem.index : -1) ? Navigate.Down : Navigate.Up;
            /** @type {?} */
            var subRequired = this.isIndexOutOfBounds(index, direction_1);
            this.focusedItem = (/** @type {?} */ ({
                value: this.virtDir.igxForOf[index],
                index: index
            }));
            if (subRequired) {
                this.virtDir.scrollTo(index);
            }
            if (subRequired) {
                this.virtDir.onChunkLoad.pipe(take(1)).subscribe(function () {
                    _this.skipHeader(direction_1);
                });
            }
            else {
                this.skipHeader(direction_1);
            }
        }
        else {
            _super.prototype.navigateItem.call(this, index);
        }
        if (this.allowItemsFocus && this.focusedItem) {
            this.focusedItem.element.nativeElement.focus();
            this.cdr.markForCheck();
        }
    };
    /**
     * @private
     * @param {?} index
     * @param {?} direction
     * @return {?}
     */
    IgxDropDownComponent.prototype.isIndexOutOfBounds = /**
     * @private
     * @param {?} index
     * @param {?} direction
     * @return {?}
     */
    function (index, direction) {
        /** @type {?} */
        var virtState = this.virtDir.state;
        /** @type {?} */
        var currentPosition = this.virtDir.getVerticalScroll().scrollTop;
        /** @type {?} */
        var itemPosition = this.virtDir.getScrollForIndex(index, direction === Navigate.Down);
        /** @type {?} */
        var indexOutOfChunk = index < virtState.startIndex || index > virtState.chunkSize + virtState.startIndex;
        /** @type {?} */
        var scrollNeeded = direction === Navigate.Down ? currentPosition < itemPosition : currentPosition > itemPosition;
        /** @type {?} */
        var subRequired = indexOutOfChunk || scrollNeeded;
        return subRequired;
    };
    /**
     * @protected
     * @param {?} direction
     * @return {?}
     */
    IgxDropDownComponent.prototype.skipHeader = /**
     * @protected
     * @param {?} direction
     * @return {?}
     */
    function (direction) {
        if (!this.focusedItem) {
            return;
        }
        if (this.focusedItem.isHeader || this.focusedItem.disabled) {
            if (direction === Navigate.Up) {
                this.navigatePrev();
            }
            else {
                this.navigateNext();
            }
        }
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @return {?}
     */
    IgxDropDownComponent.prototype.updateScrollPosition = /**
     * @hidden \@internal
     * @return {?}
     */
    function () {
        if (!this.virtDir) {
            return;
        }
        if (!this.selectedItem) {
            this.virtDir.scrollTo(0);
            return;
        }
        /** @type {?} */
        var targetScroll = this.virtDir.getScrollForIndex(this.selectedItem.index);
        /** @type {?} */
        var itemsInView = this.virtDir.igxForContainerSize / this.virtDir.igxForItemSize;
        targetScroll -= (itemsInView / 2 - 1) * this.virtDir.igxForItemSize;
        this.virtDir.getVerticalScroll().scrollTop = targetScroll;
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @param {?} e
     * @return {?}
     */
    IgxDropDownComponent.prototype.onToggleOpening = /**
     * @hidden \@internal
     * @param {?} e
     * @return {?}
     */
    function (e) {
        this.onOpening.emit(e);
        if (e.cancel) {
            return;
        }
        if (!this.virtDir && this.selectedItem) {
            this.scrollToItem(this.selectedItem);
        }
        if (this.virtDir) {
            this.virtDir.getVerticalScroll().scrollTop = this._scrollPosition;
        }
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @return {?}
     */
    IgxDropDownComponent.prototype.onToggleOpened = /**
     * @hidden \@internal
     * @return {?}
     */
    function () {
        if (this.selectedItem) {
            this.focusedItem = this.selectedItem;
            this._focusedItem.focused = true;
        }
        else if (this.allowItemsFocus) {
            this.navigateFirst();
        }
        this.onOpened.emit();
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @param {?} e
     * @return {?}
     */
    IgxDropDownComponent.prototype.onToggleClosing = /**
     * @hidden \@internal
     * @param {?} e
     * @return {?}
     */
    function (e) {
        this.onClosing.emit(e);
        if (this.virtDir) {
            this._scrollPosition = this.virtDir.getVerticalScroll().scrollTop;
        }
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @return {?}
     */
    IgxDropDownComponent.prototype.onToggleClosed = /**
     * @hidden \@internal
     * @return {?}
     */
    function () {
        if (this._focusedItem) {
            this._focusedItem.focused = false;
        }
        this.onClosed.emit();
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @return {?}
     */
    IgxDropDownComponent.prototype.ngOnDestroy = /**
     * @hidden \@internal
     * @return {?}
     */
    function () {
        this.destroy$.next(true);
        this.destroy$.complete();
        this.selection.clear(this.id);
        this.selection.clear(this.id + "-active");
    };
    /**
     * @protected
     * @param {?} item
     * @return {?}
     */
    IgxDropDownComponent.prototype.scrollToItem = /**
     * @protected
     * @param {?} item
     * @return {?}
     */
    function (item) {
        var _this = this;
        /** @type {?} */
        var itemPosition = this.calculateScrollPosition(item);
        //  in IE11 setting sctrollTop is somehow slow and forces dropdown
        //  to appear on screen before animation start. As a result dropdown
        //  flickers badly. This is why we set scrollTop just a little later
        //  allowing animation to start and prevent dropdown flickering
        if (isIE()) {
            setTimeout(function () {
                _this.scrollContainer.scrollTop = (itemPosition);
            }, 1);
        }
        else {
            this.scrollContainer.scrollTop = (itemPosition);
        }
    };
    /** @hidden @internal */
    /**
     * @hidden \@internal
     * @param {?} item
     * @return {?}
     */
    IgxDropDownComponent.prototype.calculateScrollPosition = /**
     * @hidden \@internal
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (!item) {
            return 0;
        }
        /** @type {?} */
        var elementRect = item.element.nativeElement.getBoundingClientRect();
        /** @type {?} */
        var parentRect = this.scrollContainer.getBoundingClientRect();
        /** @type {?} */
        var scrollDelta = parentRect.top - elementRect.top;
        /** @type {?} */
        var scrollPosition = this.scrollContainer.scrollTop - scrollDelta;
        /** @type {?} */
        var dropDownHeight = this.scrollContainer.clientHeight;
        scrollPosition -= dropDownHeight / 2;
        scrollPosition += item.elementHeight / 2;
        return Math.floor(scrollPosition);
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @return {?}
     */
    IgxDropDownComponent.prototype.ngOnInit = /**
     * @hidden \@internal
     * @return {?}
     */
    function () {
        this.toggleDirective.id = this.id;
    };
    /**
     * @return {?}
     */
    IgxDropDownComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        if (this.virtDir) {
            this.virtDir.igxForItemSize = 32;
        }
    };
    /** Keydown Handler */
    /**
     * Keydown Handler
     * @param {?} key
     * @param {?=} event
     * @return {?}
     */
    IgxDropDownComponent.prototype.onItemActionKey = /**
     * Keydown Handler
     * @param {?} key
     * @param {?=} event
     * @return {?}
     */
    function (key, event) {
        _super.prototype.onItemActionKey.call(this, key, event);
        this.close();
    };
    /**
     * Virtual scroll implementation
     * @hidden @internal
     */
    /**
     * Virtual scroll implementation
     * @hidden \@internal
     * @return {?}
     */
    IgxDropDownComponent.prototype.navigateFirst = /**
     * Virtual scroll implementation
     * @hidden \@internal
     * @return {?}
     */
    function () {
        if (this.virtDir) {
            this.navigateItem(0);
        }
        else {
            _super.prototype.navigateFirst.call(this);
        }
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @return {?}
     */
    IgxDropDownComponent.prototype.navigateLast = /**
     * @hidden \@internal
     * @return {?}
     */
    function () {
        if (this.virtDir) {
            this.navigateItem(this.virtDir.totalItemCount ? this.virtDir.totalItemCount - 1 : this.virtDir.igxForOf.length - 1);
        }
        else {
            _super.prototype.navigateLast.call(this);
        }
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @return {?}
     */
    IgxDropDownComponent.prototype.navigateNext = /**
     * @hidden \@internal
     * @return {?}
     */
    function () {
        if (this.virtDir) {
            this.navigateItem(this._focusedItem ? this._focusedItem.index + 1 : 0);
        }
        else {
            _super.prototype.navigateNext.call(this);
        }
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @return {?}
     */
    IgxDropDownComponent.prototype.navigatePrev = /**
     * @hidden \@internal
     * @return {?}
     */
    function () {
        if (this.virtDir) {
            this.navigateItem(this._focusedItem ? this._focusedItem.index - 1 : 0);
        }
        else {
            _super.prototype.navigatePrev.call(this);
        }
    };
    /**
     * Handles the `onSelection` emit and the drop down toggle when selection changes
     * @hidden
     * @internal
     * @param newSelection
     * @param event
     */
    /**
     * Handles the `onSelection` emit and the drop down toggle when selection changes
     * @hidden
     * \@internal
     * @param {?=} newSelection
     * @param {?=} event
     * @return {?}
     */
    IgxDropDownComponent.prototype.selectItem = /**
     * Handles the `onSelection` emit and the drop down toggle when selection changes
     * @hidden
     * \@internal
     * @param {?=} newSelection
     * @param {?=} event
     * @return {?}
     */
    function (newSelection, event) {
        /** @type {?} */
        var oldSelection = this.selectedItem;
        if (!newSelection) {
            newSelection = this.focusedItem;
        }
        if (newSelection === null) {
            return;
        }
        if (newSelection instanceof IgxDropDownItemBase && newSelection.isHeader) {
            return;
        }
        if (this.virtDir) {
            newSelection = (/** @type {?} */ ({
                value: newSelection.value,
                index: newSelection.index
            }));
        }
        /** @type {?} */
        var args = { oldSelection: oldSelection, newSelection: newSelection, cancel: false };
        this.onSelection.emit(args);
        if (!args.cancel) {
            this.selection.set(this.id, new Set([newSelection]));
            if (!this.virtDir) {
                if (oldSelection) {
                    oldSelection.selected = false;
                }
                if (newSelection) {
                    newSelection.selected = true;
                }
            }
            if (event) {
                this.toggleDirective.close();
            }
        }
    };
    IgxDropDownComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-drop-down',
                    template: "<div class=\"igx-drop-down__list\" igxToggle [style.width]=\"width\" [style.height]=\"height\"\n[style.maxHeight]=\"maxHeight\" [attr.id]=\"this.listId\" role=\"listbox\"\n    (onOpening)=\"onToggleOpening($event)\" (onOpened)=\"onToggleOpened()\"\n    (onClosing)=\"onToggleClosing($event)\" (onClosed)=\"onToggleClosed()\">\n    <ng-container *ngIf=\"!collapsed\">\n        <ng-content></ng-content>\n    </ng-container>\n</div>\n",
                    providers: [{ provide: IGX_DROPDOWN_BASE, useExisting: IgxDropDownComponent }]
                }] }
    ];
    /** @nocollapse */
    IgxDropDownComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ChangeDetectorRef },
        { type: IgxSelectionAPIService }
    ]; };
    IgxDropDownComponent.propDecorators = {
        virtDir: [{ type: ContentChild, args: [IgxForOfDirective, { read: IgxForOfDirective },] }],
        toggleDirective: [{ type: ViewChild, args: [IgxToggleDirective,] }],
        children: [{ type: ContentChildren, args: [forwardRef(function () { return IgxDropDownItemComponent; }), { descendants: true },] }],
        onOpening: [{ type: Output }],
        onOpened: [{ type: Output }],
        onClosing: [{ type: Output }],
        onClosed: [{ type: Output }],
        allowItemsFocus: [{ type: Input }],
        id: [{ type: Input }]
    };
    return IgxDropDownComponent;
}(IgxDropDownBase));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Navigation Directive that handles keyboard events on its host and controls a targeted IgxDropDownBase component
 */
var IgxDropDownItemNavigationDirective = /** @class */ (function () {
    function IgxDropDownItemNavigationDirective(dropdown) {
        this.dropdown = dropdown;
        this._target = null;
    }
    Object.defineProperty(IgxDropDownItemNavigationDirective.prototype, "target", {
        /**
         * Gets the target of the navigation directive;
         *
         * ```typescript
         * // Get
         * export class MyComponent {
         *  ...
         *  @ContentChild(IgxDropDownNavigationDirective)
         *  navDirective: IgxDropDownNavigationDirective = null
         *  ...
         *  const navTarget: IgxDropDownBase = navDirective.navTarget
         * }
         * ```
         */
        get: /**
         * Gets the target of the navigation directive;
         *
         * ```typescript
         * // Get
         * export class MyComponent {
         *  ...
         * \@ContentChild(IgxDropDownNavigationDirective)
         *  navDirective: IgxDropDownNavigationDirective = null
         *  ...
         *  const navTarget: IgxDropDownBase = navDirective.navTarget
         * }
         * ```
         * @return {?}
         */
        function () {
            return this._target;
        },
        /**
         * Sets the target of the navigation directive;
         * If no valid target is passed, it falls back to the drop down context
         *
         * ```html
         * <!-- Set -->
         * <input [igxDropDownItemNavigation]="dropdown" />
         * ...
         * <igx-drop-down #dropdown>
         * ...
         * </igx-drop-down>
         * ```
         */
        set: /**
         * Sets the target of the navigation directive;
         * If no valid target is passed, it falls back to the drop down context
         *
         * ```html
         * <!-- Set -->
         * <input [igxDropDownItemNavigation]="dropdown" />
         * ...
         * <igx-drop-down #dropdown>
         * ...
         * </igx-drop-down>
         * ```
         * @param {?} target
         * @return {?}
         */
        function (target) {
            this._target = target ? target : this.dropdown;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Captures keydown events and calls the appropriate handlers on the target component
     */
    /**
     * Captures keydown events and calls the appropriate handlers on the target component
     * @param {?} event
     * @return {?}
     */
    IgxDropDownItemNavigationDirective.prototype.handleKeyDown = /**
     * Captures keydown events and calls the appropriate handlers on the target component
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event) {
            /** @type {?} */
            var key = event.key.toLowerCase();
            if (!this.target.collapsed) { // If dropdown is opened
                // If dropdown is opened
                /** @type {?} */
                var navKeys = ['esc', 'escape', 'enter', 'space', 'spacebar', ' ',
                    'arrowup', 'up', 'arrowdown', 'down', 'home', 'end'];
                if (navKeys.indexOf(key) === -1) { // If key has appropriate function in DD
                    return;
                }
                event.preventDefault();
                event.stopPropagation();
            }
            else { // If dropdown is closed, do nothing
                return;
            }
            switch (key) {
                case 'esc':
                case 'escape':
                    this.target.onItemActionKey(DropDownActionKey.ESCAPE, event);
                    break;
                case 'enter':
                    this.target.onItemActionKey(DropDownActionKey.ENTER, event);
                    break;
                case 'space':
                case 'spacebar':
                case ' ':
                    this.target.onItemActionKey(DropDownActionKey.SPACE, event);
                    break;
                case 'arrowup':
                case 'up':
                    this.onArrowUpKeyDown();
                    break;
                case 'arrowdown':
                case 'down':
                    this.onArrowDownKeyDown();
                    break;
                case 'home':
                    this.onHomeKeyDown();
                    break;
                case 'end':
                    this.onEndKeyDown();
                    break;
                default:
                    return;
            }
        }
    };
    /**
     * Navigates to previous item
     */
    /**
     * Navigates to previous item
     * @return {?}
     */
    IgxDropDownItemNavigationDirective.prototype.onArrowDownKeyDown = /**
     * Navigates to previous item
     * @return {?}
     */
    function () {
        this.target.navigateNext();
    };
    /**
     * Navigates to previous item
     */
    /**
     * Navigates to previous item
     * @return {?}
     */
    IgxDropDownItemNavigationDirective.prototype.onArrowUpKeyDown = /**
     * Navigates to previous item
     * @return {?}
     */
    function () {
        this.target.navigatePrev();
    };
    /**
     * Navigates to target's last item
     */
    /**
     * Navigates to target's last item
     * @return {?}
     */
    IgxDropDownItemNavigationDirective.prototype.onEndKeyDown = /**
     * Navigates to target's last item
     * @return {?}
     */
    function () {
        this.target.navigateLast();
    };
    /**
     * Navigates to target's first item
     */
    /**
     * Navigates to target's first item
     * @return {?}
     */
    IgxDropDownItemNavigationDirective.prototype.onHomeKeyDown = /**
     * Navigates to target's first item
     * @return {?}
     */
    function () {
        this.target.navigateFirst();
    };
    IgxDropDownItemNavigationDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxDropDownItemNavigation]'
                },] }
    ];
    /** @nocollapse */
    IgxDropDownItemNavigationDirective.ctorParameters = function () { return [
        { type: IgxDropDownBase, decorators: [{ type: Self }, { type: Optional }, { type: Inject, args: [IGX_DROPDOWN_BASE,] }] }
    ]; };
    IgxDropDownItemNavigationDirective.propDecorators = {
        target: [{ type: Input, args: ['igxDropDownItemNavigation',] }],
        handleKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
    };
    return IgxDropDownItemNavigationDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxDropDownModule = /** @class */ (function () {
    function IgxDropDownModule() {
    }
    IgxDropDownModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxDropDownComponent, IgxDropDownItemComponent, IgxDropDownGroupComponent,
                        IgxDropDownItemNavigationDirective],
                    exports: [IgxDropDownComponent, IgxDropDownItemComponent, IgxDropDownGroupComponent,
                        IgxDropDownItemNavigationDirective],
                    imports: [CommonModule, IgxToggleModule],
                    providers: [IgxSelectionAPIService]
                },] }
    ];
    return IgxDropDownModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
var IgxHintPosition = {
    START: 0,
    END: 1,
};
IgxHintPosition[IgxHintPosition.START] = 'START';
IgxHintPosition[IgxHintPosition.END] = 'END';
var IgxHintDirective = /** @class */ (function () {
    function IgxHintDirective(_element) {
        this._element = _element;
        this._position = IgxHintPosition.START;
        /**
         * Sets/gets whether the hint position is at the start.
         * Default value is `false`.
         * ```typescript
         * \@ViewChild('hint', {read: IgxHintDirective})
         * public igxHint: IgxHintDirective;
         * this.igxHint.isPositionStart = true;
         * ```
         * ```typescript
         * let isHintPositionStart = this.igxHint.isPositionStart;
         * ```
         * \@memberof IgxHintDirective
         */
        this.isPositionStart = false;
        /**
         * Sets/gets whether the hint position is at the end.
         * Default value is `false`.
         * ```typescript
         * \@ViewChild('hint', {read: IgxHintDirective})
         * public igxHint: IgxHintDirective;
         * this.igxHint.isPositionEnd = true;
         * ```
         * ```typescript
         * let isHintPositionEnd = this.igxHint.isPositionEnd;
         * ```
         * \@memberof IgxHintDirective
         */
        this.isPositionEnd = false;
    }
    Object.defineProperty(IgxHintDirective.prototype, "position", {
        /**
         * Gets the position of the hint.
         * ```typescript
         * @ViewChild('hint', {read: IgxHintDirective})
         * public igxHint: IgxHintDirective;
         * let hintPosition =  this.igxHint.position;
         * ```
         * @memberof IgxHintDirective
         */
        get: /**
         * Gets the position of the hint.
         * ```typescript
         * \@ViewChild('hint', {read: IgxHintDirective})
         * public igxHint: IgxHintDirective;
         * let hintPosition =  this.igxHint.position;
         * ```
         * \@memberof IgxHintDirective
         * @return {?}
         */
        function () {
            return this._position.toString();
        },
        /**
         * Sets the position of the hint.
         * ```html
         * <igx-input-group>
         *  <input igxInput type="text"/>
         *  <igx-hint #hint [position]="'start'">IgxHint displayed at the start</igx-hint>
         * </igx-input-group>
         * ```
         * @memberof IgxHintDirective
         */
        set: /**
         * Sets the position of the hint.
         * ```html
         * <igx-input-group>
         *  <input igxInput type="text"/>
         *  <igx-hint #hint [position]="'start'">IgxHint displayed at the start</igx-hint>
         * </igx-input-group>
         * ```
         * \@memberof IgxHintDirective
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var position = ((/** @type {?} */ (IgxHintPosition)))[value.toUpperCase()];
            if (position !== undefined) {
                this._position = position;
                this._applyPosition(this._position);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxHintDirective.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        this._applyPosition(this._position);
    };
    /**
     * @private
     * @param {?} position
     * @return {?}
     */
    IgxHintDirective.prototype._applyPosition = /**
     * @private
     * @param {?} position
     * @return {?}
     */
    function (position) {
        this.isPositionStart = this.isPositionEnd = false;
        switch (position) {
            case IgxHintPosition.START:
                this.isPositionStart = true;
                break;
            case IgxHintPosition.END:
                this.isPositionEnd = true;
                break;
            default: break;
        }
    };
    IgxHintDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'igx-hint,[igxHint]'
                },] }
    ];
    /** @nocollapse */
    IgxHintDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    IgxHintDirective.propDecorators = {
        isPositionStart: [{ type: HostBinding, args: ['class.igx-input-group__hint-item--start',] }],
        isPositionEnd: [{ type: HostBinding, args: ['class.igx-input-group__hint-item--end',] }],
        position: [{ type: Input, args: ['position',] }]
    };
    return IgxHintDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 * @abstract
 */
var  /**
 * @hidden
 * @abstract
 */
IgxInputGroupBase = /** @class */ (function () {
    function IgxInputGroupBase() {
    }
    return IgxInputGroupBase;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var nativeValidationAttributes = ['required', 'pattern', 'minlength', 'maxlength', 'min', 'max', 'step'];
/** @enum {number} */
var IgxInputState = {
    INITIAL: 0,
    VALID: 1,
    INVALID: 2,
};
IgxInputState[IgxInputState.INITIAL] = 'INITIAL';
IgxInputState[IgxInputState.VALID] = 'VALID';
IgxInputState[IgxInputState.INVALID] = 'INVALID';
var IgxInputDirective = /** @class */ (function () {
    function IgxInputDirective(inputGroup, ngModel, formControl, element, cdr) {
        this.inputGroup = inputGroup;
        this.ngModel = ngModel;
        this.formControl = formControl;
        this.element = element;
        this.cdr = cdr;
        this._valid = IgxInputState.INITIAL;
        /**
         * Sets/gets whether the `"igx-input-group__input"` class is added to the host element.
         * Default value is `false`.
         * ```typescript
         * this.igxInput.isInput = true;
         * ```
         * ```typescript
         * let isCLassAdded = this.igxInput.isInput;
         * ```
         * \@memberof IgxInputDirective
         */
        this.isInput = false;
        /**
         * Sets/gets whether the `"class.igx-input-group__textarea"` class is added to the host element.
         * Default value is `false`.
         * ```typescript
         * this.igxInput.isTextArea = true;
         * ```
         * ```typescript
         * let isCLassAdded = this.igxInput.isTextArea;
         * ```
         * \@memberof IgxInputDirective
         */
        this.isTextArea = false;
    }
    Object.defineProperty(IgxInputDirective.prototype, "ngControl", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return this.ngModel ? this.ngModel : this.formControl;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxInputDirective.prototype, "value", {
        /**
         * Gets the `value` propery.
         * ```typescript
         * @ViewChild('igxInput', {read: IgxInputDirective})
         *  public igxInput: IgxInputDirective;
         * let inputValue = this.igxInput.value;
         * ```
         * @memberof IgxInputDirective
         */
        get: /**
         * Gets the `value` propery.
         * ```typescript
         * \@ViewChild('igxInput', {read: IgxInputDirective})
         *  public igxInput: IgxInputDirective;
         * let inputValue = this.igxInput.value;
         * ```
         * \@memberof IgxInputDirective
         * @return {?}
         */
        function () {
            return this.nativeElement.value;
        },
        /**
         * Sets the `value` property.
         * ```html
         * <input-group>
         *  <input igxInput #igxInput [value]="'IgxInput Value'">
         * </input-group>
         * ```
         * @memberof IgxInputDirective
         */
        set: /**
         * Sets the `value` property.
         * ```html
         * <input-group>
         *  <input igxInput #igxInput [value]="'IgxInput Value'">
         * </input-group>
         * ```
         * \@memberof IgxInputDirective
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.nativeElement.value = value;
            this.checkValidity();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxInputDirective.prototype, "disabled", {
        /**
         * Gets the `disabled` property
         * ```typescript
         * @ViewChild('igxInput', {read: IgxInputDirective})
         *  public igxInput: IgxInputDirective;
         * let isDisabled = this.igxInput.disabled;
         * ```
         * @memberof IgxInputDirective
         */
        get: /**
         * Gets the `disabled` property
         * ```typescript
         * \@ViewChild('igxInput', {read: IgxInputDirective})
         *  public igxInput: IgxInputDirective;
         * let isDisabled = this.igxInput.disabled;
         * ```
         * \@memberof IgxInputDirective
         * @return {?}
         */
        function () {
            return this.nativeElement.hasAttribute('disabled');
        },
        /**
         * Sets the `disabled` property.
         * ```html
         * <input-group>
         *  <input igxInput #igxInput [disabled]="true">
         * </input-group>
         * ```
         * @memberof IgxInputDirective
         */
        set: /**
         * Sets the `disabled` property.
         * ```html
         * <input-group>
         *  <input igxInput #igxInput [disabled]="true">
         * </input-group>
         * ```
         * \@memberof IgxInputDirective
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.nativeElement.disabled = value;
            this.inputGroup.disabled = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxInputDirective.prototype, "required", {
        /**
         * Gets whether the igxInput is required.
         * ```typescript
         * let isRequired = this.igxInput.required;
         * ```
         * @memberof IgxInputDirective
         */
        get: /**
         * Gets whether the igxInput is required.
         * ```typescript
         * let isRequired = this.igxInput.required;
         * ```
         * \@memberof IgxInputDirective
         * @return {?}
         */
        function () {
            return this.nativeElement.hasAttribute('required');
        },
        /**
         * Sets the `required` property.
         * ```html
         * <input-group>
         *  <input igxInput #igxInput [required]="true">
         * </input-group>
         * ```
         * @memberof IgxInputDirective
         */
        set: /**
         * Sets the `required` property.
         * ```html
         * <input-group>
         *  <input igxInput #igxInput [required]="true">
         * </input-group>
         * ```
         * \@memberof IgxInputDirective
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (typeof value === 'boolean') {
                this.nativeElement.required = this.inputGroup.isRequired = value;
                if (value && !this.nativeElement.checkValidity()) {
                    this._valid = IgxInputState.INVALID;
                }
                else {
                    this._valid = IgxInputState.INITIAL;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxInputDirective.prototype.onFocus = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.inputGroup.isFocused = true;
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxInputDirective.prototype.onBlur = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.inputGroup.isFocused = false;
        this._valid = IgxInputState.INITIAL;
        if (this.ngControl) {
            if (!this.ngControl.valid) {
                this._valid = IgxInputState.INVALID;
            }
        }
        else if (this._hasValidators() && !this.nativeElement.checkValidity()) {
            this._valid = IgxInputState.INVALID;
        }
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxInputDirective.prototype.onInput = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.checkValidity();
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxInputDirective.prototype.ngAfterViewInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.inputGroup.hasPlaceholder = this.nativeElement.hasAttribute('placeholder');
        this.inputGroup.disabled = this.inputGroup.disabled || this.nativeElement.hasAttribute('disabled');
        this.inputGroup.isRequired = this.nativeElement.hasAttribute('required');
        // Make sure we do not invalidate the input on init
        if (!this.ngControl) {
            this._valid = IgxInputState.INITIAL;
        }
        // Also check the control's validators for required
        if (!this.inputGroup.isRequired && this.ngControl && this.ngControl.control.validator) {
            /** @type {?} */
            var validation = this.ngControl.control.validator((/** @type {?} */ ({})));
            this.inputGroup.isRequired = validation && validation.required;
        }
        /** @type {?} */
        var elTag = this.nativeElement.tagName.toLowerCase();
        if (elTag === 'textarea') {
            this.isTextArea = true;
        }
        else {
            this.isInput = true;
        }
        if (this.ngControl) {
            this._statusChanges$ = this.ngControl.statusChanges.subscribe(this.onStatusChanged.bind(this));
        }
        this.cdr.detectChanges();
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxInputDirective.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (this._statusChanges$) {
            this._statusChanges$.unsubscribe();
        }
    };
    /**
     * Sets a focus on the igxInput.
     * ```typescript
     * this.igxInput.focus();
     * ```
     * @memberof IgxInputDirective
     */
    /**
     * Sets a focus on the igxInput.
     * ```typescript
     * this.igxInput.focus();
     * ```
     * \@memberof IgxInputDirective
     * @return {?}
     */
    IgxInputDirective.prototype.focus = /**
     * Sets a focus on the igxInput.
     * ```typescript
     * this.igxInput.focus();
     * ```
     * \@memberof IgxInputDirective
     * @return {?}
     */
    function () {
        this.nativeElement.focus();
    };
    Object.defineProperty(IgxInputDirective.prototype, "nativeElement", {
        /**
         * Gets the `nativeElement` of the igxInput.
         * ```typescript
         * let igxInputNativeElement = this.igxInput.nativeElement;
         * ```
         * @memberof IgxInputDirective
         */
        get: /**
         * Gets the `nativeElement` of the igxInput.
         * ```typescript
         * let igxInputNativeElement = this.igxInput.nativeElement;
         * ```
         * \@memberof IgxInputDirective
         * @return {?}
         */
        function () {
            return this.element.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *@hidden
     */
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    IgxInputDirective.prototype.onStatusChanged = /**
     * @hidden
     * @protected
     * @return {?}
     */
    function () {
        if (this.ngControl.control.validator || this.ngControl.control.asyncValidator) {
            if (this.ngControl.control.touched || this.ngControl.control.dirty) {
                if (this.inputGroup.isFocused) {
                    // the user is still typing in the control
                    this._valid = this.ngControl.valid ? IgxInputState.VALID : IgxInputState.INVALID;
                }
                else {
                    // the user had touched the control previosly but now the value is changing due to changes in the form
                    this._valid = this.ngControl.valid ? IgxInputState.INITIAL : IgxInputState.INVALID;
                }
            }
            else if (this._valid !== IgxInputState.INITIAL) {
                this._valid = this.ngControl.valid ? IgxInputState.INITIAL : IgxInputState.INVALID;
            }
            else if (this._valid === IgxInputState.INITIAL && this.ngControl.value !== undefined && this.ngControl.invalid) {
                this._valid = IgxInputState.INVALID;
            }
        }
    };
    Object.defineProperty(IgxInputDirective.prototype, "hasPlaceholder", {
        /**
         * Gets whether the igxInput has a placeholder.
         * ```typescript
         * let hasPlaceholder = this.igxInput.hasPlaceholder;
         * ```
         * @memberof IgxInputDirective
         */
        get: /**
         * Gets whether the igxInput has a placeholder.
         * ```typescript
         * let hasPlaceholder = this.igxInput.hasPlaceholder;
         * ```
         * \@memberof IgxInputDirective
         * @return {?}
         */
        function () {
            return this.nativeElement.hasAttribute('placeholder');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxInputDirective.prototype, "placeholder", {
        /**
         * Gets the placeholder element of the igxInput.
         * ```typescript
         * let igxInputPlaceholder = this.igxInput.placeholder;
         * ```
         * @memberof IgxInputDirective
         */
        get: /**
         * Gets the placeholder element of the igxInput.
         * ```typescript
         * let igxInputPlaceholder = this.igxInput.placeholder;
         * ```
         * \@memberof IgxInputDirective
         * @return {?}
         */
        function () {
            return this.nativeElement.placeholder;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @return {?}
     */
    IgxInputDirective.prototype._hasValidators = /**
     * @private
     * @return {?}
     */
    function () {
        var e_1, _a;
        try {
            for (var nativeValidationAttributes_1 = __values(nativeValidationAttributes), nativeValidationAttributes_1_1 = nativeValidationAttributes_1.next(); !nativeValidationAttributes_1_1.done; nativeValidationAttributes_1_1 = nativeValidationAttributes_1.next()) {
                var nativeValidationAttribute = nativeValidationAttributes_1_1.value;
                if (this.nativeElement.hasAttribute(nativeValidationAttribute)) {
                    return true;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (nativeValidationAttributes_1_1 && !nativeValidationAttributes_1_1.done && (_a = nativeValidationAttributes_1.return)) _a.call(nativeValidationAttributes_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return !!this.ngControl && (!!this.ngControl.control.validator || !!this.ngControl.control.asyncValidator);
    };
    Object.defineProperty(IgxInputDirective.prototype, "focused", {
        /**
         * Gets whether the igxInput is focused.
         * ```typescript
         * let isFocused = this.igxInput.focused;
         * ```
         * @memberof IgxInputDirective
         */
        get: /**
         * Gets whether the igxInput is focused.
         * ```typescript
         * let isFocused = this.igxInput.focused;
         * ```
         * \@memberof IgxInputDirective
         * @return {?}
         */
        function () {
            return this.inputGroup.isFocused;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxInputDirective.prototype, "valid", {
        /**
         * Gets the state of the igxInput.
         * ```typescript
         * let igxInputState = this.igxInput.valid;
         * ```
         * @memberof IgxInputDirective
         */
        get: /**
         * Gets the state of the igxInput.
         * ```typescript
         * let igxInputState = this.igxInput.valid;
         * ```
         * \@memberof IgxInputDirective
         * @return {?}
         */
        function () {
            return this._valid;
        },
        /**
         * Sets the state of the igxInput.
         * ```typescript
         * this.igxInput.valid = IgxInputState.INVALID;
         * ```
         * @memberof IgxInputDirective
         */
        set: /**
         * Sets the state of the igxInput.
         * ```typescript
         * this.igxInput.valid = IgxInputState.INVALID;
         * ```
         * \@memberof IgxInputDirective
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._valid = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxInputDirective.prototype, "isValid", {
        /**
         * Gets whether the igxInput is valid.
         * ```typescript
         * let valid = this.igxInput.isValid;
         * ```
         * @memberof IgxInputDirective
         */
        get: /**
         * Gets whether the igxInput is valid.
         * ```typescript
         * let valid = this.igxInput.isValid;
         * ```
         * \@memberof IgxInputDirective
         * @return {?}
         */
        function () {
            return this.valid !== IgxInputState.INVALID;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @return {?}
     */
    IgxInputDirective.prototype.checkValidity = /**
     * @private
     * @return {?}
     */
    function () {
        if (!this.ngControl && this._hasValidators()) {
            this._valid = this.nativeElement.checkValidity() ? IgxInputState.VALID : IgxInputState.INVALID;
        }
    };
    IgxInputDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxInput]',
                    exportAs: 'igxInput'
                },] }
    ];
    /** @nocollapse */
    IgxInputDirective.ctorParameters = function () { return [
        { type: IgxInputGroupBase },
        { type: NgModel, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [NgModel,] }] },
        { type: FormControlName, decorators: [{ type: Optional }, { type: Self }, { type: Inject, args: [FormControlName,] }] },
        { type: ElementRef },
        { type: ChangeDetectorRef }
    ]; };
    IgxInputDirective.propDecorators = {
        value: [{ type: Input, args: ['value',] }],
        disabled: [{ type: Input }],
        required: [{ type: Input }],
        isInput: [{ type: HostBinding, args: ['class.igx-input-group__input',] }],
        isTextArea: [{ type: HostBinding, args: ['class.igx-input-group__textarea',] }],
        onFocus: [{ type: HostListener, args: ['focus', ['$event'],] }],
        onBlur: [{ type: HostListener, args: ['blur', ['$event'],] }],
        onInput: [{ type: HostListener, args: ['input',] }]
    };
    return IgxInputDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var NEXT_ID$3 = 0;
var IgxLabelDirective = /** @class */ (function () {
    function IgxLabelDirective() {
        this.defaultClass = true;
        /**
         * @hidden
         */
        this.id = "igx-label-" + NEXT_ID$3++;
    }
    IgxLabelDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxLabel]'
                },] }
    ];
    IgxLabelDirective.propDecorators = {
        defaultClass: [{ type: HostBinding, args: ['class.igx-input-group__label',] }],
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }]
    };
    return IgxLabelDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxPrefixDirective = /** @class */ (function () {
    function IgxPrefixDirective() {
    }
    IgxPrefixDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'igx-prefix,[igxPrefix]'
                },] }
    ];
    return IgxPrefixDirective;
}());
/**
 * @hidden
 */
var IgxPrefixModule = /** @class */ (function () {
    function IgxPrefixModule() {
    }
    IgxPrefixModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxPrefixDirective],
                    exports: [IgxPrefixDirective]
                },] }
    ];
    return IgxPrefixModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxSuffixDirective = /** @class */ (function () {
    function IgxSuffixDirective() {
    }
    IgxSuffixDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'igx-suffix,[igxSuffix]'
                },] }
    ];
    return IgxSuffixDirective;
}());
/**
 * @hidden
 */
var IgxSuffixModule = /** @class */ (function () {
    function IgxSuffixModule() {
    }
    IgxSuffixModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxSuffixDirective],
                    exports: [IgxSuffixDirective]
                },] }
    ];
    return IgxSuffixModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var DisplayDensity = {
    comfortable: 'comfortable',
    cosy: 'cosy',
    compact: 'compact',
};
/**
 * Defines the DisplayDensity DI token.
 * @type {?}
 */
var DisplayDensityToken = new InjectionToken('DisplayDensity');
/**
 * Base class containing all logic required for implementing DisplayDensity.
 */
var DisplayDensityBase = /** @class */ (function () {
    function DisplayDensityBase(displayDensityOptions) {
        this.displayDensityOptions = displayDensityOptions;
        this.onDensityChanged = new EventEmitter();
        this.oldDisplayDensityOptions = { displayDensity: DisplayDensity.comfortable };
        Object.assign(this.oldDisplayDensityOptions, displayDensityOptions);
    }
    Object.defineProperty(DisplayDensityBase.prototype, "displayDensity", {
        /**
         * Returns the theme of the component.
         * The default theme is `comfortable`.
         * Available options are `comfortable`, `cosy`, `compact`.
         * ```typescript
         * let componentTheme = this.component.displayDensity;
         * ```
         */
        get: /**
         * Returns the theme of the component.
         * The default theme is `comfortable`.
         * Available options are `comfortable`, `cosy`, `compact`.
         * ```typescript
         * let componentTheme = this.component.displayDensity;
         * ```
         * @return {?}
         */
        function () {
            return this._displayDensity ||
                ((this.displayDensityOptions && this.displayDensityOptions.displayDensity) || DisplayDensity.comfortable);
        },
        /**
         * Sets the theme of the component.
         */
        set: /**
         * Sets the theme of the component.
         * @param {?} val
         * @return {?}
         */
        function (val) {
            /** @type {?} */
            var currentDisplayDensity = this._displayDensity;
            this._displayDensity = (/** @type {?} */ (val));
            if (currentDisplayDensity !== this._displayDensity) {
                /** @type {?} */
                var densityChangedArgs = {
                    oldDensity: currentDisplayDensity,
                    newDensity: this._displayDensity
                };
                this.onDensityChanged.emit(densityChangedArgs);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    DisplayDensityBase.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.initialDensity = this._displayDensity;
    };
    /**
     * @return {?}
     */
    DisplayDensityBase.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
        if (!this._displayDensity && this.displayDensityOptions &&
            this.oldDisplayDensityOptions.displayDensity !== this.displayDensityOptions.displayDensity) {
            /** @type {?} */
            var densityChangedArgs = {
                oldDensity: this.oldDisplayDensityOptions.displayDensity,
                newDensity: this.displayDensityOptions.displayDensity
            };
            this.onDensityChanged.emit(densityChangedArgs);
            this.oldDisplayDensityOptions = Object.assign(this.oldDisplayDensityOptions, this.displayDensityOptions);
        }
    };
    /**
     * Given a style class of a component/element returns the modified version of it based
     * on the current display density.
     */
    /**
     * Given a style class of a component/element returns the modified version of it based
     * on the current display density.
     * @protected
     * @param {?} baseStyleClass
     * @return {?}
     */
    DisplayDensityBase.prototype.getComponentDensityClass = /**
     * Given a style class of a component/element returns the modified version of it based
     * on the current display density.
     * @protected
     * @param {?} baseStyleClass
     * @return {?}
     */
    function (baseStyleClass) {
        switch (this.displayDensity) {
            case DisplayDensity.cosy:
                return baseStyleClass + "--" + DisplayDensity.cosy;
            case DisplayDensity.compact:
                return baseStyleClass + "--" + DisplayDensity.compact;
            default:
                return baseStyleClass;
        }
    };
    DisplayDensityBase.propDecorators = {
        displayDensity: [{ type: Input }],
        onDensityChanged: [{ type: Output }]
    };
    return DisplayDensityBase;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var NEXT_ID$4 = 0;
/** @enum {number} */
var IgxInputGroupType = {
    LINE: 0,
    BOX: 1,
    BORDER: 2,
    SEARCH: 3,
};
IgxInputGroupType[IgxInputGroupType.LINE] = 'LINE';
IgxInputGroupType[IgxInputGroupType.BOX] = 'BOX';
IgxInputGroupType[IgxInputGroupType.BORDER] = 'BORDER';
IgxInputGroupType[IgxInputGroupType.SEARCH] = 'SEARCH';
var IgxInputGroupComponent = /** @class */ (function (_super) {
    __extends(IgxInputGroupComponent, _super);
    function IgxInputGroupComponent(_element, _displayDensityOptions) {
        var _this = _super.call(this, _displayDensityOptions) || this;
        _this._element = _element;
        _this._displayDensityOptions = _displayDensityOptions;
        _this._type = IgxInputGroupType.LINE;
        _this._filled = false;
        _this._supressInputAutofocus = false;
        /**
         * An \@Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-input-group [id]="'igx-input-group-55'"></igx-input-group>
         * ```
         */
        _this.id = "igx-input-group-" + NEXT_ID$4++;
        /**
         * Property that enables/disables the autogenerated class of the `IgxInputGroupComponent`.
         * By default applied the class is applied.
         * ```typescript
         * \@ViewChild("MyInputGroup")
         * public inputGroup: IgxInputGroupComponent;
         * ngAfterViewInit(){
         * this.inputGroup.defaultClass = false;
         * ```
         * }
         */
        _this.defaultClass = true;
        /**
         * @hidden
         */
        _this.hasPlaceholder = false;
        /**
         * @hidden
         */
        _this.isRequired = false;
        /**
         * @hidden
         */
        _this.isFocused = false;
        /**
         * @hidden
         */
        _this.isBox = false;
        /**
         * @hidden
         */
        _this.isBorder = false;
        /**
         * @hidden
         */
        _this.isSearch = false;
        /**
         * An \@Input property that disables the `IgxInputGroupComponent`.
         * ```html
         * <igx-input-group [disabled]="'true'"></igx-input-group>
         * ```
         */
        _this.disabled = false;
        /**
         * @hidden
         */
        _this.hasWarning = false;
        _this.element = _element;
        return _this;
    }
    Object.defineProperty(IgxInputGroupComponent.prototype, "validClass", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.input.valid === IgxInputState.VALID;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxInputGroupComponent.prototype, "invalidClass", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.input.valid === IgxInputState.INVALID;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxInputGroupComponent.prototype.onClick = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this._supressInputAutofocus) {
            this.input.focus();
        }
    };
    Object.defineProperty(IgxInputGroupComponent.prototype, "type", {
        /**
         * Returns the type of the `IgxInputGroupComponent`. How the input is styled.
         * Values are `line` - 0, `box` - 1, `border` - 2  and `search` - 3. The default is `line`.
         * ```typescript
         *@ViewChild("MyInputGroup")
         *public inputGroup: IgxInputGroupComponent;
         *ngAfterViewInit(){
         *    let inputType = this.inputGroup.type;
         *}
         * ```
         */
        get: /**
         * Returns the type of the `IgxInputGroupComponent`. How the input is styled.
         * Values are `line` - 0, `box` - 1, `border` - 2  and `search` - 3. The default is `line`.
         * ```typescript
         * \@ViewChild("MyInputGroup")
         * public inputGroup: IgxInputGroupComponent;
         * ngAfterViewInit(){
         *    let inputType = this.inputGroup.type;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this._type.toString();
        },
        /**
         * An @Input property that sets how the input will be styled.
         * The allowed values are `line`, `box`, `border` and `search`. The default is `line`.
         * ```html
         *<igx-input-group [type]="'search'">
         * ```
         */
        set: /**
         * An \@Input property that sets how the input will be styled.
         * The allowed values are `line`, `box`, `border` and `search`. The default is `line`.
         * ```html
         * <igx-input-group [type]="'search'">
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            /** @type {?} */
            var type = ((/** @type {?} */ (IgxInputGroupType)))[value.toUpperCase()];
            if (type !== undefined) {
                this.isBox = this.isBorder = this.isSearch = false;
                switch (type) {
                    case IgxInputGroupType.BOX:
                        this.isBox = true;
                        break;
                    case IgxInputGroupType.BORDER:
                        this.isBorder = true;
                        break;
                    case IgxInputGroupType.SEARCH:
                        this.isSearch = true;
                        break;
                    default: break;
                }
                this._type = type;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxInputGroupComponent.prototype, "supressInputAutofocus", {
        /**
         * Returns whether the input element of the input group will be automatically focused on click.
         * ```typescript
         * let supressInputAutofocus = this.inputGroup.supressInputAutofocus;
         * ```
         */
        get: /**
         * Returns whether the input element of the input group will be automatically focused on click.
         * ```typescript
         * let supressInputAutofocus = this.inputGroup.supressInputAutofocus;
         * ```
         * @return {?}
         */
        function () {
            return this._supressInputAutofocus;
        },
        /**
         * Sets whether the input element of the input group will be automatically focused on click.
         * ```html
         * <igx-input-group [supressInputAutofocus]="true"></igx-input-group>
         * ```
         */
        set: /**
         * Sets whether the input element of the input group will be automatically focused on click.
         * ```html
         * <igx-input-group [supressInputAutofocus]="true"></igx-input-group>
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._supressInputAutofocus = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxInputGroupComponent.prototype, "isFilled", {
        /**
         *@hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._filled || (this.input && this.input.value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxInputGroupComponent.prototype, "isDisplayDensityCosy", {
        /**
         *@hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.displayDensity === DisplayDensity.cosy;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxInputGroupComponent.prototype, "isDisplayDensityComfortable", {
        /**
         *@hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.displayDensity === DisplayDensity.comfortable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxInputGroupComponent.prototype, "isDisplayDensityCompact", {
        /**
         *@hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.displayDensity === DisplayDensity.compact;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxInputGroupComponent.prototype, "hasHints", {
        /**
         * Returns whether the `IgxInputGroupComponent` has hints.
         * ```typescript
         *@ViewChild("MyInputGroup")
         *public inputGroup: IgxInputGroupComponent;
         *ngAfterViewInit(){
         *    let inputHints = this.inputGroup.hasHints;
         *}
         * ```
         */
        get: /**
         * Returns whether the `IgxInputGroupComponent` has hints.
         * ```typescript
         * \@ViewChild("MyInputGroup")
         * public inputGroup: IgxInputGroupComponent;
         * ngAfterViewInit(){
         *    let inputHints = this.inputGroup.hasHints;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this.hints.length > 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxInputGroupComponent.prototype, "hasBorder", {
        /**
         * Returns whether the `IgxInputGroupComponent` has border.
         * ```typescript
         *@ViewChild("MyInputGroup")
         *public inputGroup: IgxInputGroupComponent;
         *ngAfterViewInit(){
         *    let inputBroder = this.inputGroup.hasBorder;
         *}
         * ```
         */
        get: /**
         * Returns whether the `IgxInputGroupComponent` has border.
         * ```typescript
         * \@ViewChild("MyInputGroup")
         * public inputGroup: IgxInputGroupComponent;
         * ngAfterViewInit(){
         *    let inputBroder = this.inputGroup.hasBorder;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this._type === IgxInputGroupType.LINE ||
                this._type === IgxInputGroupType.BOX;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxInputGroupComponent.prototype, "isTypeLine", {
        /**
         * Returns whether the `IgxInputGroupComponent` type is line.
         * ```typescript
         *@ViewChild("MyInputGroup1")
         *public inputGroup: IgxInputGroupComponent;
         *ngAfterViewInit(){
         *    let isTypeLine = this.inputGroup.isTypeLine;
         *}
         * ```
         */
        get: /**
         * Returns whether the `IgxInputGroupComponent` type is line.
         * ```typescript
         * \@ViewChild("MyInputGroup1")
         * public inputGroup: IgxInputGroupComponent;
         * ngAfterViewInit(){
         *    let isTypeLine = this.inputGroup.isTypeLine;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this._type === IgxInputGroupType.LINE;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxInputGroupComponent.prototype, "isTypeBox", {
        /**
         * Returns whether the `IgxInputGroupComponent` type is box.
         * ```typescript
         *@ViewChild("MyInputGroup1")
         *public inputGroup: IgxInputGroupComponent;
         *ngAfterViewInit(){
         *    let isTypeBox = this.inputGroup.isTypeBox;
         *}
         *```
         */
        get: /**
         * Returns whether the `IgxInputGroupComponent` type is box.
         * ```typescript
         * \@ViewChild("MyInputGroup1")
         * public inputGroup: IgxInputGroupComponent;
         * ngAfterViewInit(){
         *    let isTypeBox = this.inputGroup.isTypeBox;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this._type === IgxInputGroupType.BOX;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxInputGroupComponent.prototype, "isTypeBorder", {
        /**
         * Returns whether the `IgxInputGroupComponent` type is border.
         * ```typescript
         *@ViewChild("MyInputGroup1")
         *public inputGroup: IgxInputGroupComponent;
         *ngAfterViewInit(){
         *    let isTypeBorder = this.inputGroup.isTypeBorder;
         *}
         * ```
         */
        get: /**
         * Returns whether the `IgxInputGroupComponent` type is border.
         * ```typescript
         * \@ViewChild("MyInputGroup1")
         * public inputGroup: IgxInputGroupComponent;
         * ngAfterViewInit(){
         *    let isTypeBorder = this.inputGroup.isTypeBorder;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this._type === IgxInputGroupType.BORDER;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxInputGroupComponent.prototype, "isTypeSearch", {
        /**
         * Returns whether the `IgxInputGroupComponent` type is search.
         * ```typescript
         *@ViewChild("MyInputGroup1")
         *public inputGroup: IgxInputGroupComponent;
         *ngAfterViewInit(){
         *    let isTypeSearch = this.inputGroup.isTypeSearch;
         *}
         * ```
         */
        get: /**
         * Returns whether the `IgxInputGroupComponent` type is search.
         * ```typescript
         * \@ViewChild("MyInputGroup1")
         * public inputGroup: IgxInputGroupComponent;
         * ngAfterViewInit(){
         *    let isTypeSearch = this.inputGroup.isTypeSearch;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this._type === IgxInputGroupType.SEARCH;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxInputGroupComponent.prototype, "filled", {
        get: /**
         * @return {?}
         */
        function () {
            return this._filled;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._filled = val;
        },
        enumerable: true,
        configurable: true
    });
    IgxInputGroupComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-input-group',
                    template: "<div class=\"igx-input-group__wrapper\" *ngIf=\"isTypeBox; else bundle\">\n    <ng-container *ngTemplateOutlet=\"bundle\"></ng-container>\n</div>\n<div class=\"igx-input-group__hint\">\n    <ng-content select=\"igx-hint,[igxHint]\"></ng-content>\n</div>\n<ng-template #bundle>\n    <div class=\"igx-input-group__bundle\">\n        <ng-content select=\"igx-prefix,[igxPrefix]\"></ng-content>\n        <div class=\"igx-input-group__bundle-main\">\n            <ng-content select=\"[igxLabel]\"></ng-content>\n            <ng-content select=\"[igxInput]\"></ng-content>\n        </div>\n        <ng-content select=\"igx-suffix,[igxSuffix]\"></ng-content>\n    </div>\n    <div class=\"igx-input-group__border\" *ngIf=\"hasBorder\"></div>\n</ng-template>\n",
                    providers: [{ provide: IgxInputGroupBase, useExisting: IgxInputGroupComponent }]
                }] }
    ];
    /** @nocollapse */
    IgxInputGroupComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
    ]; };
    IgxInputGroupComponent.propDecorators = {
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        defaultClass: [{ type: HostBinding, args: ['class.igx-input-group',] }],
        hasPlaceholder: [{ type: HostBinding, args: ['class.igx-input-group--placeholder',] }],
        isRequired: [{ type: HostBinding, args: ['class.igx-input-group--required',] }],
        isFocused: [{ type: HostBinding, args: ['class.igx-input-group--focused',] }],
        isBox: [{ type: HostBinding, args: ['class.igx-input-group--box',] }],
        isBorder: [{ type: HostBinding, args: ['class.igx-input-group--border',] }],
        isSearch: [{ type: HostBinding, args: ['class.igx-input-group--search',] }],
        disabled: [{ type: HostBinding, args: ['class.igx-input-group--disabled',] }, { type: Input }],
        validClass: [{ type: HostBinding, args: ['class.igx-input-group--valid',] }],
        invalidClass: [{ type: HostBinding, args: ['class.igx-input-group--invalid',] }],
        hasWarning: [{ type: HostBinding, args: ['class.igx-input-group--warning',] }],
        hints: [{ type: ContentChildren, args: [IgxHintDirective, { read: IgxHintDirective },] }],
        input: [{ type: ContentChild, args: [IgxInputDirective, { read: IgxInputDirective },] }],
        onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
        type: [{ type: Input, args: ['type',] }],
        supressInputAutofocus: [{ type: Input }],
        isFilled: [{ type: HostBinding, args: ['class.igx-input-group--filled',] }],
        isDisplayDensityCosy: [{ type: HostBinding, args: ['class.igx-input-group--cosy',] }],
        isDisplayDensityComfortable: [{ type: HostBinding, args: ['class.igx-input-group--comfortable',] }],
        isDisplayDensityCompact: [{ type: HostBinding, args: ['class.igx-input-group--compact',] }]
    };
    return IgxInputGroupComponent;
}(DisplayDensityBase));
/**
 * @hidden
 */
var IgxInputGroupModule = /** @class */ (function () {
    function IgxInputGroupModule() {
    }
    IgxInputGroupModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxInputGroupComponent, IgxHintDirective, IgxInputDirective, IgxLabelDirective],
                    exports: [IgxInputGroupComponent, IgxHintDirective, IgxInputDirective, IgxLabelDirective, IgxPrefixDirective, IgxSuffixDirective],
                    imports: [CommonModule, IgxPrefixModule, IgxSuffixModule]
                },] }
    ];
    return IgxInputGroupModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * **Ignite UI for Angular Autocomplete** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/autocomplete.html)
 *
 * The igxAutocomplete directive provides a way to enhance a text input
 * by showing a drop down of suggested options, provided by the developer.
 *
 * Example:
 * ```html
 * <input type="text" [igxAutocomplete]="townsPanel" />
 * <igx-drop-down #townsPanel>
 *     <igx-drop-down-item *ngFor="let town of towns | startsWith:townSelected" [value]="town">
 *         {{town}}
 *     </igx-drop-down-item>
 * </igx-drop-down>
 * ```
 */
var IgxAutocompleteDirective = /** @class */ (function (_super) {
    __extends(IgxAutocompleteDirective, _super);
    function IgxAutocompleteDirective(ngModel, formControl, group, elementRef, cdr) {
        var _this = _super.call(this, null) || this;
        _this.ngModel = ngModel;
        _this.formControl = formControl;
        _this.group = group;
        _this.elementRef = elementRef;
        _this.cdr = cdr;
        _this.defaultSettings = {
            modal: false,
            scrollStrategy: new AbsoluteScrollStrategy(),
            positionStrategy: new AutoPositionStrategy({ target: _this.parentElement }),
            excludePositionTarget: true
        };
        _this.dropDownOpened$ = new Subject();
        /**
         * Enables/disables autocomplete component
         *
         * ```typescript
         * // get
         * let disabled = this.autocomplete.disabled;
         * ```
         * ```html
         * <!--set-->
         * <input type="text" [igxAutocomplete]="townsPanel" [igxAutocompleteDisabled]="disabled"/>
         * ```
         * ```typescript
         * // set
         * public disabled = true;
         * ```
         */
        _this.disabled = false;
        /**
         * Emitted after item from the drop down is selected
         *
         * ```html
         * <input igxInput [igxAutocomplete]="townsPanel" (onItemSelected)='itemSelected($event)' />
         * ```
         */
        _this.onItemSelected = new EventEmitter();
        /**
         * @hidden \@internal
         */
        _this.autofill = 'off';
        /**
         * @hidden \@internal
         */
        _this.role = 'combobox';
        _this.select = function (value) {
            if (!value.newSelection) {
                return;
            }
            value.cancel = true; // Disable selection in the drop down, because in autocomplete we do not save selection.
            // Disable selection in the drop down, because in autocomplete we do not save selection.
            /** @type {?} */
            var newValue = value.newSelection.value;
            /** @type {?} */
            var args = { value: newValue, cancel: false };
            _this.onItemSelected.emit(args);
            if (args.cancel) {
                return;
            }
            _this.close();
            _this.nativeElement.focus();
            // Update model after the input is re-focused, in order to have proper valid styling.
            // Otherwise when item is selected using mouse (and input is blurred), then valid style will be removed.
            _this.model ? _this.model.control.setValue(newValue) : _this.nativeElement.value = newValue;
        };
        _this.highlightFirstItem = function () {
            if (_this.target.focusedItem) {
                _this.target.focusedItem.focused = false;
                _this.target.focusedItem = null;
            }
            _this.target.navigateFirst();
            _this.cdr.detectChanges();
        };
        return _this;
    }
    Object.defineProperty(IgxAutocompleteDirective.prototype, "model", {
        get: /**
         * @protected
         * @return {?}
         */
        function () {
            return this.ngModel || this.formControl;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxAutocompleteDirective.prototype, "nativeElement", {
        /** @hidden @internal */
        get: /**
         * @hidden \@internal
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxAutocompleteDirective.prototype, "parentElement", {
        /** @hidden @internal */
        get: /**
         * @hidden \@internal
         * @return {?}
         */
        function () {
            return this.group ? this.group.element.nativeElement : this.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxAutocompleteDirective.prototype, "settings", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            /** @type {?} */
            var settings = Object.assign({}, this.defaultSettings, this.autocompleteSettings);
            if (!settings.positionStrategy.settings.target) {
                /** @type {?} */
                var positionStrategyClone = settings.positionStrategy.clone();
                positionStrategyClone.settings.target = this.parentElement;
                settings.positionStrategy = positionStrategyClone;
            }
            return settings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxAutocompleteDirective.prototype, "ariaExpanded", {
        /** @hidden  @internal */
        get: /**
         * @hidden \@internal
         * @return {?}
         */
        function () {
            return !this.collapsed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxAutocompleteDirective.prototype, "hasPopUp", {
        /** @hidden  @internal */
        get: /**
         * @hidden \@internal
         * @return {?}
         */
        function () {
            return 'listbox';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxAutocompleteDirective.prototype, "ariaOwns", {
        /** @hidden  @internal */
        get: /**
         * @hidden \@internal
         * @return {?}
         */
        function () {
            return this.target.listId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxAutocompleteDirective.prototype, "ariaActiveDescendant", {
        /** @hidden  @internal */
        get: /**
         * @hidden \@internal
         * @return {?}
         */
        function () {
            return !this.target.collapsed && this.target.focusedItem ? this.target.focusedItem.id : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxAutocompleteDirective.prototype, "ariaAutocomplete", {
        /** @hidden  @internal */
        get: /**
         * @hidden \@internal
         * @return {?}
         */
        function () {
            return 'list';
        },
        enumerable: true,
        configurable: true
    });
    /** @hidden  @internal */
    /**
     * @hidden \@internal
     * @return {?}
     */
    IgxAutocompleteDirective.prototype.onInput = /**
     * @hidden \@internal
     * @return {?}
     */
    function () {
        this.open();
    };
    /** @hidden  @internal */
    /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    IgxAutocompleteDirective.prototype.onArrowDown = /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        this.open();
    };
    /** @hidden  @internal */
    /**
     * @hidden \@internal
     * @return {?}
     */
    IgxAutocompleteDirective.prototype.onTab = /**
     * @hidden \@internal
     * @return {?}
     */
    function () {
        this.close();
    };
    /** @hidden  @internal */
    /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    IgxAutocompleteDirective.prototype.handleKeyDown = /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this.collapsed) {
            switch (event.key.toLowerCase()) {
                case 'space':
                case 'spacebar':
                case ' ':
                case 'home':
                case 'end':
                    return;
                default:
                    _super.prototype.handleKeyDown.call(this, event);
            }
        }
    };
    /** @hidden  @internal */
    /**
     * @hidden \@internal
     * @return {?}
     */
    IgxAutocompleteDirective.prototype.onArrowDownKeyDown = /**
     * @hidden \@internal
     * @return {?}
     */
    function () {
        _super.prototype.onArrowDownKeyDown.call(this);
    };
    /** @hidden  @internal */
    /**
     * @hidden \@internal
     * @return {?}
     */
    IgxAutocompleteDirective.prototype.onArrowUpKeyDown = /**
     * @hidden \@internal
     * @return {?}
     */
    function () {
        _super.prototype.onArrowUpKeyDown.call(this);
    };
    /** @hidden  @internal */
    /**
     * @hidden \@internal
     * @return {?}
     */
    IgxAutocompleteDirective.prototype.onEndKeyDown = /**
     * @hidden \@internal
     * @return {?}
     */
    function () {
        _super.prototype.onEndKeyDown.call(this);
    };
    /** @hidden  @internal */
    /**
     * @hidden \@internal
     * @return {?}
     */
    IgxAutocompleteDirective.prototype.onHomeKeyDown = /**
     * @hidden \@internal
     * @return {?}
     */
    function () {
        _super.prototype.onHomeKeyDown.call(this);
    };
    /**
     * Closes autocomplete drop down
     */
    /**
     * Closes autocomplete drop down
     * @return {?}
     */
    IgxAutocompleteDirective.prototype.close = /**
     * Closes autocomplete drop down
     * @return {?}
     */
    function () {
        if (this.collapsed) {
            return;
        }
        this.target.close();
        this.dropDownOpened$.next();
    };
    /**
     * Opens autocomplete drop down
     */
    /**
     * Opens autocomplete drop down
     * @return {?}
     */
    IgxAutocompleteDirective.prototype.open = /**
     * Opens autocomplete drop down
     * @return {?}
     */
    function () {
        if (this.disabled || !this.collapsed) {
            return;
        }
        this.target.width = this.parentElement.clientWidth + 'px';
        this.target.open(this.settings);
        this.target.onSelection.pipe(takeUntil(this.dropDownOpened$)).subscribe(this.select);
        this.target.onOpened.pipe(first()).subscribe(this.highlightFirstItem);
        this.target.children.changes.pipe(takeUntil(this.dropDownOpened$)).subscribe(this.highlightFirstItem);
    };
    Object.defineProperty(IgxAutocompleteDirective.prototype, "collapsed", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return this.target ? this.target.collapsed : true;
        },
        enumerable: true,
        configurable: true
    });
    /** @hidden */
    /**
     * @hidden
     * @return {?}
     */
    IgxAutocompleteDirective.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.dropDownOpened$.complete();
    };
    IgxAutocompleteDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxAutocomplete]'
                },] }
    ];
    /** @nocollapse */
    IgxAutocompleteDirective.ctorParameters = function () { return [
        { type: NgModel, decorators: [{ type: Self }, { type: Optional }, { type: Inject, args: [NgModel,] }] },
        { type: FormControlName, decorators: [{ type: Self }, { type: Optional }, { type: Inject, args: [FormControlName,] }] },
        { type: IgxInputGroupComponent, decorators: [{ type: Optional }] },
        { type: ElementRef },
        { type: ChangeDetectorRef }
    ]; };
    IgxAutocompleteDirective.propDecorators = {
        target: [{ type: Input, args: ['igxAutocomplete',] }],
        disabled: [{ type: Input, args: ['igxAutocompleteDisabled',] }],
        autocompleteSettings: [{ type: Input, args: ['igxAutocompleteSettings',] }],
        onItemSelected: [{ type: Output }],
        autofill: [{ type: HostBinding, args: ['attr.autocomplete',] }],
        role: [{ type: HostBinding, args: ['attr.role',] }],
        ariaExpanded: [{ type: HostBinding, args: ['attr.aria-expanded',] }],
        hasPopUp: [{ type: HostBinding, args: ['attr.aria-haspopup',] }],
        ariaOwns: [{ type: HostBinding, args: ['attr.aria-owns',] }],
        ariaActiveDescendant: [{ type: HostBinding, args: ['attr.aria-activedescendant',] }],
        ariaAutocomplete: [{ type: HostBinding, args: ['attr.aria-autocomplete',] }],
        onInput: [{ type: HostListener, args: ['input', ['$event'],] }],
        onArrowDown: [{ type: HostListener, args: ['keydown.ArrowDown', ['$event'],] }, { type: HostListener, args: ['keydown.Alt.ArrowDown', ['$event'],] }, { type: HostListener, args: ['keydown.ArrowUp', ['$event'],] }, { type: HostListener, args: ['keydown.Alt.ArrowUp', ['$event'],] }],
        onTab: [{ type: HostListener, args: ['keydown.Tab', ['$event'],] }, { type: HostListener, args: ['keydown.Shift.Tab', ["$event"],] }]
    };
    return IgxAutocompleteDirective;
}(IgxDropDownItemNavigationDirective));
/**
 * @hidden
 */
var IgxAutocompleteModule = /** @class */ (function () {
    function IgxAutocompleteModule() {
    }
    IgxAutocompleteModule.decorators = [
        { type: NgModule, args: [{
                    imports: [IgxDropDownModule, CommonModule],
                    declarations: [IgxAutocompleteDirective],
                    exports: [IgxAutocompleteDirective]
                },] }
    ];
    return IgxAutocompleteModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxButtonDirective = /** @class */ (function (_super) {
    __extends(IgxButtonDirective, _super);
    function IgxButtonDirective(element, _renderer, _displayDensityOptions) {
        var _this = _super.call(this, _displayDensityOptions) || this;
        _this.element = element;
        _this._renderer = _renderer;
        _this._displayDensityOptions = _displayDensityOptions;
        /**
         * @hidden
         */
        _this._type = 'flat';
        /**
         * @hidden
         */
        _this._cssClass = 'igx-button';
        /**
         * Called when the button is clicked
         */
        _this.buttonClick = new EventEmitter();
        /**
         * Sets/gets the `role` attribute.
         * ```typescript
         * this.button.role = 'navbutton';
         * ```
         * ```typescript
         * let buttonRole =  this.button.role;
         * ```
         * \@memberof IgxButtonDirective
         */
        _this.role = 'button';
        /**
         * Gets or sets whether the button is selected.
         * Mainly used in the IgxButtonGroup component and it will have no effect if set separately.
         * ```html
         * <button igxButton="flat" [selected]="button.selected"></button>
         * ```
         * \@memberof IgxButtonDirective
         */
        _this.selected = false;
        return _this;
    }
    Object.defineProperty(IgxButtonDirective.prototype, "nativeElement", {
        /**
         * Returns the underlying DOM element
         */
        get: /**
         * Returns the underlying DOM element
         * @return {?}
         */
        function () {
            return this.element.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxButtonDirective.prototype, "type", {
        /**
         * Sets the type of the button.
         * ```html
         * <button  igxButton= "icon"></button>
         * ```
         * @memberof IgxButtonDirective
         */
        set: /**
         * Sets the type of the button.
         * ```html
         * <button  igxButton= "icon"></button>
         * ```
         * \@memberof IgxButtonDirective
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._type = value || this._type;
            this._renderer.addClass(this.nativeElement, this._cssClass + "--" + this._type);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxButtonDirective.prototype, "color", {
        /**
         * Sets the button text color.
         * ```html
         * <button igxButton="gradient" igxButtonColor="blue"></button>
         * ```
         * @memberof IgxButtonDirective
         */
        set: /**
         * Sets the button text color.
         * ```html
         * <button igxButton="gradient" igxButtonColor="blue"></button>
         * ```
         * \@memberof IgxButtonDirective
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._color = value || this.nativeElement.style.color;
            this._renderer.setStyle(this.nativeElement, 'color', this._color);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxButtonDirective.prototype, "background", {
        /**
         * Sets the background color of the button.
         * ```html
         * <button igxButton="raised" igxButtonBackground="red"></button>
         * ```
         * @memberof IgxButtonDirective
         */
        set: /**
         * Sets the background color of the button.
         * ```html
         * <button igxButton="raised" igxButtonBackground="red"></button>
         * ```
         * \@memberof IgxButtonDirective
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._backgroundColor = value || this._backgroundColor;
            this._renderer.setStyle(this.nativeElement, 'background', this._backgroundColor);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxButtonDirective.prototype, "label", {
        /**
         * Sets the `aria-label` attribute.
         * ```html
         * <button igxButton= "flat" igxLabel="Label"></button>
         * ```
         * @memberof IgxButtonDirective
         */
        set: /**
         * Sets the `aria-label` attribute.
         * ```html
         * <button igxButton= "flat" igxLabel="Label"></button>
         * ```
         * \@memberof IgxButtonDirective
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._label = value || this._label;
            this._renderer.setAttribute(this.nativeElement, "aria-label", this._label);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxButtonDirective.prototype, "disabled", {
        /**
         * Enables/disables the button.
         *  ```html
         * <button igxButton= "fab" [disabled]="true"></button>
         * ```
         * @memberof IgxButtonDirective
         */
        set: /**
         * Enables/disables the button.
         *  ```html
         * <button igxButton= "fab" [disabled]="true"></button>
         * ```
         * \@memberof IgxButtonDirective
         * @param {?} val
         * @return {?}
         */
        function (val) {
            val = !!val;
            if (val) {
                this._renderer.addClass(this.nativeElement, this._cssClass + "--disabled");
            }
            else {
                this._renderer.removeClass(this.nativeElement, this._cssClass + "--disabled");
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxButtonDirective.prototype, "cssClassCosy", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return (this._type === 'flat' || this._type === 'raised' || this._type === 'outlined') &&
                this.displayDensity === DisplayDensity.cosy;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxButtonDirective.prototype, "cssClassCompact", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return (this._type === 'flat' || this._type === 'raised' || this._type === 'outlined') &&
                this.displayDensity === DisplayDensity.compact;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxButtonDirective.prototype, "cssClassCosyFab", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._type === 'fab' && this.displayDensity === DisplayDensity.cosy;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxButtonDirective.prototype, "cssClassCompactFab", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._type === 'fab' && this.displayDensity === DisplayDensity.compact;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} ev
     * @return {?}
     */
    IgxButtonDirective.prototype.onClick = /**
     * @hidden
     * @param {?} ev
     * @return {?}
     */
    function (ev) {
        this.buttonClick.emit(ev);
    };
    IgxButtonDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxButton]'
                },] }
    ];
    /** @nocollapse */
    IgxButtonDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
    ]; };
    IgxButtonDirective.propDecorators = {
        buttonClick: [{ type: Output }],
        role: [{ type: HostBinding, args: ['attr.role',] }],
        type: [{ type: Input, args: ['igxButton',] }],
        color: [{ type: Input, args: ['igxButtonColor',] }],
        background: [{ type: Input, args: ['igxButtonBackground',] }],
        label: [{ type: Input, args: ['igxLabel',] }],
        disabled: [{ type: Input }],
        cssClassCosy: [{ type: HostBinding, args: ['class.igx-button--cosy',] }],
        cssClassCompact: [{ type: HostBinding, args: ['class.igx-button--compact',] }],
        cssClassCosyFab: [{ type: HostBinding, args: ['class.igx-button--fab-cosy',] }],
        cssClassCompactFab: [{ type: HostBinding, args: ['class.igx-button--fab-compact',] }],
        selected: [{ type: Input }],
        onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
    };
    return IgxButtonDirective;
}(DisplayDensityBase));
/**
 * @hidden
 */
var IgxButtonModule = /** @class */ (function () {
    function IgxButtonModule() {
    }
    IgxButtonModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxButtonDirective],
                    exports: [IgxButtonDirective]
                },] }
    ];
    return IgxButtonModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var IgxDividerType = {
    DEFAULT: 'default',
    DASHED: 'dashed',
};
/** @type {?} */
var NEXT_ID$5 = 0;
var IgxDividerDirective = /** @class */ (function () {
    function IgxDividerDirective() {
        /**
         * Sets/gets the `id` of the divider.
         * If not set, `id` will have value `"igx-divider-0"`;
         * ```html
         * <igx-divider id="my-divider"></igx-divider>
         * ```
         * ```typescript
         * let dividerId =  this.divider.id;
         * ```
         */
        this.id = "igx-divider-" + NEXT_ID$5++;
        /**
         * An \@Input property that sets the value of the `inset` attribute.
         * If not provided it will be set to `'0'`.
         * ```html
         * <igx-divider inset="16px"></igx-divider>
         * ```
         */
        this._inset = '0';
        /**
         * An \@Input property that sets the value of `role` attribute.
         * If not the default value of `separator` will be used.
         */
        this.role = 'separator';
        /**
         * Sets the type of the divider. The default value
         * is `default`. The divider can also be `dashed`;
         * ```html
         * <igx-divider type="dashed"></igx-divider>
         * ```
         */
        this.type = IgxDividerType.DEFAULT;
        /**
         * An \@Input that sets the `middle` attribute of the divider.
         * If set to `true` and an `inset` value has been provided,
         * the divider will start shrinking from both ends.
         * ```html
         * <igx-divider [middle]="true"></igx-divider>
         * ```
         */
        this.middle = false;
        /**
         * An \@Input that sets the vertical attribute of the divider.
         * ```html
         * <igx-divider [vertical]="true"></igx-divider>
         * ```
         */
        this.vertical = false;
    }
    Object.defineProperty(IgxDividerDirective.prototype, "isDashed", {
        get: /**
         * @return {?}
         */
        function () {
            return this.type === IgxDividerType.DASHED;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDividerDirective.prototype, "isDefault", {
        /**
         * A getter that returns `true` if the type of the divider is `default`;
         * ```typescript
         * const isDefault = this.divider.isDefault;
         * ```
         */
        get: /**
         * A getter that returns `true` if the type of the divider is `default`;
         * ```typescript
         * const isDefault = this.divider.isDefault;
         * ```
         * @return {?}
         */
        function () {
            return this.type === IgxDividerType.DEFAULT;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDividerDirective.prototype, "inset", {
        /**
         * Gets the current divider inset in terms of
         * margin representation as applied to the divider.
         * ```typescript
         * const inset = this.divider.inset;
         * ```
         */
        get: /**
         * Gets the current divider inset in terms of
         * margin representation as applied to the divider.
         * ```typescript
         * const inset = this.divider.inset;
         * ```
         * @return {?}
         */
        function () {
            /** @type {?} */
            var baseMargin = '0';
            if (this.middle) {
                if (this.vertical) {
                    return this._inset + " " + baseMargin;
                }
                return baseMargin + " " + this._inset;
            }
            else {
                if (this.vertical) {
                    return this._inset + " " + baseMargin + " 0 " + baseMargin;
                }
                return baseMargin + " 0 " + baseMargin + " " + this._inset;
            }
        },
        /**
         * Sets the inset of the divider from the side(s).
         * If the divider attribute `middle` is set to `true`,
         * it will inset the divider on both sides.
         * ```typescript
         * this.divider.inset = '32px';
         * ```
         */
        set: /**
         * Sets the inset of the divider from the side(s).
         * If the divider attribute `middle` is set to `true`,
         * it will inset the divider on both sides.
         * ```typescript
         * this.divider.inset = '32px';
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._inset = value;
        },
        enumerable: true,
        configurable: true
    });
    IgxDividerDirective.decorators = [
        { type: Directive, args: [{
                    // tslint:disable-next-line:directive-selector
                    selector: 'igx-divider'
                },] }
    ];
    IgxDividerDirective.propDecorators = {
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        _inset: [{ type: Input, args: ['inset',] }],
        role: [{ type: HostBinding, args: ['attr.role',] }, { type: Input }],
        type: [{ type: HostBinding, args: ['class.igx-divider',] }, { type: Input }],
        isDashed: [{ type: HostBinding, args: ['class.igx-divider--dashed',] }],
        middle: [{ type: HostBinding, args: ['class.igx-divider--inset',] }, { type: Input }],
        vertical: [{ type: HostBinding, args: ['class.igx-divider--vertical',] }, { type: Input }],
        inset: [{ type: HostBinding, args: ['style.margin',] }]
    };
    return IgxDividerDirective;
}());
var IgxDividerModule = /** @class */ (function () {
    function IgxDividerModule() {
    }
    IgxDividerModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxDividerDirective],
                    exports: [IgxDividerDirective]
                },] }
    ];
    return IgxDividerModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
var RestrictDrag = {
    VERTICALLY: 0,
    HORIZONTALLY: 1,
    NONE: 2,
};
RestrictDrag[RestrictDrag.VERTICALLY] = 'VERTICALLY';
RestrictDrag[RestrictDrag.HORIZONTALLY] = 'HORIZONTALLY';
RestrictDrag[RestrictDrag.NONE] = 'NONE';
var IgxDragDirective = /** @class */ (function () {
    function IgxDragDirective(cdr, element, zone, renderer) {
        this.cdr = cdr;
        this.element = element;
        this.zone = zone;
        this.renderer = renderer;
        /**
         * An \@Input property that indicates when the drag should start
         * By default the drag starts after the draggable element is moved by 5px
         * ```html
         * <div igxDrag [dragTolerance]="100">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         */
        this.dragTolerance = 5;
        /**
         * Sets a custom class that will be added to the `dragGhost` element.
         * ```html
         * <div igxDrag [ghostImageClass]="'dragGhost'">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         */
        this.ghostImageClass = '';
        /**
         * An \@Input property that hides the draggable element.
         * By default it's set to false.
         * ```html
         * <div igxDrag [dragTolerance]="100" [hideBaseOnDrag]="'true'">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         */
        this.hideBaseOnDrag = false;
        /**
         * An \@Input property that enables/disables the draggable element animation
         * when the element is released.
         * By default it's set to false.
         * ```html
         * <div igxDrag [animateOnRelease]="'true'">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         */
        this.animateOnRelease = false;
        /**
         * An \@Input property that sets the element to which the dragged element will be appended.
         * By default it's set to null and the dragged element is appended to the body.
         * ```html
         * <div #hostDiv></div>
         * <div igxDrag [dragGhostHost]="hostDiv">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         */
        this.dragGhostHost = null;
        /**
         * Event triggered when the draggable element drag starts.
         * ```html
         * <div igxDrag [animateOnRelease]="'true'" (dragStart)="onDragStart()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragStart(){
         *      alert("The drag has stared!");
         * }
         * ```
         */
        this.dragStart = new EventEmitter();
        /**
         * Event triggered when the draggable element is released.
         * ```html
         * <div igxDrag [animateOnRelease]="'true'" (dragEnd)="onDragEnd()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragEnd(){
         *      alert("The drag has ended!");
         * }
         * ```
         */
        this.dragEnd = new EventEmitter();
        /**
         * Event triggered after the draggable element is released and after its animation has finished.
         * ```html
         * <div igxDrag [animateOnRelease]="'true'" (returnMoveEnd)="onMoveEnd()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onMoveEnd(){
         *      alert("The move has ended!");
         * }
         * ```
         */
        this.returnMoveEnd = new EventEmitter();
        /**
         * Event triggered when the draggable element is clicked.
         * ```html
         * <div igxDrag [animateOnRelease]="'true'" (dragClicked)="dragClicked()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public dragClicked(){
         *      alert("The elemented has been clicked!");
         * }
         * ```
         */
        this.dragClicked = new EventEmitter();
        /**
         * @hidden
         */
        this.touch = 'none';
        /**
         * @hidden
         */
        this.transitionProperty = 'top, left';
        /**
         * @hidden
         */
        this._visibility = 'visible';
        /**
         * @hidden
         */
        this.defaultReturnDuration = '0.5s';
        /**
         * @hidden
         */
        this._startX = 0;
        /**
         * @hidden
         */
        this._startY = 0;
        /**
         * @hidden
         */
        this._dragStarted = false;
        /**
         * @hidden
         */
        this._pointerDownId = null;
        /**
         * @hidden
         */
        this._clicked = false;
        /**
         * @hidden
         */
        this._lastDropArea = null;
        /**
         * @hidden
         */
        this._destroy = new Subject();
        /**
         * @hidden
         */
        this._removeOnDestroy = true;
    }
    Object.defineProperty(IgxDragDirective.prototype, "visible", {
        /**
         * Returns the visibility state of the draggable element.
         * ```typescript
         * @ViewChild("myDrag" ,{read: IgxDragDirective})
         * public myDrag: IgxDragDirective;
         * ngAfterViewInit(){
         *     let dragVisibilty = this.myDrag.visible;
         * }
         * ```
         */
        get: /**
         * Returns the visibility state of the draggable element.
         * ```typescript
         * \@ViewChild("myDrag" ,{read: IgxDragDirective})
         * public myDrag: IgxDragDirective;
         * ngAfterViewInit(){
         *     let dragVisibilty = this.myDrag.visible;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this._visibility === 'visible';
        },
        /**
         * Sets the visibility of the draggable element.
         * ```typescript
         * @ViewChild("myDrag" ,{read: IgxDragDirective})
         * public myDrag: IgxDragDirective;
         * ngAfterViewInit(){
         *     this.myDrag.visible = false;
         * }
         * ```
         */
        set: /**
         * Sets the visibility of the draggable element.
         * ```typescript
         * \@ViewChild("myDrag" ,{read: IgxDragDirective})
         * public myDrag: IgxDragDirective;
         * ngAfterViewInit(){
         *     this.myDrag.visible = false;
         * }
         * ```
         * @param {?} bVisible
         * @return {?}
         */
        function (bVisible) {
            this._visibility = bVisible ? 'visible' : 'hidden';
            this.cdr.detectChanges();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDragDirective.prototype, "left", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return parseInt(this.dragGhost.style.left, 10);
        },
        /**
         * @hidden
         */
        set: /**
         * @hidden
         * @param {?} val
         * @return {?}
         */
        function (val) {
            var _this = this;
            requestAnimationFrame(function () {
                if (_this.dragGhost) {
                    _this.dragGhost.style.left = val + 'px';
                }
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDragDirective.prototype, "top", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return parseInt(this.dragGhost.style.top, 10);
        },
        /**
         * @hidden
         */
        set: /**
         * @hidden
         * @param {?} val
         * @return {?}
         */
        function (val) {
            var _this = this;
            requestAnimationFrame(function () {
                if (_this.dragGhost) {
                    _this.dragGhost.style.top = val + 'px';
                }
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDragDirective.prototype, "pointerEventsEnabled", {
        /**
         * Returns if the browser supports pointer events.
         * ```typescript
         * @ViewChild("myDrag" ,{read: IgxDragDirective})
         * public myDrag: IgxDragDirective;
         * ngAfterViewInit(){
         *     let pointerEvents = this.myDrag.pointerEventsEnabled;
         * }
         * ```
         */
        get: /**
         * Returns if the browser supports pointer events.
         * ```typescript
         * \@ViewChild("myDrag" ,{read: IgxDragDirective})
         * public myDrag: IgxDragDirective;
         * ngAfterViewInit(){
         *     let pointerEvents = this.myDrag.pointerEventsEnabled;
         * }
         * ```
         * @return {?}
         */
        function () {
            return typeof PointerEvent !== 'undefined';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDragDirective.prototype, "touchEventsEnabled", {
        /**
         * Returns if the browser supports touch events.
         * ```typescript
         * @ViewChild("myDrag" ,{read: IgxDragDirective})
         * public myDrag: IgxDragDirective;
         * ngAfterViewInit(){
         *     let touchEvents = this.myDrag.pointerEventsEnabled;
         * }
         * ```
         */
        get: /**
         * Returns if the browser supports touch events.
         * ```typescript
         * \@ViewChild("myDrag" ,{read: IgxDragDirective})
         * public myDrag: IgxDragDirective;
         * ngAfterViewInit(){
         *     let touchEvents = this.myDrag.pointerEventsEnabled;
         * }
         * ```
         * @return {?}
         */
        function () {
            return 'ontouchstart' in window;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxDragDirective.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        this.zone.runOutsideAngular(function () {
            if (_this.pointerEventsEnabled) {
                fromEvent(_this.element.nativeElement, 'pointerdown').pipe(takeUntil(_this._destroy))
                    .subscribe(function (res) { return _this.onPointerDown(res); });
                fromEvent(_this.element.nativeElement, 'pointermove').pipe(throttle(function () { return interval(0, animationFrameScheduler); }), takeUntil(_this._destroy)).subscribe(function (res) { return _this.onPointerMove(res); });
                fromEvent(_this.element.nativeElement, 'pointerup').pipe(takeUntil(_this._destroy))
                    .subscribe(function (res) { return _this.onPointerUp(res); });
            }
            else if (_this.touchEventsEnabled) {
                fromEvent(_this.element.nativeElement, 'touchstart').pipe(takeUntil(_this._destroy))
                    .subscribe(function (res) { return _this.onPointerDown(res); });
                fromEvent(document.defaultView, 'touchmove').pipe(throttle(function () { return interval(0, animationFrameScheduler); }), takeUntil(_this._destroy)).subscribe(function (res) { return _this.onPointerMove(res); });
                fromEvent(document.defaultView, 'touchend').pipe(takeUntil(_this._destroy))
                    .subscribe(function (res) { return _this.onPointerUp(res); });
            }
            else {
                // We don't have pointer events and touch events. Use then mouse events.
                fromEvent(_this.element.nativeElement, 'mousedown').pipe(takeUntil(_this._destroy))
                    .subscribe(function (res) { return _this.onPointerDown(res); });
                fromEvent(document.defaultView, 'mousemove').pipe(throttle(function () { return interval(0, animationFrameScheduler); }), takeUntil(_this._destroy)).subscribe(function (res) { return _this.onPointerMove(res); });
                fromEvent(document.defaultView, 'mouseup').pipe(takeUntil(_this._destroy))
                    .subscribe(function (res) { return _this.onPointerUp(res); });
            }
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxDragDirective.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        this._destroy.next(true);
        this._destroy.complete();
        if (this.dragGhost && this._removeOnDestroy) {
            this.dragGhost.parentNode.removeChild(this.dragGhost);
            this.dragGhost = null;
        }
    };
    /**
     * @hidden
     * Method bound to the PointerDown event of the base element igxDrag is initialized.
     * @param event PointerDown event captured
     */
    /**
     * @hidden
     * Method bound to the PointerDown event of the base element igxDrag is initialized.
     * @param {?} event PointerDown event captured
     * @return {?}
     */
    IgxDragDirective.prototype.onPointerDown = /**
     * @hidden
     * Method bound to the PointerDown event of the base element igxDrag is initialized.
     * @param {?} event PointerDown event captured
     * @return {?}
     */
    function (event) {
        this._clicked = true;
        this._pointerDownId = event.pointerId;
        if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
            // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
            this._startX = event.pageX;
            this._startY = event.pageY;
        }
        else if (this.touchEventsEnabled) {
            this._startX = event.touches[0].pageX;
            this._startY = event.touches[0].pageY;
        }
        // Take margins because getBoundingClientRect() doesn't include margins of the element
        /** @type {?} */
        var marginTop = parseInt(document.defaultView.getComputedStyle(this.element.nativeElement)['margin-top'], 10);
        /** @type {?} */
        var marginLeft = parseInt(document.defaultView.getComputedStyle(this.element.nativeElement)['margin-left'], 10);
        this._dragOffsetX =
            (this._startX - this.element.nativeElement.getBoundingClientRect().left - this.getWindowScrollLeft()) + marginLeft;
        this._dragOffsetY =
            (this._startY - this.element.nativeElement.getBoundingClientRect().top - this.getWindowScrollTop()) + marginTop;
        this._dragStartX = this._startX - this._dragOffsetX;
        this._dragStartY = this._startY - this._dragOffsetY;
        // Set pointer capture so we detect pointermove even if mouse is out of bounds until dragGhost is created.
        if (this.pointerEventsEnabled) {
            this.element.nativeElement.setPointerCapture(this._pointerDownId);
        }
        else {
            this.element.nativeElement.focus();
            event.preventDefault();
        }
    };
    /**
     * @hidden
     * Perfmorm drag move logic when dragging and dispatching events if there is igxDrop under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the dragGhost is rendered the pointerId is reassigned to the dragGhost. Then this method is bound to it.
     * @param event PointerMove event captured
     */
    /**
     * @hidden
     * Perfmorm drag move logic when dragging and dispatching events if there is igxDrop under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the dragGhost is rendered the pointerId is reassigned to the dragGhost. Then this method is bound to it.
     * @param {?} event PointerMove event captured
     * @return {?}
     */
    IgxDragDirective.prototype.onPointerMove = /**
     * @hidden
     * Perfmorm drag move logic when dragging and dispatching events if there is igxDrop under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the dragGhost is rendered the pointerId is reassigned to the dragGhost. Then this method is bound to it.
     * @param {?} event PointerMove event captured
     * @return {?}
     */
    function (event) {
        var _this = this;
        if (this._clicked) {
            /** @type {?} */
            var dragStartArgs_1 = {
                originalEvent: event,
                owner: this,
                cancel: false
            };
            /** @type {?} */
            var pageX = void 0;
            /** @type {?} */
            var pageY = void 0;
            if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
                // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
                pageX = event.pageX;
                pageY = event.pageY;
            }
            else if (this.touchEventsEnabled) {
                pageX = event.touches[0].pageX;
                pageY = event.touches[0].pageY;
                // Prevent scrolling on touch while dragging
                event.preventDefault();
            }
            /** @type {?} */
            var totalMovedX = pageX - this._startX;
            /** @type {?} */
            var totalMovedY = pageY - this._startY;
            if (!this._dragStarted &&
                (Math.abs(totalMovedX) > this.dragTolerance || Math.abs(totalMovedY) > this.dragTolerance)) {
                this.zone.run(function () {
                    _this.dragStart.emit(dragStartArgs_1);
                });
                if (!dragStartArgs_1.cancel) {
                    this._dragStarted = true;
                    // We moved enough so dragGhost can be rendered and actual dragging to start.
                    this.createDragGhost(event);
                }
                return;
            }
            else if (!this._dragStarted) {
                return;
            }
            this.left = this._dragStartX + totalMovedX;
            this.top = this._dragStartY + totalMovedY;
            this.dispatchDragEvents(pageX, pageY, event);
        }
    };
    /**
     * @hidden
     * Perform drag end logic when releasing the dragGhost and dispatching drop event if igxDrop is under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the dragGhost is rendered the pointerId is reassigned to the dragGhost. Then this method is bound to it.
     * @param event PointerUp event captured
     */
    /**
     * @hidden
     * Perform drag end logic when releasing the dragGhost and dispatching drop event if igxDrop is under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the dragGhost is rendered the pointerId is reassigned to the dragGhost. Then this method is bound to it.
     * @param {?} event PointerUp event captured
     * @return {?}
     */
    IgxDragDirective.prototype.onPointerUp = /**
     * @hidden
     * Perform drag end logic when releasing the dragGhost and dispatching drop event if igxDrop is under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the dragGhost is rendered the pointerId is reassigned to the dragGhost. Then this method is bound to it.
     * @param {?} event PointerUp event captured
     * @return {?}
     */
    function (event) {
        var _this = this;
        if (!this._clicked) {
            return;
        }
        /** @type {?} */
        var eventArgs = {
            originalEvent: event,
            owner: this
        };
        this._clicked = false;
        if (this._dragStarted) {
            if (this._lastDropArea && this._lastDropArea !== this.element.nativeElement) {
                if (!this.animateOnRelease) {
                    this.onTransitionEnd(null);
                }
                // dragging ended over a drop area. Call this after transition because onDrop might remove the element.
                this.dispatchDropEvent(event.pageX, event.pageY, event);
                // else the drop directive needs to call the dropFinished() method so the animation can perform
            }
            else if (this.animateOnRelease &&
                (this.left !== Math.floor(this._dragStartX) || this.top !== Math.floor(this._dragStartY))) {
                // If the start positions are the same as the current the transition will not execute.
                // return the ghost to start position before removing it. See onTransitionEnd.
                this.dragGhost.style.transitionDuration = this.defaultReturnDuration;
                this.left = this._dragStartX;
                this.top = this._dragStartY;
            }
            else {
                this.onTransitionEnd(null);
            }
            this.zone.run(function () {
                _this.dragEnd.emit(eventArgs);
            });
        }
        else {
            this.zone.run(function () {
                _this.dragClicked.emit(eventArgs);
            });
        }
    };
    /**
     * @hidden
     * Create dragGhost element - if a Node object is provided it creates a clone of that node,
     * otherwise it clones the host element.
     * Bind all needed events.
     * @param event Pointer event required when the dragGhost is being initialized.
     * @param node The Node object to be cloned.
     */
    /**
     * @hidden
     * Create dragGhost element - if a Node object is provided it creates a clone of that node,
     * otherwise it clones the host element.
     * Bind all needed events.
     * @protected
     * @param {?} event Pointer event required when the dragGhost is being initialized.
     * @param {?=} node The Node object to be cloned.
     * @return {?}
     */
    IgxDragDirective.prototype.createDragGhost = /**
     * @hidden
     * Create dragGhost element - if a Node object is provided it creates a clone of that node,
     * otherwise it clones the host element.
     * Bind all needed events.
     * @protected
     * @param {?} event Pointer event required when the dragGhost is being initialized.
     * @param {?=} node The Node object to be cloned.
     * @return {?}
     */
    function (event, node) {
        var _this = this;
        if (node === void 0) { node = null; }
        this.dragGhost = node ? node.cloneNode(true) : this.element.nativeElement.cloneNode(true);
        this.dragGhost.style.transitionDuration = '0.0s';
        this.dragGhost.style.position = 'absolute';
        /** @type {?} */
        var hostLeft = this.dragGhostHost ? this.dragGhostHost.getBoundingClientRect().left : 0;
        /** @type {?} */
        var hostTop = this.dragGhostHost ? this.dragGhostHost.getBoundingClientRect().top : 0;
        this.dragGhost.style.top = this._dragStartY - hostTop + 'px';
        this.dragGhost.style.left = this._dragStartX - hostLeft + 'px';
        if (this.ghostImageClass) {
            this.renderer.addClass(this.dragGhost, this.ghostImageClass);
        }
        if (this.dragGhostHost) {
            this.dragGhostHost.appendChild(this.dragGhost);
        }
        else {
            document.body.appendChild(this.dragGhost);
        }
        if (this.pointerEventsEnabled) {
            // The dragGhost takes control for moving and dragging after it has been shown.
            this.dragGhost.setPointerCapture(this._pointerDownId);
            this.dragGhost.addEventListener('pointermove', function (args) {
                _this.onPointerMove(args);
            });
            this.dragGhost.addEventListener('pointerup', function (args) {
                _this.onPointerUp(args);
            });
        }
        if (this.animateOnRelease) {
            // Transition animation when the dragGhost is released and it returns to it's original position.
            this.dragGhost.addEventListener('transitionend', function (args) {
                _this.onTransitionEnd(args);
            });
        }
        // Hide the base after the dragGhost is created, because otherwise the dragGhost will be not visible.
        if (this.hideBaseOnDrag) {
            this.visible = false;
        }
    };
    /**
     * @hidden
     * Dispatch custom igxDragEnter/igxDragLeave events based on current pointer position and if drop area is under.
     */
    /**
     * @hidden
     * Dispatch custom igxDragEnter/igxDragLeave events based on current pointer position and if drop area is under.
     * @protected
     * @param {?} pageX
     * @param {?} pageY
     * @param {?} originalEvent
     * @return {?}
     */
    IgxDragDirective.prototype.dispatchDragEvents = /**
     * @hidden
     * Dispatch custom igxDragEnter/igxDragLeave events based on current pointer position and if drop area is under.
     * @protected
     * @param {?} pageX
     * @param {?} pageY
     * @param {?} originalEvent
     * @return {?}
     */
    function (pageX, pageY, originalEvent) {
        /** @type {?} */
        var topDropArea;
        /** @type {?} */
        var eventArgs = {
            startX: this._startX,
            startY: this._startY,
            pageX: pageX,
            pageY: pageY,
            owner: this,
            originalEvent: originalEvent
        };
        /** @type {?} */
        var elementsFromPoint = this.getElementsAtPoint(pageX, pageY);
        for (var i = 0; i < elementsFromPoint.length; i++) {
            if (elementsFromPoint[i].getAttribute('droppable') === 'true' && elementsFromPoint[i] !== this.dragGhost) {
                topDropArea = elementsFromPoint[i];
                break;
            }
        }
        if (topDropArea) {
            this.dispatchEvent(topDropArea, 'igxDragOver', eventArgs);
        }
        if (topDropArea &&
            (!this._lastDropArea || (this._lastDropArea && this._lastDropArea !== topDropArea))) {
            if (this._lastDropArea) {
                this.dispatchEvent(this._lastDropArea, 'igxDragLeave', eventArgs);
            }
            this._lastDropArea = topDropArea;
            this.dispatchEvent(this._lastDropArea, 'igxDragEnter', eventArgs);
        }
        else if (!topDropArea && this._lastDropArea) {
            this.dispatchEvent(this._lastDropArea, 'igxDragLeave', eventArgs);
            this._lastDropArea = null;
        }
    };
    /**
     * @hidden
     * Dispatch custom igxDrop event based on current pointer position if there is last recorder drop area under the pointer.
     * Last recorder drop area is updated in @dispatchDragEvents method.
     */
    /**
     * @hidden
     * Dispatch custom igxDrop event based on current pointer position if there is last recorder drop area under the pointer.
     * Last recorder drop area is updated in \@dispatchDragEvents method.
     * @protected
     * @param {?} pageX
     * @param {?} pageY
     * @param {?} originalEvent
     * @return {?}
     */
    IgxDragDirective.prototype.dispatchDropEvent = /**
     * @hidden
     * Dispatch custom igxDrop event based on current pointer position if there is last recorder drop area under the pointer.
     * Last recorder drop area is updated in \@dispatchDragEvents method.
     * @protected
     * @param {?} pageX
     * @param {?} pageY
     * @param {?} originalEvent
     * @return {?}
     */
    function (pageX, pageY, originalEvent) {
        /** @type {?} */
        var eventArgs = {
            startX: this._startX,
            startY: this._startY,
            pageX: pageX,
            pageY: pageY,
            owner: this,
            originalEvent: originalEvent
        };
        this.dispatchEvent(this._lastDropArea, 'igxDrop', eventArgs);
        this.dispatchEvent(this._lastDropArea, 'igxDragLeave', eventArgs);
        this._lastDropArea = null;
    };
    /**
     * @hidden
     * Update relative positions
     */
    /**
     * @hidden
     * Update relative positions
     * @return {?}
     */
    IgxDragDirective.prototype.updateDragRelativePos = /**
     * @hidden
     * Update relative positions
     * @return {?}
     */
    function () {
        if (!this.dragGhost) {
            return;
        }
        // Calculate the new dragGhost position to remain where the mouse is, so it doesn't jump
        /** @type {?} */
        var totalDraggedX = this.left - this._dragStartX;
        /** @type {?} */
        var totalDraggedY = this.top - this._dragStartY;
        /** @type {?} */
        var newPosX = this.element.nativeElement.getBoundingClientRect().left;
        /** @type {?} */
        var newPosY = this.element.nativeElement.getBoundingClientRect().top;
        /** @type {?} */
        var diffStartX = this._dragStartX - newPosX;
        /** @type {?} */
        var diffStartY = this._dragStartY - newPosY;
        this.top = newPosX + totalDraggedX - diffStartX;
        this.left = newPosY + totalDraggedY - diffStartY;
    };
    /**
     * Informs the `igxDrag` directive that it has been dropped/released.
     * This should usully be called when `animateOnRelease` is set to `true`.
     * When canceling or defining custom drop logic this tells the igxDrag to update it's positions and
     * animate correctly to the new position.
     * ```typescript
     * public onDropElem(event) {
     *     // Function bound to the igxDrop directive event `onDrop`
     *     // This cancels the default drop logic of the `igxDrop`
     *     event.cancel = true;
     *     event.drag.dropFinished();
     * }
     * ```
     */
    /**
     * Informs the `igxDrag` directive that it has been dropped/released.
     * This should usully be called when `animateOnRelease` is set to `true`.
     * When canceling or defining custom drop logic this tells the igxDrag to update it's positions and
     * animate correctly to the new position.
     * ```typescript
     * public onDropElem(event) {
     *     // Function bound to the igxDrop directive event `onDrop`
     *     // This cancels the default drop logic of the `igxDrop`
     *     event.cancel = true;
     *     event.drag.dropFinished();
     * }
     * ```
     * @return {?}
     */
    IgxDragDirective.prototype.dropFinished = /**
     * Informs the `igxDrag` directive that it has been dropped/released.
     * This should usully be called when `animateOnRelease` is set to `true`.
     * When canceling or defining custom drop logic this tells the igxDrag to update it's positions and
     * animate correctly to the new position.
     * ```typescript
     * public onDropElem(event) {
     *     // Function bound to the igxDrop directive event `onDrop`
     *     // This cancels the default drop logic of the `igxDrop`
     *     event.cancel = true;
     *     event.drag.dropFinished();
     * }
     * ```
     * @return {?}
     */
    function () {
        if (this.animateOnRelease && this.dragGhost) {
            this.updateDragRelativePos();
            // Return the dragged element to the start. See onTransitionEnd next.
            // Take margins becuase getBoundingClientRect() doesn't include margins
            /** @type {?} */
            var marginTop = parseInt(document.defaultView.getComputedStyle(this.element.nativeElement)['margin-top'], 10);
            /** @type {?} */
            var marginLeft = parseInt(document.defaultView.getComputedStyle(this.element.nativeElement)['margin-left'], 10);
            /** @type {?} */
            var newPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
            /** @type {?} */
            var newPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
            this.dragGhost.style.transitionDuration = this.defaultReturnDuration;
            this.left = newPosX - marginLeft;
            this.top = newPosY - marginTop;
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxDragDirective.prototype.onTransitionEnd = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        if (this._dragStarted && !this._clicked) {
            if (this.hideBaseOnDrag) {
                this.visible = true;
            }
            this.dragGhost.parentNode.removeChild(this.dragGhost);
            this.dragGhost = null;
            this.element.nativeElement.style.transitionDuration = '0.0s';
            this._dragStarted = false;
            this.zone.run(function () {
                _this.returnMoveEnd.emit({
                    originalEvent: event,
                    owner: _this
                });
            });
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} pageX
     * @param {?} pageY
     * @return {?}
     */
    IgxDragDirective.prototype.getElementsAtPoint = /**
     * @hidden
     * @protected
     * @param {?} pageX
     * @param {?} pageY
     * @return {?}
     */
    function (pageX, pageY) {
        // correct the coordinates with the current scroll position, because
        // document.elementsFromPoint conider position within the current viewport
        // window.pageXOffset == window.scrollX; // always true
        // using window.pageXOffset for IE9 compatibility
        /** @type {?} */
        var viewPortX = pageX - window.pageXOffset;
        /** @type {?} */
        var viewPortY = pageY - window.pageYOffset;
        if (document['msElementsFromPoint']) {
            // Edge and IE special snowflakes
            return document['msElementsFromPoint'](viewPortX, viewPortY);
        }
        else {
            // Other browsers like Chrome, Firefox, Opera
            return document.elementsFromPoint(viewPortX, viewPortY);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} target
     * @param {?} eventName
     * @param {?} eventArgs
     * @return {?}
     */
    IgxDragDirective.prototype.dispatchEvent = /**
     * @hidden
     * @protected
     * @param {?} target
     * @param {?} eventName
     * @param {?} eventArgs
     * @return {?}
     */
    function (target, eventName, eventArgs) {
        // This way is IE11 compatible.
        /** @type {?} */
        var dragLeaveEvent = document.createEvent('CustomEvent');
        dragLeaveEvent.initCustomEvent(eventName, false, false, eventArgs);
        target.dispatchEvent(dragLeaveEvent);
        // Othersie can be used `target.dispatchEvent(new CustomEvent(eventName, eventArgs));`
    };
    /**
     * @protected
     * @return {?}
     */
    IgxDragDirective.prototype.getWindowScrollTop = /**
     * @protected
     * @return {?}
     */
    function () {
        return window.scrollY ? window.scrollY : (window.pageYOffset ? window.pageYOffset : 0);
    };
    /**
     * @protected
     * @return {?}
     */
    IgxDragDirective.prototype.getWindowScrollLeft = /**
     * @protected
     * @return {?}
     */
    function () {
        return window.scrollX ? window.scrollX : (window.pageXOffset ? window.pageXOffset : 0);
    };
    IgxDragDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxDrag]'
                },] }
    ];
    /** @nocollapse */
    IgxDragDirective.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone },
        { type: Renderer2 }
    ]; };
    IgxDragDirective.propDecorators = {
        data: [{ type: Input, args: ['igxDrag',] }],
        dragTolerance: [{ type: Input }],
        ghostImageClass: [{ type: Input }],
        hideBaseOnDrag: [{ type: Input }],
        animateOnRelease: [{ type: Input }],
        dragGhostHost: [{ type: Input }],
        dragStart: [{ type: Output }],
        dragEnd: [{ type: Output }],
        returnMoveEnd: [{ type: Output }],
        dragClicked: [{ type: Output }],
        touch: [{ type: HostBinding, args: ['style.touchAction',] }],
        transitionProperty: [{ type: HostBinding, args: ['style.transitionProperty',] }],
        _visibility: [{ type: HostBinding, args: ['style.visibility',] }]
    };
    return IgxDragDirective;
}());
var IgxDropDirective = /** @class */ (function () {
    function IgxDropDirective(element, _renderer, _zone) {
        this.element = element;
        this._renderer = _renderer;
        this._zone = _zone;
        /**
         * Event triggered when dragged element enters the area of the element.
         * ```html
         * <div class="cageArea" igxDrop (onEnter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragEnter(){
         *     alert("A draggable elemente has entered the chip area!");
         * }
         * ```
         */
        this.onEnter = new EventEmitter();
        /**
         * Event triggered when dragged element leaves the area of the element.
         * ```html
         * <div class="cageArea" igxDrop (onLeave)="dragLeave()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragLeave(){
         *     alert("A draggable elemente has left the chip area!");
         * }
         * ```
         */
        this.onLeave = new EventEmitter();
        /**
         * Event triggered when dragged element is dropped in the area of the element.
         * Since the `igxDrop` has default logic that appends the dropped element as a child, it can be canceled here.
         * To cancel the default logic the `cancel` property of the event needs to be set to true.
         * ```html
         * <div class="cageArea" igxDrop (onDrop)="dragDrop()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragDrop(){
         *     alert("A draggable elemente has been dropped in the chip area!");
         * }
         * ```
         */
        this.onDrop = new EventEmitter();
        /**
         * @hidden
         */
        this.droppable = true;
        /**
         * @hidden
         */
        this.dragover = false;
        /**
         * @hidden
         */
        this._destroy = new Subject();
    }
    /**
     * @return {?}
     */
    IgxDropDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this._zone.runOutsideAngular(function () {
            fromEvent(_this.element.nativeElement, 'igxDragEnter').pipe(takeUntil(_this._destroy))
                .subscribe(function (res) { return _this.onDragEnter((/** @type {?} */ (res))); });
            fromEvent(_this.element.nativeElement, 'igxDragLeave').pipe(takeUntil(_this._destroy)).subscribe(function (res) { return _this.onDragLeave(res); });
            fromEvent(_this.element.nativeElement, 'igxDragOver').pipe(takeUntil(_this._destroy)).subscribe(function (res) { return _this.onDragOver(res); });
        });
    };
    /**
     * @return {?}
     */
    IgxDropDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._destroy.next(true);
        this._destroy.complete();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxDropDirective.prototype.onDragOver = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) { };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxDropDirective.prototype.onDragEnter = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        this.dragover = true;
        /** @type {?} */
        var elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        /** @type {?} */
        var elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        /** @type {?} */
        var offsetX = event.detail.pageX - elementPosX;
        /** @type {?} */
        var offsetY = event.detail.pageY - elementPosY;
        /** @type {?} */
        var eventArgs = {
            originalEvent: event.detail.originalEvent,
            owner: this,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX: offsetX,
            offsetY: offsetY
        };
        this._zone.run(function () {
            _this.onEnter.emit(eventArgs);
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxDropDirective.prototype.onDragLeave = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        this.dragover = false;
        /** @type {?} */
        var elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        /** @type {?} */
        var elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        /** @type {?} */
        var offsetX = event.detail.pageX - elementPosX;
        /** @type {?} */
        var offsetY = event.detail.pageY - elementPosY;
        /** @type {?} */
        var eventArgs = {
            originalEvent: event.detail.originalEvent,
            owner: this,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX: offsetX,
            offsetY: offsetY
        };
        this._zone.run(function () {
            _this.onLeave.emit(eventArgs);
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxDropDirective.prototype.onDragDrop = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        /** @type {?} */
        var elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        /** @type {?} */
        var elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        /** @type {?} */
        var offsetX = event.detail.pageX - elementPosX;
        /** @type {?} */
        var offsetY = event.detail.pageY - elementPosY;
        /** @type {?} */
        var args = {
            owner: this,
            originalEvent: event.detail.originalEvent,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            offsetX: offsetX,
            offsetY: offsetY,
            cancel: false
        };
        this._zone.run(function () {
            _this.onDrop.emit(args);
        });
        if (!args.cancel) {
            // To do for generic scenario
            this._renderer.removeChild(event.detail.owner.element.nativeElement.parentNode, event.detail.owner.element.nativeElement);
            this._renderer.appendChild(this.element.nativeElement, event.detail.owner.element.nativeElement);
            setTimeout(function () {
                event.detail.owner.dropFinished();
            }, 0);
        }
    };
    /**
     * @protected
     * @return {?}
     */
    IgxDropDirective.prototype.getWindowScrollTop = /**
     * @protected
     * @return {?}
     */
    function () {
        return window.scrollY ? window.scrollY : (window.pageYOffset ? window.pageYOffset : 0);
    };
    /**
     * @protected
     * @return {?}
     */
    IgxDropDirective.prototype.getWindowScrollLeft = /**
     * @protected
     * @return {?}
     */
    function () {
        return window.scrollX ? window.scrollX : (window.pageXOffset ? window.pageXOffset : 0);
    };
    IgxDropDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxDrop]'
                },] }
    ];
    /** @nocollapse */
    IgxDropDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 },
        { type: NgZone }
    ]; };
    IgxDropDirective.propDecorators = {
        data: [{ type: Input, args: ['igxDrop',] }],
        onEnter: [{ type: Output }],
        onLeave: [{ type: Output }],
        onDrop: [{ type: Output }],
        droppable: [{ type: HostBinding, args: ['attr.droppable',] }],
        dragover: [{ type: HostBinding, args: ['class.dragOver',] }],
        onDragDrop: [{ type: HostListener, args: ['igxDrop', ['$event'],] }]
    };
    return IgxDropDirective;
}());
/**
 * @hidden
 */
var IgxDragDropModule = /** @class */ (function () {
    function IgxDragDropModule() {
    }
    IgxDragDropModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxDragDirective, IgxDropDirective],
                    exports: [IgxDragDirective, IgxDropDirective]
                },] }
    ];
    return IgxDragDropModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxFilterOptions = /** @class */ (function () {
    function IgxFilterOptions() {
        // Input text value that will be used as a filtering pattern (matching condition is based on it)
        this.inputValue = '';
    }
    // Function - get value to be tested from the item
    // item - single item of the list to be filtered
    // key - property name of item, which value should be tested
    // Default behavior - returns "key"- named property value of item if key si provided,
    // otherwise textContent of the item's html element
    // Function - get value to be tested from the item
    // item - single item of the list to be filtered
    // key - property name of item, which value should be tested
    // Default behavior - returns "key"- named property value of item if key si provided,
    // otherwise textContent of the item's html element
    /**
     * @param {?} item
     * @param {?} key
     * @return {?}
     */
    IgxFilterOptions.prototype.get_value = 
    // Function - get value to be tested from the item
    // item - single item of the list to be filtered
    // key - property name of item, which value should be tested
    // Default behavior - returns "key"- named property value of item if key si provided,
    // otherwise textContent of the item's html element
    /**
     * @param {?} item
     * @param {?} key
     * @return {?}
     */
    function (item, key) {
        /** @type {?} */
        var result = '';
        if (key && item[key]) {
            result = item[key].toString();
        }
        else if (item.element) {
            if (item.element.nativeElement) {
                result = item.element.nativeElement.textContent.trim();
                // Check if element doesn't return the DOM element directly
            }
            else if (item.element.textContent) {
                result = item.element.textContent.trim();
            }
        }
        return result;
    };
    // Function - formats the original text before matching process
    // Default behavior - returns text to lower case
    // Function - formats the original text before matching process
    // Default behavior - returns text to lower case
    /**
     * @param {?} valueToTest
     * @return {?}
     */
    IgxFilterOptions.prototype.formatter = 
    // Function - formats the original text before matching process
    // Default behavior - returns text to lower case
    /**
     * @param {?} valueToTest
     * @return {?}
     */
    function (valueToTest) {
        return valueToTest.toLowerCase();
    };
    // Function - determines whether the item met the condition
    // valueToTest - text value that should be tested
    // inputValue - text value from input that condition is based on
    // Default behavior - "contains"
    // Function - determines whether the item met the condition
    // valueToTest - text value that should be tested
    // inputValue - text value from input that condition is based on
    // Default behavior - "contains"
    /**
     * @param {?} valueToTest
     * @param {?} inputValue
     * @return {?}
     */
    IgxFilterOptions.prototype.matchFn = 
    // Function - determines whether the item met the condition
    // valueToTest - text value that should be tested
    // inputValue - text value from input that condition is based on
    // Default behavior - "contains"
    /**
     * @param {?} valueToTest
     * @param {?} inputValue
     * @return {?}
     */
    function (valueToTest, inputValue) {
        return valueToTest.indexOf(inputValue && inputValue.toLowerCase() || '') > -1;
    };
    // Function - executed after matching test for every matched item
    // Default behavior - shows the item
    // Function - executed after matching test for every matched item
    // Default behavior - shows the item
    /**
     * @param {?} item
     * @return {?}
     */
    IgxFilterOptions.prototype.metConditionFn = 
    // Function - executed after matching test for every matched item
    // Default behavior - shows the item
    /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (item.hasOwnProperty('hidden')) {
            item.hidden = false;
        }
    };
    // Function - executed for every NOT matched item after matching test
    // Default behavior - hides the item
    // Function - executed for every NOT matched item after matching test
    // Default behavior - hides the item
    /**
     * @param {?} item
     * @return {?}
     */
    IgxFilterOptions.prototype.overdueConditionFn = 
    // Function - executed for every NOT matched item after matching test
    // Default behavior - hides the item
    /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (item.hasOwnProperty('hidden')) {
            item.hidden = true;
        }
    };
    return IgxFilterOptions;
}());
var IgxFilterDirective = /** @class */ (function () {
    function IgxFilterDirective(element, renderer) {
        this.element = element;
        this.filtering = new EventEmitter(false); // synchronous event emitter
        // synchronous event emitter
        this.filtered = new EventEmitter();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    IgxFilterDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        // Detect only changes of input value
        if (changes.filterOptions &&
            changes.filterOptions.currentValue &&
            changes.filterOptions.currentValue.inputValue !== undefined &&
            changes.filterOptions.previousValue &&
            changes.filterOptions.currentValue.inputValue !== changes.filterOptions.previousValue.inputValue) {
            this.filter();
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxFilterDirective.prototype.filter = /**
     * @private
     * @return {?}
     */
    function () {
        if (!this.filterOptions.items) {
            return;
        }
        /** @type {?} */
        var args = { cancel: false, items: this.filterOptions.items };
        this.filtering.emit(args);
        if (args.cancel) {
            return;
        }
        /** @type {?} */
        var pipe = new IgxFilterPipe();
        /** @type {?} */
        var filtered = pipe.transform(this.filterOptions.items, this.filterOptions);
        this.filtered.emit({ filteredItems: filtered });
    };
    IgxFilterDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxFilter]'
                },] }
    ];
    /** @nocollapse */
    IgxFilterDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 }
    ]; };
    IgxFilterDirective.propDecorators = {
        filtering: [{ type: Output }],
        filtered: [{ type: Output }],
        filterOptions: [{ type: Input, args: ['igxFilter',] }]
    };
    return IgxFilterDirective;
}());
var IgxFilterPipe = /** @class */ (function () {
    function IgxFilterPipe() {
    }
    /**
     * @param {?} items
     * @param {?} options
     * @return {?}
     */
    IgxFilterPipe.prototype.transform = /**
     * @param {?} items
     * @param {?} options
     * @return {?}
     */
    function (items, 
    // options - initial settings of filter functionality
    options) {
        /** @type {?} */
        var result = [];
        if (!items || !items.length || !options) {
            return;
        }
        if (options.items) {
            items = options.items;
        }
        result = items.filter(function (item) {
            /** @type {?} */
            var match = options.matchFn(options.formatter(options.get_value(item, options.key)), options.inputValue);
            if (match) {
                if (options.metConditionFn) {
                    options.metConditionFn(item);
                }
            }
            else {
                if (options.overdueConditionFn) {
                    options.overdueConditionFn(item);
                }
            }
            return match;
        });
        return result;
    };
    IgxFilterPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'igxFilter',
                    pure: false
                },] }
    ];
    return IgxFilterPipe;
}());
/**
 * @hidden
 */
var IgxFilterModule = /** @class */ (function () {
    function IgxFilterModule() {
    }
    IgxFilterModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxFilterDirective, IgxFilterPipe],
                    exports: [IgxFilterDirective, IgxFilterPipe],
                    imports: [CommonModule]
                },] }
    ];
    return IgxFilterModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxFocusDirective = /** @class */ (function () {
    function IgxFocusDirective(element, comp) {
        this.element = element;
        this.comp = comp;
        this.focusState = true;
    }
    Object.defineProperty(IgxFocusDirective.prototype, "focused", {
        /**
         * Returns the state of the igxFocus.
         * ```typescript
         * @ViewChild('focusContainer', {read: IgxFocusDirective})
         * public igxFocus: IgxFocusDirective;
         * let isFocusOn = this.igxFocus.focused;
         * ```
         * @memberof IgxFocusDirective
         */
        get: /**
         * Returns the state of the igxFocus.
         * ```typescript
         * \@ViewChild('focusContainer', {read: IgxFocusDirective})
         * public igxFocus: IgxFocusDirective;
         * let isFocusOn = this.igxFocus.focused;
         * ```
         * \@memberof IgxFocusDirective
         * @return {?}
         */
        function () {
            return this.focusState;
        },
        /**
         * Sets the state of the igxFocus.
         * ```html
         * <igx-input-group >
         *  <input #focusContainer igxInput [igxFocus]="true"/>
         * </igx-input-group>
         * ```
         * @memberof IgxFocusDirective
         */
        set: /**
         * Sets the state of the igxFocus.
         * ```html
         * <igx-input-group >
         *  <input #focusContainer igxInput [igxFocus]="true"/>
         * </igx-input-group>
         * ```
         * \@memberof IgxFocusDirective
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this.focusState = val;
            this.trigger();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxFocusDirective.prototype, "nativeElement", {
        /**
         * Gets the native element of the igxFocus.
         * ```typescript
         * @ViewChild('focusContainer', {read: IgxFocusDirective})
         * public igxFocus: IgxFocusDirective;
         * let igxFocusNativeElement = this.igxFocus.nativeElement;
         * ```
         * @memberof IgxFocusDirective
         */
        get: /**
         * Gets the native element of the igxFocus.
         * ```typescript
         * \@ViewChild('focusContainer', {read: IgxFocusDirective})
         * public igxFocus: IgxFocusDirective;
         * let igxFocusNativeElement = this.igxFocus.nativeElement;
         * ```
         * \@memberof IgxFocusDirective
         * @return {?}
         */
        function () {
            if (this.comp && this.comp[0] && this.comp[0].getEditElement) {
                return ((/** @type {?} */ (this.comp[0]))).getEditElement();
            }
            return this.element.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Triggers the igxFocus state.
     * ```typescript
     * @ViewChild('focusContainer', {read: IgxFocusDirective})
     * public igxFocus: IgxFocusDirective;
     * this.igxFocus.trigger();
     * ```
     * @memberof IgxFocusDirective
     */
    /**
     * Triggers the igxFocus state.
     * ```typescript
     * \@ViewChild('focusContainer', {read: IgxFocusDirective})
     * public igxFocus: IgxFocusDirective;
     * this.igxFocus.trigger();
     * ```
     * \@memberof IgxFocusDirective
     * @return {?}
     */
    IgxFocusDirective.prototype.trigger = /**
     * Triggers the igxFocus state.
     * ```typescript
     * \@ViewChild('focusContainer', {read: IgxFocusDirective})
     * public igxFocus: IgxFocusDirective;
     * this.igxFocus.trigger();
     * ```
     * \@memberof IgxFocusDirective
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.focusState) {
            requestAnimationFrame(function () { return _this.nativeElement.focus(); });
        }
    };
    IgxFocusDirective.decorators = [
        { type: Directive, args: [{
                    exportAs: 'igxFocus',
                    selector: '[igxFocus]'
                },] }
    ];
    /** @nocollapse */
    IgxFocusDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Array, decorators: [{ type: Inject, args: [NG_VALUE_ACCESSOR,] }, { type: Self }, { type: Optional }] }
    ]; };
    IgxFocusDirective.propDecorators = {
        focused: [{ type: Input, args: ['igxFocus',] }]
    };
    return IgxFocusDirective;
}());
/**
 * @hidden
 */
var IgxFocusModule = /** @class */ (function () {
    function IgxFocusModule() {
    }
    IgxFocusModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxFocusDirective],
                    exports: [IgxFocusDirective]
                },] }
    ];
    return IgxFocusModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxLayoutDirective = /** @class */ (function () {
    function IgxLayoutDirective() {
        /**
         * Sets the default flow direction of the container's children.
         *
         * Defaults to `rows`.
         *
         * ```html
         *  <div
         *   igxLayout
         *   igxLayoutDir="row">
         *    <div igxFlex>1</div>
         *    <div igxFlex>2</div>
         *    <div igxFlex>3</div>
         *  </div>
         * ```
         */
        this.dir = 'row';
        /**
         * Defines the direction flex children are placed in the flex container.
         *
         * When set to `true`, the `rows` direction goes right to left and `columns` goes bottom to top.
         *
         * ```html
         * <div
         *   igxLayout
         *   igxLayoutReverse="true">
         *    <div igxFlex>1</div>
         *    <div igxFlex>2</div>
         *    <div igxFlex>3</div>
         * </div>
         * ```
         */
        this.reverse = false;
        /**
         * By default the immediate children will all try to fit onto one line.
         *
         * The default value `nowrap` sets this behavior.
         *
         * Other accepted values are `wrap` and `wrap-reverse`.
         *
         * ```html
         * <div
         *   igxLayout
         *   igxLayoutDir="row"
         *   igxLayoutWrap="wrap">
         *    <div igxFlex igxFlexGrow="0">1</div>
         *    <div igxFlex igxFlexGrow="0">2</div>
         *    <div igxFlex igxFlexGrow="0">3</div>
         * </div>
         * ```
         */
        this.wrap = 'nowrap';
        /**
         * Defines the alignment along the main axis.
         *
         * Defaults to `flex-start` which packs the children toward the start line.
         *
         * Other possible values are `flex-end`, `center`, `space-between`, `space-around`.
         *
         * ```html
         * <div
         *   igxLayout
         *   igxLayoutDir="column"
         *   igxLayoutJustify="space-between">
         *    <div>1</div>
         *    <div>2</div>
         *    <div>3</div>
         * </div>
         * ```
         */
        this.justify = 'flex-start';
        /**
         * Defines the default behavior for how children are laid out along the corss axis of the current line.
         *
         * Defaults to `flex-start`.
         *
         * Other possible values are `flex-end`, `center`, `baseline`, and `stretch`.
         *
         * ```html
         * <div
         *   igxLayout
         *   igxLayoutDir="column"
         *   igxLayoutItemAlign="start">
         *    <div igxFlex igxFlexGrow="0">1</div>
         *    <div igxFlex igxFlexGrow="0">2</div>
         *    <div igxFlex igxFlexGrow="0">3</div>
         * </div>
         * ```
         */
        this.itemAlign = 'stretch';
        /**
         * @hidden
         */
        this.display = 'flex';
    }
    Object.defineProperty(IgxLayoutDirective.prototype, "flexwrap", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () { return this.wrap; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxLayoutDirective.prototype, "justifycontent", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () { return this.justify; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxLayoutDirective.prototype, "align", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () { return this.itemAlign; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxLayoutDirective.prototype, "direction", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            if (this.reverse) {
                return (this.dir === 'row') ? 'row-reverse' : 'column-reverse';
            }
            return (this.dir === 'row') ? 'row' : 'column';
        },
        enumerable: true,
        configurable: true
    });
    IgxLayoutDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxLayout]'
                },] }
    ];
    IgxLayoutDirective.propDecorators = {
        dir: [{ type: Input, args: ['igxLayoutDir',] }],
        reverse: [{ type: Input, args: ['igxLayoutReverse',] }],
        wrap: [{ type: Input, args: ['igxLayoutWrap',] }],
        justify: [{ type: Input, args: ['igxLayoutJustify',] }],
        itemAlign: [{ type: Input, args: ['igxLayoutItemAlign',] }],
        display: [{ type: HostBinding, args: ['style.display',] }],
        flexwrap: [{ type: HostBinding, args: ['style.flex-wrap',] }],
        justifycontent: [{ type: HostBinding, args: ['style.justify-content',] }],
        align: [{ type: HostBinding, args: ['style.align-items',] }],
        direction: [{ type: HostBinding, args: ['style.flex-direction',] }]
    };
    return IgxLayoutDirective;
}());
var IgxFlexDirective = /** @class */ (function () {
    function IgxFlexDirective() {
        /**
         * Applies the `grow` attribute to an element that uses the directive.
         *
         * Default value is `1`.
         *
         * ```html
         * <div>
         *    <div igxFlex igxFlexGrow="0">Content1</div>
         *    <div igxFlex igxFlexGrow="1">Content2</div>
         *    <div igxFlex igxFlexGrow="0">Content3</div>
         * </div>
         * ```
         */
        this.grow = 1;
        /**
         * Applies the `shrink` attribute to an element that uses the directive.
         *
         * Default value is `1`.
         *
         * ```html
         * <div>
         *    <div igxFlex igxFlexShrink="1">Content1</div>
         *    <div igxFlex igxFlexShrink="0">Content2</div>
         *    <div igxFlex igxFlexShrink="1">Content3</div>
         * </div>
         * ```
         */
        this.shrink = 1;
        /**
         * Applies the directive to an element.
         *
         * Possible values include `igxFlexGrow`, `igxFlexShrink`, `igxFlexOrder`, `igxFlexBasis`.
         *
         * ```html
         * <div igxFlex>Content</div>
         * ```
         */
        this.flex = '';
        /**
         * Applies the `order` attribute to an element that uses the directive.
         *
         * Default value is `0`.
         *
         * ```html
         * <div>
         *    <div igxFlex igxFlexOrder="1">Content1</div>
         *    <div igxFlex igxFlexOrder="0">Content2</div>
         *    <div igxFlex igxFlexOrder="2">Content3</div>
         * </div>
         * ```
         */
        this.order = 0;
        /**
         * Applies the `flex-basis` attribute to an element that uses the directive.
         *
         * Default value is `auto`.
         *
         * Other possible values include `content`, `max-content`, `min-content`, `fit-content`.
         *
         * ```html
         * <div igxFlex igxFlexBasis="fit-content">Content</div>
         * ```
         */
        this.basis = 'auto';
    }
    Object.defineProperty(IgxFlexDirective.prototype, "style", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            if (this.flex) {
                return "" + this.flex;
            }
            return this.grow + " " + this.shrink + " " + this.basis;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxFlexDirective.prototype, "itemorder", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.order || 0;
        },
        enumerable: true,
        configurable: true
    });
    IgxFlexDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxFlex]'
                },] }
    ];
    IgxFlexDirective.propDecorators = {
        grow: [{ type: Input, args: ['igxFlexGrow',] }],
        shrink: [{ type: Input, args: ['igxFlexShrink',] }],
        flex: [{ type: Input, args: ['igxFlex',] }],
        order: [{ type: Input, args: ['igxFlexOrder',] }],
        basis: [{ type: Input, args: ['igxFlexBasis',] }],
        style: [{ type: HostBinding, args: ['style.flex',] }],
        itemorder: [{ type: HostBinding, args: ['style.order',] }]
    };
    return IgxFlexDirective;
}());
/**
 * @hidden
 */
var IgxLayoutModule = /** @class */ (function () {
    function IgxLayoutModule() {
    }
    IgxLayoutModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxFlexDirective, IgxLayoutDirective],
                    exports: [IgxFlexDirective, IgxLayoutDirective]
                },] }
    ];
    return IgxLayoutModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 * @type {?}
 */
var MASK_FLAGS = ['C', '&', 'a', 'A', '?', 'L', '9', '0', '#'];
/**
 * @hidden
 * @type {?}
 */
var KEYS$1 = {
    Ctrl: 17,
    Z: 90,
    Y: 89,
    X: 88,
    BACKSPACE: 8,
    DELETE: 46
};
/**
 * @hidden
 */
var /**
 * @hidden
 */
MaskHelper = /** @class */ (function () {
    function MaskHelper() {
    }
    Object.defineProperty(MaskHelper.prototype, "cursor", {
        get: /**
         * @return {?}
         */
        function () {
            return this._cursor;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} value
     * @param {?} maskOptions
     * @param {?} cursor
     * @return {?}
     */
    MaskHelper.prototype.parseValueByMask = /**
     * @param {?} value
     * @param {?} maskOptions
     * @param {?} cursor
     * @return {?}
     */
    function (value, maskOptions, cursor) {
        /** @type {?} */
        var inputValue = value;
        /** @type {?} */
        var mask = maskOptions.format;
        /** @type {?} */
        var literals = this.getMaskLiterals(mask);
        /** @type {?} */
        var literalKeys = Array.from(literals.keys());
        /** @type {?} */
        var nonLiteralIndeces = this.getNonLiteralIndeces(mask, literalKeys);
        if (inputValue.length < mask.length) { // BACKSPACE, DELETE
            if (inputValue === '' && cursor === -1) {
                this._cursor = 0;
                return this.parseValueByMaskOnInit(value, maskOptions);
            } // workaround for IE 'x' button
            if (nonLiteralIndeces.indexOf(cursor + 1) !== -1) {
                inputValue = this.insertCharAt(inputValue, cursor + 1, maskOptions.promptChar);
                this._cursor = cursor + 1;
            }
            else {
                inputValue = this.insertCharAt(inputValue, cursor + 1, mask[cursor + 1]);
                this._cursor = cursor + 1;
                for (var i = this._cursor; i < 0; i--) {
                    if (literalKeys.indexOf(this._cursor) !== -1) {
                        this._cursor--;
                    }
                    else {
                        break;
                    }
                }
            }
        }
        else {
            /** @type {?} */
            var char = inputValue[cursor];
            /** @type {?} */
            var isCharValid = this.validateCharOnPostion(char, cursor, mask);
            if (nonLiteralIndeces.indexOf(cursor) !== -1) {
                inputValue = this.replaceCharAt(inputValue, cursor, '');
                if (isCharValid) {
                    inputValue = this.replaceCharAt(inputValue, cursor, char);
                    this._cursor = cursor + 1;
                }
                else {
                    this._cursor = cursor;
                }
            }
            else {
                inputValue = this.replaceCharAt(inputValue, cursor, '');
                this._cursor = ++cursor;
                for (var i = cursor; i < mask.length; i++) {
                    if (literalKeys.indexOf(this._cursor) !== -1) {
                        this._cursor = ++cursor;
                    }
                    else {
                        isCharValid = this.validateCharOnPostion(char, cursor, mask);
                        if (isCharValid) {
                            inputValue = this.replaceCharAt(inputValue, cursor, char);
                            this._cursor = ++cursor;
                            break;
                        }
                        else {
                            break;
                        }
                    }
                }
            }
        }
        return inputValue;
    };
    /**
     * @param {?} maskOptions
     * @return {?}
     */
    MaskHelper.prototype.parseMask = /**
     * @param {?} maskOptions
     * @return {?}
     */
    function (maskOptions) {
        var _this = this;
        var e_1, _a;
        /** @type {?} */
        var outputVal = '';
        /** @type {?} */
        var mask = maskOptions.format;
        /** @type {?} */
        var literals = this.getMaskLiterals(mask);
        try {
            for (var mask_1 = __values(mask), mask_1_1 = mask_1.next(); !mask_1_1.done; mask_1_1 = mask_1.next()) {
                var maskSym = mask_1_1.value;
                outputVal += maskOptions.promptChar;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (mask_1_1 && !mask_1_1.done && (_a = mask_1.return)) _a.call(mask_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        literals.forEach(function (val, key) {
            outputVal = _this.replaceCharAt(outputVal, key, val);
        });
        return outputVal;
    };
    /**
     * @param {?} inputVal
     * @param {?} maskOptions
     * @return {?}
     */
    MaskHelper.prototype.parseValueByMaskOnInit = /**
     * @param {?} inputVal
     * @param {?} maskOptions
     * @return {?}
     */
    function (inputVal, maskOptions) {
        var _this = this;
        var e_2, _a, e_3, _b;
        /** @type {?} */
        var outputVal = '';
        /** @type {?} */
        var value = '';
        /** @type {?} */
        var mask = maskOptions.format;
        /** @type {?} */
        var literals = this.getMaskLiterals(mask);
        /** @type {?} */
        var literalKeys = Array.from(literals.keys());
        /** @type {?} */
        var nonLiteralIndeces = this.getNonLiteralIndeces(mask, literalKeys);
        /** @type {?} */
        var literalValues = Array.from(literals.values());
        if (inputVal != null) {
            value = inputVal.toString();
        }
        try {
            for (var mask_2 = __values(mask), mask_2_1 = mask_2.next(); !mask_2_1.done; mask_2_1 = mask_2.next()) {
                var maskSym = mask_2_1.value;
                outputVal += maskOptions.promptChar;
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (mask_2_1 && !mask_2_1.done && (_a = mask_2.return)) _a.call(mask_2);
            }
            finally { if (e_2) throw e_2.error; }
        }
        literals.forEach(function (val, key) {
            outputVal = _this.replaceCharAt(outputVal, key, val);
        });
        if (!value) {
            return outputVal;
        }
        /** @type {?} */
        var nonLiteralValues = this.getNonLiteralValues(value, literalValues);
        for (var i = 0; i < nonLiteralValues.length; i++) {
            /** @type {?} */
            var char = nonLiteralValues[i];
            /** @type {?} */
            var isCharValid = this.validateCharOnPostion(char, nonLiteralIndeces[i], mask);
            if (!isCharValid && char !== maskOptions.promptChar) {
                nonLiteralValues[i] = maskOptions.promptChar;
            }
        }
        if (nonLiteralValues.length > nonLiteralIndeces.length) {
            nonLiteralValues.splice(nonLiteralIndeces.length);
        }
        /** @type {?} */
        var pos = 0;
        try {
            for (var nonLiteralValues_1 = __values(nonLiteralValues), nonLiteralValues_1_1 = nonLiteralValues_1.next(); !nonLiteralValues_1_1.done; nonLiteralValues_1_1 = nonLiteralValues_1.next()) {
                var nonLiteralValue = nonLiteralValues_1_1.value;
                /** @type {?} */
                var char = nonLiteralValue;
                outputVal = this.replaceCharAt(outputVal, nonLiteralIndeces[pos++], char);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (nonLiteralValues_1_1 && !nonLiteralValues_1_1.done && (_b = nonLiteralValues_1.return)) _b.call(nonLiteralValues_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return outputVal;
    };
    /**
     * @param {?} value
     * @param {?} maskOptions
     * @return {?}
     */
    MaskHelper.prototype.restoreValueFromMask = /**
     * @param {?} value
     * @param {?} maskOptions
     * @return {?}
     */
    function (value, maskOptions) {
        var e_4, _a;
        /** @type {?} */
        var outputVal = '';
        /** @type {?} */
        var mask = maskOptions.format;
        /** @type {?} */
        var literals = this.getMaskLiterals(mask);
        /** @type {?} */
        var literalValues = Array.from(literals.values());
        try {
            for (var value_1 = __values(value), value_1_1 = value_1.next(); !value_1_1.done; value_1_1 = value_1.next()) {
                var val = value_1_1.value;
                if (literalValues.indexOf(val) === -1) {
                    if (val !== maskOptions.promptChar) {
                        outputVal += val;
                    }
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (value_1_1 && !value_1_1.done && (_a = value_1.return)) _a.call(value_1);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return outputVal;
    };
    /**
     * @param {?} value
     * @param {?} maskOptions
     * @param {?} cursor
     * @param {?} selection
     * @return {?}
     */
    MaskHelper.prototype.parseValueByMaskUponSelection = /**
     * @param {?} value
     * @param {?} maskOptions
     * @param {?} cursor
     * @param {?} selection
     * @return {?}
     */
    function (value, maskOptions, cursor, selection) {
        /** @type {?} */
        var isCharValid;
        /** @type {?} */
        var inputValue = value;
        /** @type {?} */
        var char = inputValue[cursor];
        /** @type {?} */
        var mask = maskOptions.format;
        /** @type {?} */
        var literals = this.getMaskLiterals(mask);
        /** @type {?} */
        var literalKeys = Array.from(literals.keys());
        /** @type {?} */
        var nonLiteralIndeces = this.getNonLiteralIndeces(mask, literalKeys);
        if (!this.data) {
            this._cursor = cursor < 0 ? ++cursor : cursor;
            if (nonLiteralIndeces.indexOf(this._cursor) !== -1) {
                isCharValid = this.validateCharOnPostion(char, this._cursor, mask);
                inputValue = isCharValid ? this.replaceCharAt(inputValue, this._cursor++, char) :
                    inputValue = this.replaceCharAt(inputValue, this._cursor++, maskOptions.promptChar);
                selection--;
                if (selection > 0) {
                    for (var i = 0; i < selection; i++) {
                        cursor++;
                        inputValue = nonLiteralIndeces.indexOf(cursor) !== -1 ?
                            this.insertCharAt(inputValue, cursor, maskOptions.promptChar) :
                            this.insertCharAt(inputValue, cursor, mask[cursor]);
                    }
                }
            }
            else {
                inputValue = this.replaceCharAt(inputValue, this._cursor, mask[this._cursor]);
                this._cursor++;
                selection--;
                /** @type {?} */
                var isMarked = false;
                if (selection > 0) {
                    cursor = this._cursor;
                    for (var i = 0; i < selection; i++) {
                        if (nonLiteralIndeces.indexOf(cursor) !== -1) {
                            isCharValid = this.validateCharOnPostion(char, cursor, mask);
                            if (isCharValid && !isMarked) {
                                inputValue = this.insertCharAt(inputValue, cursor, char);
                                cursor++;
                                this._cursor++;
                                isMarked = true;
                            }
                            else {
                                inputValue = this.insertCharAt(inputValue, cursor, maskOptions.promptChar);
                                cursor++;
                            }
                        }
                        else {
                            inputValue = this.insertCharAt(inputValue, cursor, mask[cursor]);
                            if (cursor === this._cursor) {
                                this._cursor++;
                            }
                            cursor++;
                        }
                    }
                }
            }
        }
        else {
            if (inputValue === '' && cursor === -1) {
                this._cursor = 0;
                return this.parseValueByMaskOnInit(value, maskOptions);
            } // workaround for IE 'x' button
            if (this._cursor < 0) {
                this._cursor++;
                cursor++;
            }
            cursor++;
            this._cursor = cursor;
            for (var i = 0; i < selection; i++) {
                if (nonLiteralIndeces.indexOf(cursor) !== -1) {
                    inputValue = this.insertCharAt(inputValue, cursor, maskOptions.promptChar);
                    cursor++;
                }
                else {
                    inputValue = this.insertCharAt(inputValue, cursor, mask[cursor]);
                    cursor++;
                }
            }
        }
        return inputValue;
    };
    /**
     * @param {?} value
     * @param {?} maskOptions
     * @param {?} cursor
     * @param {?} clipboardData
     * @param {?} selection
     * @return {?}
     */
    MaskHelper.prototype.parseValueByMaskUponCopyPaste = /**
     * @param {?} value
     * @param {?} maskOptions
     * @param {?} cursor
     * @param {?} clipboardData
     * @param {?} selection
     * @return {?}
     */
    function (value, maskOptions, cursor, clipboardData, selection) {
        var e_5, _a;
        /** @type {?} */
        var inputValue = value;
        /** @type {?} */
        var mask = maskOptions.format;
        /** @type {?} */
        var literals = this.getMaskLiterals(mask);
        /** @type {?} */
        var literalKeys = Array.from(literals.keys());
        /** @type {?} */
        var nonLiteralIndeces = this.getNonLiteralIndeces(mask, literalKeys);
        /** @type {?} */
        var selectionEnd = cursor + selection;
        this._cursor = cursor;
        try {
            for (var clipboardData_1 = __values(clipboardData), clipboardData_1_1 = clipboardData_1.next(); !clipboardData_1_1.done; clipboardData_1_1 = clipboardData_1.next()) {
                var clipboardSym = clipboardData_1_1.value;
                /** @type {?} */
                var char = clipboardSym;
                if (this._cursor > mask.length) {
                    return inputValue;
                }
                if (nonLiteralIndeces.indexOf(this._cursor) !== -1) {
                    /** @type {?} */
                    var isCharValid = this.validateCharOnPostion(char, this._cursor, mask);
                    if (isCharValid) {
                        inputValue = this.replaceCharAt(inputValue, this._cursor++, char);
                    }
                }
                else {
                    for (var i = cursor; i < mask.length; i++) {
                        if (literalKeys.indexOf(this._cursor) !== -1) {
                            this._cursor++;
                        }
                        else {
                            /** @type {?} */
                            var isCharValid = this.validateCharOnPostion(char, this._cursor, mask);
                            if (isCharValid) {
                                inputValue = this.replaceCharAt(inputValue, this._cursor++, char);
                            }
                            break;
                        }
                    }
                }
                selection--;
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (clipboardData_1_1 && !clipboardData_1_1.done && (_a = clipboardData_1.return)) _a.call(clipboardData_1);
            }
            finally { if (e_5) throw e_5.error; }
        }
        if (selection > 0) {
            for (var i = this._cursor; i < selectionEnd; i++) {
                if (literalKeys.indexOf(this._cursor) !== -1) {
                    this._cursor++;
                }
                else {
                    inputValue = this.replaceCharAt(inputValue, this._cursor++, maskOptions.promptChar);
                }
            }
        }
        return inputValue;
    };
    /**
     * @private
     * @param {?} inputChar
     * @param {?} position
     * @param {?} mask
     * @return {?}
     */
    MaskHelper.prototype.validateCharOnPostion = /**
     * @private
     * @param {?} inputChar
     * @param {?} position
     * @param {?} mask
     * @return {?}
     */
    function (inputChar, position, mask) {
        /** @type {?} */
        var regex;
        /** @type {?} */
        var isValid;
        /** @type {?} */
        var letterOrDigitRegEx = '[\\d\\u00C0-\\u1FFF\\u2C00-\\uD7FFa-zA-Z]';
        /** @type {?} */
        var letterDigitOrSpaceRegEx = '[\\d\\u00C0-\\u1FFF\\u2C00-\\uD7FFa-zA-Z\\u0020]';
        /** @type {?} */
        var letterRegEx = '[\\u00C0-\\u1FFF\\u2C00-\\uD7FFa-zA-Z]';
        /** @type {?} */
        var letteSpaceRegEx = '[\\u00C0-\\u1FFF\\u2C00-\\uD7FFa-zA-Z\\u0020]';
        /** @type {?} */
        var digitRegEx = '[\\d]';
        /** @type {?} */
        var digitSpaceRegEx = '[\\d\\u0020]';
        /** @type {?} */
        var digitSpecialRegEx = '[\\d-\\+]';
        switch (mask.charAt(position)) {
            case 'C':
                isValid = inputChar !== '';
                break;
            case '&':
                regex = new RegExp('[\\u0020]');
                isValid = !regex.test(inputChar);
                break;
            case 'a':
                regex = new RegExp(letterDigitOrSpaceRegEx);
                isValid = regex.test(inputChar);
                break;
            case 'A':
                regex = new RegExp(letterOrDigitRegEx);
                isValid = regex.test(inputChar);
                break;
            case '?':
                regex = new RegExp(letteSpaceRegEx);
                isValid = regex.test(inputChar);
                break;
            case 'L':
                regex = new RegExp(letterRegEx);
                isValid = regex.test(inputChar);
                break;
            case '0':
                regex = new RegExp(digitRegEx);
                isValid = regex.test(inputChar);
                break;
            case '9':
                regex = new RegExp(digitSpaceRegEx);
                isValid = regex.test(inputChar);
                break;
            case '#':
                regex = new RegExp(digitSpecialRegEx);
                isValid = regex.test(inputChar);
                break;
            default: {
                isValid = null;
            }
        }
        return isValid;
    };
    /**
     * @private
     * @param {?} strValue
     * @param {?} index
     * @param {?} char
     * @return {?}
     */
    MaskHelper.prototype.replaceCharAt = /**
     * @private
     * @param {?} strValue
     * @param {?} index
     * @param {?} char
     * @return {?}
     */
    function (strValue, index, char) {
        if (strValue !== undefined) {
            return strValue.substring(0, index) + char + strValue.substring(index + 1);
        }
    };
    /**
     * @private
     * @param {?} strValue
     * @param {?} index
     * @param {?} char
     * @return {?}
     */
    MaskHelper.prototype.insertCharAt = /**
     * @private
     * @param {?} strValue
     * @param {?} index
     * @param {?} char
     * @return {?}
     */
    function (strValue, index, char) {
        if (strValue !== undefined) {
            return strValue.substring(0, index) + char + strValue.substring(index);
        }
    };
    /**
     * @private
     * @param {?} mask
     * @return {?}
     */
    MaskHelper.prototype.getMaskLiterals = /**
     * @private
     * @param {?} mask
     * @return {?}
     */
    function (mask) {
        /** @type {?} */
        var literals = new Map();
        for (var i = 0; i < mask.length; i++) {
            /** @type {?} */
            var char = mask.charAt(i);
            if (MASK_FLAGS.indexOf(char) === -1) {
                literals.set(i, char);
            }
        }
        return literals;
    };
    /**
     * @private
     * @param {?} mask
     * @param {?} literalKeys
     * @return {?}
     */
    MaskHelper.prototype.getNonLiteralIndeces = /**
     * @private
     * @param {?} mask
     * @param {?} literalKeys
     * @return {?}
     */
    function (mask, literalKeys) {
        /** @type {?} */
        var nonLiteralsIndeces = new Array();
        for (var i = 0; i < mask.length; i++) {
            if (literalKeys.indexOf(i) === -1) {
                nonLiteralsIndeces.push(i);
            }
        }
        return nonLiteralsIndeces;
    };
    /**
     * @private
     * @param {?} value
     * @param {?} literalValues
     * @return {?}
     */
    MaskHelper.prototype.getNonLiteralValues = /**
     * @private
     * @param {?} value
     * @param {?} literalValues
     * @return {?}
     */
    function (value, literalValues) {
        var e_6, _a;
        /** @type {?} */
        var nonLiteralValues = new Array();
        try {
            for (var value_2 = __values(value), value_2_1 = value_2.next(); !value_2_1.done; value_2_1 = value_2.next()) {
                var val = value_2_1.value;
                if (literalValues.indexOf(val) === -1) {
                    nonLiteralValues.push(val);
                }
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (value_2_1 && !value_2_1.done && (_a = value_2.return)) _a.call(value_2);
            }
            finally { if (e_6) throw e_6.error; }
        }
        return nonLiteralValues;
    };
    return MaskHelper;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var noop = function () { };
var IgxMaskDirective = /** @class */ (function () {
    function IgxMaskDirective(elementRef) {
        this.elementRef = elementRef;
        /**
         * Emits an event each time the value changes.
         * Provides `rawValue: string` and `formattedValue: string` as event arguments.
         * ```html
         * <input (onValueChange) = "onValueChange(rawValue: string, formattedValue: string)">
         * ```
         */
        this.onValueChange = new EventEmitter();
        /**
         * @hidden
         */
        this._maskOptions = {
            format: '',
            promptChar: ''
        };
        /**
         * @hidden
         */
        this._onTouchedCallback = noop;
        /**
         * @hidden
         */
        this._onChangeCallback = noop;
        this.maskHelper = new MaskHelper();
    }
    Object.defineProperty(IgxMaskDirective.prototype, "value", {
        /**
         *@hidden
         */
        get: /**
         * @hidden
         * @private
         * @return {?}
         */
        function () {
            return this.nativeElement.value;
        },
        /**
         *@hidden
         */
        set: /**
         * @hidden
         * @private
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this.nativeElement.value = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxMaskDirective.prototype, "nativeElement", {
        /**
         *@hidden
         */
        get: /**
         * @hidden
         * @private
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxMaskDirective.prototype, "selectionStart", {
        /**
         *@hidden
         */
        get: /**
         * @hidden
         * @private
         * @return {?}
         */
        function () {
            return this.nativeElement.selectionStart;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxMaskDirective.prototype, "selectionEnd", {
        /**
         *@hidden
         */
        get: /**
         * @hidden
         * @private
         * @return {?}
         */
        function () {
            return this.nativeElement.selectionEnd;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxMaskDirective.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (this.promptChar && this.promptChar.length > 1) {
            this._maskOptions.promptChar = this.promptChar = this.promptChar.substring(0, 1);
        }
        this._maskOptions.format = this.mask ? this.mask : 'CCCCCCCCCC';
        this._maskOptions.promptChar = this.promptChar ? this.promptChar : '_';
        this.nativeElement.setAttribute('placeholder', this.placeholder ? this.placeholder : this._maskOptions.format);
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxMaskDirective.prototype.onKeydown = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var key = event.keyCode || event.charCode;
        if (isIE() && this._stopPropagation) {
            this._stopPropagation = false;
        }
        if (key === KEYS$1.Ctrl) {
            this._ctrlDown = true;
        }
        if ((this._ctrlDown && key === KEYS$1.Z) || (this._ctrlDown && key === KEYS$1.Y)) {
            event.preventDefault();
        }
        this._key = key;
        this._selection = Math.abs(this.selectionEnd - this.selectionStart);
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxMaskDirective.prototype.onKeyup = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var key = event.keyCode || event.charCode;
        if (key === KEYS$1.Ctrl) {
            this._ctrlDown = false;
        }
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxMaskDirective.prototype.onPaste = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this._paste = true;
        this._valOnPaste = this.value;
        this._cursorOnPaste = this.getCursorPosition();
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxMaskDirective.prototype.onInputChanged = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (isIE() && this._stopPropagation) {
            this._stopPropagation = false;
            return;
        }
        if (this._paste) {
            this._paste = false;
            /** @type {?} */
            var clipboardData = this.value.substring(this._cursorOnPaste, this.getCursorPosition());
            this.value = this.maskHelper.parseValueByMaskUponCopyPaste(this._valOnPaste, this._maskOptions, this._cursorOnPaste, clipboardData, this._selection);
            this.setCursorPosition(this.maskHelper.cursor);
        }
        else {
            /** @type {?} */
            var currentCursorPos = this.getCursorPosition();
            this.maskHelper.data = (this._key === KEYS$1.BACKSPACE) || (this._key === KEYS$1.DELETE);
            this.value = this._selection && this._selection !== 0 ?
                this.maskHelper.parseValueByMaskUponSelection(this.value, this._maskOptions, currentCursorPos - 1, this._selection) :
                this.maskHelper.parseValueByMask(this.value, this._maskOptions, currentCursorPos - 1);
            this.setCursorPosition(this.maskHelper.cursor);
        }
        /** @type {?} */
        var rawVal = this.maskHelper.restoreValueFromMask(this.value, this._maskOptions);
        this.dataValue = this.includeLiterals ? this.value : rawVal;
        this._onChangeCallback(this.dataValue);
        this.onValueChange.emit({ rawValue: rawVal, formattedValue: this.value });
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    IgxMaskDirective.prototype.onFocus = /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (this.focusedValuePipe) {
            if (isIE()) {
                this._stopPropagation = true;
            }
            this.value = this.focusedValuePipe.transform(value);
        }
        else {
            this.value = this.maskHelper.parseValueByMaskOnInit(this.value, this._maskOptions);
        }
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    IgxMaskDirective.prototype.onBlur = /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (this.displayValuePipe) {
            this.value = this.displayValuePipe.transform(value);
        }
        else if (value === this.maskHelper.parseMask(this._maskOptions)) {
            this.value = '';
        }
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @private
     * @return {?}
     */
    IgxMaskDirective.prototype.getCursorPosition = /**
     * @hidden
     * @private
     * @return {?}
     */
    function () {
        return this.nativeElement.selectionStart;
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @private
     * @param {?} start
     * @param {?=} end
     * @return {?}
     */
    IgxMaskDirective.prototype.setCursorPosition = /**
     * @hidden
     * @private
     * @param {?} start
     * @param {?=} end
     * @return {?}
     */
    function (start, end) {
        if (end === void 0) { end = start; }
        this.nativeElement.setSelectionRange(start, end);
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    IgxMaskDirective.prototype.writeValue = /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (this.promptChar && this.promptChar.length > 1) {
            this._maskOptions.promptChar = this.promptChar.substring(0, 1);
        }
        this.value = value ? this.maskHelper.parseValueByMaskOnInit(value, this._maskOptions) : '';
        if (this.displayValuePipe) {
            this.value = this.displayValuePipe.transform(this.value);
        }
        this.dataValue = this.includeLiterals ? this.value : value;
        this._onChangeCallback(this.dataValue);
        this.onValueChange.emit({ rawValue: value, formattedValue: this.value });
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    IgxMaskDirective.prototype.registerOnChange = /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._onChangeCallback = fn; };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    IgxMaskDirective.prototype.registerOnTouched = /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._onTouchedCallback = fn; };
    IgxMaskDirective.decorators = [
        { type: Directive, args: [{
                    providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: IgxMaskDirective, multi: true }],
                    selector: '[igxMask]'
                },] }
    ];
    /** @nocollapse */
    IgxMaskDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    IgxMaskDirective.propDecorators = {
        mask: [{ type: Input, args: ['igxMask',] }],
        promptChar: [{ type: Input }],
        includeLiterals: [{ type: Input }],
        placeholder: [{ type: Input }],
        displayValuePipe: [{ type: Input }],
        focusedValuePipe: [{ type: Input }],
        dataValue: [{ type: Input }],
        onValueChange: [{ type: Output }],
        onKeydown: [{ type: HostListener, args: ['keydown', ['$event'],] }],
        onKeyup: [{ type: HostListener, args: ['keyup', ['$event'],] }],
        onPaste: [{ type: HostListener, args: ['paste', ['$event'],] }],
        onInputChanged: [{ type: HostListener, args: ['input', ['$event'],] }],
        onFocus: [{ type: HostListener, args: ['focus', ['$event.target.value'],] }],
        onBlur: [{ type: HostListener, args: ['blur', ['$event.target.value'],] }]
    };
    return IgxMaskDirective;
}());
/**
 * @hidden
 */
var IgxMaskModule = /** @class */ (function () {
    function IgxMaskModule() {
    }
    IgxMaskModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxMaskDirective],
                    exports: [IgxMaskDirective],
                    imports: [CommonModule]
                },] }
    ];
    return IgxMaskModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var RadioLabelPosition = {
    BEFORE: 'before',
    AFTER: 'after',
};
/** @type {?} */
var nextId = 0;
/** @type {?} */
var noop$1 = function () { };
/**
 * **Ignite UI for Angular Radio Button** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/radio_button.html)
 *
 * The Ignite UI Radio Button allows the user to select a single option from an available set of options that are listed side by side.
 *
 * Example:
 * ```html
 * <igx-radio>
 *   Simple radio button
 * </igx-radio>
 * ```
 */
var IgxRadioComponent = /** @class */ (function () {
    function IgxRadioComponent() {
        /**
         * Sets/gets the `id` of the radio component.
         * If not set, the `id` of the first radio component will be `"igx-radio-0"`.
         * ```html
         * <igx-radio id = "my-first-radio"></igx-radio>
         * ```
         * ```typescript
         * let radioId =  this.radio.id;
         * ```
         * \@memberof IgxRadioComponent
         */
        this.id = "igx-radio-" + nextId++;
        /**
         * Sets/gets the id of the `label` element in the radio component.
         * If not set, the id of the `label` in the first radio component will be `"igx-radio-0-label"`.
         * ```html
         * <igx-radio labelId = "Label1"></igx-radio>
         * ```
         * ```typescript
         * let labelId =  this.radio.labelId;
         * ```
         * \@memberof IgxRadioComponent
         */
        this.labelId = this.id + "-label";
        /**
         * Sets/gets the position of the `label` in the radio component.
         * If not set, `labelPosition` will have value `"after"`.
         * ```html
         * <igx-radio labelPosition = "before"></igx-radio>
         * ```
         * ```typescript
         * let labelPosition =  this.radio.labelPosition;
         * ```
         * \@memberof IgxRadioComponent
         */
        this.labelPosition = 'after';
        /**
         * Sets the value of the `tabindex` attribute.
         * ```html
         * <igx-radio [tabindex] = "1"></igx-radio>
         * ```
         * ```typescript
         * let tabIndex =  this.radio.tabindex;
         * ```
         * \@memberof IgxRadioComponent
         */
        this.tabindex = null;
        /**
         * Enables/disables the ripple effect on the radio button..
         * If not set, the `disableRipple` will have value `false`.
         * ```html
         * <igx-radio [disableRipple] = "true"></igx-radio>
         * ```
         * ```typescript
         * let isDisabledRipple =  this.radio.disableRipple;
         * ```
         * \@memberof IgxRadioComponent
         */
        this.disableRipple = false;
        /**
         * Sets/gets whether the radio button is required.
         * If not set, `required` will have value `false`.
         * ```html
         * <igx-radio [required] = "true"></igx-radio>
         * ```
         * ```typescript
         * let isRequired =  this.radio.required;
         * ```
         * \@memberof IgxRadioComponent
         */
        this.required = false;
        /**
         * Sets/gets the `aria-labelledby` attribute of the radio component.
         * If not set, the `aria-labelledby` will be equal to the value of `labelId` attribute.
         * ```html
         * <igx-radio aria-labelledby = "Radio1"></igx-radio>
         * ```
         * ```typescript
         * let ariaLabelledBy = this.radio.ariaLabelledBy;
         * ```
         * \@memberof IgxRadioComponent
         */
        this.ariaLabelledBy = this.labelId;
        /**
         * Sets/gets the `aria-label` attribute of the radio component.
         * ```html
         * <igx-radio aria-label = "Radio1"></igx-radio>
         * ```
         * ```typescript
         * let ariaLabel =  this.radio.ariaLabel;
         * ```
         * \@memberof IgxRadioComponent
         */
        this.ariaLabel = null;
        /**
         * An event that is emitted after the radio `value` is changed.
         * Provides references to the `IgxRadioComponent` and the `value` property as event arguments.
         * \@memberof IgxRadioComponent
         */
        this.change = new EventEmitter();
        /**
         * Returns the class of the radio component.
         * ```typescript
         * let radioClass = this.radio.cssClass;
         * ```
         * \@memberof IgxRadioComponent
         */
        this.cssClass = 'igx-radio';
        /**
         * Sets/gets  the `checked` attribute.
         * Default value is `false`.
         * ```html
         * <igx-radio [checked] = "true"></igx-radio>
         * ```
         * ```typescript
         * let isChecked =  this.radio.checked;
         * ```
         * \@memberof IgxRadioComponent
         */
        this.checked = false;
        /**
         * Sets/gets  the `disabled` attribute.
         * Default value is `false`.
         * ```html
         * <igx-radio [disabled] = "true"></igx-radio>
         * ```
         * ```typescript
         * let isDisabled =  this.radio.disabled;
         * ```
         * \@memberof IgxRadioComponent
         */
        this.disabled = false;
        /**
         * Sets/gets whether the radio component is on focus.
         * Default value is `false`.
         * ```typescript
         * this.radio.focus = true;
         * ```
         * ```typescript
         * let isFocused =  this.radio.focused;
         * ```
         * \@memberof IgxRadioComponent
         */
        this.focused = false;
        /**
         * @hidden
         */
        this.inputId = this.id + "-input";
        /**
         * @hidden
         */
        this._value = null;
        /**
         * @hidden
         */
        this._onTouchedCallback = noop$1;
        /**
         * @hidden
         */
        this._onChangeCallback = noop$1;
    }
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxRadioComponent.prototype._onRadioChange = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.stopPropagation();
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxRadioComponent.prototype._onRadioClick = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.stopPropagation();
        this.select();
        if (isIE()) {
            this.nativeRadio.nativeElement.blur();
        }
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxRadioComponent.prototype._onLabelClick = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.select();
    };
    /**
     * Selects the current radio button.
     * ```typescript
     * this.radio.select();
     * ```
     * @memberof IgxRadioComponent
     */
    /**
     * Selects the current radio button.
     * ```typescript
     * this.radio.select();
     * ```
     * \@memberof IgxRadioComponent
     * @return {?}
     */
    IgxRadioComponent.prototype.select = /**
     * Selects the current radio button.
     * ```typescript
     * this.radio.select();
     * ```
     * \@memberof IgxRadioComponent
     * @return {?}
     */
    function () {
        if (this.disabled) {
            return;
        }
        this.checked = true;
        this.focused = false;
        this.change.emit({ value: this.value, radio: this });
        this._onChangeCallback(this.value);
    };
    /**
     * Checks whether the provided value is consistent to the current radio button.
     * If it is, the checked attribute will have value `true`;
     * ```typescript
     * this.radio.writeValue('radioButtonValue');
     * ```
     */
    /**
     * Checks whether the provided value is consistent to the current radio button.
     * If it is, the checked attribute will have value `true`;
     * ```typescript
     * this.radio.writeValue('radioButtonValue');
     * ```
     * @param {?} value
     * @return {?}
     */
    IgxRadioComponent.prototype.writeValue = /**
     * Checks whether the provided value is consistent to the current radio button.
     * If it is, the checked attribute will have value `true`;
     * ```typescript
     * this.radio.writeValue('radioButtonValue');
     * ```
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this._value = value;
        this.checked = (this._value === this.value);
    };
    /** @hidden */
    /**
     * @hidden
     * @return {?}
     */
    IgxRadioComponent.prototype.getEditElement = /**
     * @hidden
     * @return {?}
     */
    function () {
        return this.nativeRadio.nativeElement;
    };
    Object.defineProperty(IgxRadioComponent.prototype, "labelClass", {
        /**
         *@hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            switch (this.labelPosition) {
                case RadioLabelPosition.BEFORE:
                    return this.cssClass + "__label--before";
                case RadioLabelPosition.AFTER:
                default:
                    return this.cssClass + "__label";
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxRadioComponent.prototype.onFocus = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.focused = true;
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxRadioComponent.prototype.onBlur = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.focused = false;
        this._onTouchedCallback();
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    IgxRadioComponent.prototype.registerOnChange = /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._onChangeCallback = fn; };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    IgxRadioComponent.prototype.registerOnTouched = /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._onTouchedCallback = fn; };
    IgxRadioComponent.decorators = [
        { type: Component, args: [{
                    providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: IgxRadioComponent, multi: true }],
                    selector: 'igx-radio',
                    template: "<input #radio class=\"igx-radio__input\" type=\"radio\"\n    [id]=\"inputId\"\n    [name]=\"name\"\n    [value]=\"value\"\n    [tabindex]=\"tabindex\"\n    [disabled]=\"disabled\"\n    [checked]=\"checked\"\n    [required]=\"required\"\n    [attr.aria-checked]=\"checked\"\n    [attr.aria-labelledby]=\"ariaLabelledBy\"\n    [attr.aria-label]=\"ariaLabel\"\n    (click)=\"_onRadioClick($event)\"\n    (change)=\"_onRadioChange($event)\"\n    (focus)=\"onFocus($event)\"\n    (blur)=\"onBlur($event)\" />\n\n<label #nativeLabel class=\"igx-radio__composite\" igxRipple\n    igxRippleTarget=\".igx-radio__ripple\"\n    [igxRippleDisabled]=\"disableRipple\"\n    [igxRippleCentered]=\"true\"\n    [igxRippleDuration]=\"300\"\n    [for]=\"inputId\">\n    <div class=\"igx-radio__ripple\"></div>\n</label>\n\n<span #placeholderLabel role=\"label\"\n    [id]=\"labelId\"\n    [class]=\"labelClass\"\n    (click)=\"_onLabelClick()\">\n    <ng-content></ng-content>\n</span>\n"
                }] }
    ];
    /** @nocollapse */
    IgxRadioComponent.ctorParameters = function () { return []; };
    IgxRadioComponent.propDecorators = {
        nativeRadio: [{ type: ViewChild, args: ['radio',] }],
        nativeLabel: [{ type: ViewChild, args: ['nativeLabel',] }],
        placeholderLabel: [{ type: ViewChild, args: ['placeholderLabel',] }],
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        labelId: [{ type: Input }],
        labelPosition: [{ type: Input }],
        value: [{ type: Input }],
        name: [{ type: Input }],
        tabindex: [{ type: Input }],
        disableRipple: [{ type: Input }],
        required: [{ type: Input }],
        ariaLabelledBy: [{ type: Input, args: ['aria-labelledby',] }],
        ariaLabel: [{ type: Input, args: ['aria-label',] }],
        change: [{ type: Output }],
        cssClass: [{ type: HostBinding, args: ['class.igx-radio',] }],
        checked: [{ type: HostBinding, args: ['class.igx-radio--checked',] }, { type: Input }],
        disabled: [{ type: HostBinding, args: ['class.igx-radio--disabled',] }, { type: Input }],
        focused: [{ type: HostBinding, args: ['class.igx-radio--focused',] }]
    };
    return IgxRadioComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxRippleDirective = /** @class */ (function () {
    function IgxRippleDirective(builder, elementRef, renderer, zone) {
        this.builder = builder;
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.zone = zone;
        /**
         * Sets/gets the ripple target.
         * ```html
         * <div  #rippleContainer class="div-1" igxRipple [igxRippleTarget] = "'.div-1'"></div>
         * ```
         * ```typescript
         * \@ViewChild('rippleContainer', {read: IgxRippleDirective})
         * public ripple: IgxRippleDirective;
         * let rippleTarget = this.ripple.rippleTarget;
         * ```
         * Can set the ripple to activate on a child element inside the parent where igxRipple is defined.
         * ```html
         * <div #rippleContainer [igxRippleTarget] = "'#child"'>
         *  <button id="child">Click</button>
         * </div>
         * ```
         * \@memberof IgxRippleDirective
         */
        this.rippleTarget = '';
        /**
         * Sets/gets the ripple duration(in milliseconds).
         * Default value is `600`.
         * ```html
         * <button #rippleContainer igxRipple [igxRippleDuration] = "800"></button>
         * ```
         * ```typescript
         * \@ViewChild('rippleContainer', {read: IgxRippleDirective})
         * public ripple: IgxRippleDirective;
         * let rippleDuration = this.ripple.rippleDuration;
         * ```
         * \@memberof IgxRippleDirective
         */
        this.rippleDuration = 600;
        /**
         * Sets/gets whether the ripple is disabled.
         * Default value is `false`.
         * ```html
         * <button #rippleContainer igxRipple [igxRippleDisabled] = "true"></button>
         * ```
         * ```typescript
         * \@ViewChild('rippleContainer', {read: IgxRippleDirective})
         * public ripple: IgxRippleDirective;
         * let isRippleDisabled = this.ripple.rippleDisabled;
         * ```
         * \@memberof IgxRippleDirective
         */
        this.rippleDisabled = false;
        this.rippleElementClass = 'igx-ripple__inner';
        this.rippleHostClass = 'igx-ripple';
        this._centered = false;
        this.animationQueue = [];
    }
    Object.defineProperty(IgxRippleDirective.prototype, "centered", {
        /**
         * Enables/disables the ripple to be centered.
         * ```html
         * <button #rippleContainer igxRipple [igxRippleCentered] = "true"></button>
         * ```
         * @memberof IgxRippleDirective
         */
        set: /**
         * Enables/disables the ripple to be centered.
         * ```html
         * <button #rippleContainer igxRipple [igxRippleCentered] = "true"></button>
         * ```
         * \@memberof IgxRippleDirective
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._centered = value || this.centered;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxRippleDirective.prototype, "nativeElement", {
        get: /**
         * @protected
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxRippleDirective.prototype.onMouseDown = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        this.zone.runOutsideAngular(function () { return _this._ripple(event); });
    };
    /**
     * @private
     * @param {?} rippleElement
     * @param {?} styleParams
     * @return {?}
     */
    IgxRippleDirective.prototype.setStyles = /**
     * @private
     * @param {?} rippleElement
     * @param {?} styleParams
     * @return {?}
     */
    function (rippleElement, styleParams) {
        this.renderer.addClass(rippleElement, this.rippleElementClass);
        this.renderer.setStyle(rippleElement, 'width', styleParams.radius + "px");
        this.renderer.setStyle(rippleElement, 'height', styleParams.radius + "px");
        this.renderer.setStyle(rippleElement, 'top', styleParams.top + "px");
        this.renderer.setStyle(rippleElement, 'left', styleParams.left + "px");
        if (this.rippleColor) {
            this.renderer.setStyle(rippleElement, 'background', this.rippleColor);
        }
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    IgxRippleDirective.prototype._ripple = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        if (this.rippleDisabled) {
            return;
        }
        /** @type {?} */
        var target = (this.rippleTarget ? this.nativeElement.querySelector(this.rippleTarget) || this.nativeElement : this.nativeElement);
        /** @type {?} */
        var rectBounds = target.getBoundingClientRect();
        /** @type {?} */
        var radius = Math.max(rectBounds.width, rectBounds.height);
        /** @type {?} */
        var left = event.clientX - rectBounds.left - radius / 2;
        /** @type {?} */
        var top = event.clientY - rectBounds.top - radius / 2;
        if (this._centered) {
            left = top = 0;
        }
        /** @type {?} */
        var dimensions = {
            radius: radius,
            top: top,
            left: left
        };
        /** @type {?} */
        var rippleElement = this.renderer.createElement('span');
        this.setStyles(rippleElement, dimensions);
        this.renderer.addClass(target, this.rippleHostClass);
        this.renderer.appendChild(target, rippleElement);
        /** @type {?} */
        var animation$$1 = this.builder.build([
            style({ opacity: 0.5, transform: 'scale(.3)' }),
            animate(this.rippleDuration, style({ opacity: 0, transform: 'scale(2)' }))
        ]).create(rippleElement);
        this.animationQueue.push(animation$$1);
        animation$$1.onDone(function () {
            _this.animationQueue.splice(_this.animationQueue.indexOf(animation$$1), 1);
            target.removeChild(rippleElement);
            if (_this.animationQueue.length < 1) {
                _this.renderer.removeClass(target, _this.rippleHostClass);
            }
        });
        animation$$1.play();
    };
    IgxRippleDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxRipple]'
                },] }
    ];
    /** @nocollapse */
    IgxRippleDirective.ctorParameters = function () { return [
        { type: AnimationBuilder },
        { type: ElementRef },
        { type: Renderer2 },
        { type: NgZone }
    ]; };
    IgxRippleDirective.propDecorators = {
        rippleTarget: [{ type: Input, args: ['igxRippleTarget',] }],
        rippleColor: [{ type: Input, args: ['igxRipple',] }],
        rippleDuration: [{ type: Input, args: ['igxRippleDuration',] }],
        centered: [{ type: Input, args: ['igxRippleCentered',] }],
        rippleDisabled: [{ type: Input, args: ['igxRippleDisabled',] }],
        onMouseDown: [{ type: HostListener, args: ['mousedown', ['$event'],] }]
    };
    return IgxRippleDirective;
}());
/**
 * @hidden
 */
var IgxRippleModule = /** @class */ (function () {
    function IgxRippleModule() {
    }
    IgxRippleModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxRippleDirective],
                    exports: [IgxRippleDirective]
                },] }
    ];
    return IgxRippleModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var noop$2 = function () { };
/** @type {?} */
var nextId$1 = 0;
/**
 * **Ignite UI for Angular Radio Group** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/radio_button.html)
 *
 * The Ignite UI Radio Group allows the user to select a single option from an available set of options that are listed side by side.
 *
 * Example:
 * ```html
 * <igx-radio-group name="radioGroup">
 *   <igx-radio *ngFor="let item of ['Foo', 'Bar', 'Baz']" value="{{item}}">
 *      {{item}}
 *   </igx-radio>
 * </igx-radio-group>
 * ```
 */
var IgxRadioGroupDirective = /** @class */ (function () {
    function IgxRadioGroupDirective() {
        /**
         * An event that is emitted after the radio group `value` is changed.
         * Provides references to the selected `IgxRadioComponent` and the `value` property as event arguments.
         * \@memberof IgxRadioGroupDirective
         */
        this.change = new EventEmitter();
        /**
         * @hidden
         */
        this.cssClass = 'igx-radio-group';
        /**
         * @hidden
         */
        this._onChangeCallback = noop$2;
        /**
         * @hidden
         */
        this._name = "igx-radio-group-" + nextId$1++;
        /**
         * @hidden
         */
        this._value = null;
        /**
         * @hidden
         */
        this._selected = null;
        /**
         * @hidden
         */
        this._isInitialized = false;
        /**
         * @hidden
         */
        this._labelPosition = 'after';
        /**
         * @hidden
         */
        this._disabled = false;
        /**
         * @hidden
         */
        this._required = false;
        /**
         * @hidden
         */
        this.destroy$ = new Subject();
    }
    Object.defineProperty(IgxRadioGroupDirective.prototype, "value", {
        /**
         * Sets/gets the `value` attribute.
         * ```html
         * <igx-radio-group [value] = "'radioButtonValue'"></igx-radio-group>
         * ```
         * ```typescript
         * let value =  this.radioGroup.value;
         * ```
         * @memberof IgxRadioGroupDirective
         */
        get: /**
         * Sets/gets the `value` attribute.
         * ```html
         * <igx-radio-group [value] = "'radioButtonValue'"></igx-radio-group>
         * ```
         * ```typescript
         * let value =  this.radioGroup.value;
         * ```
         * \@memberof IgxRadioGroupDirective
         * @return {?}
         */
        function () { return this._value; },
        set: /**
         * @param {?} newValue
         * @return {?}
         */
        function (newValue) {
            if (this._value !== newValue) {
                this._value = newValue;
                this._selectRadioButton();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxRadioGroupDirective.prototype, "name", {
        /**
         * Sets/gets the `name` attribute of the radio group component. All child radio buttons inherits this name.
         * ```html
         * <igx-radio-group name = "Radio1"></igx-radio-group>
         *  ```
         * ```typescript
         * let name =  this.radioGroup.name;
         * ```
         * @memberof IgxRadioGroupDirective
         */
        get: /**
         * Sets/gets the `name` attribute of the radio group component. All child radio buttons inherits this name.
         * ```html
         * <igx-radio-group name = "Radio1"></igx-radio-group>
         *  ```
         * ```typescript
         * let name =  this.radioGroup.name;
         * ```
         * \@memberof IgxRadioGroupDirective
         * @return {?}
         */
        function () { return this._name; },
        set: /**
         * @param {?} newValue
         * @return {?}
         */
        function (newValue) {
            if (this._name !== newValue) {
                this._name = newValue;
                this._setRadioButtonNames();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxRadioGroupDirective.prototype, "required", {
        /**
         * Sets/gets whether the radio group is required.
         * If not set, `required` will have value `false`.
         * ```html
         * <igx-radio-group [required] = "true"></igx-radio-group>
         * ```
         * ```typescript
         * let isRequired =  this.radioGroup.required;
         * ```
         * @memberof IgxRadioGroupDirective
         */
        get: /**
         * Sets/gets whether the radio group is required.
         * If not set, `required` will have value `false`.
         * ```html
         * <igx-radio-group [required] = "true"></igx-radio-group>
         * ```
         * ```typescript
         * let isRequired =  this.radioGroup.required;
         * ```
         * \@memberof IgxRadioGroupDirective
         * @return {?}
         */
        function () { return this._required; },
        set: /**
         * @param {?} newValue
         * @return {?}
         */
        function (newValue) {
            if (this._required !== newValue) {
                this._required = newValue;
                this._setRadioButtonsRequired();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxRadioGroupDirective.prototype, "disabled", {
        /**
         * An @Input property that allows you to disable the radio group. By default it's false.
         * ```html
         * <igx-radio-group [disabled]="true"></igx-radio-group>
         * ```
         * @memberof IgxRadioGroupDirective
         */
        get: /**
         * An \@Input property that allows you to disable the radio group. By default it's false.
         * ```html
         * <igx-radio-group [disabled]="true"></igx-radio-group>
         * ```
         * \@memberof IgxRadioGroupDirective
         * @return {?}
         */
        function () { return this._disabled; },
        set: /**
         * @param {?} newValue
         * @return {?}
         */
        function (newValue) {
            if (this._disabled !== newValue) {
                this._disabled = newValue;
                this._disableRadioButtons();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxRadioGroupDirective.prototype, "labelPosition", {
        /**
         * Sets/gets the position of the `label` in the child radio buttons.
         * If not set, `labelPosition` will have value `"after"`.
         * ```html
         * <igx-radio-group labelPosition = "before"></igx-radio-group>
         * ```
         * ```typescript
         * let labelPosition =  this.radioGroup.labelPosition;
         * ```
         * @memberof IgxRadioGroupDirective
         */
        get: /**
         * Sets/gets the position of the `label` in the child radio buttons.
         * If not set, `labelPosition` will have value `"after"`.
         * ```html
         * <igx-radio-group labelPosition = "before"></igx-radio-group>
         * ```
         * ```typescript
         * let labelPosition =  this.radioGroup.labelPosition;
         * ```
         * \@memberof IgxRadioGroupDirective
         * @return {?}
         */
        function () { return this._labelPosition; },
        set: /**
         * @param {?} newValue
         * @return {?}
         */
        function (newValue) {
            if (this._labelPosition !== newValue) {
                this._labelPosition = newValue === RadioLabelPosition.BEFORE ? RadioLabelPosition.BEFORE : RadioLabelPosition.AFTER;
                this._setRadioButtonLabelPosition();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxRadioGroupDirective.prototype, "selected", {
        /**
         * Sets/gets the selected child radio button.
         * ```typescript
         * let selectedButton = this.radioGroup.selected;
         * this.radioGroup.selected = selectedButton;
         * ```
         * @memberof IgxRadioGroupDirective
         */
        get: /**
         * Sets/gets the selected child radio button.
         * ```typescript
         * let selectedButton = this.radioGroup.selected;
         * this.radioGroup.selected = selectedButton;
         * ```
         * \@memberof IgxRadioGroupDirective
         * @return {?}
         */
        function () { return this._selected; },
        set: /**
         * @param {?} selected
         * @return {?}
         */
        function (selected) {
            if (this._selected !== selected) {
                this._selected = selected;
                this.value = selected ? selected.value : null;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    IgxRadioGroupDirective.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // The initial value can possibly be set by NgModel and it is possible that
        // the OnInit of the NgModel occurs after the OnInit of this class.
        this._isInitialized = true;
        setTimeout(function () { _this._initRadioButtons(); });
    };
    /**
     * Checks whether the provided value is consistent to the current radio button.
     * If it is, the checked attribute will have value `true` and selected property will contain the selected `IgxRadioComponent`.
     * ```typescript
     * this.radioGroup.writeValue('radioButtonValue');
     * ```
     */
    /**
     * Checks whether the provided value is consistent to the current radio button.
     * If it is, the checked attribute will have value `true` and selected property will contain the selected `IgxRadioComponent`.
     * ```typescript
     * this.radioGroup.writeValue('radioButtonValue');
     * ```
     * @param {?} value
     * @return {?}
     */
    IgxRadioGroupDirective.prototype.writeValue = /**
     * Checks whether the provided value is consistent to the current radio button.
     * If it is, the checked attribute will have value `true` and selected property will contain the selected `IgxRadioComponent`.
     * ```typescript
     * this.radioGroup.writeValue('radioButtonValue');
     * ```
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.value = value;
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    IgxRadioGroupDirective.prototype.registerOnChange = /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._onChangeCallback = fn; };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    IgxRadioGroupDirective.prototype.registerOnTouched = /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        if (this.radioButtons) {
            this.radioButtons.forEach(function (button) {
                button.registerOnTouched(fn);
            });
        }
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxRadioGroupDirective.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.destroy$.next(true);
        this.destroy$.complete();
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @private
     * @return {?}
     */
    IgxRadioGroupDirective.prototype._initRadioButtons = /**
     * @hidden
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.radioButtons) {
            this.radioButtons.forEach(function (button) {
                button.name = _this._name;
                button.labelPosition = _this._labelPosition;
                button.disabled = _this._disabled;
                button.required = _this._required;
                if (_this._value && button.value === _this._value) {
                    button.checked = true;
                    _this._selected = button;
                }
                button.change.pipe(takeUntil(_this.destroy$)).subscribe(function (ev) { return _this._selectedRadioButtonChanged(ev); });
            });
        }
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @private
     * @param {?} args
     * @return {?}
     */
    IgxRadioGroupDirective.prototype._selectedRadioButtonChanged = /**
     * @hidden
     * @private
     * @param {?} args
     * @return {?}
     */
    function (args) {
        if (this._selected !== args.radio) {
            if (this._selected) {
                this._selected.checked = false;
            }
            this._selected = args.radio;
        }
        this._value = args.value;
        if (this._isInitialized) {
            this.change.emit(args);
            this._onChangeCallback(this.value);
        }
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @private
     * @return {?}
     */
    IgxRadioGroupDirective.prototype._setRadioButtonNames = /**
     * @hidden
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.radioButtons) {
            this.radioButtons.forEach(function (button) {
                button.name = _this._name;
            });
        }
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @private
     * @return {?}
     */
    IgxRadioGroupDirective.prototype._selectRadioButton = /**
     * @hidden
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.radioButtons) {
            this.radioButtons.forEach(function (button) {
                if (!_this._value) {
                    // no value - uncheck all radio buttons
                    if (button.checked) {
                        button.checked = false;
                    }
                }
                else {
                    if (_this._value === button.value) {
                        // selected button
                        if (_this._selected !== button) {
                            _this._selected = button;
                        }
                        if (!button.checked) {
                            button.select();
                        }
                    }
                    else {
                        // non-selected button
                        if (button.checked) {
                            button.checked = false;
                        }
                    }
                }
            });
        }
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @private
     * @return {?}
     */
    IgxRadioGroupDirective.prototype._setRadioButtonLabelPosition = /**
     * @hidden
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.radioButtons) {
            this.radioButtons.forEach(function (button) {
                button.labelPosition = _this._labelPosition;
            });
        }
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @private
     * @return {?}
     */
    IgxRadioGroupDirective.prototype._disableRadioButtons = /**
     * @hidden
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.radioButtons) {
            this.radioButtons.forEach(function (button) {
                button.disabled = _this._disabled;
            });
        }
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @private
     * @return {?}
     */
    IgxRadioGroupDirective.prototype._setRadioButtonsRequired = /**
     * @hidden
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.radioButtons) {
            this.radioButtons.forEach(function (button) {
                button.required = _this._required;
            });
        }
    };
    IgxRadioGroupDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'igx-radio-group, [igxRadioGroup]',
                    providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: IgxRadioGroupDirective, multi: true }]
                },] }
    ];
    IgxRadioGroupDirective.propDecorators = {
        radioButtons: [{ type: ContentChildren, args: [IgxRadioComponent,] }],
        value: [{ type: Input }],
        name: [{ type: Input }],
        required: [{ type: Input }],
        disabled: [{ type: Input }],
        labelPosition: [{ type: Input }],
        selected: [{ type: Input }],
        change: [{ type: Output }],
        cssClass: [{ type: HostBinding, args: ['class.igx-radio-group',] }]
    };
    return IgxRadioGroupDirective;
}());
/**
 * @hidden
 */
var IgxRadioModule = /** @class */ (function () {
    function IgxRadioModule() {
    }
    IgxRadioModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxRadioGroupDirective, IgxRadioComponent],
                    exports: [IgxRadioGroupDirective, IgxRadioComponent],
                    imports: [IgxRippleModule]
                },] }
    ];
    return IgxRadioModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxTextHighlightDirective = /** @class */ (function () {
    function IgxTextHighlightDirective(element, renderer) {
        var _this = this;
        this.element = element;
        this.renderer = renderer;
        this._div = null;
        this._observer = null;
        this._nodeWasRemoved = false;
        this._forceEvaluation = false;
        this._activeElementIndex = -1;
        /**
         * Identifies the highlight within a unique group.
         * This allows it to have several different highlight groups,
         * with each of them having their own active highlight.
         *
         * ```html
         * <div
         *   igxTextHighlight
         *   [groupName]="myGroupName">
         * </div>
         * ```
         */
        this.groupName = '';
        this._value = '';
        this.destroy$ = new Subject();
        IgxTextHighlightDirective.onActiveElementChanged.pipe(takeUntil(this.destroy$)).subscribe(function (groupName) {
            if (_this.groupName === groupName) {
                if (_this._activeElementIndex !== -1) {
                    _this.deactivate();
                }
                _this.activateIfNecessary();
            }
        });
    }
    Object.defineProperty(IgxTextHighlightDirective.prototype, "value", {
        /**
         * The underlying value of the element that will be highlighted.
         *
         * ```typescript
         * // get
         * const elementValue = this.textHighlight.value;
         * ```
         *
         * ```html
         * <!--set-->
         * <div
         *   igxTextHighlight
         *   [value]="newValue">
         * </div>
         * ```
         */
        get: /**
         * The underlying value of the element that will be highlighted.
         *
         * ```typescript
         * // get
         * const elementValue = this.textHighlight.value;
         * ```
         *
         * ```html
         * <!--set-->
         * <div
         *   igxTextHighlight
         *   [value]="newValue">
         * </div>
         * ```
         * @return {?}
         */
        function () {
            return this._value;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value === undefined || value === null) {
                this._value = '';
            }
            else {
                this._value = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTextHighlightDirective.prototype, "lastSearchInfo", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._lastSearchInfo;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Activates the highlight at a given index.
     * (if such index exists)
     */
    /**
     * Activates the highlight at a given index.
     * (if such index exists)
     * @param {?} groupName
     * @param {?} highlight
     * @return {?}
     */
    IgxTextHighlightDirective.setActiveHighlight = /**
     * Activates the highlight at a given index.
     * (if such index exists)
     * @param {?} groupName
     * @param {?} highlight
     * @return {?}
     */
    function (groupName, highlight) {
        IgxTextHighlightDirective.highlightGroupsMap.set(groupName, highlight);
        IgxTextHighlightDirective.onActiveElementChanged.emit(groupName);
    };
    /**
     * Clears any existing highlight.
     */
    /**
     * Clears any existing highlight.
     * @param {?} groupName
     * @return {?}
     */
    IgxTextHighlightDirective.clearActiveHighlight = /**
     * Clears any existing highlight.
     * @param {?} groupName
     * @return {?}
     */
    function (groupName) {
        IgxTextHighlightDirective.highlightGroupsMap.set(groupName, {
            index: -1
        });
        IgxTextHighlightDirective.onActiveElementChanged.emit(groupName);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTextHighlightDirective.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.clearHighlight();
        if (this._observer !== null) {
            this._observer.disconnect();
        }
        this.destroy$.next(true);
        this.destroy$.complete();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} changes
     * @return {?}
     */
    IgxTextHighlightDirective.prototype.ngOnChanges = /**
     * @hidden
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes.value && !changes.value.firstChange) {
            this._valueChanged = true;
        }
        else if ((changes.row !== undefined && !changes.row.firstChange) ||
            (changes.column !== undefined && !changes.column.firstChange) ||
            (changes.page !== undefined && !changes.page.firstChange)) {
            if (this._activeElementIndex !== -1) {
                this.deactivate();
            }
            this.activateIfNecessary();
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTextHighlightDirective.prototype.ngAfterViewInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.parentElement = this.renderer.parentNode(this.element.nativeElement);
        if (IgxTextHighlightDirective.highlightGroupsMap.has(this.groupName) === false) {
            IgxTextHighlightDirective.highlightGroupsMap.set(this.groupName, {
                index: -1
            });
        }
        this._lastSearchInfo = {
            searchedText: '',
            content: this.value,
            matchCount: 0,
            caseSensitive: false,
            exactMatch: false
        };
        this._container = this.parentElement.firstElementChild;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTextHighlightDirective.prototype.ngAfterViewChecked = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (this._valueChanged) {
            this.highlight(this._lastSearchInfo.searchedText, this._lastSearchInfo.caseSensitive, this._lastSearchInfo.exactMatch);
            this.activateIfNecessary();
            this._valueChanged = false;
        }
    };
    /**
     * Clears the existing highlight and highlights the searched text.
     * Returns how many times the element contains the searched text.
     */
    /**
     * Clears the existing highlight and highlights the searched text.
     * Returns how many times the element contains the searched text.
     * @param {?} text
     * @param {?=} caseSensitive
     * @param {?=} exactMatch
     * @return {?}
     */
    IgxTextHighlightDirective.prototype.highlight = /**
     * Clears the existing highlight and highlights the searched text.
     * Returns how many times the element contains the searched text.
     * @param {?} text
     * @param {?=} caseSensitive
     * @param {?=} exactMatch
     * @return {?}
     */
    function (text, caseSensitive, exactMatch) {
        /** @type {?} */
        var caseSensitiveResolved = caseSensitive ? true : false;
        /** @type {?} */
        var exactMatchResolved = exactMatch ? true : false;
        if (this.searchNeedsEvaluation(text, caseSensitiveResolved, exactMatchResolved)) {
            this._lastSearchInfo.searchedText = text;
            this._lastSearchInfo.caseSensitive = caseSensitiveResolved;
            this._lastSearchInfo.exactMatch = exactMatchResolved;
            this._lastSearchInfo.content = this.value;
            if (text === '' || text === undefined || text === null) {
                this.clearHighlight();
            }
            else {
                this.clearChildElements(true);
                this._lastSearchInfo.matchCount = this.getHighlightedText(text, caseSensitive, exactMatch);
            }
        }
        else if (this._nodeWasRemoved) {
            this._lastSearchInfo.searchedText = text;
            this._lastSearchInfo.caseSensitive = caseSensitiveResolved;
            this._lastSearchInfo.exactMatch = exactMatchResolved;
        }
        return this._lastSearchInfo.matchCount;
    };
    /**
     * Clears any existing highlight.
     */
    /**
     * Clears any existing highlight.
     * @return {?}
     */
    IgxTextHighlightDirective.prototype.clearHighlight = /**
     * Clears any existing highlight.
     * @return {?}
     */
    function () {
        this.clearChildElements(false);
        this._lastSearchInfo.searchedText = '';
        this._lastSearchInfo.matchCount = 0;
    };
    /**
     * Activates the highlight if it is on the currently active row, column and page.
     */
    /**
     * Activates the highlight if it is on the currently active row, column and page.
     * @return {?}
     */
    IgxTextHighlightDirective.prototype.activateIfNecessary = /**
     * Activates the highlight if it is on the currently active row, column and page.
     * @return {?}
     */
    function () {
        /** @type {?} */
        var group = IgxTextHighlightDirective.highlightGroupsMap.get(this.groupName);
        /** @type {?} */
        var column = group.columnIndex === undefined ? group.column : group.columnIndex;
        /** @type {?} */
        var row = group.rowIndex === undefined ? group.row : group.rowIndex;
        if (column === this.column && row === this.row && group.page === this.page) {
            this.activate(group.index);
        }
    };
    /**
     * Attaches a MutationObserver to the parentElement and watches for when the container element is removed/readded to the DOM.
     * Should be used only when necessary as using many observers may lead to performance degradation.
     */
    /**
     * Attaches a MutationObserver to the parentElement and watches for when the container element is removed/readded to the DOM.
     * Should be used only when necessary as using many observers may lead to performance degradation.
     * @return {?}
     */
    IgxTextHighlightDirective.prototype.observe = /**
     * Attaches a MutationObserver to the parentElement and watches for when the container element is removed/readded to the DOM.
     * Should be used only when necessary as using many observers may lead to performance degradation.
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._observer === null) {
            /** @type {?} */
            var callback = function (mutationList) {
                mutationList.forEach(function (mutation) {
                    /** @type {?} */
                    var removedNodes = Array.from(mutation.removedNodes);
                    removedNodes.forEach(function (n) {
                        if (n === _this._container) {
                            _this._nodeWasRemoved = true;
                            _this.clearChildElements(false);
                        }
                    });
                    /** @type {?} */
                    var addedNodes = Array.from(mutation.addedNodes);
                    addedNodes.forEach(function (n) {
                        if (n === _this.parentElement.firstElementChild && _this._nodeWasRemoved) {
                            _this._container = _this.parentElement.firstElementChild;
                            _this._nodeWasRemoved = false;
                            _this._forceEvaluation = true;
                            _this.highlight(_this._lastSearchInfo.searchedText, _this._lastSearchInfo.caseSensitive, _this._lastSearchInfo.exactMatch);
                            _this._forceEvaluation = false;
                            _this.activateIfNecessary();
                            _this._observer.disconnect();
                            _this._observer = null;
                        }
                    });
                });
            };
            this._observer = new MutationObserver(callback);
            this._observer.observe(this.parentElement, { childList: true });
        }
    };
    /**
     * @private
     * @param {?} index
     * @return {?}
     */
    IgxTextHighlightDirective.prototype.activate = /**
     * @private
     * @param {?} index
     * @return {?}
     */
    function (index) {
        this.deactivate();
        if (this._div !== null) {
            /** @type {?} */
            var spans = this._div.querySelectorAll('span');
            this._activeElementIndex = index;
            if (spans.length <= index) {
                return;
            }
            /** @type {?} */
            var elementToActivate = spans[index];
            this.renderer.addClass(elementToActivate, this.activeCssClass);
            this.renderer.setAttribute(elementToActivate, 'style', 'background:orange;color:black');
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxTextHighlightDirective.prototype.deactivate = /**
     * @private
     * @return {?}
     */
    function () {
        if (this._activeElementIndex === -1) {
            return;
        }
        /** @type {?} */
        var spans = this._div.querySelectorAll('span');
        if (spans.length <= this._activeElementIndex) {
            this._activeElementIndex = -1;
            return;
        }
        /** @type {?} */
        var elementToDeactivate = spans[this._activeElementIndex];
        this.renderer.removeClass(elementToDeactivate, this.activeCssClass);
        this.renderer.setAttribute(elementToDeactivate, 'style', 'background:yellow;color:black');
        this._activeElementIndex = -1;
    };
    /**
     * @private
     * @param {?} originalContentHidden
     * @return {?}
     */
    IgxTextHighlightDirective.prototype.clearChildElements = /**
     * @private
     * @param {?} originalContentHidden
     * @return {?}
     */
    function (originalContentHidden) {
        this.renderer.setProperty(this.element.nativeElement, 'hidden', originalContentHidden);
        if (this._div !== null) {
            this.renderer.removeChild(this.parentElement, this._div);
            this._div = null;
            this._activeElementIndex = -1;
        }
    };
    /**
     * @private
     * @param {?} searchText
     * @param {?} caseSensitive
     * @param {?} exactMatch
     * @return {?}
     */
    IgxTextHighlightDirective.prototype.getHighlightedText = /**
     * @private
     * @param {?} searchText
     * @param {?} caseSensitive
     * @param {?} exactMatch
     * @return {?}
     */
    function (searchText, caseSensitive, exactMatch) {
        this.appendDiv();
        /** @type {?} */
        var stringValue = String(this.value);
        /** @type {?} */
        var contentStringResolved = !caseSensitive ? stringValue.toLowerCase() : stringValue;
        /** @type {?} */
        var searchTextResolved = !caseSensitive ? searchText.toLowerCase() : searchText;
        /** @type {?} */
        var matchCount = 0;
        if (exactMatch) {
            if (contentStringResolved === searchTextResolved) {
                // tslint:disable-next-line:max-line-length
                this.appendSpan("<span class=\"" + this.cssClass + "\" style=\"background:yellow;color:black\">" + stringValue + "</span>");
                matchCount++;
            }
            else {
                this.appendText(stringValue);
            }
        }
        else {
            /** @type {?} */
            var foundIndex = contentStringResolved.indexOf(searchTextResolved, 0);
            /** @type {?} */
            var previousMatchEnd = 0;
            while (foundIndex !== -1) {
                /** @type {?} */
                var start = foundIndex;
                /** @type {?} */
                var end = foundIndex + searchTextResolved.length;
                this.appendText(stringValue.substring(previousMatchEnd, start));
                // tslint:disable-next-line:max-line-length
                this.appendSpan("<span class=\"" + this.cssClass + "\" style=\"background:yellow;color:black\">" + stringValue.substring(start, end) + "</span>");
                previousMatchEnd = end;
                matchCount++;
                foundIndex = contentStringResolved.indexOf(searchTextResolved, end);
            }
            this.appendText(stringValue.substring(previousMatchEnd, stringValue.length));
        }
        return matchCount;
    };
    /**
     * @private
     * @param {?} text
     * @return {?}
     */
    IgxTextHighlightDirective.prototype.appendText = /**
     * @private
     * @param {?} text
     * @return {?}
     */
    function (text) {
        /** @type {?} */
        var textElement = this.renderer.createText(text);
        this.renderer.appendChild(this._div, textElement);
    };
    /**
     * @private
     * @param {?} outerHTML
     * @return {?}
     */
    IgxTextHighlightDirective.prototype.appendSpan = /**
     * @private
     * @param {?} outerHTML
     * @return {?}
     */
    function (outerHTML) {
        /** @type {?} */
        var span = this.renderer.createElement('span');
        this.renderer.appendChild(this._div, span);
        this.renderer.setProperty(span, 'outerHTML', outerHTML);
    };
    /**
     * @private
     * @return {?}
     */
    IgxTextHighlightDirective.prototype.appendDiv = /**
     * @private
     * @return {?}
     */
    function () {
        this._div = this.renderer.createElement('div');
        if (this.containerClass) {
            this.renderer.addClass(this._div, this.containerClass);
        }
        this.renderer.appendChild(this.parentElement, this._div);
    };
    /**
     * @private
     * @param {?} text
     * @param {?} caseSensitive
     * @param {?} exactMatch
     * @return {?}
     */
    IgxTextHighlightDirective.prototype.searchNeedsEvaluation = /**
     * @private
     * @param {?} text
     * @param {?} caseSensitive
     * @param {?} exactMatch
     * @return {?}
     */
    function (text, caseSensitive, exactMatch) {
        /** @type {?} */
        var searchedText = this._lastSearchInfo.searchedText;
        return !this._nodeWasRemoved &&
            (searchedText === null ||
                searchedText !== text ||
                this._lastSearchInfo.content !== this.value ||
                this._lastSearchInfo.caseSensitive !== caseSensitive ||
                this._lastSearchInfo.exactMatch !== exactMatch ||
                this._forceEvaluation);
    };
    IgxTextHighlightDirective.onActiveElementChanged = new EventEmitter();
    IgxTextHighlightDirective.highlightGroupsMap = new Map();
    IgxTextHighlightDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxTextHighlight]'
                },] }
    ];
    /** @nocollapse */
    IgxTextHighlightDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 }
    ]; };
    IgxTextHighlightDirective.propDecorators = {
        cssClass: [{ type: Input, args: ['cssClass',] }],
        activeCssClass: [{ type: Input, args: ['activeCssClass',] }],
        containerClass: [{ type: Input, args: ['containerClass',] }],
        groupName: [{ type: Input, args: ['groupName',] }],
        value: [{ type: Input, args: ['value',] }],
        row: [{ type: Input, args: ['row',] }],
        column: [{ type: Input, args: ['column',] }],
        page: [{ type: Input, args: ['page',] }]
    };
    __decorate([
        DeprecateProperty("IgxTextHighlightDirective 'page' input property is deprecated."),
        __metadata("design:type", Number)
    ], IgxTextHighlightDirective.prototype, "page", void 0);
    return IgxTextHighlightDirective;
}());
/**
 * @hidden
 */
var IgxTextHighlightModule = /** @class */ (function () {
    function IgxTextHighlightModule() {
    }
    IgxTextHighlightModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxTextHighlightDirective],
                    exports: [IgxTextHighlightDirective]
                },] }
    ];
    return IgxTextHighlightModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxTextSelectionDirective = /** @class */ (function () {
    function IgxTextSelectionDirective(element) {
        this.element = element;
        this.selectionState = true;
    }
    Object.defineProperty(IgxTextSelectionDirective.prototype, "selected", {
        /**
         * Returns whether the input element is selectable through the directive.
         *
         * ```typescript
         * // get
         * @ViewChild('firstName',
         *  {read: IgxTextSelectionDirective})
         * public firstName: IgxTextSelectionDirective;
         *
         * public getFirstNameSelectionStatus() {
         *  return this.firstName.selected;
         * }
         * ```
         */
        get: /**
         * Returns whether the input element is selectable through the directive.
         *
         * ```typescript
         * // get
         * \@ViewChild('firstName',
         *  {read: IgxTextSelectionDirective})
         * public firstName: IgxTextSelectionDirective;
         *
         * public getFirstNameSelectionStatus() {
         *  return this.firstName.selected;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this.selectionState;
        },
        /**
         *  Determines whether the input element could be selected through the directive.
         *
         *```html
         * <!--set-->
         * <input
         *   type="text"
         *   id="firstName"
         *   [igxTextSelection]="true">
         * </input>
         *
         * <input
         *   type="text"
         *   id="lastName"
         *   igxTextSelection
         *   [selected]="true">
         * </input>
         * ```
         */
        set: /**
         *  Determines whether the input element could be selected through the directive.
         *
         * ```html
         * <!--set-->
         * <input
         *   type="text"
         *   id="firstName"
         *   [igxTextSelection]="true">
         * </input>
         *
         * <input
         *   type="text"
         *   id="lastName"
         *   igxTextSelection
         *   [selected]="true">
         * </input>
         * ```
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this.selectionState = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTextSelectionDirective.prototype, "nativeElement", {
        /**
         * Returns the nativeElement of the element where the directive was applied.
         *
         * ```html
         * <input
         *   type="text"
        *    id="firstName"
         *   igxTextSelection>
         * </input>
         * ```
         *
         * ```typescript
         * @ViewChild('firstName',
         *  {read: IgxTextSelectionDirective})
         * public inputElement: IgxTextSelectionDirective;
         *
         * public getNativeElement() {
         *  return this.inputElement.nativeElement;
         * }
         * ```
         */
        get: /**
         * Returns the nativeElement of the element where the directive was applied.
         *
         * ```html
         * <input
         *   type="text"
         *    id="firstName"
         *   igxTextSelection>
         * </input>
         * ```
         *
         * ```typescript
         * \@ViewChild('firstName',
         *  {read: IgxTextSelectionDirective})
         * public inputElement: IgxTextSelectionDirective;
         *
         * public getNativeElement() {
         *  return this.inputElement.nativeElement;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this.element.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTextSelectionDirective.prototype.onFocus = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.trigger();
    };
    /**
     * Triggers the selection of the element if it is marked as selectable.
     *
     * ```html
     * <input
     *   type="text"
     *   id="firstName"
     *   igxTextSelection>
     * </input>
     * ```
     *
     * ```typescript
     * @ViewChild('firstName',
     *  {read: IgxTextSelectionDirective})
     * public inputElement: IgxTextSelectionDirective;
     *
     * public triggerElementSelection() {
     *  this.inputElement.trigger();
     * }
     * ```
     */
    /**
     * Triggers the selection of the element if it is marked as selectable.
     *
     * ```html
     * <input
     *   type="text"
     *   id="firstName"
     *   igxTextSelection>
     * </input>
     * ```
     *
     * ```typescript
     * \@ViewChild('firstName',
     *  {read: IgxTextSelectionDirective})
     * public inputElement: IgxTextSelectionDirective;
     *
     * public triggerElementSelection() {
     *  this.inputElement.trigger();
     * }
     * ```
     * @return {?}
     */
    IgxTextSelectionDirective.prototype.trigger = /**
     * Triggers the selection of the element if it is marked as selectable.
     *
     * ```html
     * <input
     *   type="text"
     *   id="firstName"
     *   igxTextSelection>
     * </input>
     * ```
     *
     * ```typescript
     * \@ViewChild('firstName',
     *  {read: IgxTextSelectionDirective})
     * public inputElement: IgxTextSelectionDirective;
     *
     * public triggerElementSelection() {
     *  this.inputElement.trigger();
     * }
     * ```
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.selected && this.nativeElement.value.length) {
            requestAnimationFrame(function () { return _this.nativeElement.setSelectionRange(0, _this.nativeElement.value.length); });
        }
    };
    IgxTextSelectionDirective.decorators = [
        { type: Directive, args: [{
                    exportAs: 'igxTextSelection',
                    selector: '[igxTextSelection]'
                },] }
    ];
    /** @nocollapse */
    IgxTextSelectionDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    IgxTextSelectionDirective.propDecorators = {
        selected: [{ type: Input, args: ['igxTextSelection',] }],
        onFocus: [{ type: HostListener, args: ['focus',] }]
    };
    return IgxTextSelectionDirective;
}());
/**
 * @hidden
 */
var IgxTextSelectionModule = /** @class */ (function () {
    function IgxTextSelectionModule() {
    }
    IgxTextSelectionModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxTextSelectionDirective],
                    exports: [IgxTextSelectionDirective]
                },] }
    ];
    return IgxTextSelectionModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * **Ignite UI for Angular Tooltip Target** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/tooltip.html)
 *
 * The Ignite UI for Angular Tooltip Target directive is used to mark an HTML element in the markup as one that has a tooltip.
 * The tooltip target is used in combination with the Ignite UI for Angular Tooltip by assigning the exported tooltip reference to the
 * target's selector property.
 *
 * Example:
 * ```html
 * <button [igxTooltipTarget]="tooltipRef">Hover me</button>
 * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
 * ```
 */
var IgxTooltipTargetDirective = /** @class */ (function (_super) {
    __extends(IgxTooltipTargetDirective, _super);
    function IgxTooltipTargetDirective(_element, _navigationService) {
        var _this = _super.call(this, _element, _navigationService) || this;
        _this._element = _element;
        _this._navigationService = _navigationService;
        /**
         * Gets/sets the amount of milliseconds that should pass before showing the tooltip.
         *
         * ```typescript
         * // get
         * let tooltipShowDelay = this.tooltipTarget.showDelay;
         * ```
         *
         * ```html
         * <!--set-->
         * <button [igxTooltipTarget]="tooltipRef" showDelay="1500">Hover me</button>
         * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
         * ```
         */
        _this.showDelay = 500;
        /**
         * Gets/sets the amount of milliseconds that should pass before hiding the tooltip.
         *
         * ```typescript
         * // get
         * let tooltipHideDelay = this.tooltipTarget.hideDelay;
         * ```
         *
         * ```html
         * <!--set-->
         * <button [igxTooltipTarget]="tooltipRef" hideDelay="1500">Hover me</button>
         * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
         * ```
         */
        _this.hideDelay = 500;
        /**
         * Specifies if the tooltip should not show when hovering its target with the mouse. (defaults to false)
         * While setting this property to 'true' will disable the user interactions that shows/hides the tooltip,
         * the developer will still be able to show/hide the tooltip through the API.
         *
         * ```typescript
         * // get
         * let tooltipDisabledValue = this.tooltipTarget.tooltipDisabled;
         * ```
         *
         * ```html
         * <!--set-->
         * <button [igxTooltipTarget]="tooltipRef" [tooltipDisabled]="true">Hover me</button>
         * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
         * ```
         */
        _this.tooltipDisabled = false;
        /**
         * Emits an event when the tooltip that is associated with this target starts showing.
         * This event is fired before the start of the countdown to showing the tooltip.
         *
         * ```typescript
         * tooltipShowing(args: ITooltipShowEventArgs) {
         *    alert("Tooltip started showing!");
         * }
         * ```
         *
         * ```html
         * <button [igxTooltipTarget]="tooltipRef"
         *         (onTooltipShow)='tooltipShowing($event)'>Hover me</button>
         * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
         * ```
         */
        _this.onTooltipShow = new EventEmitter();
        /**
         * Emits an event when the tooltip that is associated with this target starts hiding.
         * This event is fired before the start of the countdown to hiding the tooltip.
         *
         * ```typescript
         * tooltipHiding(args: ITooltipHideEventArgs) {
         *    alert("Tooltip started hiding!");
         * }
         * ```
         *
         * ```html
         * <button [igxTooltipTarget]="tooltipRef"
         *         (onTooltipHide)='tooltipHiding($event)'>Hover me</button>
         * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
         * ```
         */
        _this.onTooltipHide = new EventEmitter();
        return _this;
    }
    Object.defineProperty(IgxTooltipTargetDirective.prototype, "target", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            if (typeof this._target === 'string') {
                return this._navigationService.get(this._target);
            }
            return this._target;
        },
        /**
         * @hidden
         */
        set: /**
         * @hidden
         * @param {?} target
         * @return {?}
         */
        function (target) {
            if (target !== null && target !== '') {
                this._target = target;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTooltipTargetDirective.prototype, "nativeElement", {
        /**
         * Gets the respective native element of the directive.
         *
         * ```typescript
         * let tooltipTargetElement = this.tooltipTarget.nativeElement;
         * ```
         */
        get: /**
         * Gets the respective native element of the directive.
         *
         * ```typescript
         * let tooltipTargetElement = this.tooltipTarget.nativeElement;
         * ```
         * @return {?}
         */
        function () {
            return this._element.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTooltipTargetDirective.prototype, "tooltipHidden", {
        /**
         * Indicates if the tooltip that is is associated with this target is currently hidden.
         *
         * ```typescript
         * let tooltipHiddenValue = this.tooltipTarget.tooltipHidden;
         * ```
         */
        get: /**
         * Indicates if the tooltip that is is associated with this target is currently hidden.
         *
         * ```typescript
         * let tooltipHiddenValue = this.tooltipTarget.tooltipHidden;
         * ```
         * @return {?}
         */
        function () {
            return !this.target || this.target.collapsed;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTooltipTargetDirective.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
        /** @type {?} */
        var positionSettings = {
            target: this.nativeElement,
            horizontalDirection: HorizontalAlignment.Center,
            horizontalStartPoint: HorizontalAlignment.Center,
            openAnimation: useAnimation(scaleInCenter, { params: { duration: '150ms' } }),
            closeAnimation: useAnimation(fadeOut, { params: { duration: '75ms' } })
        };
        this._overlayDefaults.positionStrategy = new AutoPositionStrategy(positionSettings);
        this._overlayDefaults.closeOnOutsideClick = false;
    };
    /**
     * @private
     * @return {?}
     */
    IgxTooltipTargetDirective.prototype.checkOutletAndOutsideClick = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.closeOnOutsideClick !== undefined) {
            this._overlayDefaults.closeOnOutsideClick = this.closeOnOutsideClick;
        }
        if (this.outlet) {
            this._overlayDefaults.outlet = this.outlet;
        }
    };
    Object.defineProperty(IgxTooltipTargetDirective.prototype, "mergedOverlaySettings", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return Object.assign({}, this._overlayDefaults, this.overlaySettings);
        },
        enumerable: true,
        configurable: true
    });
    // Return true if the execution in onMouseEnter should be terminated after this method
    // Return true if the execution in onMouseEnter should be terminated after this method
    /**
     * @private
     * @return {?}
     */
    IgxTooltipTargetDirective.prototype.preMouseEnterCheck = 
    // Return true if the execution in onMouseEnter should be terminated after this method
    /**
     * @private
     * @return {?}
     */
    function () {
        // If tooltip is about to be opened
        if (this.target.toBeShown) {
            clearTimeout(this.target.timeoutId);
            this.target.toBeShown = false;
        }
        // If Tooltip is opened or about to be hidden
        if (!this.target.collapsed || this.target.toBeHidden) {
            clearTimeout(this.target.timeoutId);
            /** @type {?} */
            var hidingArgs = { target: this, tooltip: this.target, cancel: false };
            this.onTooltipHide.emit(hidingArgs);
            if (hidingArgs.cancel) {
                return true;
            }
            //  if close animation has started finish it, or close the tooltip with no animation
            this.target.forceClose(this.mergedOverlaySettings);
            this.target.toBeHidden = false;
        }
        return false;
    };
    // Return true if the execution in onMouseLeave should be terminated after this method
    // Return true if the execution in onMouseLeave should be terminated after this method
    /**
     * @private
     * @return {?}
     */
    IgxTooltipTargetDirective.prototype.preMouseLeaveCheck = 
    // Return true if the execution in onMouseLeave should be terminated after this method
    /**
     * @private
     * @return {?}
     */
    function () {
        clearTimeout(this.target.timeoutId);
        // If tooltip is about to be opened
        if (this.target.toBeShown) {
            this.target.toBeShown = false;
            this.target.toBeHidden = false;
            return true;
        }
        return false;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTooltipTargetDirective.prototype.onKeydownEscape = /**
     * @hidden
     * @return {?}
     */
    function () {
        /** @type {?} */
        var hidingArgs = { target: this, tooltip: this.target, cancel: false };
        this.onTooltipHide.emit(hidingArgs);
        if (hidingArgs.cancel) {
            return;
        }
        this.target.toBeHidden = true;
        this.target.close();
        this.target.toBeHidden = false;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTooltipTargetDirective.prototype.onClick = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (!this.target.collapsed) {
            /** @type {?} */
            var hidingArgs = { target: this, tooltip: this.target, cancel: false };
            this.onTooltipHide.emit(hidingArgs);
            if (hidingArgs.cancel) {
                return;
            }
            this.target.forceClose(this.mergedOverlaySettings);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTooltipTargetDirective.prototype.onMouseEnter = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.tooltipDisabled) {
            return;
        }
        this.checkOutletAndOutsideClick();
        /** @type {?} */
        var shouldReturn = this.preMouseEnterCheck();
        if (shouldReturn) {
            return;
        }
        /** @type {?} */
        var showingArgs = { target: this, tooltip: this.target, cancel: false };
        this.onTooltipShow.emit(showingArgs);
        if (showingArgs.cancel) {
            return;
        }
        this.target.toBeShown = true;
        this.target.timeoutId = setTimeout(function () {
            _this.target.open(_this.mergedOverlaySettings); // Call open() of IgxTooltipDirective
            _this.target.toBeShown = false;
        }, this.showDelay);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTooltipTargetDirective.prototype.onMouseLeave = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.tooltipDisabled) {
            return;
        }
        this.checkOutletAndOutsideClick();
        /** @type {?} */
        var shouldReturn = this.preMouseLeaveCheck();
        if (shouldReturn || this.target.collapsed) {
            return;
        }
        /** @type {?} */
        var hidingArgs = { target: this, tooltip: this.target, cancel: false };
        this.onTooltipHide.emit(hidingArgs);
        if (hidingArgs.cancel) {
            return;
        }
        this.target.toBeHidden = true;
        this.target.timeoutId = setTimeout(function () {
            _this.target.close(); // Call close() of IgxTooltipDirective
            _this.target.toBeHidden = false;
        }, this.hideDelay);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxTooltipTargetDirective.prototype.onTouchStart = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.tooltipDisabled) {
            return;
        }
        event.preventDefault();
        this.showTooltip();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxTooltipTargetDirective.prototype.onDocumentTouchStart = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.tooltipDisabled) {
            return;
        }
        if (this.nativeElement !== event.target &&
            !this.nativeElement.contains(event.target)) {
            this.hideTooltip();
        }
    };
    /**
     * Shows the tooltip by respecting the 'showDelay' property.
     *
     * ```typescript
     * this.tooltipTarget.showTooltip();
     * ```
     */
    /**
     * Shows the tooltip by respecting the 'showDelay' property.
     *
     * ```typescript
     * this.tooltipTarget.showTooltip();
     * ```
     * @return {?}
     */
    IgxTooltipTargetDirective.prototype.showTooltip = /**
     * Shows the tooltip by respecting the 'showDelay' property.
     *
     * ```typescript
     * this.tooltipTarget.showTooltip();
     * ```
     * @return {?}
     */
    function () {
        var _this = this;
        clearTimeout(this.target.timeoutId);
        if (!this.target.collapsed) {
            /** @type {?} */
            var hidingArgs = { target: this, tooltip: this.target, cancel: false };
            this.onTooltipHide.emit(hidingArgs);
            if (hidingArgs.cancel) {
                return;
            }
            //  if close animation has started finish it, or close the tooltip with no animation
            this.target.forceClose(this.mergedOverlaySettings);
            this.target.toBeHidden = false;
        }
        /** @type {?} */
        var showingArgs = { target: this, tooltip: this.target, cancel: false };
        this.onTooltipShow.emit(showingArgs);
        if (showingArgs.cancel) {
            return;
        }
        this.target.toBeShown = true;
        this.target.timeoutId = setTimeout(function () {
            _this.target.open(_this.mergedOverlaySettings); // Call open() of IgxTooltipDirective
            _this.target.toBeShown = false;
        }, this.showDelay);
    };
    /**
     * Hides the tooltip by respecting the 'hideDelay' property.
     *
     * ```typescript
     * this.tooltipTarget.hideTooltip();
     * ```
     */
    /**
     * Hides the tooltip by respecting the 'hideDelay' property.
     *
     * ```typescript
     * this.tooltipTarget.hideTooltip();
     * ```
     * @return {?}
     */
    IgxTooltipTargetDirective.prototype.hideTooltip = /**
     * Hides the tooltip by respecting the 'hideDelay' property.
     *
     * ```typescript
     * this.tooltipTarget.hideTooltip();
     * ```
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.target.collapsed && this.target.toBeShown) {
            clearTimeout(this.target.timeoutId);
        }
        if (this.target.collapsed || this.target.toBeHidden) {
            return;
        }
        /** @type {?} */
        var hidingArgs = { target: this, tooltip: this.target, cancel: false };
        this.onTooltipHide.emit(hidingArgs);
        if (hidingArgs.cancel) {
            return;
        }
        this.target.toBeHidden = true;
        this.target.timeoutId = setTimeout(function () {
            _this.target.close(); // Call close() of IgxTooltipDirective
            _this.target.toBeHidden = false;
        }, this.hideDelay);
    };
    IgxTooltipTargetDirective.decorators = [
        { type: Directive, args: [{
                    exportAs: 'tooltipTarget',
                    selector: '[igxTooltipTarget]'
                },] }
    ];
    /** @nocollapse */
    IgxTooltipTargetDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: IgxNavigationService, decorators: [{ type: Optional }] }
    ]; };
    IgxTooltipTargetDirective.propDecorators = {
        showDelay: [{ type: Input, args: ['showDelay',] }],
        hideDelay: [{ type: Input, args: ['hideDelay',] }],
        tooltipDisabled: [{ type: Input, args: ['tooltipDisabled',] }],
        target: [{ type: Input, args: ['igxTooltipTarget',] }],
        onTooltipShow: [{ type: Output }],
        onTooltipHide: [{ type: Output }],
        onKeydownEscape: [{ type: HostListener, args: ['document:keydown.escape', ['$event'],] }],
        onClick: [{ type: HostListener, args: ['click',] }],
        onMouseEnter: [{ type: HostListener, args: ['mouseenter',] }],
        onMouseLeave: [{ type: HostListener, args: ['mouseleave',] }],
        onTouchStart: [{ type: HostListener, args: ['touchstart', ['$event'],] }],
        onDocumentTouchStart: [{ type: HostListener, args: ['document:touchstart', ['$event'],] }]
    };
    return IgxTooltipTargetDirective;
}(IgxToggleActionDirective));
/** @type {?} */
var NEXT_ID$6 = 0;
/**
 * **Ignite UI for Angular Tooltip** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/tooltip.html)
 *
 * The Ignite UI for Angular Tooltip directive is used to mark an HTML element in the markup as one that should behave as a tooltip.
 * The tooltip is used in combination with the Ignite UI for Angular Tooltip Target by assigning the exported tooltip reference to the
 * respective target's selector property.
 *
 * Example:
 * ```html
 * <button [igxTooltipTarget]="tooltipRef">Hover me</button>
 * <span #tooltipRef="tooltip" igxTooltip>Hello there, I am a tooltip!</span>
 * ```
 */
var IgxTooltipDirective = /** @class */ (function (_super) {
    __extends(IgxTooltipDirective, _super);
    /** @hidden */
    function IgxTooltipDirective(elementRef, cdr, overlayService, navigationService) {
        var _this = 
        // D.P. constructor duplication due to es6 compilation, might be obsolete in the future
        _super.call(this, elementRef, cdr, overlayService, navigationService) || this;
        /**
         * @hidden
         * Returns whether close time out has started
         */
        _this.toBeHidden = false;
        /**
         * @hidden
         * Returns whether open time out has started
         */
        _this.toBeShown = false;
        /**
         * Identifier for the tooltip.
         * If this is property is not explicitly set, it will be automatically generated.
         *
         * ```typescript
         * let tooltipId = this.tooltip.id;
         * ```
         */
        _this.id = "igx-tooltip-" + NEXT_ID$6++;
        return _this;
    }
    Object.defineProperty(IgxTooltipDirective.prototype, "hiddenClass", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.collapsed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTooltipDirective.prototype, "defaultClass", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return !this.collapsed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTooltipDirective.prototype, "role", {
        /**
         * Get the role attribute of the tooltip.
         *
         * ```typescript
         * let tooltipRole = this.tooltip.role;
         * ```
         */
        get: /**
         * Get the role attribute of the tooltip.
         *
         * ```typescript
         * let tooltipRole = this.tooltip.role;
         * ```
         * @return {?}
         */
        function () {
            return 'tooltip';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * If there is open animation in progress this method will finish is.
     * If there is no open animation in progress this method will open the toggle with no animation.
     * @param overlaySettings setting to use for opening the toggle
     */
    /**
     * If there is open animation in progress this method will finish is.
     * If there is no open animation in progress this method will open the toggle with no animation.
     * @protected
     * @param {?=} overlaySettings setting to use for opening the toggle
     * @return {?}
     */
    IgxTooltipDirective.prototype.forceOpen = /**
     * If there is open animation in progress this method will finish is.
     * If there is no open animation in progress this method will open the toggle with no animation.
     * @protected
     * @param {?=} overlaySettings setting to use for opening the toggle
     * @return {?}
     */
    function (overlaySettings) {
        /** @type {?} */
        var info = this.overlayService.getOverlayById(this._overlayId);
        /** @type {?} */
        var hasOpenAnimation = info ? info.openAnimationPlayer : false;
        if (hasOpenAnimation) {
            info.openAnimationPlayer.finish();
            info.openAnimationPlayer.reset();
            info.openAnimationPlayer = null;
        }
        else if (this.collapsed) {
            /** @type {?} */
            var animation$$1 = overlaySettings.positionStrategy.settings.openAnimation;
            overlaySettings.positionStrategy.settings.openAnimation = null;
            this.open(overlaySettings);
            overlaySettings.positionStrategy.settings.openAnimation = animation$$1;
        }
    };
    /**
     * If there is close animation in progress this method will finish is.
     * If there is no close animation in progress this method will close the toggle with no animation.
     * @param overlaySettings settings to use for closing the toggle
     */
    /**
     * If there is close animation in progress this method will finish is.
     * If there is no close animation in progress this method will close the toggle with no animation.
     * @protected
     * @param {?=} overlaySettings settings to use for closing the toggle
     * @return {?}
     */
    IgxTooltipDirective.prototype.forceClose = /**
     * If there is close animation in progress this method will finish is.
     * If there is no close animation in progress this method will close the toggle with no animation.
     * @protected
     * @param {?=} overlaySettings settings to use for closing the toggle
     * @return {?}
     */
    function (overlaySettings) {
        /** @type {?} */
        var info = this.overlayService.getOverlayById(this._overlayId);
        /** @type {?} */
        var hasCloseAnimation = info ? info.closeAnimationPlayer : false;
        if (hasCloseAnimation) {
            info.closeAnimationPlayer.finish();
            info.closeAnimationPlayer.reset();
            info.closeAnimationPlayer = null;
        }
        else if (!this.collapsed) {
            /** @type {?} */
            var animation$$1 = overlaySettings.positionStrategy.settings.closeAnimation;
            overlaySettings.positionStrategy.settings.closeAnimation = null;
            this.close();
            overlaySettings.positionStrategy.settings.closeAnimation = animation$$1;
        }
    };
    IgxTooltipDirective.decorators = [
        { type: Directive, args: [{
                    exportAs: 'tooltip',
                    selector: '[igxTooltip]'
                },] }
    ];
    /** @nocollapse */
    IgxTooltipDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ChangeDetectorRef },
        { type: IgxOverlayService, decorators: [{ type: Inject, args: [IgxOverlayService,] }] },
        { type: IgxNavigationService, decorators: [{ type: Optional }] }
    ]; };
    IgxTooltipDirective.propDecorators = {
        hiddenClass: [{ type: HostBinding, args: ['class.igx-tooltip--hidden',] }],
        defaultClass: [{ type: HostBinding, args: ['class.igx-tooltip--desktop',] }],
        context: [{ type: Input, args: ['context',] }],
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        role: [{ type: HostBinding, args: ['attr.role',] }]
    };
    return IgxTooltipDirective;
}(IgxToggleDirective));
/**
 * @hidden
 */
var IgxTooltipModule = /** @class */ (function () {
    function IgxTooltipModule() {
    }
    IgxTooltipModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxTooltipDirective, IgxTooltipTargetDirective],
                    exports: [IgxTooltipDirective, IgxTooltipTargetDirective],
                    imports: [CommonModule],
                    providers: [IgxOverlayService]
                },] }
    ];
    return IgxTooltipModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Provides base filtering operations
 * Implementations should be Singleton
 *
 * @export
 */
var  /**
 * Provides base filtering operations
 * Implementations should be Singleton
 *
 * @export
 */
IgxFilteringOperand = /** @class */ (function () {
    function IgxFilteringOperand() {
        this.operations = [{
                name: 'null',
                isUnary: true,
                iconName: 'is_null',
                logic: function (target) {
                    return target === null;
                }
            }, {
                name: 'notNull',
                isUnary: true,
                iconName: 'is_not_null',
                logic: function (target) {
                    return target !== null;
                }
            }];
    }
    /**
     * @return {?}
     */
    IgxFilteringOperand.prototype.conditionList = /**
     * @return {?}
     */
    function () {
        return this.operations.map(function (element) { return element.name; });
    };
    /**
     * @param {?} name
     * @return {?}
     */
    IgxFilteringOperand.prototype.condition = /**
     * @param {?} name
     * @return {?}
     */
    function (name) {
        return this.operations.find(function (element) { return element.name === name; });
    };
    /**
     * @param {?} operation
     * @return {?}
     */
    IgxFilteringOperand.prototype.append = /**
     * @param {?} operation
     * @return {?}
     */
    function (operation) {
        this.operations.push(operation);
    };
    return IgxFilteringOperand;
}());
/**
 * Provides filtering operations for booleans
 *
 * @export
 */
var IgxBooleanFilteringOperand = /** @class */ (function (_super) {
    __extends(IgxBooleanFilteringOperand, _super);
    function IgxBooleanFilteringOperand() {
        var _this = _super.call(this) || this;
        _this.operations = [{
                name: 'all',
                isUnary: true,
                iconName: 'all',
                logic: function (target) {
                    return true;
                }
            }, {
                name: 'true',
                isUnary: true,
                iconName: 'is_true',
                logic: function (target) {
                    return !!(target && target !== null && target !== undefined);
                }
            }, {
                name: 'false',
                isUnary: true,
                iconName: 'is_false',
                logic: function (target) {
                    return !target && target !== null && target !== undefined;
                }
            }, {
                name: 'empty',
                isUnary: true,
                iconName: 'empty',
                logic: function (target) {
                    return target === null || target === undefined;
                }
            }, {
                name: 'notEmpty',
                isUnary: true,
                iconName: 'not_empty',
                logic: function (target) {
                    return target !== null && target !== undefined;
                }
            }].concat(_this.operations);
        return _this;
    }
    /**
     * @return {?}
     */
    IgxBooleanFilteringOperand.instance = /**
     * @return {?}
     */
    function () {
        return this._instance || (this._instance = new this());
    };
    IgxBooleanFilteringOperand._instance = null;
    return IgxBooleanFilteringOperand;
}(IgxFilteringOperand));
/**
 * Provides filtering operations for Dates
 *
 * @export
 */
var IgxDateFilteringOperand = /** @class */ (function (_super) {
    __extends(IgxDateFilteringOperand, _super);
    function IgxDateFilteringOperand() {
        var _this = _super.call(this) || this;
        _this.operations = [{
                name: 'equals',
                isUnary: false,
                iconName: 'equals',
                logic: function (target, searchVal) {
                    if (!target) {
                        return false;
                    }
                    _this.validateInputData(target);
                    /** @type {?} */
                    var targetp = IgxDateFilteringOperand.getDateParts(target, 'yMd');
                    /** @type {?} */
                    var searchp = IgxDateFilteringOperand.getDateParts(searchVal, 'yMd');
                    return targetp.year === searchp.year &&
                        targetp.month === searchp.month &&
                        targetp.day === searchp.day;
                }
            }, {
                name: 'doesNotEqual',
                isUnary: false,
                iconName: 'not_equal',
                logic: function (target, searchVal) {
                    if (!target) {
                        return true;
                    }
                    _this.validateInputData(target);
                    /** @type {?} */
                    var targetp = IgxDateFilteringOperand.getDateParts(target, 'yMd');
                    /** @type {?} */
                    var searchp = IgxDateFilteringOperand.getDateParts(searchVal, 'yMd');
                    return targetp.year !== searchp.year ||
                        targetp.month !== searchp.month ||
                        targetp.day !== searchp.day;
                }
            }, {
                name: 'before',
                isUnary: false,
                iconName: 'is_before',
                logic: function (target, searchVal) {
                    if (!target) {
                        return false;
                    }
                    _this.validateInputData(target);
                    return target < searchVal;
                }
            }, {
                name: 'after',
                isUnary: false,
                iconName: 'is_after',
                logic: function (target, searchVal) {
                    if (!target) {
                        return false;
                    }
                    _this.validateInputData(target);
                    return target > searchVal;
                }
            }, {
                name: 'today',
                isUnary: true,
                iconName: 'today',
                logic: function (target) {
                    if (!target) {
                        return false;
                    }
                    _this.validateInputData(target);
                    /** @type {?} */
                    var d = IgxDateFilteringOperand.getDateParts(target, 'yMd');
                    /** @type {?} */
                    var now = IgxDateFilteringOperand.getDateParts(new Date(), 'yMd');
                    return d.year === now.year &&
                        d.month === now.month &&
                        d.day === now.day;
                }
            }, {
                name: 'yesterday',
                isUnary: true,
                iconName: 'yesterday',
                logic: function (target) {
                    if (!target) {
                        return false;
                    }
                    _this.validateInputData(target);
                    /** @type {?} */
                    var td = IgxDateFilteringOperand.getDateParts(target, 'yMd');
                    /** @type {?} */
                    var y = (function (d) { return new Date(d.setDate(d.getDate() - 1)); })(new Date());
                    /** @type {?} */
                    var yesterday = IgxDateFilteringOperand.getDateParts(y, 'yMd');
                    return td.year === yesterday.year &&
                        td.month === yesterday.month &&
                        td.day === yesterday.day;
                }
            }, {
                name: 'thisMonth',
                isUnary: true,
                iconName: 'this_month',
                logic: function (target) {
                    if (!target) {
                        return false;
                    }
                    _this.validateInputData(target);
                    /** @type {?} */
                    var d = IgxDateFilteringOperand.getDateParts(target, 'yM');
                    /** @type {?} */
                    var now = IgxDateFilteringOperand.getDateParts(new Date(), 'yM');
                    return d.year === now.year &&
                        d.month === now.month;
                }
            }, {
                name: 'lastMonth',
                isUnary: true,
                iconName: 'last_month',
                logic: function (target) {
                    if (!target) {
                        return false;
                    }
                    _this.validateInputData(target);
                    /** @type {?} */
                    var d = IgxDateFilteringOperand.getDateParts(target, 'yM');
                    /** @type {?} */
                    var now = IgxDateFilteringOperand.getDateParts(new Date(), 'yM');
                    if (!now.month) {
                        now.month = 11;
                        now.year -= 1;
                    }
                    else {
                        now.month--;
                    }
                    return d.year === now.year &&
                        d.month === now.month;
                }
            }, {
                name: 'nextMonth',
                isUnary: true,
                iconName: 'next_month',
                logic: function (target) {
                    if (!target) {
                        return false;
                    }
                    _this.validateInputData(target);
                    /** @type {?} */
                    var d = IgxDateFilteringOperand.getDateParts(target, 'yM');
                    /** @type {?} */
                    var now = IgxDateFilteringOperand.getDateParts(new Date(), 'yM');
                    if (now.month === 11) {
                        now.month = 0;
                        now.year += 1;
                    }
                    else {
                        now.month++;
                    }
                    return d.year === now.year &&
                        d.month === now.month;
                }
            }, {
                name: 'thisYear',
                isUnary: true,
                iconName: 'this_year',
                logic: function (target) {
                    if (!target) {
                        return false;
                    }
                    _this.validateInputData(target);
                    /** @type {?} */
                    var d = IgxDateFilteringOperand.getDateParts(target, 'y');
                    /** @type {?} */
                    var now = IgxDateFilteringOperand.getDateParts(new Date(), 'y');
                    return d.year === now.year;
                }
            }, {
                name: 'lastYear',
                isUnary: true,
                iconName: 'last_year',
                logic: function (target) {
                    if (!target) {
                        return false;
                    }
                    _this.validateInputData(target);
                    /** @type {?} */
                    var d = IgxDateFilteringOperand.getDateParts(target, 'y');
                    /** @type {?} */
                    var now = IgxDateFilteringOperand.getDateParts(new Date(), 'y');
                    return d.year === now.year - 1;
                }
            }, {
                name: 'nextYear',
                isUnary: true,
                iconName: 'next_year',
                logic: function (target) {
                    if (!target) {
                        return false;
                    }
                    _this.validateInputData(target);
                    /** @type {?} */
                    var d = IgxDateFilteringOperand.getDateParts(target, 'y');
                    /** @type {?} */
                    var now = IgxDateFilteringOperand.getDateParts(new Date(), 'y');
                    return d.year === now.year + 1;
                }
            }, {
                name: 'empty',
                isUnary: true,
                iconName: 'empty',
                logic: function (target) {
                    return target === null || target === undefined;
                }
            }, {
                name: 'notEmpty',
                isUnary: true,
                iconName: 'not_empty',
                logic: function (target) {
                    return target !== null && target !== undefined;
                }
            }].concat(_this.operations);
        return _this;
    }
    /**
     * @return {?}
     */
    IgxDateFilteringOperand.instance = /**
     * @return {?}
     */
    function () {
        return this._instance || (this._instance = new this());
    };
    /**
     * Splits a Date object into parts
     *
     * @memberof IgxDateFilteringOperand
     */
    /**
     * Splits a Date object into parts
     *
     * \@memberof IgxDateFilteringOperand
     * @param {?} date
     * @param {?=} dateFormat
     * @return {?}
     */
    IgxDateFilteringOperand.getDateParts = /**
     * Splits a Date object into parts
     *
     * \@memberof IgxDateFilteringOperand
     * @param {?} date
     * @param {?=} dateFormat
     * @return {?}
     */
    function (date, dateFormat) {
        /** @type {?} */
        var res = {
            day: null,
            hours: null,
            milliseconds: null,
            minutes: null,
            month: null,
            seconds: null,
            year: null
        };
        if (!date || !dateFormat) {
            return res;
        }
        if (dateFormat.indexOf('y') >= 0) {
            res.year = date.getFullYear();
        }
        if (dateFormat.indexOf('M') >= 0) {
            res.month = date.getMonth();
        }
        if (dateFormat.indexOf('d') >= 0) {
            res.day = date.getDate();
        }
        if (dateFormat.indexOf('h') >= 0) {
            res.hours = date.getHours();
        }
        if (dateFormat.indexOf('m') >= 0) {
            res.minutes = date.getMinutes();
        }
        if (dateFormat.indexOf('s') >= 0) {
            res.seconds = date.getSeconds();
        }
        if (dateFormat.indexOf('f') >= 0) {
            res.milliseconds = date.getMilliseconds();
        }
        return res;
    };
    /**
     * @private
     * @param {?} target
     * @return {?}
     */
    IgxDateFilteringOperand.prototype.validateInputData = /**
     * @private
     * @param {?} target
     * @return {?}
     */
    function (target) {
        if (!(target instanceof Date)) {
            throw new Error('Could not perform filtering on \'date\' column because the datasource object type is not \'Date\'.');
        }
    };
    IgxDateFilteringOperand._instance = null;
    return IgxDateFilteringOperand;
}(IgxFilteringOperand));
/**
 * Provides filtering operations for numbers
 *
 * @export
 */
var IgxNumberFilteringOperand = /** @class */ (function (_super) {
    __extends(IgxNumberFilteringOperand, _super);
    function IgxNumberFilteringOperand() {
        var _this = _super.call(this) || this;
        _this.operations = [{
                name: 'equals',
                isUnary: false,
                iconName: 'equals',
                logic: function (target, searchVal) {
                    return target === searchVal;
                }
            }, {
                name: 'doesNotEqual',
                isUnary: false,
                iconName: 'not_equal',
                logic: function (target, searchVal) {
                    return target !== searchVal;
                }
            }, {
                name: 'greaterThan',
                isUnary: false,
                iconName: 'greater_than',
                logic: function (target, searchVal) {
                    return target > searchVal;
                }
            }, {
                name: 'lessThan',
                isUnary: false,
                iconName: 'less_than',
                logic: function (target, searchVal) {
                    return target < searchVal;
                }
            }, {
                name: 'greaterThanOrEqualTo',
                isUnary: false,
                iconName: 'greater_than_or_equal',
                logic: function (target, searchVal) {
                    return target >= searchVal;
                }
            }, {
                name: 'lessThanOrEqualTo',
                isUnary: false,
                iconName: 'less_than_or_equal',
                logic: function (target, searchVal) {
                    return target <= searchVal;
                }
            }, {
                name: 'empty',
                isUnary: true,
                iconName: 'empty',
                logic: function (target) {
                    return target === null || target === undefined || isNaN(target);
                }
            }, {
                name: 'notEmpty',
                isUnary: true,
                iconName: 'not_empty',
                logic: function (target) {
                    return target !== null && target !== undefined && !isNaN(target);
                }
            }].concat(_this.operations);
        return _this;
    }
    /**
     * @return {?}
     */
    IgxNumberFilteringOperand.instance = /**
     * @return {?}
     */
    function () {
        return this._instance || (this._instance = new this());
    };
    IgxNumberFilteringOperand._instance = null;
    return IgxNumberFilteringOperand;
}(IgxFilteringOperand));
/**
 * Provides filtering operations for strings
 *
 * @export
 */
var IgxStringFilteringOperand = /** @class */ (function (_super) {
    __extends(IgxStringFilteringOperand, _super);
    function IgxStringFilteringOperand() {
        var _this = _super.call(this) || this;
        _this.operations = [{
                name: 'contains',
                isUnary: false,
                iconName: 'contains',
                logic: function (target, searchVal, ignoreCase) {
                    /** @type {?} */
                    var search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                    target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                    return target.indexOf(search) !== -1;
                }
            }, {
                name: 'doesNotContain',
                isUnary: false,
                iconName: 'does_not_contain',
                logic: function (target, searchVal, ignoreCase) {
                    /** @type {?} */
                    var search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                    target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                    return target.indexOf(search) === -1;
                }
            }, {
                name: 'startsWith',
                isUnary: false,
                iconName: 'starts_with',
                logic: function (target, searchVal, ignoreCase) {
                    /** @type {?} */
                    var search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                    target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                    return target.startsWith(search);
                }
            }, {
                name: 'endsWith',
                isUnary: false,
                iconName: 'ends_with',
                logic: function (target, searchVal, ignoreCase) {
                    /** @type {?} */
                    var search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                    target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                    return target.endsWith(search);
                }
            }, {
                name: 'equals',
                isUnary: false,
                iconName: 'equals',
                logic: function (target, searchVal, ignoreCase) {
                    /** @type {?} */
                    var search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                    target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                    return target === search;
                }
            }, {
                name: 'doesNotEqual',
                isUnary: false,
                iconName: 'not_equal',
                logic: function (target, searchVal, ignoreCase) {
                    /** @type {?} */
                    var search = IgxStringFilteringOperand.applyIgnoreCase(searchVal, ignoreCase);
                    target = IgxStringFilteringOperand.applyIgnoreCase(target, ignoreCase);
                    return target !== search;
                }
            }, {
                name: 'empty',
                isUnary: true,
                iconName: 'empty',
                logic: function (target) {
                    return target === null || target === undefined || target.length === 0;
                }
            }, {
                name: 'notEmpty',
                isUnary: true,
                iconName: 'not_empty',
                logic: function (target) {
                    return target !== null && target !== undefined && target.length > 0;
                }
            }].concat(_this.operations);
        return _this;
    }
    /**
     * @return {?}
     */
    IgxStringFilteringOperand.instance = /**
     * @return {?}
     */
    function () {
        return this._instance || (this._instance = new this());
    };
    /**
     * Applies case sensitivity on strings if provided
     *
     * @memberof IgxStringFilteringOperand
     */
    /**
     * Applies case sensitivity on strings if provided
     *
     * \@memberof IgxStringFilteringOperand
     * @param {?} a
     * @param {?} ignoreCase
     * @return {?}
     */
    IgxStringFilteringOperand.applyIgnoreCase = /**
     * Applies case sensitivity on strings if provided
     *
     * \@memberof IgxStringFilteringOperand
     * @param {?} a
     * @param {?} ignoreCase
     * @return {?}
     */
    function (a, ignoreCase) {
        a = a || '';
        // bulletproof
        return ignoreCase ? ('' + a).toLowerCase() : a;
    };
    IgxStringFilteringOperand._instance = null;
    return IgxStringFilteringOperand;
}(IgxFilteringOperand));
/**
 * @hidden
 */
var  /**
 * @hidden
 */
InFilteringOperation = /** @class */ (function () {
    function InFilteringOperation() {
        this.name = 'in';
        this.isUnary = false;
        this.iconName = 'is_in';
        this.logic = function (target, searchVal) {
            return searchVal.has(target);
        };
    }
    return InFilteringOperation;
}());
/**
 * @hidden
 */
var  /**
 * @hidden
 */
InDateFilteringOperation = /** @class */ (function (_super) {
    __extends(InDateFilteringOperation, _super);
    function InDateFilteringOperation() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.logic = function (target, searchVal) {
            if (target instanceof Date) {
                return searchVal.has(new Date(target.getFullYear(), target.getMonth(), target.getDate()).toISOString());
            }
            return searchVal.has(target);
        };
        return _this;
    }
    return InDateFilteringOperation;
}(InFilteringOperation));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var filteringStateDefaults = {
    strategy: new FilteringStrategy()
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var  /**
 * @hidden
 */
GroupedRecords = /** @class */ (function (_super) {
    __extends(GroupedRecords, _super);
    function GroupedRecords() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return GroupedRecords;
}(Array));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * **Ignite UI for Angular Icon Service** -
 *
 * The Ignite UI Icon Service makes it easy for developers to include custom SVG images and use them with IgxIconComponent.
 * In addition it could be used to associate a custom class to be applied on IgxIconComponent according to given fontSet.
 *
 * Example:
 * ```typescript
 * this.iconService.registerFontSetAlias('material', 'material-icons');
 * this.iconService.addSvgIcon('aruba', '/assets/svg/country_flags/aruba.svg', 'svg-flags');
 * ```
 */
var IgxIconService = /** @class */ (function () {
    function IgxIconService(_sanitizer, _httpClient, _document) {
        this._sanitizer = _sanitizer;
        this._httpClient = _httpClient;
        this._document = _document;
        this._fontSet = 'material-icons';
        this._fontSetAliases = new Map();
        this._cachedSvgIcons = new Set();
    }
    Object.defineProperty(IgxIconService.prototype, "defaultFontSet", {
        /**
         *  Returns the default font set.
         *```typescript
         *   const defaultFontSet = this.iconService.defaultFontSet;
         * ```
         */
        get: /**
         *  Returns the default font set.
         * ```typescript
         *   const defaultFontSet = this.iconService.defaultFontSet;
         * ```
         * @return {?}
         */
        function () {
            return this._fontSet;
        },
        /**
         *  Sets the default font set.
         *```typescript
         *   this.iconService.defaultFontSet = 'svg-flags';
         * ```
         */
        set: /**
         *  Sets the default font set.
         * ```typescript
         *   this.iconService.defaultFontSet = 'svg-flags';
         * ```
         * @param {?} className
         * @return {?}
         */
        function (className) {
            this._fontSet = className;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *  Registers a custom class to be applied to IgxIconComponent for a given fontSet.
     *```typescript
     *   this.iconService.registerFontSetAlias('material', 'material-icons');
     * ```
     */
    /**
     *  Registers a custom class to be applied to IgxIconComponent for a given fontSet.
     * ```typescript
     *   this.iconService.registerFontSetAlias('material', 'material-icons');
     * ```
     * @template THIS
     * @this {THIS}
     * @param {?} alias
     * @param {?=} className
     * @return {THIS}
     */
    IgxIconService.prototype.registerFontSetAlias = /**
     *  Registers a custom class to be applied to IgxIconComponent for a given fontSet.
     * ```typescript
     *   this.iconService.registerFontSetAlias('material', 'material-icons');
     * ```
     * @template THIS
     * @this {THIS}
     * @param {?} alias
     * @param {?=} className
     * @return {THIS}
     */
    function (alias, className) {
        if (className === void 0) { className = alias; }
        (/** @type {?} */ (this))._fontSetAliases.set(alias, className);
        return (/** @type {?} */ (this));
    };
    /**
     *  Returns the custom class, if any, associated to a given fontSet.
     *```typescript
     *   const fontSetClass = this.iconService.fontSetClassName('material');
     * ```
     */
    /**
     *  Returns the custom class, if any, associated to a given fontSet.
     * ```typescript
     *   const fontSetClass = this.iconService.fontSetClassName('material');
     * ```
     * @param {?} alias
     * @return {?}
     */
    IgxIconService.prototype.fontSetClassName = /**
     *  Returns the custom class, if any, associated to a given fontSet.
     * ```typescript
     *   const fontSetClass = this.iconService.fontSetClassName('material');
     * ```
     * @param {?} alias
     * @return {?}
     */
    function (alias) {
        return this._fontSetAliases.get(alias) || alias;
    };
    /**
     *  Adds an SVG image to the cache. SVG source is an url.
     *```typescript
     *   this.iconService.addSvgIcon('aruba', '/assets/svg/country_flags/aruba.svg', 'svg-flags');
     * ```
     */
    /**
     *  Adds an SVG image to the cache. SVG source is an url.
     * ```typescript
     *   this.iconService.addSvgIcon('aruba', '/assets/svg/country_flags/aruba.svg', 'svg-flags');
     * ```
     * @param {?} iconName
     * @param {?} url
     * @param {?=} fontSet
     * @return {?}
     */
    IgxIconService.prototype.addSvgIcon = /**
     *  Adds an SVG image to the cache. SVG source is an url.
     * ```typescript
     *   this.iconService.addSvgIcon('aruba', '/assets/svg/country_flags/aruba.svg', 'svg-flags');
     * ```
     * @param {?} iconName
     * @param {?} url
     * @param {?=} fontSet
     * @return {?}
     */
    function (iconName, url, fontSet) {
        if (fontSet === void 0) { fontSet = ''; }
        if (iconName && url) {
            /** @type {?} */
            var safeUrl = this._sanitizer.bypassSecurityTrustResourceUrl(url);
            if (!safeUrl) {
                throw new Error("The provided URL could not be processed as trusted resource URL by Angular's DomSanitizer: \"" + url + "\".");
            }
            /** @type {?} */
            var sanitizedUrl = this._sanitizer.sanitize(SecurityContext.RESOURCE_URL, safeUrl);
            if (!sanitizedUrl) {
                throw new Error("The URL provided was not trusted as a resource URL: \"" + url + "\".");
            }
            this.fetchSvg(iconName, url, fontSet);
        }
        else {
            throw new Error('You should provide at least `iconName` and `url` to register an svg icon.');
        }
    };
    /**
     *  Adds an SVG image to the cache. SVG source is its text.
     *```typescript
     *   this.iconService.addSvgIcon('simple', '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200">
     *   <path d="M74 74h54v54H74" /></svg>', 'svg-flags');
     * ```
     */
    /**
     *  Adds an SVG image to the cache. SVG source is its text.
     * ```typescript
     *   this.iconService.addSvgIcon('simple', '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200">
     *   <path d="M74 74h54v54H74" /></svg>', 'svg-flags');
     * ```
     * @param {?} iconName
     * @param {?} iconText
     * @param {?=} fontSet
     * @return {?}
     */
    IgxIconService.prototype.addSvgIconFromText = /**
     *  Adds an SVG image to the cache. SVG source is its text.
     * ```typescript
     *   this.iconService.addSvgIcon('simple', '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 200 200">
     *   <path d="M74 74h54v54H74" /></svg>', 'svg-flags');
     * ```
     * @param {?} iconName
     * @param {?} iconText
     * @param {?=} fontSet
     * @return {?}
     */
    function (iconName, iconText, fontSet) {
        if (fontSet === void 0) { fontSet = ''; }
        if (iconName && iconText) {
            this.cacheSvgIcon(iconName, iconText, fontSet);
        }
        else {
            throw new Error('You should provide at least `iconName` and `iconText` to register an svg icon.');
        }
    };
    /**
     *  Returns wheather a given SVG image is present in the cache.
     *```typescript
     *   const isSvgCached = this.iconService.isSvgIconCached('aruba', 'svg-flags');
     * ```
     */
    /**
     *  Returns wheather a given SVG image is present in the cache.
     * ```typescript
     *   const isSvgCached = this.iconService.isSvgIconCached('aruba', 'svg-flags');
     * ```
     * @param {?} iconName
     * @param {?=} fontSet
     * @return {?}
     */
    IgxIconService.prototype.isSvgIconCached = /**
     *  Returns wheather a given SVG image is present in the cache.
     * ```typescript
     *   const isSvgCached = this.iconService.isSvgIconCached('aruba', 'svg-flags');
     * ```
     * @param {?} iconName
     * @param {?=} fontSet
     * @return {?}
     */
    function (iconName, fontSet) {
        if (fontSet === void 0) { fontSet = ''; }
        /** @type {?} */
        var iconKey = this.getSvgIconKey(iconName, fontSet);
        return this._cachedSvgIcons.has(iconKey);
    };
    /**
     *  Returns the key of a cached SVG image.
     *```typescript
     *   const svgIconKey = this.iconService.getSvgIconKey('aruba', 'svg-flags');
     * ```
     */
    /**
     *  Returns the key of a cached SVG image.
     * ```typescript
     *   const svgIconKey = this.iconService.getSvgIconKey('aruba', 'svg-flags');
     * ```
     * @param {?} iconName
     * @param {?=} fontSet
     * @return {?}
     */
    IgxIconService.prototype.getSvgIconKey = /**
     *  Returns the key of a cached SVG image.
     * ```typescript
     *   const svgIconKey = this.iconService.getSvgIconKey('aruba', 'svg-flags');
     * ```
     * @param {?} iconName
     * @param {?=} fontSet
     * @return {?}
     */
    function (iconName, fontSet) {
        if (fontSet === void 0) { fontSet = ''; }
        return fontSet + '_' + iconName;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @private
     * @param {?} iconName
     * @param {?} url
     * @param {?=} fontSet
     * @return {?}
     */
    IgxIconService.prototype.fetchSvg = /**
     * @hidden
     * @private
     * @param {?} iconName
     * @param {?} url
     * @param {?=} fontSet
     * @return {?}
     */
    function (iconName, url, fontSet) {
        var _this = this;
        if (fontSet === void 0) { fontSet = ''; }
        /** @type {?} */
        var request = this._httpClient.get(url, { responseType: 'text' });
        /** @type {?} */
        var subscription = request.subscribe(function (value) {
            _this.cacheSvgIcon(iconName, value, fontSet);
        }, function (error) {
            throw new Error("Could not fetch SVG from url: " + url + "; error: " + error.message);
        }, function () {
            subscription.unsubscribe();
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @private
     * @param {?} iconName
     * @param {?} value
     * @param {?=} fontSet
     * @return {?}
     */
    IgxIconService.prototype.cacheSvgIcon = /**
     * @hidden
     * @private
     * @param {?} iconName
     * @param {?} value
     * @param {?=} fontSet
     * @return {?}
     */
    function (iconName, value, fontSet) {
        if (fontSet === void 0) { fontSet = ''; }
        if (iconName && value) {
            this.ensureSvgContainerCreated();
            /** @type {?} */
            var div = this._document.createElement('DIV');
            div.innerHTML = value;
            /** @type {?} */
            var svg = (/** @type {?} */ (div.querySelector('svg')));
            if (svg) {
                /** @type {?} */
                var iconKey = this.getSvgIconKey(iconName, fontSet);
                svg.setAttribute('id', iconKey);
                svg.setAttribute('fit', '');
                svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
                svg.setAttribute('focusable', 'false'); // Disable IE11 default behavior to make SVGs focusable.
                if (this._cachedSvgIcons.has(iconKey)) {
                    /** @type {?} */
                    var oldChild = this._svgContainer.querySelector("svg[id='" + iconKey + "']");
                    this._svgContainer.removeChild(oldChild);
                }
                this._svgContainer.appendChild(svg);
                this._cachedSvgIcons.add(iconKey);
            }
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @private
     * @return {?}
     */
    IgxIconService.prototype.ensureSvgContainerCreated = /**
     * @hidden
     * @private
     * @return {?}
     */
    function () {
        if (!this._svgContainer) {
            this._svgContainer = this._document.documentElement.querySelector('.igx-svg-container');
            if (!this._svgContainer) {
                this._svgContainer = this._document.createElement('DIV');
                this._svgContainer.classList.add('igx-svg-container');
                this._document.documentElement.appendChild(this._svgContainer);
            }
        }
    };
    IgxIconService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    /** @nocollapse */
    IgxIconService.ctorParameters = function () { return [
        { type: DomSanitizer },
        { type: HttpClient },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
    ]; };
    /** @nocollapse */ IgxIconService.ngInjectableDef = defineInjectable({ factory: function IgxIconService_Factory() { return new IgxIconService(inject(DomSanitizer), inject(HttpClient), inject(DOCUMENT)); }, token: IgxIconService, providedIn: "root" });
    return IgxIconService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * **Ignite UI for Angular Icon** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/icon.html)
 *
 * The Ignite UI Icon makes it easy for developers to include material design icons directly in their markup. The icons
 * support custom colors and can be marked as active or disabled using the `isActive` property. This will change the appearence
 * of the icon.
 *
 * Example:
 * ```html
 * <igx-icon color="#00ff00" isActive="true">home</igx-icon>
 * ```
 * @type {?}
 */
var NEXT_ID$7 = 0;
var IgxIconComponent = /** @class */ (function () {
    function IgxIconComponent(_el, iconService) {
        this._el = _el;
        this.iconService = iconService;
        /**
         *  This allows you to change the value of `class.igx-icon`. By default it's `igx-icon`.
         * ```typescript
         * \@ViewChild("MyIcon") public icon: IgxIconComponent;
         * constructor(private cdRef:ChangeDetectorRef) {}
         * ngAfterViewInit() {
         *    this.icon.cssClass = "";
         *    this.cdRef.detectChanges();
         * }
         * ```
         */
        this.cssClass = 'igx-icon';
        /**
         *  This allows you to disable the `aria-hidden` attribute. By default it's applied.
         * ```typescript
         * \@ViewChild("MyIcon") public icon: IgxIconComponent;
         * constructor(private cdRef:ChangeDetectorRef) {}
         * ngAfterViewInit() {
         *    this.icon.ariaHidden = false;
         *    this.cdRef.detectChanges();
         * }
         * ```
         */
        this.ariaHidden = true;
        /**
         *  An \@Input property that sets the value of the `id` attribute.
         * ```html
         * <igx-icon id="igx-icon-1" fontSet="material" color="blue" [isActive]="false">settings</igx-icon>
         * ```
         */
        this.id = "igx-icon-" + NEXT_ID$7++;
        /**
         *  An \@Input property that allows you to disable the `active` property. By default it's applied.
         * ```html
         * <igx-icon [isActive]="false" fontSet="material" color="blue">settings</igx-icon>
         * ```
         */
        this.active = true;
        this.el = _el;
        this.font = this.iconService.defaultFontSet;
        this.iconService.registerFontSetAlias('material', 'material-icons');
    }
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxIconComponent.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.updateIconClass();
    };
    Object.defineProperty(IgxIconComponent.prototype, "getFontSet", {
        /**
         *  An accessor that returns the value of the font property.
         *```typescript
         *@ViewChild("MyIcon")
         *public icon: IgxIconComponent;
         *ngAfterViewInit() {
         *    let iconFont = this.icon.getFontSet;
         * }
         * ```
         */
        get: /**
         *  An accessor that returns the value of the font property.
         * ```typescript
         * \@ViewChild("MyIcon")
         * public icon: IgxIconComponent;
         * ngAfterViewInit() {
         *    let iconFont = this.icon.getFontSet;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this.font;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxIconComponent.prototype, "getActive", {
        /**
         *  An accessor that returns the value of the active property.
         *```typescript
         *@ViewChild("MyIcon")
         *public icon: IgxIconComponent;
         *ngAfterViewInit() {
         *    let iconActive = this.icon.getActive;
         * }
         * ```
         */
        get: /**
         *  An accessor that returns the value of the active property.
         * ```typescript
         * \@ViewChild("MyIcon")
         * public icon: IgxIconComponent;
         * ngAfterViewInit() {
         *    let iconActive = this.icon.getActive;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this.active;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxIconComponent.prototype, "getInactive", {
        /**
         *  An accessor that returns inactive property.
         *```typescript
         *@ViewChild("MyIcon")
         *public icon: IgxIconComponent;
         *ngAfterViewInit() {
         *    let iconActive = this.icon.getInactive;
         * }
         * ```
         */
        get: /**
         *  An accessor that returns inactive property.
         * ```typescript
         * \@ViewChild("MyIcon")
         * public icon: IgxIconComponent;
         * ngAfterViewInit() {
         *    let iconActive = this.icon.getInactive;
         * }
         * ```
         * @return {?}
         */
        function () {
            return !this.active;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxIconComponent.prototype, "getIconColor", {
        /**
         *  An accessor that returns the opposite value of the `iconColor` property.
         *```typescript
         *@ViewChild("MyIcon")
         *public icon: IgxIconComponent;
         *ngAfterViewInit() {
         *    let iconColor = this.icon.getIconColor;
         * }
         * ```
         */
        get: /**
         *  An accessor that returns the opposite value of the `iconColor` property.
         * ```typescript
         * \@ViewChild("MyIcon")
         * public icon: IgxIconComponent;
         * ngAfterViewInit() {
         *    let iconColor = this.icon.getIconColor;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this.iconColor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxIconComponent.prototype, "getIconName", {
        /**
         *  An accessor that returns the value of the iconName property.
         *```typescript
         *@ViewChild("MyIcon")
         *public icon: IgxIconComponent;
         *ngAfterViewInit() {
         *    let iconName = this.icon.getIconName;
         * }
         * ```
         */
        get: /**
         *  An accessor that returns the value of the iconName property.
         * ```typescript
         * \@ViewChild("MyIcon")
         * public icon: IgxIconComponent;
         * ngAfterViewInit() {
         *    let iconName = this.icon.getIconName;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this.iconName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxIconComponent.prototype, "getSvgKey", {
        /**
         *  An accessor that returns the key of the SVG image.
         *  The key consists of the fontSet and the iconName separated by underscore.
         *```typescript
         *@ViewChild("MyIcon")
         *public icon: IgxIconComponent;
         *ngAfterViewInit() {
         *    let svgKey = this.icon.getSvgKey;
         * }
         * ```
         */
        get: /**
         *  An accessor that returns the key of the SVG image.
         *  The key consists of the fontSet and the iconName separated by underscore.
         * ```typescript
         * \@ViewChild("MyIcon")
         * public icon: IgxIconComponent;
         * ngAfterViewInit() {
         *    let svgKey = this.icon.getSvgKey;
         * }
         * ```
         * @return {?}
         */
        function () {
            if (this.iconService.isSvgIconCached(this.iconName, this.font)) {
                return '#' + this.iconService.getSvgIconKey(this.iconName, this.font);
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxIconComponent.prototype, "template", {
        /**
         *   An accessor that returns a TemplateRef to explicit, svg or no ligature.
         *```typescript
         *@ViewChild("MyIcon")
         *public icon: IgxIconComponent;
         *ngAfterViewInit() {
         *    let iconTemplate = this.icon.template;
         * }
         * ```
         */
        get: /**
         *   An accessor that returns a TemplateRef to explicit, svg or no ligature.
         * ```typescript
         * \@ViewChild("MyIcon")
         * public icon: IgxIconComponent;
         * ngAfterViewInit() {
         *    let iconTemplate = this.icon.template;
         * }
         * ```
         * @return {?}
         */
        function () {
            if (this.iconName) {
                if (this.iconService.isSvgIconCached(this.iconName, this.font)) {
                    return this.svgImage;
                }
                return this.noLigature;
            }
            return this.explicitLigature;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @private
     * @return {?}
     */
    IgxIconComponent.prototype.updateIconClass = /**
     * @hidden
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var className = this.iconService.fontSetClassName(this.font);
        this.el.nativeElement.classList.add(className);
        if (this.iconName && !this.iconService.isSvgIconCached(this.iconName, this.font)) {
            this.el.nativeElement.classList.add(this.iconName);
        }
    };
    IgxIconComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-icon',
                    template: "<ng-template #noLigature></ng-template>\n\n<ng-template #explicitLigature>\n    <ng-content></ng-content>\n</ng-template>\n\n<ng-template #svgImage>\n    <svg>\n        <use [attr.href]=\"getSvgKey\"></use>\n    </svg>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template\"></ng-container>\n"
                }] }
    ];
    /** @nocollapse */
    IgxIconComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: IgxIconService }
    ]; };
    IgxIconComponent.propDecorators = {
        noLigature: [{ type: ViewChild, args: ['noLigature', { read: TemplateRef },] }],
        explicitLigature: [{ type: ViewChild, args: ['explicitLigature', { read: TemplateRef },] }],
        svgImage: [{ type: ViewChild, args: ['svgImage', { read: TemplateRef },] }],
        cssClass: [{ type: HostBinding, args: ['class.igx-icon',] }],
        ariaHidden: [{ type: HostBinding, args: ['attr.aria-hidden',] }],
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        font: [{ type: Input, args: ['fontSet',] }],
        active: [{ type: Input, args: ['isActive',] }],
        iconColor: [{ type: Input, args: ['color',] }],
        iconName: [{ type: Input, args: ['name',] }],
        getInactive: [{ type: HostBinding, args: ['class.igx-icon--inactive',] }],
        getIconColor: [{ type: HostBinding, args: ['style.color',] }]
    };
    return IgxIconComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxIconModule = /** @class */ (function () {
    function IgxIconModule() {
    }
    /**
     * @return {?}
     */
    IgxIconModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: IgxIconModule
        };
    };
    IgxIconModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxIconComponent],
                    exports: [IgxIconComponent],
                    imports: [CommonModule, HttpClientModule]
                },] }
    ];
    __decorate([
        DeprecateMethod('IgxIconModule.forRoot method is deprecated. Use IgxIconModule instead.'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], IgxIconModule, "forRoot", null);
    return IgxIconModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var NEXT_ID$8 = 0;
/** @enum {string} */
var Size$1 = {
    SMALL: 'small',
    MEDIUM: 'medium',
    LARGE: 'large',
};
/** @enum {string} */
var AvatarType = {
    DEFAULT: 'default',
    INITIALS: 'initials',
    IMAGE: 'image',
    ICON: 'icon',
};
/**
 * **Ignite UI for Angular Avatar** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/avatar.html)
 *
 * The Ignite UI Avatar provides an easy way to add an avatar icon to your application.  This icon can be an
 * image, someone's initials or a material icon from the google material icon set.
 *
 * Example:
 * ```html
 * <igx-avatar initials="MS" roundShape="true" size="large">
 * </igx-avatar>
 * ```
 */
var IgxAvatarComponent = /** @class */ (function () {
    function IgxAvatarComponent(elementRef) {
        this.elementRef = elementRef;
        /**
         * Returns the `aria-label` of the avatar.
         *
         * ```typescript
         * let ariaLabel = this.avatar.ariaLabel;
         * ```
         *
         */
        this.ariaLabel = 'avatar';
        /**
         * Returns the `role` attribute of the avatar.
         *
         * ```typescript
         * let avatarRole = this.avatar.role;
         * ```
         *
         * \@memberof IgxAvatarComponent
         */
        this.role = 'img';
        /**
         * Returns the class of the avatar.
         *
         * ```typescript
         * let avatarCLass =  this.avatar.cssClass;
         * ```
         *
         * \@memberof IgxAvatarComponent
         */
        this.cssClass = 'igx-avatar';
        /**
         * @hidden
         */
        this._size = 'small';
        /**
         * Sets the `id` of the avatar. If not set, the first avatar component will have `id` = `"igx-avatar-0"`.
         *
         * ```html
         * <igx-avatar id="my-first-avatar"></igx-avatar>
         * ```
         *
         * \@memberof IgxAvatarComponent
         */
        this.id = "igx-avatar-" + NEXT_ID$8++;
        /**
         * Sets a round shape to the avatar if `roundShape` is `"true"`.
         * By default the shape of the avatar is a square.
         *
         * ```html
         * <igx-avatar roundShape = "true" ></igx-avatar>
         * ```
         *
         * \@memberof IgxAvatarComponent
         */
        this.roundShape = false;
    }
    Object.defineProperty(IgxAvatarComponent.prototype, "size", {
        /**
         * Returns the `size` of the avatar.
         *
         * ```typescript
         *let avatarSize =  this.avatar.size;
         * ```
         *
         * @memberof IgxAvatarComponent
         */
        get: /**
         * Returns the `size` of the avatar.
         *
         * ```typescript
         * let avatarSize =  this.avatar.size;
         * ```
         *
         * \@memberof IgxAvatarComponent
         * @return {?}
         */
        function () {
            return this._size;
        },
        /**
         * Sets the `size`  of the avatar.
         * By default the `size` is `"small"`. It can be set to `"medium"` or `"large"`.
         *
         * ```
         * <igx-avatar size="large"></igx-avatar>
         * ```
         *
         * @memberof IgxAvatarComponent
         */
        set: /**
         * Sets the `size`  of the avatar.
         * By default the `size` is `"small"`. It can be set to `"medium"` or `"large"`.
         *
         * ```
         * <igx-avatar size="large"></igx-avatar>
         * ```
         *
         * \@memberof IgxAvatarComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            switch (value) {
                case 'small':
                case 'medium':
                case 'large':
                    this._size = value;
                    break;
                default:
                    this._size = 'small';
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxAvatarComponent.prototype, "type", {
        /**
         * Returns the type of the avatar.
         *
         * ```typescript
         * let avatarType = this.avatar.type;
         * ```
         *
         * @memberof IgxAvatarComponent
         */
        get: /**
         * Returns the type of the avatar.
         *
         * ```typescript
         * let avatarType = this.avatar.type;
         * ```
         *
         * \@memberof IgxAvatarComponent
         * @return {?}
         */
        function () {
            if (this.src) {
                return AvatarType.IMAGE;
            }
            if (this.icon) {
                return AvatarType.ICON;
            }
            if (this.initials) {
                return AvatarType.INITIALS;
            }
            return AvatarType.DEFAULT;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxAvatarComponent.prototype, "template", {
        /**
         * Returns the template of the avatar.
         *
         * ```typescript
         * let template = this.avatar.template;
         * ```
         *
         * @memberof IgxAvatarComponent
         */
        get: /**
         * Returns the template of the avatar.
         *
         * ```typescript
         * let template = this.avatar.template;
         * ```
         *
         * \@memberof IgxAvatarComponent
         * @return {?}
         */
        function () {
            switch (this.type) {
                case AvatarType.IMAGE:
                    return this.imageTemplate;
                case AvatarType.INITIALS:
                    return this.initialsTemplate;
                case AvatarType.ICON:
                    return this.iconTemplate;
                default:
                    return this.defaultTemplate;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxAvatarComponent.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.roleDescription = this.getRole();
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxAvatarComponent.prototype.ngAfterViewInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.elementRef.nativeElement.classList
            .add("igx-avatar--" + this._size, "igx-avatar--" + this.type);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @private
     * @return {?}
     */
    IgxAvatarComponent.prototype.getRole = /**
     * @hidden
     * @private
     * @return {?}
     */
    function () {
        switch (this.type) {
            case AvatarType.IMAGE:
                return 'image avatar';
            case AvatarType.ICON:
                return 'icon avatar';
            case AvatarType.INITIALS:
                return 'initials avatar';
            default:
                return 'custom avatar';
        }
    };
    /**
     * Returns the url of the `image`.
     *
     * ```typescript
     * let imageSourceUrl = this.avatar.getSrcUrl();
     * ```
     *
     * @memberof IgxAvatarComponent
     */
    /**
     * Returns the url of the `image`.
     *
     * ```typescript
     * let imageSourceUrl = this.avatar.getSrcUrl();
     * ```
     *
     * \@memberof IgxAvatarComponent
     * @return {?}
     */
    IgxAvatarComponent.prototype.getSrcUrl = /**
     * Returns the url of the `image`.
     *
     * ```typescript
     * let imageSourceUrl = this.avatar.getSrcUrl();
     * ```
     *
     * \@memberof IgxAvatarComponent
     * @return {?}
     */
    function () {
        return "url(" + this.src + ")";
    };
    IgxAvatarComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-avatar',
                    template: "<ng-template #defaultTemplate>\n    <ng-content></ng-content>\n</ng-template>\n\n<ng-template #imageTemplate>\n    <div #image class=\"igx-avatar__image\" [style.backgroundImage]=\"getSrcUrl()\"></div>\n</ng-template>\n\n<ng-template #initialsTemplate>\n    <span>{{initials.substring(0, 2)}}</span>\n</ng-template>\n\n<ng-template #iconTemplate>\n     <igx-icon>{{icon}}</igx-icon>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template\"></ng-container>\n"
                }] }
    ];
    /** @nocollapse */
    IgxAvatarComponent.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    IgxAvatarComponent.propDecorators = {
        image: [{ type: ViewChild, args: ['image',] }],
        defaultTemplate: [{ type: ViewChild, args: ['defaultTemplate', { read: TemplateRef },] }],
        imageTemplate: [{ type: ViewChild, args: ['imageTemplate', { read: TemplateRef },] }],
        initialsTemplate: [{ type: ViewChild, args: ['initialsTemplate', { read: TemplateRef },] }],
        iconTemplate: [{ type: ViewChild, args: ['iconTemplate', { read: TemplateRef },] }],
        ariaLabel: [{ type: HostBinding, args: ['attr.aria-label',] }],
        role: [{ type: HostBinding, args: ['attr.role',] }],
        cssClass: [{ type: HostBinding, args: ['class.igx-avatar',] }],
        roleDescription: [{ type: HostBinding, args: ['attr.aria-roledescription',] }],
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        roundShape: [{ type: HostBinding, args: ['class.igx-avatar--rounded',] }, { type: Input }],
        color: [{ type: HostBinding, args: ['style.color',] }, { type: Input }],
        bgColor: [{ type: HostBinding, args: ['style.background',] }, { type: Input }],
        initials: [{ type: Input }],
        icon: [{ type: Input }],
        src: [{ type: Input }],
        size: [{ type: Input }]
    };
    return IgxAvatarComponent;
}());
/**
 * @hidden
 */
var IgxAvatarModule = /** @class */ (function () {
    function IgxAvatarModule() {
    }
    IgxAvatarModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxAvatarComponent],
                    exports: [IgxAvatarComponent],
                    imports: [CommonModule, IgxIconModule]
                },] }
    ];
    return IgxAvatarModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var NEXT_ID$9 = 0;
/** @enum {string} */
var Type = {
    DEFAULT: 'default',
    INFO: 'info',
    SUCCESS: 'success',
    WARNING: 'warning',
    ERROR: 'error',
};
/**
 * **Ignite UI for Angular Badge** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/badge.html)
 *
 * The Ignite UI Badge is used to decorate avatars, navigation menus, or other components in the
 * application when visual notification is needed. They are usually designed as icons with a predefined
 * style to communicate information, success, warnings, or errors.
 *
 * Example:
 * ```html
 * <igx-avatar icon="person" roundShape="true" size="small">
 *   <igx-badge icon="check" type="success" class="badge-style">
 *   </igx-badge>
 * </igx-avatar>
 * ```
 * The `badge-style` class is used to position the badge:
 * ```css
 * .badge-style {
 *   position: absolute;
 *   bottom: -6px;
 *   right:-50px;
 * }
 * ```
 */
var IgxBadgeComponent = /** @class */ (function () {
    function IgxBadgeComponent() {
        /**
         * An \@Input property that sets the value of the `id` attribute.
         * ```html
         * <igx-badge id="igx-badge-2" icon="check" type="success" class="badge-style"></igx-badge>
         * ```
         */
        this.id = "igx-badge-" + NEXT_ID$9++;
        /**
         * An \@Input property controlling the type of the badge.
         * Allowed values are `default`, `info`, `success`, `warning`, `error`.
         * Providing an invalid value won't display a badge.
         * ```html
         * <igx-badge type="success" icon="check" class="badge-style"></igx-badge>
         * ```
         */
        this.type = 'default';
        /**
         * An \@Input property that sets the value to be displayed inside the badge.
         * If an `icon` property is already set the `icon` will be displayed.
         * If neither a `value` nor an `icon` is set the contentent of the badge will be empty.
         * ```html
         * <igx-badge value="11" type="success" class="badge-style"></igx-badge>
         * ```
         */
        this.value = '';
        /**
         * This allows you to set value to role attribute.
         * ```html
         * \@ViewChild("MyBadge", { read: IgxBadgeComponent })
         * public badge: IgxBadgeComponent;
         * //...
         * badge.label = "badge-status";
         * ```
         */
        this.role = 'status';
        /**
         * This allows you to disable igx-badge class. The default it's applied.
         * ```html
         * \@ViewChild("MyBadge", { read: IgxBadgeComponent })
         * public badge: IgxBadgeComponent;
         * //...
         * badge.cssClass = false;
         * ```
         */
        this.cssClass = 'igx-badge';
        /**
         * This allows you to set value to aria-label attribute.
         * ```html
         * \@ViewChild("MyBadge", { read: IgxBadgeComponent })
         * public badge: IgxBadgeComponent;
         * //...
         * badge.label = "icon-badge";
         * ```
         */
        this.label = 'badge';
    }
    Object.defineProperty(IgxBadgeComponent.prototype, "roleDescription", {
        /**
         * @hidden
         * Defines a human-readable, accessor, author-localized description for the `type` and the `icon` or `value` of the element.
         */
        get: /**
         * @hidden
         * Defines a human-readable, accessor, author-localized description for the `type` and the `icon` or `value` of the element.
         * @return {?}
         */
        function () {
            /** @type {?} */
            var message;
            // tslint:disable-next-line:prefer-conditional-expression
            if (this.icon) {
                message = this.type + ' type badge with icon type ' + this.icon;
            }
            else if (this.value) {
                message = this.type + ' badge type with value ' + this.value;
            }
            else {
                message = this.type + ' badge type without value';
            }
            return message;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     * Method which makes the name of the class more descriptive.
     * This helps the styling of the badges.
     */
    /**
     * @hidden
     * Method which makes the name of the class more descriptive.
     * This helps the styling of the badges.
     * @return {?}
     */
    IgxBadgeComponent.prototype.setClasses = /**
     * @hidden
     * Method which makes the name of the class more descriptive.
     * This helps the styling of the badges.
     * @return {?}
     */
    function () {
        var _a, _b, _c, _d, _e;
        /** @type {?} */
        var classes = {};
        switch (Type[this.type.toUpperCase()]) {
            case Type.DEFAULT:
                classes = (_a = {},
                    _a[this.cssClass + "__circle--default"] = true,
                    _a);
                break;
            case Type.INFO:
                classes = (_b = {},
                    _b[this.cssClass + "__circle--info"] = true,
                    _b);
                break;
            case Type.SUCCESS:
                classes = (_c = {},
                    _c[this.cssClass + "__circle--success"] = true,
                    _c);
                break;
            case Type.WARNING:
                classes = (_d = {},
                    _d[this.cssClass + "__circle--warning"] = true,
                    _d);
                break;
            case Type.ERROR:
                classes = (_e = {},
                    _e[this.cssClass + "__circle--error"] = true,
                    _e);
                break;
        }
        return classes;
    };
    IgxBadgeComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-badge',
                    template: "<div class=\"igx-badge__circle\" [ngClass]=\"setClasses()\" [attr.aria-roledescription]=\"roleDescription\">\n    <span *ngIf=\"!icon\" class=\"igx-badge__circle-value\">{{value}}</span>\n    <igx-icon *ngIf=\"icon\" fontSet=\"material\">{{icon}}</igx-icon>\n</div>\n"
                }] }
    ];
    IgxBadgeComponent.propDecorators = {
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        type: [{ type: Input }],
        value: [{ type: Input }],
        icon: [{ type: Input }],
        role: [{ type: HostBinding, args: ['attr.role',] }],
        cssClass: [{ type: HostBinding, args: ['class.igx-badge',] }],
        label: [{ type: HostBinding, args: ['attr.aria-label',] }]
    };
    return IgxBadgeComponent;
}());
/**
 * @hidden
 */
var IgxBadgeModule = /** @class */ (function () {
    function IgxBadgeModule() {
    }
    IgxBadgeModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxBadgeComponent],
                    exports: [IgxBadgeComponent],
                    imports: [CommonModule, IgxIconModule]
                },] }
    ];
    return IgxBadgeModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 * @type {?}
 */
var IGX_EXPANSION_PANEL_COMPONENT = 'IgxExpansionPanelToken';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxExpansionPanelBodyComponent = /** @class */ (function () {
    function IgxExpansionPanelBodyComponent(panel, element, cdr) {
        this.panel = panel;
        this.element = element;
        this.cdr = cdr;
        this._labelledBy = '';
        this._label = '';
        /**
         * @hidden
         */
        this.cssClass = "igx-expansion-panel__body";
        /**
         * Gets/sets the `role` attribute of the panel body
         * Default is 'region';
         * Get
         * ```typescript
         *  const currentRole = this.panel.body.role;
         * ```
         * Set
         * ```typescript
         *  this.panel.body.role = 'content';
         * ```
         * ```html
         *  <igx-expansion-panel-body [role]="'custom'"></igx-expansion-panel-body>
         * ```
         */
        this.role = 'region';
    }
    Object.defineProperty(IgxExpansionPanelBodyComponent.prototype, "label", {
        /**
         * Gets the `aria-label` attribute of the panel body
         * Defaults to the panel id with '-region' in the end;
         * Get
         * ```typescript
         *  const currentLabel = this.panel.body.label;
         * ```
         */
        get: /**
         * Gets the `aria-label` attribute of the panel body
         * Defaults to the panel id with '-region' in the end;
         * Get
         * ```typescript
         *  const currentLabel = this.panel.body.label;
         * ```
         * @return {?}
         */
        function () {
            return this._label || this.panel.id + '-region';
        },
        /**
         * Sets the `aria-label` attribute of the panel body
         * ```typescript
         *  this.panel.body.label = 'my-custom-label';
         * ```
         * ```html
         *  <igx-expansion-panel-body [label]="'my-custom-label'"></igx-expansion-panel-body>
         * ```
         */
        set: /**
         * Sets the `aria-label` attribute of the panel body
         * ```typescript
         *  this.panel.body.label = 'my-custom-label';
         * ```
         * ```html
         *  <igx-expansion-panel-body [label]="'my-custom-label'"></igx-expansion-panel-body>
         * ```
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._label = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxExpansionPanelBodyComponent.prototype, "labelledBy", {
        /**
         * Gets the `aria-labelledby` attribute of the panel body
         * Defaults to the panel header id;
         * Get
         * ```typescript
         *  const currentLabel = this.panel.body.labelledBy;
         * ```
         */
        get: /**
         * Gets the `aria-labelledby` attribute of the panel body
         * Defaults to the panel header id;
         * Get
         * ```typescript
         *  const currentLabel = this.panel.body.labelledBy;
         * ```
         * @return {?}
         */
        function () {
            return this._labelledBy;
        },
        /**
         * Sets the `aria-labelledby` attribute of the panel body
         * ```typescript
         *  this.panel.body.labelledBy = 'my-custom-id';
         * ```
         * ```html
         *  <igx-expansion-panel-body [labelledBy]="'my-custom-id'"></igx-expansion-panel-body>
         * ```
         */
        set: /**
         * Sets the `aria-labelledby` attribute of the panel body
         * ```typescript
         *  this.panel.body.labelledBy = 'my-custom-id';
         * ```
         * ```html
         *  <igx-expansion-panel-body [labelledBy]="'my-custom-id'"></igx-expansion-panel-body>
         * ```
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._labelledBy = val;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    IgxExpansionPanelBodyComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.labelledBy = this.panel.headerId;
        this.label = this.panel.id + '-region';
    };
    IgxExpansionPanelBodyComponent.decorators = [
        { type: Component, args: [{
                    // tslint:disable-next-line:directive-selector
                    selector: 'igx-expansion-panel-body',
                    template: "<ng-content></ng-content>"
                }] }
    ];
    /** @nocollapse */
    IgxExpansionPanelBodyComponent.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [IGX_EXPANSION_PANEL_COMPONENT,] }] },
        { type: ElementRef },
        { type: ChangeDetectorRef }
    ]; };
    IgxExpansionPanelBodyComponent.propDecorators = {
        cssClass: [{ type: HostBinding, args: ['class.igx-expansion-panel__body',] }],
        label: [{ type: Input }, { type: HostBinding, args: ['attr.aria-label',] }],
        labelledBy: [{ type: Input }, { type: HostBinding, args: ['attr.aria-labelledby',] }],
        role: [{ type: Input }, { type: HostBinding, args: ['attr.role',] }]
    };
    return IgxExpansionPanelBodyComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxExpansionPanelTitleDirective = /** @class */ (function () {
    function IgxExpansionPanelTitleDirective() {
        this.cssClass = "igx-expansion-panel__header-title";
    }
    IgxExpansionPanelTitleDirective.decorators = [
        { type: Directive, args: [{
                    // tslint:disable-next-line:directive-selector
                    selector: 'igx-expansion-panel-title'
                },] }
    ];
    IgxExpansionPanelTitleDirective.propDecorators = {
        cssClass: [{ type: HostBinding, args: ['class.igx-expansion-panel__header-title',] }]
    };
    return IgxExpansionPanelTitleDirective;
}());
/**
 * @hidden
 */
var IgxExpansionPanelDescriptionDirective = /** @class */ (function () {
    function IgxExpansionPanelDescriptionDirective() {
        this.cssClass = "igx-expansion-panel__header-description";
    }
    IgxExpansionPanelDescriptionDirective.decorators = [
        { type: Directive, args: [{
                    // tslint:disable-next-line:directive-selector
                    selector: 'igx-expansion-panel-description'
                },] }
    ];
    IgxExpansionPanelDescriptionDirective.propDecorators = {
        cssClass: [{ type: HostBinding, args: ['class.igx-expansion-panel__header-description',] }]
    };
    return IgxExpansionPanelDescriptionDirective;
}());
/**
 * @hidden
 */
var IgxExpansionPanelIconDirective = /** @class */ (function () {
    function IgxExpansionPanelIconDirective() {
    }
    IgxExpansionPanelIconDirective.decorators = [
        { type: Directive, args: [{
                    // tslint:disable-next-line:directive-selector
                    selector: 'igx-expansion-panel-icon'
                },] }
    ];
    return IgxExpansionPanelIconDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var ICON_POSITION = {
    LEFT: 'left',
    NONE: 'none',
    RIGHT: 'right',
};
var IgxExpansionPanelHeaderComponent = /** @class */ (function () {
    function IgxExpansionPanelHeaderComponent(panel, cdr, elementRef) {
        this.panel = panel;
        this.cdr = cdr;
        this.elementRef = elementRef;
        // properties section
        this._iconTemplate = false;
        /**
         * Sets/gets the `id` of the expansion panel header.
         * ```typescript
         * let panelHeaderId =  this.panel.header.id;
         * ```
         * \@memberof IgxExpansionPanelComponent
         */
        this.id = '';
        /**
         * Gets/sets the `aria-level` attribute of the header
         * Get
         * ```typescript
         *  const currentAriaLevel = this.panel.header.lv;
         * ```
         * Set
         * ```typescript
         *  this.panel.header.lv = '5';
         * ```
         * ```html
         *  <igx-expansion-panel-header [lv]="myCustomLevel"></igx-expansion-panel-header>
         * ```
         */
        this.lv = '3';
        /**
         * Gets/sets the `role` attribute of the header
         * Get
         * ```typescript
         *  const currentRole = this.panel.header.role;
         * ```
         * Set
         * ```typescript
         *  this.panel.header.role = '5';
         * ```
         * ```html
         *  <igx-expansion-panel-header [role]="'custom'"></igx-expansion-panel-header>
         * ```
         */
        this.role = 'heading';
        /**
         * Gets/sets the position of the expansion-panel-header expand/collapse icon
         * Accepts `left`, `right` or `none`
         * ```typescript
         *  const currentIconPosition = this.panel.header.iconPosition;
         * ```
         * Set
         * ```typescript
         *  this.panel.header.iconPosition = 'left';
         * ```
         * ```html
         *  <igx-expansion-panel-header [iconPosition]="'right'"></igx-expansion-panel-header>
         * ```
         */
        this.iconPosition = ICON_POSITION.LEFT;
        /**
         * Emitted whenever a user interacts with the header host
         * ```typescript
         *  handleInteraction(event: IExpansionPanelEventArgs) {
         *  ...
         * }
         * ```
         * ```html
         *  <igx-expansion-panel-header (onInteraction)="handleInteraction($event)">
         *      ...
         *  </igx-expansion-panel-header>
         * ```
         */
        this.onInteraction = new EventEmitter();
        /**
         * @hidden
         */
        this.cssClass = 'igx-expansion-panel__header';
        /**
         * Gets/sets the whether the header is disabled
         * When disabled, the header will not handle user events and will stop their propagation
         *
         * ```typescript
         *  const isDisabled = this.panel.header.disabled;
         * ```
         * Set
         * ```typescript
         *  this.panel.header.disabled = true;
         * ```
         * ```html
         *  <igx-expansion-panel-header [disabled]="true">
         *     ...
         *  </igx-expansion-panel-header>
         * ```
         */
        this.disabled = false;
        this.id = this.panel.id + "-header";
    }
    Object.defineProperty(IgxExpansionPanelHeaderComponent.prototype, "iconTemplate", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._iconTemplate;
        },
        /**
         * @hidden
         */
        set: /**
         * @hidden
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._iconTemplate = (/** @type {?} */ (val));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxExpansionPanelHeaderComponent.prototype, "controls", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.panel.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxExpansionPanelHeaderComponent.prototype, "isExpanded", {
        /**
        * @hidden
        */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return !this.panel.collapsed;
        },
        enumerable: true,
        configurable: true
    });
    /**
    * @hidden
    */
    /**
     * @hidden
     * @param {?=} evt
     * @return {?}
     */
    IgxExpansionPanelHeaderComponent.prototype.onAction = /**
     * @hidden
     * @param {?=} evt
     * @return {?}
     */
    function (evt) {
        if (this.disabled) {
            evt.stopPropagation();
            return;
        }
        this.onInteraction.emit({ event: evt, panel: this.panel });
        this.panel.toggle(evt);
        evt.preventDefault();
    };
    /** @hidden @internal */
    /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    IgxExpansionPanelHeaderComponent.prototype.openPanel = /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.altKey) {
            this.panel.expand(event);
            this.onInteraction.emit({ event: event, panel: this.panel });
        }
    };
    /** @hidden @internal */
    /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    IgxExpansionPanelHeaderComponent.prototype.closePanel = /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.altKey) {
            this.panel.collapse(event);
            this.onInteraction.emit({ event: event, panel: this.panel });
        }
    };
    Object.defineProperty(IgxExpansionPanelHeaderComponent.prototype, "iconPositionClass", {
        /**
        * @hidden
        */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            switch (this.iconPosition) {
                case (ICON_POSITION.LEFT):
                    return "igx-expansion-panel__header-icon--start";
                case (ICON_POSITION.RIGHT):
                    return "igx-expansion-panel__header-icon--end";
                case (ICON_POSITION.NONE):
                    return "igx-expansion-panel__header-icon--none";
                default:
                    return '';
            }
        },
        enumerable: true,
        configurable: true
    });
    IgxExpansionPanelHeaderComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-expansion-panel-header',
                    template: "<div class=\"igx-expansion-panel__header-inner\" tabindex=\"0\" role=\"button\" [attr.id]=\"id\"\n[attr.aria-disabled]=\"disabled\" [attr.aria-expanded]=\"isExpanded\" [attr.aria-controls]=\"controls\">\n    <div class=\"igx-expansion-panel__title-wrapper\">\n        <ng-content select=\"igx-expansion-panel-title\"></ng-content>\n        <ng-content select=\"igx-expansion-panel-description\"></ng-content>\n    </div>\n    <ng-content></ng-content>\n    <div [class]=\"iconPositionClass\">\n        <ng-content *ngIf=\"iconTemplate\" select=\"igx-expansion-panel-icon\"></ng-content>\n        <igx-icon *ngIf=\"!iconTemplate\" fontSet=\"material\">\n            {{panel.collapsed? 'expand_more':'expand_less'}}\n        </igx-icon>\n    </div>\n</div>\n"
                }] }
    ];
    /** @nocollapse */
    IgxExpansionPanelHeaderComponent.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Host }, { type: Inject, args: [IGX_EXPANSION_PANEL_COMPONENT,] }] },
        { type: ChangeDetectorRef },
        { type: ElementRef }
    ]; };
    IgxExpansionPanelHeaderComponent.propDecorators = {
        iconTemplate: [{ type: ContentChild, args: [IgxExpansionPanelIconDirective,] }],
        lv: [{ type: HostBinding, args: ['attr.aria-level',] }, { type: Input }],
        role: [{ type: HostBinding, args: ['attr.role',] }, { type: Input }],
        iconPosition: [{ type: Input }],
        onInteraction: [{ type: Output }],
        cssClass: [{ type: HostBinding, args: ['class.igx-expansion-panel__header',] }],
        isExpanded: [{ type: HostBinding, args: ['class.igx-expansion-panel__header--expanded',] }],
        disabled: [{ type: Input }, { type: HostBinding, args: ['class.igx-expansion-panel--disabled',] }],
        onAction: [{ type: HostListener, args: ['keydown.Enter', ['$event'],] }, { type: HostListener, args: ['keydown.Space', ['$event'],] }, { type: HostListener, args: ['keydown.Spacebar', ['$event'],] }, { type: HostListener, args: ['click', ['$event'],] }],
        openPanel: [{ type: HostListener, args: ['keydown.Alt.ArrowDown', ['$event'],] }],
        closePanel: [{ type: HostListener, args: ['keydown.Alt.ArrowUp', ['$event'],] }]
    };
    return IgxExpansionPanelHeaderComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var NEXT_ID$a = 0;
var IgxExpansionPanelComponent = /** @class */ (function () {
    function IgxExpansionPanelComponent(cdr, builder) {
        this.cdr = cdr;
        this.builder = builder;
        /**
         * Sets/gets the animation settings of the expansion panel component
         * Open and Close animation should be passed
         *
         * Get
         * ```typescript
         *  const currentAnimations = this.panel.animationSettings;
         * ```
         * Set
         * ```typescript
         *  import { slideInLeft, slideOutRight } from 'igniteui-angular';
         *  ...
         *  this.panel.animationsSettings = {
         *      openAnimation: slideInLeft,
         *      closeAnimation: slideOutRight
         * };
         * ```
         * or via template
         * ```typescript
         *  import { slideInLeft, slideOutRight } from 'igniteui-angular';
         *  ...
         *  myCustomAnimationObject = {
         *      openAnimation: slideInLeft,
         *      closeAnimation: slideOutRight
         * };
         * ```html
         *  <igx-expansion-panel [animationSettings]='myCustomAnimationObject'>
         *  ...
         *  </igx-expansion-panel>
         * ```
         */
        this.animationSettings = {
            openAnimation: growVerIn,
            closeAnimation: growVerOut
        };
        /**
         * Sets/gets the `id` of the expansion panel component.
         * If not set, `id` will have value `"igx-expansion-panel-0"`;
         * ```html
         * <igx-expansion-panel id = "my-first-expansion-panel"></igx-expansion-panel>
         * ```
         * ```typescript
         * let panelId =  this.panel.id;
         * ```
         * \@memberof IgxExpansionPanelComponent
         */
        this.id = "igx-expansion-panel-" + NEXT_ID$a++;
        /**
         * @hidden
         */
        this.cssClass = 'igx-expansion-panel';
        /**
         * Gets/sets whether the component is collapsed (its content is hidden)
         * Get
         * ```typescript
         *  const myPanelState: boolean = this.panel.collapsed;
         * ```
         * Set
         * ```html
         *  this.panel.collapsed = true;
         * ```
         */
        this.collapsed = true;
        /**
         * Emitted when the expansion panel finishes collapsing
         * ```typescript
         *  handleCollapsed(event: {
         *  panel: IgxExpansionPanelComponent,
         *  event: Event
         * })
         * ```
         * ```html
         *  <igx-expansion-panel (onCollapsed)="handleCollapsed($event)">
         *      ...
         *  </igx-expansion-panel>
         * ```
         */
        this.onCollapsed = new EventEmitter();
        /**
         * Emitted when the expansion panel finishes expanding
         * ```typescript
         *  handleExpanded(event: {
         *  panel: IgxExpansionPanelComponent,
         *  event: Event
         * })
         * ```
         * ```html
         *  <igx-expansion-panel (onExpanded)="handleExpanded($event)">
         *      ...
         *  </igx-expansion-panel>
         * ```
         */
        this.onExpanded = new EventEmitter();
    }
    Object.defineProperty(IgxExpansionPanelComponent.prototype, "headerId", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.header ? this.id + "-header" : '';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @param {?} cb
     * @return {?}
     */
    IgxExpansionPanelComponent.prototype.playOpenAnimation = /**
     * @private
     * @param {?} cb
     * @return {?}
     */
    function (cb) {
        if (!this.body) { // if not body element is passed, there is nothing to animate
            return;
        }
        /** @type {?} */
        var animation$$1 = useAnimation(this.animationSettings.openAnimation);
        /** @type {?} */
        var animationBuilder = this.builder.build(animation$$1);
        /** @type {?} */
        var openAnimationPlayer = animationBuilder.create(this.body.element.nativeElement);
        openAnimationPlayer.onDone(function () {
            cb();
            openAnimationPlayer.reset();
        });
        openAnimationPlayer.play();
    };
    /**
     * @private
     * @param {?} cb
     * @return {?}
     */
    IgxExpansionPanelComponent.prototype.playCloseAnimation = /**
     * @private
     * @param {?} cb
     * @return {?}
     */
    function (cb) {
        if (!this.body) { // if not body element is passed, there is nothing to animate
            return;
        }
        /** @type {?} */
        var animation$$1 = useAnimation(this.animationSettings.closeAnimation);
        /** @type {?} */
        var animationBuilder = this.builder.build(animation$$1);
        /** @type {?} */
        var closeAnimationPlayer = animationBuilder.create(this.body.element.nativeElement);
        closeAnimationPlayer.onDone(function () {
            cb();
            closeAnimationPlayer.reset();
        });
        closeAnimationPlayer.play();
    };
    /**
     * Collapses the panel
     *
     * ```html
     *  <igx-expansion-panel #myPanel>
     *      ...
     *  </igx-expansion-panel>
     *  <button (click)="myPanel.collapse($event)">Collpase Panel</button>
     * ```
     */
    /**
     * Collapses the panel
     *
     * ```html
     *  <igx-expansion-panel #myPanel>
     *      ...
     *  </igx-expansion-panel>
     *  <button (click)="myPanel.collapse($event)">Collpase Panel</button>
     * ```
     * @param {?=} evt
     * @return {?}
     */
    IgxExpansionPanelComponent.prototype.collapse = /**
     * Collapses the panel
     *
     * ```html
     *  <igx-expansion-panel #myPanel>
     *      ...
     *  </igx-expansion-panel>
     *  <button (click)="myPanel.collapse($event)">Collpase Panel</button>
     * ```
     * @param {?=} evt
     * @return {?}
     */
    function (evt) {
        var _this = this;
        if (this.collapsed) { // If expansion panel is already collapsed, do nothing
            return;
        }
        this.playCloseAnimation(function () {
            _this.onCollapsed.emit({ event: evt, panel: _this });
            _this.collapsed = true;
        });
    };
    /**
     * Expands the panel
     *
     * ```html
     *  <igx-expansion-panel #myPanel>
     *      ...
     *  </igx-expansion-panel>
     *  <button (click)="myPanel.expand($event)">Expand Panel</button>
     * ```
     */
    /**
     * Expands the panel
     *
     * ```html
     *  <igx-expansion-panel #myPanel>
     *      ...
     *  </igx-expansion-panel>
     *  <button (click)="myPanel.expand($event)">Expand Panel</button>
     * ```
     * @param {?=} evt
     * @return {?}
     */
    IgxExpansionPanelComponent.prototype.expand = /**
     * Expands the panel
     *
     * ```html
     *  <igx-expansion-panel #myPanel>
     *      ...
     *  </igx-expansion-panel>
     *  <button (click)="myPanel.expand($event)">Expand Panel</button>
     * ```
     * @param {?=} evt
     * @return {?}
     */
    function (evt) {
        var _this = this;
        if (!this.collapsed) { // If the panel is already opened, do nothing
            return;
        }
        this.collapsed = false;
        this.cdr.detectChanges();
        this.playOpenAnimation(function () {
            _this.onExpanded.emit({ event: evt, panel: _this });
        });
    };
    /**
     * Toggles the panel
     *
     * ```html
     *  <igx-expansion-panel #myPanel>
     *      ...
     *  </igx-expansion-panel>
     *  <button (click)="myPanel.toggle($event)">Expand Panel</button>
     * ```
     */
    /**
     * Toggles the panel
     *
     * ```html
     *  <igx-expansion-panel #myPanel>
     *      ...
     *  </igx-expansion-panel>
     *  <button (click)="myPanel.toggle($event)">Expand Panel</button>
     * ```
     * @param {?=} evt
     * @return {?}
     */
    IgxExpansionPanelComponent.prototype.toggle = /**
     * Toggles the panel
     *
     * ```html
     *  <igx-expansion-panel #myPanel>
     *      ...
     *  </igx-expansion-panel>
     *  <button (click)="myPanel.toggle($event)">Expand Panel</button>
     * ```
     * @param {?=} evt
     * @return {?}
     */
    function (evt) {
        if (this.collapsed) {
            this.open(evt);
        }
        else {
            this.close(evt);
        }
    };
    /**
     * @param {?=} evt
     * @return {?}
     */
    IgxExpansionPanelComponent.prototype.open = /**
     * @param {?=} evt
     * @return {?}
     */
    function (evt) {
        this.expand(evt);
    };
    /**
     * @param {?=} evt
     * @return {?}
     */
    IgxExpansionPanelComponent.prototype.close = /**
     * @param {?=} evt
     * @return {?}
     */
    function (evt) {
        this.collapse(evt);
    };
    IgxExpansionPanelComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-expansion-panel',
                    template: "<ng-content select=\"igx-expansion-panel-header\"></ng-content>\n<ng-content *ngIf=\"!collapsed\" select=\"igx-expansion-panel-body\"></ng-content>\n",
                    providers: [{ provide: IGX_EXPANSION_PANEL_COMPONENT, useExisting: IgxExpansionPanelComponent }]
                }] }
    ];
    /** @nocollapse */
    IgxExpansionPanelComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: AnimationBuilder }
    ]; };
    IgxExpansionPanelComponent.propDecorators = {
        animationSettings: [{ type: Input }],
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        cssClass: [{ type: HostBinding, args: ['class.igx-expansion-panel',] }],
        collapsed: [{ type: Input }],
        onCollapsed: [{ type: Output }],
        onExpanded: [{ type: Output }],
        body: [{ type: ContentChild, args: [forwardRef(function () { return IgxExpansionPanelBodyComponent; }), { read: forwardRef(function () { return IgxExpansionPanelBodyComponent; }) },] }],
        header: [{ type: ContentChild, args: [forwardRef(function () { return IgxExpansionPanelHeaderComponent; }), { read: forwardRef(function () { return IgxExpansionPanelHeaderComponent; }) },] }]
    };
    return IgxExpansionPanelComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxExpansionPanelModule = /** @class */ (function () {
    function IgxExpansionPanelModule() {
    }
    IgxExpansionPanelModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        IgxExpansionPanelComponent,
                        IgxExpansionPanelHeaderComponent,
                        IgxExpansionPanelBodyComponent,
                        IgxExpansionPanelDescriptionDirective,
                        IgxExpansionPanelTitleDirective,
                        IgxExpansionPanelIconDirective
                    ],
                    entryComponents: [],
                    exports: [
                        IgxExpansionPanelComponent,
                        IgxExpansionPanelHeaderComponent,
                        IgxExpansionPanelBodyComponent,
                        IgxExpansionPanelDescriptionDirective,
                        IgxExpansionPanelTitleDirective,
                        IgxExpansionPanelIconDirective
                    ],
                    imports: [
                        CommonModule,
                        IgxRippleModule,
                        IgxIconModule,
                        IgxButtonModule,
                        IgxAvatarModule
                    ]
                },] }
    ];
    return IgxExpansionPanelModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// tslint:disable:directive-selector
var IgxBannerActionsDirective = /** @class */ (function () {
    function IgxBannerActionsDirective() {
    }
    IgxBannerActionsDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'igx-banner-actions'
                },] }
    ];
    return IgxBannerActionsDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * **Ignite UI for Angular Banner** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/banner.html)
 *
 * The Ignite UI Banner provides a highly templateable and easy to use banner that can be shown in your application.
 *
 * Usage:
 *
 * ```html
 * <igx-banner #banner>
 *   Our privacy settings have changed.
 *  <igx-banner-actions>
 *      <button igxButton="raised">Read More</button>
 *      <button igxButton="raised">Accept and Continue</button>
 *  </igx-banner-actions>
 * </igx-banner>
 * ```
 */
var IgxBannerComponent = /** @class */ (function () {
    function IgxBannerComponent(elementRef) {
        this.elementRef = elementRef;
        /**
         * Fires after the banner shows up
         * ```typescript
         * public handleOpened(event) {
         *  ...
         * }
         * ```
         * ```html
         * <igx-banner (onOpened)="handleOpened($event)"></igx-banner>
         * ```
         */
        this.onOpened = new EventEmitter();
        /**
         * Fires before the banner shows up
         * ```typescript
         * public handleOpening(event) {
         *  ...
         * }
         * ```
         * ```html
         * <igx-banner (onOpening)="handleOpening($event)"></igx-banner>
         * ```
         */
        this.onOpening = new EventEmitter();
        /**
         * Fires after the banner hides
         * ```typescript
         * public handleClosed(event) {
         *  ...
         * }
         * ```
         * ```html
         * <igx-banner (onClosed)="handleClosed($event)"></igx-banner>
         * ```
         */
        this.onClosed = new EventEmitter();
        /**
         * Fires before the banner hides
         * ```typescript
         * public handleClosing(event) {
         *  ...
         * }
         * ```
         * ```html
         * <igx-banner (onClosing)="handleClosing($event)"></igx-banner>
         * ```
         */
        this.onClosing = new EventEmitter();
    }
    Object.defineProperty(IgxBannerComponent.prototype, "useDefaultTemplate", {
        /** @hidden */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return !this._bannerActionTemplate;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxBannerComponent.prototype, "animationSettings", {
        /**
         * Get the animation settings used by the banner open/close methods
         * ```typescript
         * let currentAnimations: AnimationSettings = banner.animationSettings
         * ```
         */
        get: /**
         * Get the animation settings used by the banner open/close methods
         * ```typescript
         * let currentAnimations: AnimationSettings = banner.animationSettings
         * ```
         * @return {?}
         */
        function () {
            return this._animationSettings ? this._animationSettings : this._expansionPanel.animationSettings;
        },
        /**
         * Set the animation settings used by the banner open/close methods
         * ```typescript
         * import { slideInLeft, slideOutRight } from 'igniteui-angular';
         * ...
         * banner.animationSettings: AnimationSettings = { openAnimation: slideInLeft, closeAnimation: slideOutRight };
         * ```
         */
        set: /**
         * Set the animation settings used by the banner open/close methods
         * ```typescript
         * import { slideInLeft, slideOutRight } from 'igniteui-angular';
         * ...
         * banner.animationSettings: AnimationSettings = { openAnimation: slideInLeft, closeAnimation: slideOutRight };
         * ```
         * @param {?} settings
         * @return {?}
         */
        function (settings) {
            this._animationSettings = settings;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxBannerComponent.prototype, "collapsed", {
        /**
         * Gets whether banner is collapsed
         *
         * ```typescript
         * const isCollapsed: boolean = banner.collapsed;
         * ```
         */
        get: /**
         * Gets whether banner is collapsed
         *
         * ```typescript
         * const isCollapsed: boolean = banner.collapsed;
         * ```
         * @return {?}
         */
        function () {
            return this._expansionPanel.collapsed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxBannerComponent.prototype, "element", {
        /**
         * Returns the native element of the banner component
         * ```typescript
         *  const myBannerElement: HTMLElement = banner.element;
         * ```
         */
        get: /**
         * Returns the native element of the banner component
         * ```typescript
         *  const myBannerElement: HTMLElement = banner.element;
         * ```
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxBannerComponent.prototype, "displayStyle", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.collapsed ? '' : 'block';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Opens the banner
     *
     * ```typescript
     *  myBanner.open();
     * ```
     *
     * ```html
     * <igx-banner #banner>
     * ...
     * </igx-banner>
     * <button (click)="banner.open()">Open Banner</button>
     * ```
     */
    /**
     * Opens the banner
     *
     * ```typescript
     *  myBanner.open();
     * ```
     *
     * ```html
     * <igx-banner #banner>
     * ...
     * </igx-banner>
     * <button (click)="banner.open()">Open Banner</button>
     * ```
     * @param {?=} event
     * @return {?}
     */
    IgxBannerComponent.prototype.open = /**
     * Opens the banner
     *
     * ```typescript
     *  myBanner.open();
     * ```
     *
     * ```html
     * <igx-banner #banner>
     * ...
     * </igx-banner>
     * <button (click)="banner.open()">Open Banner</button>
     * ```
     * @param {?=} event
     * @return {?}
     */
    function (event) {
        this._bannerEvent = { banner: this, event: event };
        /** @type {?} */
        var openingArgs = {
            banner: this,
            event: event,
            cancel: false
        };
        this.onOpening.emit(openingArgs);
        if (openingArgs.cancel) {
            return;
        }
        this._expansionPanel.open(event);
    };
    /**
     * Closes the banner
     *
     * ```typescript
     *  myBanner.close();
     * ```
     *
     * ```html
     * <igx-banner #banner>
     * ...
     * </igx-banner>
     * <button (click)="banner.close()">Close Banner</button>
     * ```
     */
    /**
     * Closes the banner
     *
     * ```typescript
     *  myBanner.close();
     * ```
     *
     * ```html
     * <igx-banner #banner>
     * ...
     * </igx-banner>
     * <button (click)="banner.close()">Close Banner</button>
     * ```
     * @param {?=} event
     * @return {?}
     */
    IgxBannerComponent.prototype.close = /**
     * Closes the banner
     *
     * ```typescript
     *  myBanner.close();
     * ```
     *
     * ```html
     * <igx-banner #banner>
     * ...
     * </igx-banner>
     * <button (click)="banner.close()">Close Banner</button>
     * ```
     * @param {?=} event
     * @return {?}
     */
    function (event) {
        this._bannerEvent = { banner: this, event: event };
        /** @type {?} */
        var closingArgs = {
            banner: this,
            event: event,
            cancel: false
        };
        this.onClosing.emit(closingArgs);
        if (closingArgs.cancel) {
            return;
        }
        this._expansionPanel.close(event);
    };
    /**
     * Toggles the banner
     *
     * ```typescript
     *  myBanner.toggle();
     * ```
     *
     * ```html
     * <igx-banner #banner>
     * ...
     * </igx-banner>
     * <button (click)="banner.toggle()">Toggle Banner</button>
     * ```
     */
    /**
     * Toggles the banner
     *
     * ```typescript
     *  myBanner.toggle();
     * ```
     *
     * ```html
     * <igx-banner #banner>
     * ...
     * </igx-banner>
     * <button (click)="banner.toggle()">Toggle Banner</button>
     * ```
     * @param {?=} event
     * @return {?}
     */
    IgxBannerComponent.prototype.toggle = /**
     * Toggles the banner
     *
     * ```typescript
     *  myBanner.toggle();
     * ```
     *
     * ```html
     * <igx-banner #banner>
     * ...
     * </igx-banner>
     * <button (click)="banner.toggle()">Toggle Banner</button>
     * ```
     * @param {?=} event
     * @return {?}
     */
    function (event) {
        if (this.collapsed) {
            this.open(event);
        }
        else {
            this.close(event);
        }
    };
    /** @hidden */
    /**
     * @hidden
     * @return {?}
     */
    IgxBannerComponent.prototype.onExpansionPanelOpen = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.onOpened.emit(this._bannerEvent);
    };
    /** @hidden */
    /**
     * @hidden
     * @return {?}
     */
    IgxBannerComponent.prototype.onExpansionPanelClose = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.onClosed.emit(this._bannerEvent);
    };
    IgxBannerComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-banner',
                    template: "<igx-expansion-panel #expansionPanel [animationSettings]=\"animationSettings\" (onCollapsed)=\"onExpansionPanelClose()\" (onExpanded)=\"onExpansionPanelOpen()\"\n    [collapsed]=\"collapsed\" aria-live=\"polite\" [attr.aria-hidden]=\"collapsed\">\n    <igx-expansion-panel-body>\n        <div class=\"igx-banner\">\n            <div class=\"igx-banner__message\">\n                <div *ngIf=\"bannerIcon\" class=\"igx-banner__illustration\">\n                    <ng-content select=\"igx-icon\"></ng-content>\n                </div>\n                <span class=\"igx-banner__text\">\n                    <ng-content></ng-content>\n                </span>\n            </div>\n            <div class=\"igx-banner__actions\">\n                <div class=\"igx-banner__row\">\n                    <ng-container *ngIf=\"useDefaultTemplate\">\n                        <button igxButton=\"flat\" igxRipple (click)=\"close()\">\n                            Dismiss\n                        </button>\n                    </ng-container>\n                    <ng-container *ngIf=\"!useDefaultTemplate\">\n                        <ng-content select=\"igx-banner-actions\"></ng-content>\n                    </ng-container>\n                </div>\n            </div>\n        </div>\n    </igx-expansion-panel-body>\n</igx-expansion-panel>"
                }] }
    ];
    /** @nocollapse */
    IgxBannerComponent.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    IgxBannerComponent.propDecorators = {
        _expansionPanel: [{ type: ViewChild, args: ['expansionPanel',] }],
        _bannerActionTemplate: [{ type: ContentChild, args: [IgxBannerActionsDirective,] }],
        bannerIcon: [{ type: ContentChild, args: [IgxIconComponent,] }],
        onOpened: [{ type: Output }],
        onOpening: [{ type: Output }],
        onClosed: [{ type: Output }],
        onClosing: [{ type: Output }],
        animationSettings: [{ type: Input }],
        displayStyle: [{ type: HostBinding, args: ['style.display',] }]
    };
    return IgxBannerComponent;
}());
/**
 * @hidden
 */
var IgxBannerModule = /** @class */ (function () {
    function IgxBannerModule() {
    }
    IgxBannerModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxBannerComponent, IgxBannerActionsDirective],
                    exports: [IgxBannerComponent, IgxBannerActionsDirective],
                    imports: [CommonModule, IgxExpansionPanelModule, IgxIconModule, IgxButtonModule, IgxRippleModule]
                },] }
    ];
    return IgxBannerModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
var ButtonGroupAlignment = {
    horizontal: 0, vertical: 1,
};
ButtonGroupAlignment[ButtonGroupAlignment.horizontal] = 'horizontal';
ButtonGroupAlignment[ButtonGroupAlignment.vertical] = 'vertical';
/** @type {?} */
var NEXT_ID$b = 0;
/**
 * **Ignite UI for Angular Button Group** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/buttongroup.html)
 *
 * The Ignite UI Button Group displays a group of buttons either vertically or horizontally.  The group supports
 * single, multiple and toggle selection.
 *
 * Example:
 * ```html
 * <igx-buttongroup multiSelection="true" [values]="fontOptions">
 * </igx-buttongroup>
 * ```
 * The `fontOptions` value shown above is defined as:
 * ```typescript
 * this.fontOptions = [
 *   { icon: 'format_bold', selected: false },
 *   { icon: 'format_italic', selected: false },
 *   { icon: 'format_underlined', selected: false }];
 * ```
 */
var IgxButtonGroupComponent = /** @class */ (function (_super) {
    __extends(IgxButtonGroupComponent, _super);
    function IgxButtonGroupComponent(_cdr, _renderer, _displayDensityOptions) {
        var _this = _super.call(this, _displayDensityOptions) || this;
        _this._cdr = _cdr;
        _this._renderer = _renderer;
        _this._displayDensityOptions = _displayDensityOptions;
        _this._disabled = false;
        _this.buttonClickNotifier$ = new Subject();
        _this.queryListNotifier$ = new Subject();
        /**
         * An \@Input property that sets the value of the `id` attribute. If not set it will be automatically generated.
         * ```html
         *  <igx-buttongroup [id]="'igx-dialog-56'" [multiSelection]="!multi" [values]="alignOptions">
         * ```
         */
        _this.id = "igx-buttongroup-" + NEXT_ID$b++;
        /**
         * An \@Input property that enables selecting multiple buttons. By default, multi-selection is false.
         * ```html
         * <igx-buttongroup [multiSelection]="false" [alignment]="alignment"></igx-buttongroup>
         * ```
         */
        _this.multiSelection = false;
        /**
         * @hidden
         */
        _this.selectedIndexes = [];
        /**
         * An \@Ouput property that emits an event when a button is selected.
         * ```typescript
         * \@ViewChild("toast")
         * private toast: IgxToastComponent;
         * public onSelect(buttongroup){
         *    this.toast.show()
         * }
         * //...
         * ```
         * ```html
         * <igx-buttongroup #MyChild [multiSelection]="!multi" (onSelect)="onSelect($event)"></igx-buttongroup>
         * <igx-toast #toast message="You have made a selection!"></igx-toast>
         * ```
         */
        _this.onSelect = new EventEmitter();
        /**
         * An \@Ouput property that emits an event when a button is deselected.
         * ```typescript
         * \@ViewChild("toast")
         * private toast: IgxToastComponent;
         * public onUnselect(buttongroup){
         *    this.toast.show()
         * }
         * //...
         * ```
         * ```html
         * igx-buttongroup #MyChild [multiSelection]="multi" (onUnselect)="onUnselect($event)"></igx-buttongroup>
         * <igx-toast #toast message="You have deselected a button!"></igx-toast>
         * ```
         */
        _this.onUnselect = new EventEmitter();
        return _this;
    }
    Object.defineProperty(IgxButtonGroupComponent.prototype, "buttons", {
        /**
         * A collection containing all buttons inside the button group.
         */
        get: /**
         * A collection containing all buttons inside the button group.
         * @return {?}
         */
        function () {
            return __spread(this.viewButtons.toArray(), this.templateButtons.toArray());
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxButtonGroupComponent.prototype, "itemContentCssClass", {
        /**
         * Returns the CSS class of the item content of the `IgxButtonGroup`.
         *```typescript
         *@ViewChild("MyChild")
         *public buttonG: IgxButtonGroupComponent;
         *ngAfterViewInit(){
         *   let buttonSelect = this.buttonG.itemContentCssClass;
         *}
         *```
         */
        get: /**
         * Returns the CSS class of the item content of the `IgxButtonGroup`.
         * ```typescript
         * \@ViewChild("MyChild")
         * public buttonG: IgxButtonGroupComponent;
         * ngAfterViewInit(){
         *   let buttonSelect = this.buttonG.itemContentCssClass;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this._itemContentCssClass;
        },
        /**
         * Allows you to set a style using the `itemContentCssClass` input.
         * The value should be the CSS class name that will be applied to the button group.
         *```typescript
         *public style1 = "styleClass";
         * //..
         *```
         * ```html
         *<igx-buttongroup [itemContentCssClass]="style1" [multiSelection]="!multi" [values]="alignOptions">
         *```
         */
        set: /**
         * Allows you to set a style using the `itemContentCssClass` input.
         * The value should be the CSS class name that will be applied to the button group.
         * ```typescript
         * public style1 = "styleClass";
         * //..
         * ```
         * ```html
         * <igx-buttongroup [itemContentCssClass]="style1" [multiSelection]="!multi" [values]="alignOptions">
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._itemContentCssClass = value || this._itemContentCssClass;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxButtonGroupComponent.prototype, "disabled", {
        /**
         * An @Input property that allows you to disable the `igx-buttongroup` component. By default it's false.
         * ```html
         * <igx-buttongroup [disabled]="true" [multiSelection]="multi" [values]="fontOptions"></igx-buttongroup>
         * ```
         */
        get: /**
         * An \@Input property that allows you to disable the `igx-buttongroup` component. By default it's false.
         * ```html
         * <igx-buttongroup [disabled]="true" [multiSelection]="multi" [values]="fontOptions"></igx-buttongroup>
         * ```
         * @return {?}
         */
        function () {
            return this._disabled;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var _this = this;
            if (this._disabled !== value) {
                this._disabled = value;
                if (this.viewButtons && this.templateButtons) {
                    this.buttons.forEach(function (b) { return b.disabled = _this._disabled; });
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxButtonGroupComponent.prototype, "alignment", {
        /**
         * Returns the alignment of the `igx-buttongroup`.
         *```typescript
         *@ViewChild("MyChild")
         *public buttonG: IgxButtonGroupComponent;
         *ngAfterViewInit(){
         *    let buttonAlignment = this.buttonG.alignment;
         *}
         *```
         */
        get: /**
         * Returns the alignment of the `igx-buttongroup`.
         * ```typescript
         * \@ViewChild("MyChild")
         * public buttonG: IgxButtonGroupComponent;
         * ngAfterViewInit(){
         *    let buttonAlignment = this.buttonG.alignment;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this._isVertical ? ButtonGroupAlignment.vertical : ButtonGroupAlignment.horizontal;
        },
        /**
         * Allows you to set the button group alignment.
         * Available options are `ButtonGroupAlignment.horizontal` (default) and `ButtonGroupAlignment.vertical`.
         * ```typescript
         *public alignment = ButtonGroupAlignment.vertical;
         * //..
         * ```
         * ```html
         *<igx-buttongroup [multiSelection]="false" [values]="cities" [alignment]="alignment"></igx-buttongroup>
         * ```
         */
        set: /**
         * Allows you to set the button group alignment.
         * Available options are `ButtonGroupAlignment.horizontal` (default) and `ButtonGroupAlignment.vertical`.
         * ```typescript
         * public alignment = ButtonGroupAlignment.vertical;
         * //..
         * ```
         * ```html
         * <igx-buttongroup [multiSelection]="false" [values]="cities" [alignment]="alignment"></igx-buttongroup>
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._isVertical = value === ButtonGroupAlignment.vertical;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxButtonGroupComponent.prototype, "isVertical", {
        /**
         * Returns true if the `igx-buttongroup` alignment is vertical.
         * Note that in order for the accessor to work correctly the property should be set explicitly.
         * ```html
         * <igx-buttongroup #MyChild [alignment]="alignment" [values]="alignOptions">
         * ```
         * ```typescript
         * //...
         *@ViewChild("MyChild")
         *private buttonG: IgxButtonGroupComponent;
         *ngAfterViewInit(){
         *    let orientation = this.buttonG.isVertical;
         *}
         *```
         */
        get: /**
         * Returns true if the `igx-buttongroup` alignment is vertical.
         * Note that in order for the accessor to work correctly the property should be set explicitly.
         * ```html
         * <igx-buttongroup #MyChild [alignment]="alignment" [values]="alignOptions">
         * ```
         * ```typescript
         * //...
         * \@ViewChild("MyChild")
         * private buttonG: IgxButtonGroupComponent;
         * ngAfterViewInit(){
         *    let orientation = this.buttonG.isVertical;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this._isVertical;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxButtonGroupComponent.prototype, "selectedButtons", {
        /**
         * Gets the selected button/buttons.
         *```typescript
         *@ViewChild("MyChild")
         *private buttonG: IgxButtonGroupComponent;
         *ngAfterViewInit(){
         *    let selectedButton = this.buttonG.selectedButtons;
         *}
         *```
         */
        get: /**
         * Gets the selected button/buttons.
         * ```typescript
         * \@ViewChild("MyChild")
         * private buttonG: IgxButtonGroupComponent;
         * ngAfterViewInit(){
         *    let selectedButton = this.buttonG.selectedButtons;
         * }
         * ```
         * @return {?}
         */
        function () {
            var _this = this;
            return this.buttons.filter(function (b, i) {
                return _this.selectedIndexes.indexOf(i) !== -1;
            });
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Selects a button by its index.
     * @memberOf {@link IgxButtonGroupComponent}
     *```typescript
     *@ViewChild("MyChild")
     *private buttonG: IgxButtonGroupComponent;
     *ngAfterViewInit(){
     *    this.buttonG.selectButton(2);
     *    this.cdr.detectChanges();
     *}
     *```
     */
    /**
     * Selects a button by its index.
     * \@memberOf {\@link IgxButtonGroupComponent}
     * ```typescript
     * \@ViewChild("MyChild")
     * private buttonG: IgxButtonGroupComponent;
     * ngAfterViewInit(){
     *    this.buttonG.selectButton(2);
     *    this.cdr.detectChanges();
     * }
     * ```
     * @param {?} index
     * @return {?}
     */
    IgxButtonGroupComponent.prototype.selectButton = /**
     * Selects a button by its index.
     * \@memberOf {\@link IgxButtonGroupComponent}
     * ```typescript
     * \@ViewChild("MyChild")
     * private buttonG: IgxButtonGroupComponent;
     * ngAfterViewInit(){
     *    this.buttonG.selectButton(2);
     *    this.cdr.detectChanges();
     * }
     * ```
     * @param {?} index
     * @return {?}
     */
    function (index) {
        var _this = this;
        if (index >= this.buttons.length || index < 0) {
            return;
        }
        /** @type {?} */
        var button = this.buttons[index];
        /** @type {?} */
        var buttonElement = button.nativeElement;
        if (buttonElement.classList.contains('igx-button--disabled')) {
            return;
        }
        this.selectedIndexes.push(index);
        button.selected = true;
        this._renderer.setAttribute(buttonElement, 'aria-pressed', 'true');
        this._renderer.addClass(buttonElement, 'igx-button-group__item--selected');
        this.onSelect.emit({ button: button, index: index });
        /** @type {?} */
        var indexInViewButtons = this.viewButtons.toArray().indexOf(button);
        if (indexInViewButtons !== -1) {
            this.values[indexInViewButtons].selected = true;
        }
        // deselect other buttons if multiSelection is not enabled
        if (!this.multiSelection && this.selectedIndexes.length > 1) {
            this.buttons.forEach(function (b, i) {
                if (i !== index && _this.selectedIndexes.indexOf(i) !== -1) {
                    _this.deselectButton(i);
                }
            });
        }
    };
    /**
     * Deselects a button by its index.
     * @memberOf {@link IgxButtonGroupComponent}
     * ```typescript
     *@ViewChild("MyChild")
     *private buttonG: IgxButtonGroupComponent;
     *ngAfterViewInit(){
     *    this.buttonG.deselectButton(2);
     *    this.cdr.detectChanges();
     *}
     * ```
     */
    /**
     * Deselects a button by its index.
     * \@memberOf {\@link IgxButtonGroupComponent}
     * ```typescript
     * \@ViewChild("MyChild")
     * private buttonG: IgxButtonGroupComponent;
     * ngAfterViewInit(){
     *    this.buttonG.deselectButton(2);
     *    this.cdr.detectChanges();
     * }
     * ```
     * @param {?} index
     * @return {?}
     */
    IgxButtonGroupComponent.prototype.deselectButton = /**
     * Deselects a button by its index.
     * \@memberOf {\@link IgxButtonGroupComponent}
     * ```typescript
     * \@ViewChild("MyChild")
     * private buttonG: IgxButtonGroupComponent;
     * ngAfterViewInit(){
     *    this.buttonG.deselectButton(2);
     *    this.cdr.detectChanges();
     * }
     * ```
     * @param {?} index
     * @return {?}
     */
    function (index) {
        if (index >= this.buttons.length || index < 0) {
            return;
        }
        /** @type {?} */
        var button = this.buttons[index];
        /** @type {?} */
        var buttonElement = button.nativeElement;
        if (buttonElement.classList.contains('igx-button--disabled')) {
            return;
        }
        this.selectedIndexes.splice(this.selectedIndexes.indexOf(index), 1);
        button.selected = false;
        this._renderer.setAttribute(buttonElement, 'aria-pressed', 'false');
        this._renderer.removeClass(buttonElement, 'igx-button-group__item--selected');
        this.onUnselect.emit({ button: button, index: index });
        /** @type {?} */
        var indexInViewButtons = this.viewButtons.toArray().indexOf(button);
        if (indexInViewButtons !== -1) {
            this.values[indexInViewButtons].selected = false;
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxButtonGroupComponent.prototype.ngAfterContentInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        this.templateButtons.forEach(function (button) {
            if (!button.initialDensity) {
                button.displayDensity = _this.displayDensity;
            }
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxButtonGroupComponent.prototype.ngAfterViewInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var initButtons = function () {
            // Cancel any existing buttonClick subscriptions
            _this.buttonClickNotifier$.next();
            _this.selectedIndexes.splice(0, _this.selectedIndexes.length);
            // initial configuration
            _this.buttons.forEach(function (button, index) {
                /** @type {?} */
                var buttonElement = button.nativeElement;
                if (_this.disabled) {
                    button.disabled = true;
                }
                if (!button.disabled && button.selected) {
                    _this.selectButton(index);
                }
                button.buttonClick.pipe(takeUntil(_this.buttonClickNotifier$)).subscribe(function (ev) { return _this._clickHandler(ev, index); });
                _this._renderer.addClass(buttonElement, 'igx-button-group__item');
            });
        };
        this.viewButtons.changes.pipe(takeUntil(this.queryListNotifier$)).subscribe(function () { return initButtons(); });
        this.templateButtons.changes.pipe(takeUntil(this.queryListNotifier$)).subscribe(function () { return initButtons(); });
        initButtons();
        this._cdr.detectChanges();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxButtonGroupComponent.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.buttonClickNotifier$.next();
        this.buttonClickNotifier$.complete();
        this.queryListNotifier$.next();
        this.queryListNotifier$.complete();
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @param {?} i
     * @return {?}
     */
    IgxButtonGroupComponent.prototype._clickHandler = /**
     * @hidden
     * @param {?} event
     * @param {?} i
     * @return {?}
     */
    function (event, i) {
        if (this.selectedIndexes.indexOf(i) !== -1) {
            this.deselectButton(i);
        }
        else {
            this.selectButton(i);
        }
    };
    IgxButtonGroupComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-buttongroup',
                    template: "<div class=\"igx-button-group\" role=\"group\" [class.igx-button-group--vertical]=\"isVertical\">\n    <span *ngFor=\"let button of values; let i = 'index'\" type=\"button\" igxButton=\"flat\" [displayDensity]=\"displayDensity\" [selected]=\"button.selected\"\n        [attr.data-togglable]=\"button.togglable\" [disabled]=\"disabled || button.disabled\" [igxButtonColor]=\"button.color\"\n        [igxButtonBackground]=\"button.bgcolor\" [igxLabel]=\"button.label\" [igxRipple]=\"button.ripple\">\n        <div class=\"igx-button-group__item-content {{ itemContentCssClass }}\">\n            <igx-icon *ngIf=\"button.icon\" fontSet=\"material\">{{button.icon}}</igx-icon>\n            <span *ngIf=\"button.label\">{{button.label}}</span>\n        </div>\n    </span>\n    <ng-content></ng-content>\n</div>\n"
                }] }
    ];
    /** @nocollapse */
    IgxButtonGroupComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: Renderer2 },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
    ]; };
    IgxButtonGroupComponent.propDecorators = {
        viewButtons: [{ type: ViewChildren, args: [IgxButtonDirective,] }],
        templateButtons: [{ type: ContentChildren, args: [IgxButtonDirective,] }],
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        itemContentCssClass: [{ type: Input }],
        multiSelection: [{ type: Input }],
        values: [{ type: Input }],
        disabled: [{ type: Input }],
        alignment: [{ type: Input }],
        onSelect: [{ type: Output }],
        onUnselect: [{ type: Output }]
    };
    return IgxButtonGroupComponent;
}(DisplayDensityBase));
/**
 * @hidden
 */
var IgxButtonGroupModule = /** @class */ (function () {
    function IgxButtonGroupModule() {
    }
    IgxButtonGroupModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxButtonGroupComponent],
                    exports: [IgxButtonGroupComponent],
                    imports: [IgxButtonModule, CommonModule, IgxRippleModule, IgxIconModule]
                },] }
    ];
    return IgxButtonGroupModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
var DateRangeType = {
    After: 0,
    Before: 1,
    Between: 2,
    Specific: 3,
    Weekdays: 4,
    Weekends: 5,
};
DateRangeType[DateRangeType.After] = 'After';
DateRangeType[DateRangeType.Before] = 'Before';
DateRangeType[DateRangeType.Between] = 'Between';
DateRangeType[DateRangeType.Specific] = 'Specific';
DateRangeType[DateRangeType.Weekdays] = 'Weekdays';
DateRangeType[DateRangeType.Weekends] = 'Weekends';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var MDAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
/** @type {?} */
var FEBRUARY = 1;
/**
 * @param {?=} start
 * @param {?=} stop
 * @param {?=} step
 * @return {?}
 */
function range(start, stop, step) {
    if (start === void 0) { start = 0; }
    if (step === void 0) { step = 1; }
    /** @type {?} */
    var res = [];
    /** @type {?} */
    var cur = (stop === undefined) ? 0 : start;
    /** @type {?} */
    var max = (stop === undefined) ? start : stop;
    for (var i = cur; step < 0 ? i > max : i < max; i += step) {
        res.push(i);
    }
    return res;
}
/**
 * Returns true for leap years, false for non-leap years.
 *
 * @export
 * @param {?} year
 * @return {?}
 */
function isLeap(year) {
    return (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0));
}
/**
 * @param {?} year
 * @param {?} month
 * @param {?} day
 * @return {?}
 */
function weekDay(year, month, day) {
    return new Date(year, month, day).getDay();
}
/**
 * Return weekday and number of days for year, month.
 *
 * @export
 * @param {?} year
 * @param {?} month
 * @return {?}
 */
function monthRange(year, month) {
    if ((month < 0) || (month > 11)) {
        throw new Error('Invalid month specified');
    }
    /** @type {?} */
    var day = weekDay(year, month, 1);
    /** @type {?} */
    var nDays = MDAYS[month];
    if ((month === FEBRUARY) && (isLeap(year))) {
        nDays++;
    }
    return [day, nDays];
}
/**
 * @param {?} date
 * @param {?} ranges
 * @return {?}
 */
function isDateInRanges(date, ranges) {
    var e_1, _a, e_2, _b;
    date = new Date(date.getFullYear(), date.getMonth(), date.getDate());
    /** @type {?} */
    var dateInMs = date.getTime();
    try {
        for (var ranges_1 = __values(ranges), ranges_1_1 = ranges_1.next(); !ranges_1_1.done; ranges_1_1 = ranges_1.next()) {
            var descriptor = ranges_1_1.value;
            /** @type {?} */
            var dRanges = descriptor.dateRange ? descriptor.dateRange.map(function (r) { return new Date(r.getFullYear(), r.getMonth(), r.getDate()); }) : undefined;
            switch (descriptor.type) {
                case (DateRangeType.After):
                    if (dateInMs > dRanges[0].getTime()) {
                        return true;
                    }
                    break;
                case (DateRangeType.Before):
                    if (dateInMs < dRanges[0].getTime()) {
                        return true;
                    }
                    break;
                case (DateRangeType.Between):
                    /** @type {?} */
                    var dRange = dRanges.map(function (d) { return d.getTime(); });
                    /** @type {?} */
                    var min = Math.min(dRange[0], dRange[1]);
                    /** @type {?} */
                    var max = Math.max(dRange[0], dRange[1]);
                    if (dateInMs >= min && dateInMs <= max) {
                        return true;
                    }
                    break;
                case (DateRangeType.Specific):
                    /** @type {?} */
                    var datesInMs = dRanges.map(function (d) { return d.getTime(); });
                    try {
                        for (var datesInMs_1 = __values(datesInMs), datesInMs_1_1 = datesInMs_1.next(); !datesInMs_1_1.done; datesInMs_1_1 = datesInMs_1.next()) {
                            var specificDateInMs = datesInMs_1_1.value;
                            if (dateInMs === specificDateInMs) {
                                return true;
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (datesInMs_1_1 && !datesInMs_1_1.done && (_b = datesInMs_1.return)) _b.call(datesInMs_1);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                    break;
                case (DateRangeType.Weekdays):
                    /** @type {?} */
                    var day = date.getDay();
                    if (day % 6 !== 0) {
                        return true;
                    }
                    break;
                case (DateRangeType.Weekends):
                    /** @type {?} */
                    var weekday = date.getDay();
                    if (weekday % 6 === 0) {
                        return true;
                    }
                    break;
                default:
                    return false;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (ranges_1_1 && !ranges_1_1.done && (_a = ranges_1.return)) _a.call(ranges_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return false;
}
/** @enum {number} */
var WEEKDAYS = {
    SUNDAY: 0,
    MONDAY: 1,
    TUESDAY: 2,
    WEDNESDAY: 3,
    THURSDAY: 4,
    FRIDAY: 5,
    SATURDAY: 6,
};
WEEKDAYS[WEEKDAYS.SUNDAY] = 'SUNDAY';
WEEKDAYS[WEEKDAYS.MONDAY] = 'MONDAY';
WEEKDAYS[WEEKDAYS.TUESDAY] = 'TUESDAY';
WEEKDAYS[WEEKDAYS.WEDNESDAY] = 'WEDNESDAY';
WEEKDAYS[WEEKDAYS.THURSDAY] = 'THURSDAY';
WEEKDAYS[WEEKDAYS.FRIDAY] = 'FRIDAY';
WEEKDAYS[WEEKDAYS.SATURDAY] = 'SATURDAY';
var Calendar = /** @class */ (function () {
    function Calendar(firstWeekDay) {
        if (firstWeekDay === void 0) { firstWeekDay = WEEKDAYS.SUNDAY; }
        this._firstWeekDay = firstWeekDay;
    }
    Object.defineProperty(Calendar.prototype, "firstWeekDay", {
        get: /**
         * @return {?}
         */
        function () {
            return this._firstWeekDay % 7;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._firstWeekDay = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns an array of weekdays for one week starting
     * with the currently set `firstWeekDay`
     *
     * this.firstWeekDay = 0 (Sunday) --> [0, 1, 2, 3, 4, 5, 6]
     * this.firstWeekDay = 1 (Monday) --> [1, 2, 3, 4, 5, 6, 0]
     *
     * @returns
     *
     * @memberof Calendar
     */
    /**
     * Returns an array of weekdays for one week starting
     * with the currently set `firstWeekDay`
     *
     * this.firstWeekDay = 0 (Sunday) --> [0, 1, 2, 3, 4, 5, 6]
     * this.firstWeekDay = 1 (Monday) --> [1, 2, 3, 4, 5, 6, 0]
     *
     * \@memberof Calendar
     * @return {?}
     *
     */
    Calendar.prototype.weekdays = /**
     * Returns an array of weekdays for one week starting
     * with the currently set `firstWeekDay`
     *
     * this.firstWeekDay = 0 (Sunday) --> [0, 1, 2, 3, 4, 5, 6]
     * this.firstWeekDay = 1 (Monday) --> [1, 2, 3, 4, 5, 6, 0]
     *
     * \@memberof Calendar
     * @return {?}
     *
     */
    function () {
        var e_3, _a;
        /** @type {?} */
        var res = [];
        try {
            for (var _b = __values(range(this.firstWeekDay, this.firstWeekDay + 7)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var i = _c.value;
                res.push(i % 7);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return res;
    };
    /**
     * Returns the date values for one month. It will always iterate throught
     * complete weeks, so it will contain dates outside the specified month.
     *
     * @param year
     * @param month
     * @param boolean
     * @returns
     *
     * @memberof Calendar
     */
    /**
     * Returns the date values for one month. It will always iterate throught
     * complete weeks, so it will contain dates outside the specified month.
     *
     * \@memberof Calendar
     * @param {?} year
     * @param {?} month
     * @param {?=} extraWeek
     * @return {?}
     *
     */
    Calendar.prototype.monthdates = /**
     * Returns the date values for one month. It will always iterate throught
     * complete weeks, so it will contain dates outside the specified month.
     *
     * \@memberof Calendar
     * @param {?} year
     * @param {?} month
     * @param {?=} extraWeek
     * @return {?}
     *
     */
    function (year, month, extraWeek) {
        if (extraWeek === void 0) { extraWeek = false; }
        var e_4, _a;
        /** @type {?} */
        var date = new Date(year, month, 1);
        /** @type {?} */
        var days = (date.getDay() - this.firstWeekDay) % 7;
        if (days < 0) {
            days = 7 - Math.abs(days);
        }
        date = this.timedelta(date, 'day', -days);
        /** @type {?} */
        var res = [];
        /** @type {?} */
        var value;
        while (true) {
            value = this.generateICalendarDate(date, year, month);
            res.push(value);
            date = this.timedelta(date, 'day', 1);
            if ((date.getMonth() !== month) && (date.getDay() === this.firstWeekDay)) {
                if (extraWeek && res.length <= 35) {
                    try {
                        for (var _b = __values(range(0, 7)), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var i = _c.value;
                            value = this.generateICalendarDate(date, year, month);
                            res.push(value);
                            date = this.timedelta(date, 'day', 1);
                        }
                    }
                    catch (e_4_1) { e_4 = { error: e_4_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_4) throw e_4.error; }
                    }
                }
                break;
            }
        }
        return res;
    };
    /**
     * Returns a matrix (array of arrays) representing a month's calendar.
     * Each row represents a full week; week entries are ICalendarDate objects.
     *
     * @param year
     * @param month
     * @returns
     *
     * @memberof Calendar
     */
    /**
     * Returns a matrix (array of arrays) representing a month's calendar.
     * Each row represents a full week; week entries are ICalendarDate objects.
     *
     * \@memberof Calendar
     * @param {?} year
     * @param {?} month
     * @param {?=} extraWeek
     * @return {?}
     *
     */
    Calendar.prototype.monthdatescalendar = /**
     * Returns a matrix (array of arrays) representing a month's calendar.
     * Each row represents a full week; week entries are ICalendarDate objects.
     *
     * \@memberof Calendar
     * @param {?} year
     * @param {?} month
     * @param {?=} extraWeek
     * @return {?}
     *
     */
    function (year, month, extraWeek) {
        if (extraWeek === void 0) { extraWeek = false; }
        var e_5, _a;
        /** @type {?} */
        var dates = this.monthdates(year, month, extraWeek);
        /** @type {?} */
        var res = [];
        try {
            for (var _b = __values(range(0, dates.length, 7)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var i = _c.value;
                res.push(dates.slice(i, i + 7));
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_5) throw e_5.error; }
        }
        return res;
    };
    /**
     * @param {?} date
     * @param {?} interval
     * @param {?} units
     * @return {?}
     */
    Calendar.prototype.timedelta = /**
     * @param {?} date
     * @param {?} interval
     * @param {?} units
     * @return {?}
     */
    function (date, interval$$1, units) {
        /** @type {?} */
        var ret = new Date(date);
        /** @type {?} */
        var checkRollover = function () {
            if (ret.getDate() !== date.getDate()) {
                ret.setDate(0);
            }
        };
        switch (interval$$1.toLowerCase()) {
            case 'year':
                ret.setFullYear(ret.getFullYear() + units);
                checkRollover();
                break;
            case 'quarter':
                ret.setMonth(ret.getMonth() + 3 * units);
                checkRollover();
                break;
            case 'month':
                ret.setMonth(ret.getMonth() + units);
                checkRollover();
                break;
            case 'week':
                ret.setDate(ret.getDate() + 7 * units);
                break;
            case 'day':
                ret.setDate(ret.getDate() + units);
                break;
            case 'hour':
                ret.setTime(ret.getTime() + units * 3600000);
                break;
            case 'minute':
                ret.setTime(ret.getTime() + units * 60000);
                break;
            case 'second':
                ret.setTime(ret.getTime() + units * 1000);
                break;
            default:
                throw new Error('Invalid interval specifier');
        }
        return ret;
    };
    /**
     * @param {?} date
     * @param {?} locale
     * @param {?} options
     * @param {?} parts
     * @return {?}
     */
    Calendar.prototype.formatToParts = /**
     * @param {?} date
     * @param {?} locale
     * @param {?} options
     * @param {?} parts
     * @return {?}
     */
    function (date, locale, options, parts) {
        var e_6, _a, e_7, _b;
        /** @type {?} */
        var formatter = new Intl.DateTimeFormat(locale, options);
        /** @type {?} */
        var result = {
            date: date,
            full: formatter.format(date)
        };
        if (((/** @type {?} */ (formatter))).formatToParts) {
            /** @type {?} */
            var formattedParts_1 = ((/** @type {?} */ (formatter))).formatToParts(date);
            /** @type {?} */
            var toType = function (partType) {
                /** @type {?} */
                var index = formattedParts_1.findIndex(function (_a) {
                    var type = _a.type;
                    return type === partType;
                });
                /** @type {?} */
                var o = { value: '', literal: '', combined: '' };
                if (partType === 'era' && index > -1) {
                    o.value = formattedParts_1[index].value;
                    return o;
                }
                else if (partType === 'era' && index === -1) {
                    return o;
                }
                o.value = formattedParts_1[index].value;
                o.literal = formattedParts_1[index + 1] ? formattedParts_1[index + 1].value : '';
                o.combined = [o.value, o.literal].join('');
                return o;
            };
            try {
                for (var parts_1 = __values(parts), parts_1_1 = parts_1.next(); !parts_1_1.done; parts_1_1 = parts_1.next()) {
                    var each = parts_1_1.value;
                    result[each] = toType(each);
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (parts_1_1 && !parts_1_1.done && (_a = parts_1.return)) _a.call(parts_1);
                }
                finally { if (e_6) throw e_6.error; }
            }
        }
        else {
            try {
                for (var parts_2 = __values(parts), parts_2_1 = parts_2.next(); !parts_2_1.done; parts_2_1 = parts_2.next()) {
                    var each = parts_2_1.value;
                    result[each] = { value: '', literal: '', combined: '' };
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (parts_2_1 && !parts_2_1.done && (_b = parts_2.return)) _b.call(parts_2);
                }
                finally { if (e_7) throw e_7.error; }
            }
        }
        return result;
    };
    /**
     * @private
     * @param {?} date
     * @param {?} year
     * @param {?} month
     * @return {?}
     */
    Calendar.prototype.generateICalendarDate = /**
     * @private
     * @param {?} date
     * @param {?} year
     * @param {?} month
     * @return {?}
     */
    function (date, year, month) {
        return {
            date: date,
            isCurrentMonth: date.getFullYear() === year && date.getMonth() === month,
            isNextMonth: this.isNextMonth(date, year, month),
            isPrevMonth: this.isPreviousMonth(date, year, month)
        };
    };
    /**
     * @private
     * @param {?} date
     * @param {?} year
     * @param {?} month
     * @return {?}
     */
    Calendar.prototype.isPreviousMonth = /**
     * @private
     * @param {?} date
     * @param {?} year
     * @param {?} month
     * @return {?}
     */
    function (date, year, month) {
        if (date.getFullYear() === year) {
            return date.getMonth() < month;
        }
        return date.getFullYear() < year;
    };
    /**
     * @private
     * @param {?} date
     * @param {?} year
     * @param {?} month
     * @return {?}
     */
    Calendar.prototype.isNextMonth = /**
     * @private
     * @param {?} date
     * @param {?} year
     * @param {?} month
     * @return {?}
     */
    function (date, year, month) {
        if (date.getFullYear() === year) {
            return date.getMonth() > month;
        }
        return date.getFullYear() > year;
    };
    return Calendar;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxCalendarYearDirective = /** @class */ (function () {
    function IgxCalendarYearDirective() {
        this.onYearSelection = new EventEmitter();
    }
    Object.defineProperty(IgxCalendarYearDirective.prototype, "defaultCSS", {
        get: /**
         * @return {?}
         */
        function () {
            return !this.isCurrentYear;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxCalendarYearDirective.prototype, "currentCSS", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isCurrentYear;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxCalendarYearDirective.prototype, "isCurrentYear", {
        get: /**
         * @return {?}
         */
        function () {
            return this.date.getFullYear() === this.value.getFullYear();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    IgxCalendarYearDirective.prototype.onClick = /**
     * @return {?}
     */
    function () {
        this.onYearSelection.emit(this.value);
    };
    IgxCalendarYearDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxCalendarYear]'
                },] }
    ];
    IgxCalendarYearDirective.propDecorators = {
        value: [{ type: Input, args: ['igxCalendarYear',] }],
        date: [{ type: Input }],
        onYearSelection: [{ type: Output }],
        defaultCSS: [{ type: HostBinding, args: ['class.igx-calendar__year',] }],
        currentCSS: [{ type: HostBinding, args: ['class.igx-calendar__year--current',] }],
        onClick: [{ type: HostListener, args: ['click',] }]
    };
    return IgxCalendarYearDirective;
}());
var IgxCalendarMonthDirective = /** @class */ (function () {
    function IgxCalendarMonthDirective(elementRef) {
        this.elementRef = elementRef;
        this.onMonthSelection = new EventEmitter();
        this.tabindex = 0;
    }
    Object.defineProperty(IgxCalendarMonthDirective.prototype, "defaultCSS", {
        get: /**
         * @return {?}
         */
        function () {
            return !this.isCurrentMonth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxCalendarMonthDirective.prototype, "currentCSS", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isCurrentMonth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxCalendarMonthDirective.prototype, "isCurrentMonth", {
        get: /**
         * @return {?}
         */
        function () {
            return this.date.getMonth() === this.value.getMonth();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxCalendarMonthDirective.prototype, "nativeElement", {
        get: /**
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    IgxCalendarMonthDirective.prototype.onClick = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var date = new Date(this.value.getFullYear(), this.value.getMonth(), this.date.getDate());
        this.onMonthSelection.emit(date);
    };
    IgxCalendarMonthDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxCalendarMonth]'
                },] }
    ];
    /** @nocollapse */
    IgxCalendarMonthDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    IgxCalendarMonthDirective.propDecorators = {
        value: [{ type: Input, args: ['igxCalendarMonth',] }],
        date: [{ type: Input }],
        index: [{ type: Input }],
        onMonthSelection: [{ type: Output }],
        tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
        defaultCSS: [{ type: HostBinding, args: ['class.igx-calendar__month',] }],
        currentCSS: [{ type: HostBinding, args: ['class.igx-calendar__month--current',] }],
        onClick: [{ type: HostListener, args: ['click',] }]
    };
    return IgxCalendarMonthDirective;
}());
/**
 * @hidden
 */
var IgxCalendarHeaderTemplateDirective = /** @class */ (function () {
    function IgxCalendarHeaderTemplateDirective(template) {
        this.template = template;
    }
    IgxCalendarHeaderTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxCalendarHeader]'
                },] }
    ];
    /** @nocollapse */
    IgxCalendarHeaderTemplateDirective.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return IgxCalendarHeaderTemplateDirective;
}());
/**
 * @hidden
 */
var IgxCalendarSubheaderTemplateDirective = /** @class */ (function () {
    function IgxCalendarSubheaderTemplateDirective(template) {
        this.template = template;
    }
    IgxCalendarSubheaderTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxCalendarSubheader]'
                },] }
    ];
    /** @nocollapse */
    IgxCalendarSubheaderTemplateDirective.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return IgxCalendarSubheaderTemplateDirective;
}());
/**
 * @hidden
 */
var IgxCalendarScrollMonthDirective = /** @class */ (function () {
    function IgxCalendarScrollMonthDirective(element, zone) {
        this.element = element;
        this.zone = zone;
        /**
         * @hidden
         */
        this.destroy$ = new Subject();
    }
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxCalendarScrollMonthDirective.prototype.ngAfterViewInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        fromEvent(this.element.nativeElement, 'keyup').pipe(debounce(function () { return interval(100); }), takeUntil(this.destroy$)).subscribe(function (event) {
            _this.stopScroll(event);
        });
        this.zone.runOutsideAngular(function () {
            fromEvent(_this.element.nativeElement, 'keydown').pipe(tap(function (event) {
                if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
                    event.preventDefault();
                    event.stopPropagation();
                }
            }), debounce(function () { return interval(100); }), takeUntil(_this.destroy$)).subscribe(function (event) {
                if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
                    _this.zone.run(function () { return _this.startScroll(true); });
                }
            });
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxCalendarScrollMonthDirective.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.destroy$.next(true);
        this.destroy$.complete();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxCalendarScrollMonthDirective.prototype.onMouseDown = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.startScroll();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxCalendarScrollMonthDirective.prototype.onMouseUp = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.stopScroll(event);
    };
    IgxCalendarScrollMonthDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxCalendarScrollMonth]'
                },] }
    ];
    /** @nocollapse */
    IgxCalendarScrollMonthDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: NgZone }
    ]; };
    IgxCalendarScrollMonthDirective.propDecorators = {
        startScroll: [{ type: Input }],
        stopScroll: [{ type: Input }],
        onMouseDown: [{ type: HostListener, args: ['mousedown',] }],
        onMouseUp: [{ type: HostListener, args: ['mouseup', ['$event'],] }]
    };
    return IgxCalendarScrollMonthDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var CalendarSelection = {
    SINGLE: 'single',
    MULTI: 'multi',
    RANGE: 'range',
};
/** @enum {string} */
var ScrollMonth = {
    PREV: 'prev',
    NEXT: 'next',
    NONE: 'none',
};
var IgxCalendarBase = /** @class */ (function () {
    /**
     * @hidden
     */
    function IgxCalendarBase() {
        /**
         * Emits an event when a date is selected.
         * Provides reference the `selectedDates` property.
         */
        this.onSelection = new EventEmitter();
        /**
         * @hidden
         */
        this._selection = CalendarSelection.SINGLE;
        /**
         * @hidden
         */
        this.rangeStarted = false;
        /**
         * @hidden
         */
        this._locale = 'en';
        /**
         * @hidden
         */
        this._disabledDates = null;
        /**
         * @hidden
         */
        this._specialDates = null;
        /**
         * @hidden
         */
        this._formatOptions = {
            day: 'numeric',
            month: 'short',
            weekday: 'short',
            year: 'numeric'
        };
        /**
         * @hidden
         */
        this._formatViews = {
            day: false,
            month: true,
            year: false
        };
        /**
         * @hidden
         */
        this.monthScrollDirection = ScrollMonth.NONE;
        /**
         * @hidden
         */
        this.scrollMonth$ = new Subject();
        /**
         * @hidden
         */
        this.stopMonthScroll$ = new Subject();
        /**
         * @hidden
         */
        this.startMonthScroll$ = new Subject();
        /**
         * @hidden
         */
        this._onTouchedCallback = function () { };
        /**
         * @hidden
         */
        this._onChangeCallback = function () { };
        this.calendarModel = new Calendar();
        this.viewDate = this.viewDate ? this.viewDate : new Date();
        this.calendarModel.firstWeekDay = this.weekStart;
        this.initFormatters();
    }
    Object.defineProperty(IgxCalendarBase.prototype, "weekStart", {
        /**
         * Gets the start day of the week.
         * Can return a numeric or an enum representation of the week day.
         * Defaults to `Sunday` / `0`.
         */
        get: /**
         * Gets the start day of the week.
         * Can return a numeric or an enum representation of the week day.
         * Defaults to `Sunday` / `0`.
         * @return {?}
         */
        function () {
            return this.calendarModel.firstWeekDay;
        },
        /**
         * Sets the start day of the week.
         * Can be assigned to a numeric value or to `WEEKDAYS` enum value.
         */
        set: /**
         * Sets the start day of the week.
         * Can be assigned to a numeric value or to `WEEKDAYS` enum value.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.calendarModel.firstWeekDay = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxCalendarBase.prototype, "locale", {
        /**
         * Gets the `locale` of the calendar.
         * Default value is `"en"`.
         */
        get: /**
         * Gets the `locale` of the calendar.
         * Default value is `"en"`.
         * @return {?}
         */
        function () {
            return this._locale;
        },
        /**
         * Sets the `locale` of the calendar.
         * Expects a valid BCP 47 language tag.
         * Default value is `"en"`.
         */
        set: /**
         * Sets the `locale` of the calendar.
         * Expects a valid BCP 47 language tag.
         * Default value is `"en"`.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._locale = value;
            this.initFormatters();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxCalendarBase.prototype, "formatOptions", {
        /**
         * Gets the date format options of the days view.
         */
        get: /**
         * Gets the date format options of the days view.
         * @return {?}
         */
        function () {
            return this._formatOptions;
        },
        /**
         * Sets the date format options of the days view.
         * Default is { day: 'numeric', month: 'short', weekday: 'short', year: 'numeric' }
         */
        set: /**
         * Sets the date format options of the days view.
         * Default is { day: 'numeric', month: 'short', weekday: 'short', year: 'numeric' }
         * @param {?} formatOptions
         * @return {?}
         */
        function (formatOptions) {
            this._formatOptions = Object.assign(this._formatOptions, formatOptions);
            this.initFormatters();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxCalendarBase.prototype, "formatViews", {
        /**
         * Gets whether the `day`, `month` and `year` should be rendered
         * according to the locale and formatOptions, if any.
         */
        get: /**
         * Gets whether the `day`, `month` and `year` should be rendered
         * according to the locale and formatOptions, if any.
         * @return {?}
         */
        function () {
            return this._formatViews;
        },
        /**
         * Gets whether the `day`, `month` and `year` should be rendered
         * according to the locale and formatOptions, if any.
         */
        set: /**
         * Gets whether the `day`, `month` and `year` should be rendered
         * according to the locale and formatOptions, if any.
         * @param {?} formatViews
         * @return {?}
         */
        function (formatViews) {
            this._formatViews = Object.assign(this._formatViews, formatViews);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxCalendarBase.prototype, "selection", {
        /**
         *
         * Gets the selection type.
         * Default value is `"single"`.
         * Changing the type of selection resets the currently
         * selected values if any.
         */
        get: /**
         *
         * Gets the selection type.
         * Default value is `"single"`.
         * Changing the type of selection resets the currently
         * selected values if any.
         * @return {?}
         */
        function () {
            return this._selection;
        },
        /**
         * Sets the selection.
         */
        set: /**
         * Sets the selection.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            switch (value) {
                case CalendarSelection.SINGLE:
                    this.selectedDates = null;
                    break;
                case CalendarSelection.MULTI:
                case CalendarSelection.RANGE:
                    this.selectedDates = [];
                    break;
                default:
                    throw new Error('Invalid selection value');
            }
            this._onChangeCallback(this.selectedDates);
            this.rangeStarted = false;
            this._selection = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxCalendarBase.prototype, "value", {
        /**
         * Gets the selected date(s).
         *
         * When selection is set to `single`, it returns
         * a single `Date` object.
         * Otherwise it is an array of `Date` objects.
         */
        get: /**
         * Gets the selected date(s).
         *
         * When selection is set to `single`, it returns
         * a single `Date` object.
         * Otherwise it is an array of `Date` objects.
         * @return {?}
         */
        function () {
            return this.selectedDates;
        },
        /**
         * Sets the selected date(s).
         *
         * When selection is set to `single`, it accepts
         * a single `Date` object.
         * Otherwise it is an array of `Date` objects.
         */
        set: /**
         * Sets the selected date(s).
         *
         * When selection is set to `single`, it accepts
         * a single `Date` object.
         * Otherwise it is an array of `Date` objects.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.selectDate(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxCalendarBase.prototype, "viewDate", {
        /**
         * Gets the date that is presented.
         * By default it is the current date.
         */
        get: /**
         * Gets the date that is presented.
         * By default it is the current date.
         * @return {?}
         */
        function () {
            return this._viewDate;
        },
        /**
         * Sets the date that will be presented in the default view when the component renders.
         */
        set: /**
         * Sets the date that will be presented in the default view when the component renders.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._viewDate = this.getDateOnly(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxCalendarBase.prototype, "disabledDates", {
        /**
         * Gets the disabled dates descriptors.
         */
        get: /**
         * Gets the disabled dates descriptors.
         * @return {?}
         */
        function () {
            return this._disabledDates;
        },
        /**
         * Sets the disabled dates' descriptors.
         * ```typescript
         *@ViewChild("MyCalendar")
         *public calendar: IgxCalendarComponent;
         *ngOnInit(){
         *    this.calendar.disabledDates = [
         *     {type: DateRangeType.Between, dateRange: [new Date("2020-1-1"), new Date("2020-1-15")]},
         *     {type: DateRangeType.Weekends}];
         *}
         *```
         */
        set: /**
         * Sets the disabled dates' descriptors.
         * ```typescript
         * \@ViewChild("MyCalendar")
         * public calendar: IgxCalendarComponent;
         * ngOnInit(){
         *    this.calendar.disabledDates = [
         *     {type: DateRangeType.Between, dateRange: [new Date("2020-1-1"), new Date("2020-1-15")]},
         *     {type: DateRangeType.Weekends}];
         * }
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._disabledDates = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxCalendarBase.prototype, "specialDates", {
        /**
         * Gets the special dates descriptors.
         */
        get: /**
         * Gets the special dates descriptors.
         * @return {?}
         */
        function () {
            return this._specialDates;
        },
        /**
         * Sets the special dates' descriptors.
         * ```typescript
         *@ViewChild("MyCalendar")
         *public calendar: IgxCalendarComponent;
         *ngOnInit(){
         *    this.calendar.specialDates = [
         *     {type: DateRangeType.Between, dateRange: [new Date("2020-1-1"), new Date("2020-1-15")]},
         *     {type: DateRangeType.Weekends}];
         *}
         *```
         */
        set: /**
         * Sets the special dates' descriptors.
         * ```typescript
         * \@ViewChild("MyCalendar")
         * public calendar: IgxCalendarComponent;
         * ngOnInit(){
         *    this.calendar.specialDates = [
         *     {type: DateRangeType.Between, dateRange: [new Date("2020-1-1"), new Date("2020-1-15")]},
         *     {type: DateRangeType.Weekends}];
         * }
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._specialDates = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *@hidden
     */
    /**
     * @hidden
     * @private
     * @param {?} date
     * @return {?}
     */
    IgxCalendarBase.prototype.getDateOnlyInMs = /**
     * @hidden
     * @private
     * @param {?} date
     * @return {?}
     */
    function (date) {
        return this.getDateOnly(date).getTime();
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @private
     * @param {?} start
     * @param {?} end
     * @return {?}
     */
    IgxCalendarBase.prototype.generateDateRange = /**
     * @hidden
     * @private
     * @param {?} start
     * @param {?} end
     * @return {?}
     */
    function (start, end) {
        /** @type {?} */
        var result = [];
        start = this.getDateOnly(start);
        end = this.getDateOnly(end);
        while (start.getTime() !== end.getTime()) {
            start = this.calendarModel.timedelta(start, 'day', 1);
            result.push(start);
        }
        return result;
    };
    /**
     * Performs a single selection.
     * @hidden
     */
    /**
     * Performs a single selection.
     * @hidden
     * @private
     * @param {?} value
     * @return {?}
     */
    IgxCalendarBase.prototype.selectSingle = /**
     * Performs a single selection.
     * @hidden
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.selectedDates = this.getDateOnly(value);
        this._onChangeCallback(this.selectedDates);
    };
    /**
     * Performs a multiple selection
     * @hidden
     */
    /**
     * Performs a multiple selection
     * @hidden
     * @private
     * @param {?} value
     * @return {?}
     */
    IgxCalendarBase.prototype.selectMultiple = /**
     * Performs a multiple selection
     * @hidden
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        var _this = this;
        if (Array.isArray(value)) {
            this.selectedDates = this.selectedDates.concat(value.map(function (v) { return _this.getDateOnly(v); }));
        }
        else {
            /** @type {?} */
            var valueDateOnly_1 = this.getDateOnly(value);
            /** @type {?} */
            var newSelection = [];
            if (this.selectedDates.every(function (date) { return date.getTime() !== valueDateOnly_1.getTime(); })) {
                newSelection.push(valueDateOnly_1);
            }
            else {
                this.selectedDates = this.selectedDates.filter(function (date) { return date.getTime() !== valueDateOnly_1.getTime(); });
            }
            if (newSelection.length > 0) {
                this.selectedDates = this.selectedDates.concat(newSelection);
            }
        }
        this._onChangeCallback(this.selectedDates);
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @private
     * @param {?} value
     * @param {?=} excludeDisabledDates
     * @return {?}
     */
    IgxCalendarBase.prototype.selectRange = /**
     * @hidden
     * @private
     * @param {?} value
     * @param {?=} excludeDisabledDates
     * @return {?}
     */
    function (value, excludeDisabledDates) {
        var _this = this;
        if (excludeDisabledDates === void 0) { excludeDisabledDates = false; }
        /** @type {?} */
        var start;
        /** @type {?} */
        var end;
        if (Array.isArray(value)) {
            // this.rangeStarted = false;
            value.sort(function (a, b) { return a.valueOf() - b.valueOf(); });
            start = this.getDateOnly(value[0]);
            end = this.getDateOnly(value[value.length - 1]);
            this.selectedDates = __spread([start], this.generateDateRange(start, end));
        }
        else {
            if (!this.rangeStarted) {
                this.rangeStarted = true;
                this.selectedDates = [value];
            }
            else {
                this.rangeStarted = false;
                if (this.selectedDates[0].getTime() === value.getTime()) {
                    this.selectedDates = [];
                    this._onChangeCallback(this.selectedDates);
                    return;
                }
                this.selectedDates.push(value);
                this.selectedDates.sort(function (a, b) { return a.valueOf() - b.valueOf(); });
                start = this.selectedDates.shift();
                end = this.selectedDates.pop();
                this.selectedDates = __spread([start], this.generateDateRange(start, end));
            }
        }
        if (excludeDisabledDates) {
            this.selectedDates = this.selectedDates.filter(function (d) { return !_this.isDateDisabled(d); });
        }
        this._onChangeCallback(this.selectedDates);
    };
    /**
     * Performs a single deselection.
     * @hidden
     */
    /**
     * Performs a single deselection.
     * @hidden
     * @private
     * @param {?} value
     * @return {?}
     */
    IgxCalendarBase.prototype.deselectSingle = /**
     * Performs a single deselection.
     * @hidden
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (this.selectedDates !== null &&
            this.getDateOnlyInMs((/** @type {?} */ (value))) === this.getDateOnlyInMs(this.selectedDates)) {
            this.selectedDates = null;
            this._onChangeCallback(this.selectedDates);
        }
    };
    /**
     * Performs a multiple deselection.
     * @hidden
     */
    /**
     * Performs a multiple deselection.
     * @hidden
     * @private
     * @param {?} value
     * @return {?}
     */
    IgxCalendarBase.prototype.deselectMultiple = /**
     * Performs a multiple deselection.
     * @hidden
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        var _this = this;
        value = value.filter(function (v) { return v !== null; });
        /** @type {?} */
        var selectedDatesCount = this.selectedDates.length;
        /** @type {?} */
        var datesInMsToDeselect = new Set(value.map(function (v) { return _this.getDateOnlyInMs(v); }));
        for (var i = this.selectedDates.length - 1; i >= 0; i--) {
            if (datesInMsToDeselect.has(this.getDateOnlyInMs(this.selectedDates[i]))) {
                this.selectedDates.splice(i, 1);
            }
        }
        if (this.selectedDates.length !== selectedDatesCount) {
            this._onChangeCallback(this.selectedDates);
        }
    };
    /**
     * Performs a range deselection.
     * @hidden
     */
    /**
     * Performs a range deselection.
     * @hidden
     * @private
     * @param {?} value
     * @return {?}
     */
    IgxCalendarBase.prototype.deselectRange = /**
     * Performs a range deselection.
     * @hidden
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        value = value.filter(function (v) { return v !== null; });
        if (value.length < 1) {
            return;
        }
        value.sort(function (a, b) { return a.valueOf() - b.valueOf(); });
        /** @type {?} */
        var valueStart = this.getDateOnlyInMs(value[0]);
        /** @type {?} */
        var valueEnd = this.getDateOnlyInMs(value[value.length - 1]);
        this.selectedDates.sort(function (a, b) { return a.valueOf() - b.valueOf(); });
        /** @type {?} */
        var selectedDatesStart = this.getDateOnlyInMs(this.selectedDates[0]);
        /** @type {?} */
        var selectedDatesEnd = this.getDateOnlyInMs(this.selectedDates[this.selectedDates.length - 1]);
        if (!(valueEnd < selectedDatesStart) && !(valueStart > selectedDatesEnd)) {
            this.selectedDates = [];
            this.rangeStarted = false;
            this._onChangeCallback(this.selectedDates);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    IgxCalendarBase.prototype.initFormatters = /**
     * @hidden
     * @protected
     * @return {?}
     */
    function () {
        this.formatterDay = new Intl.DateTimeFormat(this._locale, { day: this._formatOptions.day });
        this.formatterWeekday = new Intl.DateTimeFormat(this._locale, { weekday: this._formatOptions.weekday });
        this.formatterMonth = new Intl.DateTimeFormat(this._locale, { month: this._formatOptions.month });
        this.formatterYear = new Intl.DateTimeFormat(this._locale, { year: this._formatOptions.year });
        this.formatterMonthday = new Intl.DateTimeFormat(this._locale, { month: this._formatOptions.month, day: this._formatOptions.day });
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} date
     * @return {?}
     */
    IgxCalendarBase.prototype.getDateOnly = /**
     * @hidden
     * @protected
     * @param {?} date
     * @return {?}
     */
    function (date) {
        return new Date(date.getFullYear(), date.getMonth(), date.getDate());
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    IgxCalendarBase.prototype.registerOnChange = /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._onChangeCallback = fn;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    IgxCalendarBase.prototype.registerOnTouched = /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._onTouchedCallback = fn;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    IgxCalendarBase.prototype.writeValue = /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.selectedDates = value;
    };
    /**
     * Checks whether a date is disabled.
     * @hidden
     */
    /**
     * Checks whether a date is disabled.
     * @hidden
     * @param {?} date
     * @return {?}
     */
    IgxCalendarBase.prototype.isDateDisabled = /**
     * Checks whether a date is disabled.
     * @hidden
     * @param {?} date
     * @return {?}
     */
    function (date) {
        if (this.disabledDates === null) {
            return false;
        }
        return isDateInRanges(date, this.disabledDates);
    };
    /**
     * Selects date(s) (based on the selection type).
     */
    /**
     * Selects date(s) (based on the selection type).
     * @param {?} value
     * @return {?}
     */
    IgxCalendarBase.prototype.selectDate = /**
     * Selects date(s) (based on the selection type).
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value === null || value === undefined || (Array.isArray(value) && value.length === 0)) {
            return new Date();
        }
        switch (this.selection) {
            case CalendarSelection.SINGLE:
                this.selectSingle((/** @type {?} */ (value)));
                break;
            case CalendarSelection.MULTI:
                this.selectMultiple(value);
                break;
            case CalendarSelection.RANGE:
                this.selectRange(value, true);
                break;
        }
    };
    /**
     * Deselects date(s) (based on the selection type).
     */
    /**
     * Deselects date(s) (based on the selection type).
     * @param {?=} value
     * @return {?}
     */
    IgxCalendarBase.prototype.deselectDate = /**
     * Deselects date(s) (based on the selection type).
     * @param {?=} value
     * @return {?}
     */
    function (value) {
        if (this.selectedDates === null || this.selectedDates === []) {
            return;
        }
        if (value === null || value === undefined) {
            this.selectedDates = this.selection === CalendarSelection.SINGLE ? null : [];
            this.rangeStarted = false;
            this._onChangeCallback(this.selectedDates);
            return;
        }
        switch (this.selection) {
            case CalendarSelection.SINGLE:
                this.deselectSingle((/** @type {?} */ (value)));
                break;
            case CalendarSelection.MULTI:
                this.deselectMultiple((/** @type {?} */ (value)));
                break;
            case CalendarSelection.RANGE:
                this.deselectRange((/** @type {?} */ (value)));
                break;
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    IgxCalendarBase.prototype.selectDateFromClient = /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    function (value) {
        switch (this.selection) {
            case CalendarSelection.SINGLE:
            case CalendarSelection.MULTI:
                if (!this.isDateDisabled(value)) {
                    this.selectDate(value);
                }
                break;
            case CalendarSelection.RANGE:
                this.selectRange(value, true);
                break;
        }
    };
    IgxCalendarBase.propDecorators = {
        weekStart: [{ type: Input }],
        locale: [{ type: Input }],
        formatOptions: [{ type: Input }],
        formatViews: [{ type: Input }],
        selection: [{ type: Input }],
        value: [{ type: Input }],
        viewDate: [{ type: Input }],
        disabledDates: [{ type: Input }],
        specialDates: [{ type: Input }],
        onSelection: [{ type: Output }]
    };
    return IgxCalendarBase;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
var CalendarView = {
    DEFAULT: 0,
    YEAR: 1,
    DECADE: 2,
};
CalendarView[CalendarView.DEFAULT] = 'DEFAULT';
CalendarView[CalendarView.YEAR] = 'YEAR';
CalendarView[CalendarView.DECADE] = 'DECADE';
var IgxMonthPickerBase = /** @class */ (function (_super) {
    __extends(IgxMonthPickerBase, _super);
    function IgxMonthPickerBase() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * The default `tabindex` attribute for the component.
         *
         * @hidden
         */
        _this.tabindex = 0;
        /**
         * @hidden
         */
        _this._activeView = CalendarView.DEFAULT;
        return _this;
    }
    Object.defineProperty(IgxMonthPickerBase.prototype, "activeView", {
        /**
         * Gets the current active view.
         */
        get: /**
         * Gets the current active view.
         * @return {?}
         */
        function () {
            return this._activeView;
        },
        /**
         * Sets the current active view.
         */
        set: /**
         * Sets the current active view.
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._activeView = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxMonthPickerBase.prototype, "isDefaultView", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._activeView === CalendarView.DEFAULT;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxMonthPickerBase.prototype, "isDecadeView", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._activeView === CalendarView.DECADE;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxMonthPickerBase.prototype.changeYear = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        this.viewDate = new Date(event.getFullYear(), this.viewDate.getMonth());
        this._activeView = CalendarView.DEFAULT;
        requestAnimationFrame(function () {
            _this.yearsBtn.nativeElement.focus();
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxMonthPickerBase.prototype.activeViewDecade = /**
     * @hidden
     * @return {?}
     */
    function () {
        this._activeView = CalendarView.DECADE;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxMonthPickerBase.prototype.activeViewDecadeKB = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
            event.preventDefault();
            this.activeViewDecade();
        }
    };
    /**
     * Returns the locale representation of the year in the year view if enabled,
     * otherwise returns the default `Date.getFullYear()` value.
     *
     * @hidden
     */
    /**
     * Returns the locale representation of the year in the year view if enabled,
     * otherwise returns the default `Date.getFullYear()` value.
     *
     * @hidden
     * @param {?} value
     * @return {?}
     */
    IgxMonthPickerBase.prototype.formattedYear = /**
     * Returns the locale representation of the year in the year view if enabled,
     * otherwise returns the default `Date.getFullYear()` value.
     *
     * @hidden
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (this.formatViews.year) {
            return this.formatterYear.format(value);
        }
        return "" + value.getFullYear();
    };
    IgxMonthPickerBase.propDecorators = {
        yearsBtn: [{ type: ViewChild, args: ['yearsBtn',] }],
        tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }]
    };
    return IgxMonthPickerBase;
}(IgxCalendarBase));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var NEXT_ID$c = 0;
var IgxMonthsViewComponent = /** @class */ (function () {
    function IgxMonthsViewComponent(el) {
        this.el = el;
        /**
         * Sets/gets the `id` of the months view.
         * If not set, the `id` will have value `"igx-months-view-0"`.
         * ```html
         * <igx-months-view id="my-months-view"></igx-months-view>
         * ```
         * ```typescript
         * let monthsViewId =  this.monthsView.id;
         * ```
         * \@memberof IgxMonthsViewComponent
         */
        this.id = "igx-months-view-" + NEXT_ID$c++;
        /**
         * Gets/sets the selected date of the months view.
         * By default it is the current date.
         * ```html
         * <igx-months-view [date]="myDate"></igx-months-view>
         * ```
         * ```typescript
         * let date =  this.monthsView.date;
         * ```
         * \@memberof IgxMonthsViewComponent
         */
        this.date = new Date();
        /**
         * Gets/sets whether the view should be rendered
         * according to the locale and monthFormat, if any.
         */
        this.formatView = true;
        /**
         * Emits an event when a selection is made in the months view.
         * Provides reference the `date` property in the `IgxMonthsViewComponent`.
         * ```html
         * <igx-months-view (onSelection)="onSelection($event)"></igx-months-view>
         * ```
         * \@memberof IgxMonthsViewComponent
         */
        this.onSelection = new EventEmitter();
        /**
         * The default css class applied to the component.
         *
         * @hidden
         */
        this.styleClass = true;
        /**
         * The default `tabindex` attribute for the component.
         *
         * @hidden
         */
        this.tabindex = 0;
        /**
         * @hidden
         */
        this._locale = 'en';
        /**
         * @hidden
         */
        this._monthFormat = 'short';
        /**
         * @hidden
         */
        this._onTouchedCallback = function () { };
        /**
         * @hidden
         */
        this._onChangeCallback = function () { };
        this.initMonthFormatter();
        this._calendarModel = new Calendar();
    }
    Object.defineProperty(IgxMonthsViewComponent.prototype, "monthFormat", {
        /**
         * Gets the month format option of the months view.
         * ```typescript
         * let monthFormat = this.monthsView.monthFormat.
         * ```
         */
        get: /**
         * Gets the month format option of the months view.
         * ```typescript
         * let monthFormat = this.monthsView.monthFormat.
         * ```
         * @return {?}
         */
        function () {
            return this._monthFormat;
        },
        /**
         * Sets the month format option of the months view.
         * ```html
         * <igx-months-view> [monthFormat] = "short'"</igx-months-view>
         * ```
         * @memberof IgxMonthsViewComponent
         */
        set: /**
         * Sets the month format option of the months view.
         * ```html
         * <igx-months-view> [monthFormat] = "short'"</igx-months-view>
         * ```
         * \@memberof IgxMonthsViewComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._monthFormat = value;
            this.initMonthFormatter();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxMonthsViewComponent.prototype, "locale", {
        /**
         * Gets the `locale` of the months view.
         * Default value is `"en"`.
         * ```typescript
         * let locale =  this.monthsView.locale;
         * ```
         * @memberof IgxMonthsViewComponent
         */
        get: /**
         * Gets the `locale` of the months view.
         * Default value is `"en"`.
         * ```typescript
         * let locale =  this.monthsView.locale;
         * ```
         * \@memberof IgxMonthsViewComponent
         * @return {?}
         */
        function () {
            return this._locale;
        },
        /**
         * Sets the `locale` of the months view.
         * Expects a valid BCP 47 language tag.
         * Default value is `"en"`.
         * ```html
         * <igx-months-view [locale]="de"></igx-months-view>
         * ```
         * @memberof IgxMonthsViewComponent
         */
        set: /**
         * Sets the `locale` of the months view.
         * Expects a valid BCP 47 language tag.
         * Default value is `"en"`.
         * ```html
         * <igx-months-view [locale]="de"></igx-months-view>
         * ```
         * \@memberof IgxMonthsViewComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._locale = value;
            this.initMonthFormatter();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxMonthsViewComponent.prototype, "months", {
        /**
         * Returns an array of date objects which are then used to
         * properly render the month names.
         *
         * Used in the template of the component
         *
         * @hidden
         */
        get: /**
         * Returns an array of date objects which are then used to
         * properly render the month names.
         *
         * Used in the template of the component
         *
         * @hidden
         * @return {?}
         */
        function () {
            /** @type {?} */
            var start = new Date(this.date.getFullYear(), 0, 1);
            /** @type {?} */
            var result = [];
            for (var i = 0; i < 12; i++) {
                result.push(start);
                start = this._calendarModel.timedelta(start, 'month', 1);
            }
            return result;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the locale representation of the month in the months view.
     *
     * @hidden
     */
    /**
     * Returns the locale representation of the month in the months view.
     *
     * @hidden
     * @param {?} value
     * @return {?}
     */
    IgxMonthsViewComponent.prototype.formattedMonth = /**
     * Returns the locale representation of the month in the months view.
     *
     * @hidden
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (this.formatView) {
            return this._formatterMonth.format(value);
        }
        return "" + value.getMonth();
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxMonthsViewComponent.prototype.selectMonth = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onSelection.emit(event);
        this.date = event;
        this._onChangeCallback(this.date);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    IgxMonthsViewComponent.prototype.registerOnChange = /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._onChangeCallback = fn;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    IgxMonthsViewComponent.prototype.registerOnTouched = /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._onTouchedCallback = fn;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    IgxMonthsViewComponent.prototype.writeValue = /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value) {
            this.date = value;
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    IgxMonthsViewComponent.prototype.monthTracker = /**
     * @hidden
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    function (index, item) {
        return item.getMonth() + "}";
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @private
     * @return {?}
     */
    IgxMonthsViewComponent.prototype.initMonthFormatter = /**
     * @hidden
     * @private
     * @return {?}
     */
    function () {
        this._formatterMonth = new Intl.DateTimeFormat(this._locale, { month: this.monthFormat });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxMonthsViewComponent.prototype.onKeydownArrowUp = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        event.stopPropagation();
        /** @type {?} */
        var node = this.dates.find(function (date) { return date.nativeElement === event.target; });
        if (!node) {
            return;
        }
        /** @type {?} */
        var months = this.dates.toArray();
        /** @type {?} */
        var nodeRect = node.nativeElement.getBoundingClientRect();
        for (var index = months.indexOf(node) - 1; index >= 0; index--) {
            /** @type {?} */
            var nextNodeRect = months[index].nativeElement.getBoundingClientRect();
            if (nodeRect.top !== nextNodeRect.top && nodeRect.left === nextNodeRect.left) {
                months[index].nativeElement.focus();
                break;
            }
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxMonthsViewComponent.prototype.onKeydownArrowDown = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        event.stopPropagation();
        /** @type {?} */
        var node = this.dates.find(function (date) { return date.nativeElement === event.target; });
        if (!node) {
            return;
        }
        /** @type {?} */
        var months = this.dates.toArray();
        /** @type {?} */
        var nodeRect = node.nativeElement.getBoundingClientRect();
        for (var index = months.indexOf(node) + 1; index < months.length; index++) {
            /** @type {?} */
            var nextNodeRect = months[index].nativeElement.getBoundingClientRect();
            if (nodeRect.top !== nextNodeRect.top && nodeRect.left === nextNodeRect.left) {
                months[index].nativeElement.focus();
                break;
            }
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxMonthsViewComponent.prototype.onKeydownArrowRight = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        event.stopPropagation();
        /** @type {?} */
        var node = this.dates.find(function (date) { return date.nativeElement === event.target; });
        if (!node) {
            return;
        }
        /** @type {?} */
        var months = this.dates.toArray();
        if (months.indexOf(node) + 1 < months.length) {
            /** @type {?} */
            var month = months[months.indexOf(node) + 1];
            month.nativeElement.focus();
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxMonthsViewComponent.prototype.onKeydownArrowLeft = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        event.stopPropagation();
        /** @type {?} */
        var node = this.dates.find(function (date) { return date.nativeElement === event.target; });
        if (!node) {
            return;
        }
        /** @type {?} */
        var months = this.dates.toArray();
        if (months.indexOf(node) - 1 >= 0) {
            /** @type {?} */
            var month = months[months.indexOf(node) - 1];
            month.nativeElement.focus();
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxMonthsViewComponent.prototype.onKeydownHome = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        event.stopPropagation();
        /** @type {?} */
        var month = this.dates.toArray()[0];
        month.nativeElement.focus();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxMonthsViewComponent.prototype.onKeydownEnd = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        event.stopPropagation();
        /** @type {?} */
        var months = this.dates.toArray();
        /** @type {?} */
        var month = months[months.length - 1];
        month.nativeElement.focus();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxMonthsViewComponent.prototype.onKeydownEnter = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var value = this.dates.find(function (date) { return date.nativeElement === event.target; }).value;
        this.date = new Date(value.getFullYear(), value.getMonth(), this.date.getDate());
        this.onSelection.emit(this.date);
        this._onChangeCallback(this.date);
    };
    IgxMonthsViewComponent.decorators = [
        { type: Component, args: [{
                    providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: IgxMonthsViewComponent, multi: true }],
                    selector: 'igx-months-view',
                    template: "<div class=\"igx-calendar__body\">\n    <div class=\"igx-calendar__body-row--wrap\">\n        <div [igxCalendarMonth]=\"month\" [date]=\"date\" (onMonthSelection)=\"selectMonth($event)\" [index]=\"i\" *ngFor=\"let month of months; index as i; trackBy: monthTracker\">\n            {{ formattedMonth(month) | titlecase }}\n        </div>\n    </div>\n</div>\n\n"
                }] }
    ];
    /** @nocollapse */
    IgxMonthsViewComponent.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    IgxMonthsViewComponent.propDecorators = {
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        date: [{ type: Input }],
        monthFormat: [{ type: Input }],
        locale: [{ type: Input }],
        formatView: [{ type: Input }],
        onSelection: [{ type: Output }],
        styleClass: [{ type: HostBinding, args: ['class.igx-calendar',] }],
        dates: [{ type: ViewChildren, args: [IgxCalendarMonthDirective, { read: IgxCalendarMonthDirective },] }],
        tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
        onKeydownArrowUp: [{ type: HostListener, args: ['keydown.arrowup', ['$event'],] }],
        onKeydownArrowDown: [{ type: HostListener, args: ['keydown.arrowdown', ['$event'],] }],
        onKeydownArrowRight: [{ type: HostListener, args: ['keydown.arrowright', ['$event'],] }],
        onKeydownArrowLeft: [{ type: HostListener, args: ['keydown.arrowleft', ['$event'],] }],
        onKeydownHome: [{ type: HostListener, args: ['keydown.home', ['$event'],] }],
        onKeydownEnd: [{ type: HostListener, args: ['keydown.end', ['$event'],] }],
        onKeydownEnter: [{ type: HostListener, args: ['keydown.enter', ['$event'],] }]
    };
    return IgxMonthsViewComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var NEXT_ID$d = 0;
var CalendarHammerConfig = /** @class */ (function (_super) {
    __extends(CalendarHammerConfig, _super);
    function CalendarHammerConfig() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.overrides = {
            pan: { direction: Hammer.DIRECTION_VERTICAL, threshold: 1 }
        };
        return _this;
    }
    CalendarHammerConfig.decorators = [
        { type: Injectable }
    ];
    return CalendarHammerConfig;
}(HammerGestureConfig));
var IgxYearsViewComponent = /** @class */ (function () {
    function IgxYearsViewComponent(el) {
        this.el = el;
        /**
         * Sets/gets the `id` of the years view.
         * If not set, the `id` will have value `"igx-years-view-0"`.
         * ```html
         * <igx-years-view id = "my-years-view"></igx-years-view>
         * ```
         * ```typescript
         * let yearsViewId =  this.yearsView.id;
         * ```
         * \@memberof IgxCalendarComponent
         */
        this.id = "igx-years-view-" + NEXT_ID$d++;
        /**
         * Gets/sets the selected date of the years view.
         * By default it is the current date.
         * ```html
         * <igx-years-view [date]="myDate"></igx-years-view>
         * ```
         * ```typescript
         * let date =  this.yearsView.date;
         * ```
         * \@memberof IgxYearsViewComponent
         */
        this.date = new Date();
        /**
         * Emits an event when a selection is made in the years view.
         * Provides reference the `date` property in the `IgxYearsViewComponent`.
         * ```html
         * <igx-years-view (onSelection)="onSelection($event)"></igx-years-view>
         * ```
         * \@memberof IgxYearsViewComponent
         */
        this.onSelection = new EventEmitter();
        /**
         * The default css class applied to the component.
         *
         * @hidden
         */
        this.styleClass = true;
        /**
         * The default `tabindex` attribute for the component.
         *
         * @hidden
         */
        this.tabindex = 0;
        /**
         * @hidden
         */
        this._locale = 'en';
        /**
         * @hidden
         */
        this._yearFormat = 'numeric';
        /**
         * @hidden
         */
        this._onTouchedCallback = function () { };
        /**
         * @hidden
         */
        this._onChangeCallback = function () { };
        this.initYearFormatter();
        this._calendarModel = new Calendar();
    }
    Object.defineProperty(IgxYearsViewComponent.prototype, "yearFormat", {
        /**
         * Gets the year format option of the years view.
         * ```typescript
         * let yearFormat = this.yearsView.yearFormat.
         * ```
         */
        get: /**
         * Gets the year format option of the years view.
         * ```typescript
         * let yearFormat = this.yearsView.yearFormat.
         * ```
         * @return {?}
         */
        function () {
            return this._yearFormat;
        },
        /**
         * Sets the year format option of the years view.
         * ```html
         * <igx-years-view [yearFormat]="numeric"></igx-years-view>
         * ```
         * @memberof IgxYearsViewComponent
         */
        set: /**
         * Sets the year format option of the years view.
         * ```html
         * <igx-years-view [yearFormat]="numeric"></igx-years-view>
         * ```
         * \@memberof IgxYearsViewComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._yearFormat = value;
            this.initYearFormatter();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxYearsViewComponent.prototype, "locale", {
        /**
         * Gets the `locale` of the years view.
         * Default value is `"en"`.
         * ```typescript
         * let locale =  this.yearsView.locale;
         * ```
         * @memberof IgxYearsViewComponent
         */
        get: /**
         * Gets the `locale` of the years view.
         * Default value is `"en"`.
         * ```typescript
         * let locale =  this.yearsView.locale;
         * ```
         * \@memberof IgxYearsViewComponent
         * @return {?}
         */
        function () {
            return this._locale;
        },
        /**
         * Sets the `locale` of the years view.
         * Expects a valid BCP 47 language tag.
         * Default value is `"en"`.
         * ```html
         * <igx-years-view [locale]="de"></igx-years-view>
         * ```
         * @memberof IgxYearsViewComponent
         */
        set: /**
         * Sets the `locale` of the years view.
         * Expects a valid BCP 47 language tag.
         * Default value is `"en"`.
         * ```html
         * <igx-years-view [locale]="de"></igx-years-view>
         * ```
         * \@memberof IgxYearsViewComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._locale = value;
            this.initYearFormatter();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxYearsViewComponent.prototype, "decade", {
        /**
         * Returns an array of date objects which are then used to properly
         * render the years.
         *
         * Used in the template of the component.
         *
         * @hidden
         */
        get: /**
         * Returns an array of date objects which are then used to properly
         * render the years.
         *
         * Used in the template of the component.
         *
         * @hidden
         * @return {?}
         */
        function () {
            var e_1, _a;
            /** @type {?} */
            var result = [];
            /** @type {?} */
            var start = this.date.getFullYear() - 3;
            /** @type {?} */
            var end = this.date.getFullYear() + 4;
            try {
                for (var _b = __values(range(start, end)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var year = _c.value;
                    result.push(new Date(year, this.date.getMonth(), this.date.getDate()));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return result;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the locale representation of the year in the years view.
     *
     * @hidden
     */
    /**
     * Returns the locale representation of the year in the years view.
     *
     * @hidden
     * @param {?} value
     * @return {?}
     */
    IgxYearsViewComponent.prototype.formattedYear = /**
     * Returns the locale representation of the year in the years view.
     *
     * @hidden
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (this.formatView) {
            return this._formatterYear.format(value);
        }
        return "" + value.getFullYear();
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxYearsViewComponent.prototype.selectYear = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.date = event;
        this.onSelection.emit(this.date);
        this._onChangeCallback(this.date);
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxYearsViewComponent.prototype.scroll = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        event.stopPropagation();
        /** @type {?} */
        var delta = event.deltaY < 0 ? -1 : 1;
        this.generateYearRange(delta);
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxYearsViewComponent.prototype.pan = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var delta = event.deltaY < 0 ? 1 : -1;
        this.generateYearRange(delta);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    IgxYearsViewComponent.prototype.registerOnChange = /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._onChangeCallback = fn;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    IgxYearsViewComponent.prototype.registerOnTouched = /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._onTouchedCallback = fn;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    IgxYearsViewComponent.prototype.yearTracker = /**
     * @hidden
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    function (index, item) {
        return item.getFullYear() + "}";
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    IgxYearsViewComponent.prototype.writeValue = /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value) {
            this.date = value;
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxYearsViewComponent.prototype.onKeydownArrowDown = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        event.stopPropagation();
        this.generateYearRange(1);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxYearsViewComponent.prototype.onKeydownArrowUp = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        event.stopPropagation();
        this.generateYearRange(-1);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxYearsViewComponent.prototype.onKeydownEnter = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.onSelection.emit(this.date);
        this._onChangeCallback(this.date);
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @private
     * @return {?}
     */
    IgxYearsViewComponent.prototype.initYearFormatter = /**
     * @hidden
     * @private
     * @return {?}
     */
    function () {
        this._formatterYear = new Intl.DateTimeFormat(this._locale, { year: this.yearFormat });
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @private
     * @param {?} delta
     * @return {?}
     */
    IgxYearsViewComponent.prototype.generateYearRange = /**
     * @hidden
     * @private
     * @param {?} delta
     * @return {?}
     */
    function (delta) {
        /** @type {?} */
        var currentYear = new Date().getFullYear();
        if ((delta > 0 && this.date.getFullYear() - currentYear >= 95) ||
            (delta < 0 && currentYear - this.date.getFullYear() >= 95)) {
            return;
        }
        this.date = this._calendarModel.timedelta(this.date, 'year', delta);
    };
    IgxYearsViewComponent.decorators = [
        { type: Component, args: [{
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: IgxYearsViewComponent,
                            multi: true
                        },
                        {
                            provide: HAMMER_GESTURE_CONFIG,
                            useClass: CalendarHammerConfig
                        }
                    ],
                    selector: 'igx-years-view',
                    template: "<div class=\"igx-calendar__body\">\n    <div class=\"igx-calendar__body-column\" (wheel)=\"scroll($event)\" (pan)=\"pan($event)\">\n        <span [igxCalendarYear]=\"year\" [date]=\"date\" (onYearSelection)=\"selectYear($event)\" *ngFor=\"let year of decade; trackBy: yearTracker\">\n            {{ formattedYear(year) }}\n        </span>\n    </div>\n</div>\n"
                }] }
    ];
    /** @nocollapse */
    IgxYearsViewComponent.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    IgxYearsViewComponent.propDecorators = {
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        date: [{ type: Input }],
        yearFormat: [{ type: Input }],
        locale: [{ type: Input }],
        formatView: [{ type: Input }],
        onSelection: [{ type: Output }],
        styleClass: [{ type: HostBinding, args: ['class.igx-calendar',] }],
        tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
        onKeydownArrowDown: [{ type: HostListener, args: ['keydown.arrowdown', ['$event'],] }],
        onKeydownArrowUp: [{ type: HostListener, args: ['keydown.arrowup', ['$event'],] }],
        onKeydownEnter: [{ type: HostListener, args: ['keydown.enter',] }]
    };
    return IgxYearsViewComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxDayItemComponent = /** @class */ (function () {
    function IgxDayItemComponent(elementRef) {
        this.elementRef = elementRef;
        this.onDateSelection = new EventEmitter();
        this.tabindex = 0;
        this._selected = false;
    }
    Object.defineProperty(IgxDayItemComponent.prototype, "selected", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var date = this.date.date;
            if (!this.value) {
                return;
            }
            if (this.selection === CalendarSelection.SINGLE) {
                this._selected = ((/** @type {?} */ (this.value))).getTime() === date.getTime();
            }
            else {
                this._selected = ((/** @type {?} */ (this.value)))
                    .some(function (each) { return each.getTime() === date.getTime(); });
            }
            return this._selected;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._selected = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDayItemComponent.prototype, "isCurrentMonth", {
        get: /**
         * @return {?}
         */
        function () {
            return this.date.isCurrentMonth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDayItemComponent.prototype, "isPreviousMonth", {
        get: /**
         * @return {?}
         */
        function () {
            return this.date.isPrevMonth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDayItemComponent.prototype, "isNextMonth", {
        get: /**
         * @return {?}
         */
        function () {
            return this.date.isNextMonth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDayItemComponent.prototype, "nativeElement", {
        get: /**
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDayItemComponent.prototype, "isInactive", {
        get: /**
         * @return {?}
         */
        function () {
            return this.date.isNextMonth || this.date.isPrevMonth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDayItemComponent.prototype, "isToday", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var today = new Date(Date.now());
            /** @type {?} */
            var date = this.date.date;
            return (date.getFullYear() === today.getFullYear() &&
                date.getMonth() === today.getMonth() &&
                date.getDate() === today.getDate());
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDayItemComponent.prototype, "isWeekend", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var day = this.date.date.getDay();
            return day === 0 || day === 6;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDayItemComponent.prototype, "isDisabled", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.disabledDates === null) {
                return false;
            }
            return isDateInRanges(this.date.date, this.disabledDates);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDayItemComponent.prototype, "isOutOfRange", {
        get: /**
         * @return {?}
         */
        function () {
            if (!this.outOfRangeDates) {
                return false;
            }
            return isDateInRanges(this.date.date, this.outOfRangeDates);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDayItemComponent.prototype, "isSpecial", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.specialDates === null) {
                return false;
            }
            return isDateInRanges(this.date.date, this.specialDates);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDayItemComponent.prototype, "defaultCSS", {
        get: /**
         * @return {?}
         */
        function () {
            return this.date.isCurrentMonth && !(this.isWeekend && this.selected);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDayItemComponent.prototype, "isInactiveCSS", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isInactive;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDayItemComponent.prototype, "isTodayCSS", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isToday && !this.selected;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDayItemComponent.prototype, "isSelectedCSS", {
        get: /**
         * @return {?}
         */
        function () {
            return this.selected;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDayItemComponent.prototype, "isWeekendCSS", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isWeekend;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDayItemComponent.prototype, "isDisabledCSS", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isDisabled || this.isOutOfRange;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDayItemComponent.prototype, "isSpecialCSS", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isSpecial;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    IgxDayItemComponent.prototype.onSelect = /**
     * @return {?}
     */
    function () {
        this.onDateSelection.emit(this.date);
    };
    IgxDayItemComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-day-item',
                    template: "<ng-content></ng-content>\n"
                }] }
    ];
    /** @nocollapse */
    IgxDayItemComponent.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    IgxDayItemComponent.propDecorators = {
        date: [{ type: Input }],
        selection: [{ type: Input }],
        value: [{ type: Input }],
        disabledDates: [{ type: Input }],
        outOfRangeDates: [{ type: Input }],
        specialDates: [{ type: Input }],
        onDateSelection: [{ type: Output }],
        tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
        defaultCSS: [{ type: HostBinding, args: ['class.igx-calendar__date',] }],
        isInactiveCSS: [{ type: HostBinding, args: ['class.igx-calendar__date--inactive',] }],
        isTodayCSS: [{ type: HostBinding, args: ['class.igx-calendar__date--current',] }],
        isSelectedCSS: [{ type: HostBinding, args: ['class.igx-calendar__date--selected',] }],
        isWeekendCSS: [{ type: HostBinding, args: ['class.igx-calendar__date--weekend',] }],
        isDisabledCSS: [{ type: HostBinding, args: ['class.igx-calendar__date--disabled',] }],
        isSpecialCSS: [{ type: HostBinding, args: ['class.igx-calendar__date--special',] }],
        onSelect: [{ type: HostListener, args: ['click',] }, { type: HostListener, args: ['keydown.enter',] }]
    };
    return IgxDayItemComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var NEXT_ID$e = 0;
var IgxDaysViewComponent = /** @class */ (function (_super) {
    __extends(IgxDaysViewComponent, _super);
    function IgxDaysViewComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Sets/gets the `id` of the days view.
         * If not set, the `id` will have value `"igx-days-view-0"`.
         * ```html
         * <igx-days-view id="my-days-view"></igx-days-view>
         * ```
         * ```typescript
         * let daysViewId =  this.daysView.id;
         * ```
         */
        _this.id = "igx-days-view-" + NEXT_ID$e++;
        /**
         * @hidden
         */
        _this.animationAction = '';
        /**
         * @hidden
         */
        _this.changeDaysView = false;
        /**
         * @hidden
         */
        _this.onDateSelection = new EventEmitter();
        /**
         * @hidden
         */
        _this.onViewChanged = new EventEmitter();
        /**
         * @hidden
         */
        _this.isKeydownTrigger = false;
        /**
         * The default css class applied to the component.
         *
         * @hidden
         */
        _this.styleClass = true;
        return _this;
    }
    Object.defineProperty(IgxDaysViewComponent.prototype, "getCalendarMonth", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.calendarModel.monthdatescalendar(this.viewDate.getFullYear(), this.viewDate.getMonth(), true);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxDaysViewComponent.prototype.ngDoCheck = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (!this.changeDaysView && this.dates) {
            this.disableOutOfRangeDates();
        }
    };
    /**
     * Returns the locale representation of the date in the days view.
     *
     * @hidden
     */
    /**
     * Returns the locale representation of the date in the days view.
     *
     * @hidden
     * @param {?} value
     * @return {?}
     */
    IgxDaysViewComponent.prototype.formattedDate = /**
     * Returns the locale representation of the date in the days view.
     *
     * @hidden
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (this.formatViews.day) {
            return this.formatterDay.format(value);
        }
        return "" + value.getDate();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxDaysViewComponent.prototype.generateWeekHeader = /**
     * @hidden
     * @return {?}
     */
    function () {
        var e_1, _a;
        /** @type {?} */
        var dayNames = [];
        /** @type {?} */
        var rv = this.calendarModel.monthdatescalendar(this.viewDate.getFullYear(), this.viewDate.getMonth())[0];
        try {
            for (var rv_1 = __values(rv), rv_1_1 = rv_1.next(); !rv_1_1.done; rv_1_1 = rv_1.next()) {
                var day = rv_1_1.value;
                dayNames.push(this.formatterWeekday.format(day.date));
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (rv_1_1 && !rv_1_1.done && (_a = rv_1.return)) _a.call(rv_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return dayNames;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    IgxDaysViewComponent.prototype.rowTracker = /**
     * @hidden
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    function (index, item) {
        return "" + item[index].date.getMonth() + item[index].date.getDate();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    IgxDaysViewComponent.prototype.dateTracker = /**
     * @hidden
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    function (index, item) {
        return item.date.getMonth() + "--" + item.date.getDate();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    IgxDaysViewComponent.prototype.isCurrentMonth = /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return this.viewDate.getMonth() === value.getMonth();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    IgxDaysViewComponent.prototype.isCurrentYear = /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return this.viewDate.getFullYear() === value.getFullYear();
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxDaysViewComponent.prototype.focusActiveDate = /**
     * @hidden
     * @return {?}
     */
    function () {
        /** @type {?} */
        var date = this.dates.find(function (d) { return d.selected; });
        if (!date) {
            date = this.dates.find(function (d) { return d.isToday; });
        }
        if (date) {
            date.nativeElement.focus();
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxDaysViewComponent.prototype.selectDay = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.selectDateFromClient(event.date);
        this.onDateSelection.emit(event);
        this.onSelection.emit(this.selectedDates);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @param {?} isLast
     * @return {?}
     */
    IgxDaysViewComponent.prototype.animationDone = /**
     * @hidden
     * @param {?} event
     * @param {?} isLast
     * @return {?}
     */
    function (event, isLast) {
        if (isLast) {
            if (this.monthScrollDirection !== ScrollMonth.NONE) {
                this.scrollMonth$.next();
            }
            /** @type {?} */
            var date_1 = this.dates.find(function (d) { return d.selected; });
            if (date_1 && !this.isKeydownTrigger) {
                setTimeout(function () {
                    date_1.nativeElement.focus();
                }, parseInt(slideInRight.options.params.duration, 10));
            }
            else if (this.callback && (event.toState === 'next' || event.toState === 'prev')) {
                this.callback(this.dates, this.nextDate);
            }
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @private
     * @param {?} target
     * @param {?=} prevView
     * @return {?}
     */
    IgxDaysViewComponent.prototype.focusPreviousUpDate = /**
     * @hidden
     * @private
     * @param {?} target
     * @param {?=} prevView
     * @return {?}
     */
    function (target, prevView) {
        var _this = this;
        if (prevView === void 0) { prevView = false; }
        /** @type {?} */
        var node = this.dates.find(function (date) { return date.nativeElement === target; });
        if (!node) {
            return;
        }
        /** @type {?} */
        var dates = this.dates.toArray();
        for (var index = dates.indexOf(node); index - 7 > -1; index -= 7) {
            /** @type {?} */
            var date = prevView ? dates[index] : dates[index - 7];
            if (!date.isDisabled) {
                if (!date.isOutOfRange) {
                    date.nativeElement.focus();
                    break;
                }
            }
        }
        if (this.changeDaysView && dates.indexOf(node) - 7 < 0) {
            /** @type {?} */
            var dayItem = dates[dates.indexOf(node)];
            this.nextDate = new Date(dayItem.date.date);
            this.nextDate.setDate(this.nextDate.getDate() - 7);
            this.isKeydownTrigger = true;
            this.animationAction = 'prev';
            this.callback = function (items, next) {
                /** @type {?} */
                var day = items.find(function (item) { return item.date.date.getTime() === next.getTime(); });
                if (day) {
                    _this.focusPreviousUpDate(day.nativeElement, true);
                }
            };
            this.onViewChanged.emit(this.nextDate);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @private
     * @param {?} target
     * @param {?=} nextView
     * @return {?}
     */
    IgxDaysViewComponent.prototype.focusNextDownDate = /**
     * @hidden
     * @private
     * @param {?} target
     * @param {?=} nextView
     * @return {?}
     */
    function (target, nextView) {
        var _this = this;
        if (nextView === void 0) { nextView = false; }
        /** @type {?} */
        var node = this.dates.find(function (date) { return date.nativeElement === target; });
        if (!node) {
            return;
        }
        /** @type {?} */
        var dates = this.dates.toArray();
        for (var index = dates.indexOf(node); index + 7 < this.dates.length; index += 7) {
            /** @type {?} */
            var date = nextView ? dates[index] : dates[index + 7];
            if (!date.isDisabled) {
                if (!date.isOutOfRange) {
                    date.nativeElement.focus();
                    break;
                }
            }
        }
        if (this.changeDaysView && dates.indexOf(node) + 7 > this.dates.length - 1) {
            /** @type {?} */
            var dayItem = dates[dates.indexOf(node)];
            this.nextDate = new Date(dayItem.date.date);
            this.nextDate.setDate(this.nextDate.getDate() + 7);
            this.isKeydownTrigger = true;
            this.animationAction = 'next';
            this.callback = function (items, next) {
                /** @type {?} */
                var day = items.find(function (item) { return item.date.date.getTime() === next.getTime(); });
                if (day) {
                    _this.focusNextDownDate(day.nativeElement, true);
                }
            };
            this.onViewChanged.emit(this.nextDate);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @private
     * @param {?} target
     * @return {?}
     */
    IgxDaysViewComponent.prototype.focusPreviousDate = /**
     * @hidden
     * @private
     * @param {?} target
     * @return {?}
     */
    function (target) {
        var _this = this;
        /** @type {?} */
        var node = this.dates.find(function (date) { return date.nativeElement === target; });
        if (!node) {
            return;
        }
        /** @type {?} */
        var dates = this.dates.toArray();
        for (var index = dates.indexOf(node); index > 0; index--) {
            /** @type {?} */
            var date = dates[index - 1];
            if (!date.isDisabled) {
                if (!date.isOutOfRange) {
                    date.nativeElement.focus();
                    break;
                }
            }
        }
        if (this.changeDaysView && dates.indexOf(node) === 0) {
            /** @type {?} */
            var dayItem = dates[0];
            if (dayItem.isCurrentMonth) {
                this.nextDate = this.calendarModel.timedelta(dayItem.date.date, 'day', -1);
            }
            else {
                this.nextDate = new Date(dayItem.date.date);
            }
            this.isKeydownTrigger = true;
            this.animationAction = 'prev';
            this.callback = function (items, next) {
                /** @type {?} */
                var day = items.find(function (item) { return item.date.date.getTime() === next.getTime(); });
                if (day) {
                    _this.focusPreviousDate(day.nativeElement);
                }
            };
            this.onViewChanged.emit(this.nextDate);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @private
     * @param {?} target
     * @return {?}
     */
    IgxDaysViewComponent.prototype.focusNextDate = /**
     * @hidden
     * @private
     * @param {?} target
     * @return {?}
     */
    function (target) {
        var _this = this;
        /** @type {?} */
        var node = this.dates.find(function (date) { return date.nativeElement === target; });
        if (!node) {
            return;
        }
        /** @type {?} */
        var dates = this.dates.toArray();
        for (var index = dates.indexOf(node); index < this.dates.length - 1; index++) {
            /** @type {?} */
            var date = dates[index + 1];
            if (!date.isDisabled) {
                if (!date.isOutOfRange) {
                    date.nativeElement.focus();
                    break;
                }
            }
        }
        if (this.changeDaysView && dates.indexOf(node) === this.dates.length - 1) {
            /** @type {?} */
            var dayItem = dates[this.dates.length - 1];
            this.nextDate = new Date(dayItem.date.date);
            this.isKeydownTrigger = true;
            this.animationAction = 'next';
            this.callback = function (items, next) {
                /** @type {?} */
                var day = items.find(function (item) { return item.date.date.getTime() === next.getTime(); });
                if (day) {
                    _this.focusNextDate(day.nativeElement);
                }
            };
            this.onViewChanged.emit(this.nextDate);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @private
     * @return {?}
     */
    IgxDaysViewComponent.prototype.disableOutOfRangeDates = /**
     * @hidden
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var dateRange = [];
        this.dates.toArray().forEach(function (date) {
            if (!date.isCurrentMonth) {
                dateRange.push(date.date.date);
            }
        });
        this.outOfRangeDates = [{
                type: DateRangeType.Specific,
                dateRange: dateRange
            }];
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxDaysViewComponent.prototype.onKeydownArrowUp = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        event.stopPropagation();
        this.focusPreviousUpDate(event.target);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxDaysViewComponent.prototype.onKeydownArrowDown = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        event.stopPropagation();
        this.focusNextDownDate(event.target);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxDaysViewComponent.prototype.onKeydownArrowLeft = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        event.stopPropagation();
        this.focusPreviousDate(event.target);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxDaysViewComponent.prototype.onKeydownArrowRight = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        event.stopPropagation();
        this.focusNextDate(event.target);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxDaysViewComponent.prototype.onKeydownHome = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        event.stopPropagation();
        /** @type {?} */
        var dates = this.dates.filter(function (d) { return d.isCurrentMonth; });
        for (var i = 0; i < dates.length; i++) {
            if (!dates[i].isDisabled) {
                dates[i].nativeElement.focus();
                break;
            }
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxDaysViewComponent.prototype.onKeydownEnd = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        event.stopPropagation();
        /** @type {?} */
        var dates = this.dates.filter(function (d) { return d.isCurrentMonth; });
        for (var i = dates.length - 1; i >= 0; i--) {
            if (!dates[i].isDisabled) {
                dates[i].nativeElement.focus();
                break;
            }
        }
    };
    IgxDaysViewComponent.decorators = [
        { type: Component, args: [{
                    providers: [
                        {
                            multi: true,
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: IgxDaysViewComponent
                        }
                    ],
                    animations: [
                        trigger('animateChange', [
                            transition('* => prev', useAnimation(slideInLeft, {
                                params: {
                                    fromPosition: 'translateX(-30%)'
                                }
                            })),
                            transition('* => next', useAnimation(slideInRight, {
                                params: {
                                    fromPosition: 'translateX(30%)'
                                }
                            }))
                        ])
                    ],
                    selector: 'igx-days-view',
                    template: "<div class=\"igx-calendar__body-row\">\n    <span *ngFor=\"let dayName of generateWeekHeader()\" class=\"igx-calendar__label\">\n        {{ dayName | titlecase }}\n    </span>\n</div>\n\n<div *ngFor=\"let week of getCalendarMonth; last as isLast; index as i; trackBy: rowTracker\" class=\"igx-calendar__body-row\" [@animateChange]=\"animationAction\" (@animateChange.done)=\"animationDone($event, isLast)\">\n    <igx-day-item [date]=\"day\" [selection]=\"selection\" [value]=\"value\" [disabledDates]=\"disabledDates\" [specialDates]=\"specialDates\" [outOfRangeDates]=\"outOfRangeDates\" (onDateSelection)=\"selectDay($event)\" *ngFor=\"let day of week; trackBy: dateTracker\">\n        {{ formattedDate(day.date) }}\n    </igx-day-item>\n</div>\n"
                }] }
    ];
    IgxDaysViewComponent.propDecorators = {
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        animationAction: [{ type: Input }],
        changeDaysView: [{ type: Input }],
        onDateSelection: [{ type: Output }],
        onViewChanged: [{ type: Output }],
        dates: [{ type: ViewChildren, args: [IgxDayItemComponent, { read: IgxDayItemComponent },] }],
        styleClass: [{ type: HostBinding, args: ['class.igx-calendar',] }],
        onKeydownArrowUp: [{ type: HostListener, args: ['keydown.arrowup', ['$event'],] }],
        onKeydownArrowDown: [{ type: HostListener, args: ['keydown.arrowdown', ['$event'],] }],
        onKeydownArrowLeft: [{ type: HostListener, args: ['keydown.arrowleft', ['$event'],] }],
        onKeydownArrowRight: [{ type: HostListener, args: ['keydown.arrowright', ['$event'],] }],
        onKeydownHome: [{ type: HostListener, args: ['keydown.home', ['$event'],] }],
        onKeydownEnd: [{ type: HostListener, args: ['keydown.end', ['$event'],] }]
    };
    return IgxDaysViewComponent;
}(IgxCalendarBase));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var NEXT_ID$f = 0;
/**
 * **Ignite UI for Angular Calendar** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/calendar.html)
 *
 * The Ignite UI Calendar provides an easy way to display a calendar and allow users to select dates using single, multiple
 * or range selection.
 *
 * Example:
 * ```html
 * <igx-calendar selection="range"></igx-calendar>
 * ```
 */
var IgxCalendarComponent = /** @class */ (function (_super) {
    __extends(IgxCalendarComponent, _super);
    function IgxCalendarComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Sets/gets the `id` of the calendar.
         * If not set, the `id` will have value `"igx-calendar-0"`.
         * ```html
         * <igx-calendar id = "my-first-calendar"></igx-calendar>
         * ```
         * ```typescript
         * let calendarId =  this.calendar.id;
         * ```
         * \@memberof IgxCalendarComponent
         */
        _this.id = "igx-calendar-" + NEXT_ID$f++;
        _this.hasHeader = true;
        /**
         * Sets/gets whether the calendar header will be in vertical position.
         * Default value is `false`.
         * ```html
         * <igx-calendar [vertical] = "true"></igx-calendar>
         * ```
         * ```typescript
         * let isVertical = this.calendar.vertical;
         * ```
         */
        _this.vertical = false;
        /**
         * The default `tabindex` attribute for the component.
         *
         * @hidden
         */
        _this.tabindex = 0;
        /**
         * The default aria role attribute for the component.
         *
         * @hidden
         */
        _this.role = 'grid';
        /**
         * The default aria lebelled by attribute for the component.
         *
         * @hidden
         */
        _this.ariaLabelledBy = 'calendar';
        /**
         * The default css class applied to the component.
         *
         * @hidden
         */
        _this.styleClass = true;
        /**
         * @hidden
         */
        _this._monthAction = '';
        /**
         * @hidden
         */
        _this.startPrevMonthScroll = function (isKeydownTrigger) {
            if (isKeydownTrigger === void 0) { isKeydownTrigger = false; }
            _this.startMonthScroll$.next();
            _this.daysView.monthScrollDirection = ScrollMonth.PREV;
            _this.previousMonth(isKeydownTrigger);
        };
        /**
         * @hidden
         */
        _this.startNextMonthScroll = function (isKeydownTrigger) {
            if (isKeydownTrigger === void 0) { isKeydownTrigger = false; }
            _this.startMonthScroll$.next();
            _this.daysView.monthScrollDirection = ScrollMonth.NEXT;
            _this.nextMonth(isKeydownTrigger);
        };
        /**
         * @hidden
         */
        _this.stopMonthScroll = function (event) {
            event.stopPropagation();
            _this.daysView.stopMonthScroll$.next(true);
            _this.daysView.stopMonthScroll$.complete();
            if (_this.daysView.monthScrollDirection === ScrollMonth.PREV) {
                _this.prevMonthBtn.nativeElement.focus();
            }
            else if (_this.daysView.monthScrollDirection === ScrollMonth.NEXT) {
                _this.nextMonthBtn.nativeElement.focus();
            }
            _this.daysView.monthScrollDirection = ScrollMonth.NONE;
        };
        return _this;
    }
    Object.defineProperty(IgxCalendarComponent.prototype, "styleVerticalClass", {
        /**
         * The default css class applied to the component.
         *
         * @hidden
         */
        get: /**
         * The default css class applied to the component.
         *
         * @hidden
         * @return {?}
         */
        function () {
            return this.vertical;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxCalendarComponent.prototype, "isYearView", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.activeView === CalendarView.YEAR;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxCalendarComponent.prototype, "monthAction", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._monthAction;
        },
        /**
         * @hidden
         */
        set: /**
         * @hidden
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._monthAction = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxCalendarComponent.prototype, "headerTemplate", {
        /**
         * Gets the header template.
         * ```typescript
         * let headerTemplate =  this.calendar.headerTeamplate;
         * ```
         * @memberof IgxCalendarComponent
         */
        get: /**
         * Gets the header template.
         * ```typescript
         * let headerTemplate =  this.calendar.headerTeamplate;
         * ```
         * \@memberof IgxCalendarComponent
         * @return {?}
         */
        function () {
            if (this.headerTemplateDirective) {
                return this.headerTemplateDirective.template;
            }
            return null;
        },
        /**
         * Sets the header template.
         * ```html
         * <igx-calendar headerTemplateDirective = "igxCalendarHeader"></igx-calendar>
         * ```
         * @memberof IgxCalendarComponent
         */
        set: /**
         * Sets the header template.
         * ```html
         * <igx-calendar headerTemplateDirective = "igxCalendarHeader"></igx-calendar>
         * ```
         * \@memberof IgxCalendarComponent
         * @param {?} directive
         * @return {?}
         */
        function (directive) {
            this.headerTemplateDirective = directive;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxCalendarComponent.prototype, "subheaderTemplate", {
        /**
         * Gets the subheader template.
         * ```typescript
         * let subheaderTemplate = this.calendar.subheaderTemplate;
         * ```
         */
        get: /**
         * Gets the subheader template.
         * ```typescript
         * let subheaderTemplate = this.calendar.subheaderTemplate;
         * ```
         * @return {?}
         */
        function () {
            if (this.subheaderTemplateDirective) {
                return this.subheaderTemplateDirective.template;
            }
            return null;
        },
        /**
         * Sets the subheader template.
         * ```html
         * <igx-calendar subheaderTemplate = "igxCalendarSubheader"></igx-calendar>
         * ```
         * @memberof IgxCalendarComponent
         */
        set: /**
         * Sets the subheader template.
         * ```html
         * <igx-calendar subheaderTemplate = "igxCalendarSubheader"></igx-calendar>
         * ```
         * \@memberof IgxCalendarComponent
         * @param {?} directive
         * @return {?}
         */
        function (directive) {
            this.subheaderTemplateDirective = directive;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxCalendarComponent.prototype, "headerContext", {
        /**
         * Gets the context for the template marked with the `igxCalendarHeader` directive.
         * ```typescript
         * let headerContext =  this.calendar.headerContext;
         * ```
         */
        get: /**
         * Gets the context for the template marked with the `igxCalendarHeader` directive.
         * ```typescript
         * let headerContext =  this.calendar.headerContext;
         * ```
         * @return {?}
         */
        function () {
            /** @type {?} */
            var date = this.headerDate;
            return this.generateContext(date);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxCalendarComponent.prototype, "context", {
        /**
         * Gets the context for the template marked with either `igxCalendarSubHeaderMonth`
         * or `igxCalendarSubHeaderYear` directive.
         * ```typescript
         * let context =  this.calendar.context;
         * ```
         */
        get: /**
         * Gets the context for the template marked with either `igxCalendarSubHeaderMonth`
         * or `igxCalendarSubHeaderYear` directive.
         * ```typescript
         * let context =  this.calendar.context;
         * ```
         * @return {?}
         */
        function () {
            /** @type {?} */
            var date = this.viewDate;
            return this.generateContext(date);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxCalendarComponent.prototype, "headerDate", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.selectedDates ? this.selectedDates : new Date();
        },
        enumerable: true,
        configurable: true
    });
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxCalendarComponent.prototype.ngAfterViewInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        this.startMonthScroll$.pipe(takeUntil(this.stopMonthScroll$), switchMap(function () { return _this.daysView.scrollMonth$.pipe(skipLast(1), debounce(function () { return interval(300); }), takeUntil(_this.stopMonthScroll$)); })).subscribe(function () {
            switch (_this.daysView.monthScrollDirection) {
                case ScrollMonth.PREV:
                    _this.previousMonth();
                    break;
                case ScrollMonth.NEXT:
                    _this.nextMonth();
                    break;
                case ScrollMonth.NONE:
                default:
                    break;
            }
        });
    };
    /**
     * Returns the locale representation of the month in the month view if enabled,
     * otherwise returns the default `Date.getMonth()` value.
     *
     * @hidden
     */
    /**
     * Returns the locale representation of the month in the month view if enabled,
     * otherwise returns the default `Date.getMonth()` value.
     *
     * @hidden
     * @param {?} value
     * @return {?}
     */
    IgxCalendarComponent.prototype.formattedMonth = /**
     * Returns the locale representation of the month in the month view if enabled,
     * otherwise returns the default `Date.getMonth()` value.
     *
     * @hidden
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (this.formatViews.month) {
            return this.formatterMonth.format(value);
        }
        return "" + value.getMonth();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?=} isKeydownTrigger
     * @return {?}
     */
    IgxCalendarComponent.prototype.previousMonth = /**
     * @hidden
     * @param {?=} isKeydownTrigger
     * @return {?}
     */
    function (isKeydownTrigger) {
        if (isKeydownTrigger === void 0) { isKeydownTrigger = false; }
        this.viewDate = this.calendarModel.timedelta(this.viewDate, 'month', -1);
        this._monthAction = 'prev';
        if (this.daysView) {
            this.daysView.isKeydownTrigger = isKeydownTrigger;
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?=} isKeydownTrigger
     * @return {?}
     */
    IgxCalendarComponent.prototype.nextMonth = /**
     * @hidden
     * @param {?=} isKeydownTrigger
     * @return {?}
     */
    function (isKeydownTrigger) {
        if (isKeydownTrigger === void 0) { isKeydownTrigger = false; }
        this.viewDate = this.calendarModel.timedelta(this.viewDate, 'month', 1);
        this._monthAction = 'next';
        if (this.daysView) {
            this.daysView.isKeydownTrigger = isKeydownTrigger;
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxCalendarComponent.prototype.activeViewDecade = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        _super.prototype.activeViewDecade.call(this);
        requestAnimationFrame(function () {
            if (_this.dacadeView) {
                _this.dacadeView.el.nativeElement.focus();
            }
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxCalendarComponent.prototype.activeViewDecadeKB = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        _super.prototype.activeViewDecadeKB.call(this, event);
        requestAnimationFrame(function () {
            if (_this.dacadeView) {
                _this.dacadeView.el.nativeElement.focus();
            }
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxCalendarComponent.prototype.getFormattedDate = /**
     * @hidden
     * @return {?}
     */
    function () {
        /** @type {?} */
        var date = this.headerDate;
        return {
            monthday: this.formatterMonthday.format(date),
            weekday: this.formatterWeekday.format(date),
        };
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} instance
     * @return {?}
     */
    IgxCalendarComponent.prototype.childClicked = /**
     * @hidden
     * @param {?} instance
     * @return {?}
     */
    function (instance) {
        if (instance.isPrevMonth) {
            this.previousMonth();
        }
        if (instance.isNextMonth) {
            this.nextMonth();
        }
        this.selectDateFromClient(instance.date);
        this.onSelection.emit(this.selectedDates);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxCalendarComponent.prototype.viewChanged = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.viewDate = this.calendarModel.timedelta(event, 'month', 0);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxCalendarComponent.prototype.changeMonth = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        this.viewDate = new Date(this.viewDate.getFullYear(), event.getMonth());
        this.activeView = CalendarView.DEFAULT;
        requestAnimationFrame(function () {
            _this.monthsBtn.nativeElement.focus();
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxCalendarComponent.prototype.activeViewYear = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        this.activeView = CalendarView.YEAR;
        requestAnimationFrame(function () {
            _this.monthsView.dates.find(function (date) { return date.isCurrentMonth; }).nativeElement.focus();
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxCalendarComponent.prototype.activeViewYearKB = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
            event.preventDefault();
            this.activeViewYear();
        }
    };
    /**
     * Deselects date(s) (based on the selection type).
     *```typescript
     * this.calendar.deselectDate(new Date(`2018-06-12`));
     *````
     */
    /**
     * Deselects date(s) (based on the selection type).
     * ```typescript
     * this.calendar.deselectDate(new Date(`2018-06-12`));
     * ````
     * @param {?=} value
     * @return {?}
     */
    IgxCalendarComponent.prototype.deselectDate = /**
     * Deselects date(s) (based on the selection type).
     * ```typescript
     * this.calendar.deselectDate(new Date(`2018-06-12`));
     * ````
     * @param {?=} value
     * @return {?}
     */
    function (value) {
        _super.prototype.deselectDate.call(this, value);
        this.daysView.selectedDates = this.selectedDates;
        this._onChangeCallback(this.selectedDates);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxCalendarComponent.prototype.onKeydownPageUp = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        /** @type {?} */
        var activeDate = this.daysView.dates.find(function (date) { return date.nativeElement === document.activeElement; });
        if (activeDate) {
            this.daysView.nextDate = new Date(activeDate.date.date);
            /** @type {?} */
            var year = this.daysView.nextDate.getFullYear();
            /** @type {?} */
            var month = this.daysView.nextDate.getMonth() - 1;
            if (month < 0) {
                month = 11;
                year -= 1;
            }
            /** @type {?} */
            var range$$1 = monthRange(this.daysView.nextDate.getFullYear(), month);
            /** @type {?} */
            var day = this.daysView.nextDate.getDate();
            if (day > range$$1[1]) {
                day = range$$1[1];
            }
            this.daysView.nextDate.setDate(day);
            this.daysView.nextDate.setMonth(month);
            this.daysView.nextDate.setFullYear(year);
            this.daysView.callback = function (dates, next) {
                /** @type {?} */
                var dayItem = dates.find(function (d) { return d.date.date.getTime() === next.getTime(); });
                if (dayItem) {
                    dayItem.nativeElement.focus();
                }
            };
        }
        this.previousMonth(true);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxCalendarComponent.prototype.onKeydownPageDown = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        this.nextMonth(true);
        /** @type {?} */
        var activeDate = this.daysView.dates.find(function (date) { return date.nativeElement === document.activeElement; });
        if (activeDate) {
            this.daysView.nextDate = new Date(activeDate.date.date);
            /** @type {?} */
            var year = this.daysView.nextDate.getFullYear();
            /** @type {?} */
            var month = this.daysView.nextDate.getMonth() + 1;
            if (month > 11) {
                month = 0;
                year += 1;
            }
            /** @type {?} */
            var range$$1 = monthRange(this.daysView.nextDate.getFullYear(), month);
            /** @type {?} */
            var day = this.daysView.nextDate.getDate();
            if (day > range$$1[1]) {
                day = range$$1[1];
            }
            this.daysView.nextDate.setDate(day);
            this.daysView.nextDate.setMonth(month);
            this.daysView.nextDate.setFullYear(year);
            this.daysView.callback = function (dates, next) {
                /** @type {?} */
                var dayItem = dates.find(function (d) { return d.date.date.getTime() === next.getTime(); });
                if (dayItem) {
                    dayItem.nativeElement.focus();
                }
            };
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxCalendarComponent.prototype.onKeydownShiftPageUp = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        this.viewDate = this.calendarModel.timedelta(this.viewDate, 'year', -1);
        this.daysView.animationAction = 'prev';
        this.daysView.isKeydownTrigger = true;
        /** @type {?} */
        var activeDate = this.daysView.dates.find(function (date) { return date.nativeElement === document.activeElement; });
        if (activeDate) {
            this.daysView.nextDate = new Date(activeDate.date.date);
            /** @type {?} */
            var year = this.daysView.nextDate.getFullYear() - 1;
            /** @type {?} */
            var range$$1 = monthRange(year, this.daysView.nextDate.getMonth());
            /** @type {?} */
            var day = this.daysView.nextDate.getDate();
            if (day > range$$1[1]) {
                day = range$$1[1];
            }
            this.daysView.nextDate.setDate(day);
            this.daysView.nextDate.setFullYear(year);
            this.daysView.callback = function (dates, next) {
                /** @type {?} */
                var dayItem = dates.find(function (d) { return d.date.date.getTime() === next.getTime(); });
                if (dayItem) {
                    dayItem.nativeElement.focus();
                }
            };
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxCalendarComponent.prototype.onKeydownShiftPageDown = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        this.viewDate = this.calendarModel.timedelta(this.viewDate, 'year', 1);
        this.daysView.animationAction = 'next';
        this.daysView.isKeydownTrigger = true;
        /** @type {?} */
        var activeDate = this.daysView.dates.find(function (date) { return date.nativeElement === document.activeElement; });
        if (activeDate) {
            this.daysView.nextDate = new Date(activeDate.date.date);
            /** @type {?} */
            var year = this.daysView.nextDate.getFullYear() + 1;
            /** @type {?} */
            var range$$1 = monthRange(year, this.daysView.nextDate.getMonth());
            /** @type {?} */
            var day = this.daysView.nextDate.getDate();
            if (day > range$$1[1]) {
                day = range$$1[1];
            }
            this.daysView.nextDate.setDate(day);
            this.daysView.nextDate.setFullYear(year);
            this.daysView.callback = function (dates, next) {
                /** @type {?} */
                var dayItem = dates.find(function (d) { return d.date.date.getTime() === next.getTime(); });
                if (dayItem) {
                    dayItem.nativeElement.focus();
                }
            };
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxCalendarComponent.prototype.onKeydownHome = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.daysView) {
            this.daysView.onKeydownHome(event);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxCalendarComponent.prototype.onKeydownEnd = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.daysView) {
            this.daysView.onKeydownEnd(event);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxCalendarComponent.prototype.onMouseUp = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.daysView && this.daysView.monthScrollDirection !== ScrollMonth.NONE) {
            this.stopMonthScroll(event);
        }
    };
    /**
     * Helper method building and returning the context object inside
     * the calendar templates.
     * @hidden
     */
    /**
     * Helper method building and returning the context object inside
     * the calendar templates.
     * @hidden
     * @private
     * @param {?} value
     * @return {?}
     */
    IgxCalendarComponent.prototype.generateContext = /**
     * Helper method building and returning the context object inside
     * the calendar templates.
     * @hidden
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        var _this = this;
        /** @type {?} */
        var formatObject = __assign({ monthView: function () { return _this.activeViewYear(); }, yearView: function () { return _this.activeViewDecade(); } }, this.calendarModel.formatToParts(value, this.locale, this.formatOptions, ['era', 'year', 'month', 'day', 'weekday']));
        return { $implicit: formatObject };
    };
    IgxCalendarComponent.decorators = [
        { type: Component, args: [{
                    providers: [
                        {
                            multi: true,
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: IgxCalendarComponent
                        }
                    ],
                    animations: [
                        trigger('animateView', [
                            transition('void => 0', useAnimation(fadeIn)),
                            transition('void => *', useAnimation(scaleInCenter, {
                                params: {
                                    duration: '.2s',
                                    fromScale: .9
                                }
                            }))
                        ])
                    ],
                    selector: 'igx-calendar',
                    template: "<ng-template let-result #defaultHeader>\n    <span>{{ getFormattedDate().weekday }},&nbsp;</span>\n    <span>{{ getFormattedDate().monthday }}</span>\n</ng-template>\n\n<ng-template let-result #defaultMonth>\n    <span tabindex=\"0\" #monthsBtn (keydown)=\"activeViewYearKB($event)\" (click)=\"activeViewYear()\"\n        class=\"igx-calendar-picker__date\">\n        {{ formattedMonth(viewDate) }}\n    </span>\n    <span tabindex=\"0\" #yearsBtn (keydown)=\"activeViewDecadeKB($event)\" (click)=\"activeViewDecade()\"\n        class=\"igx-calendar-picker__date\">\n        {{ formattedYear(viewDate) }}\n    </span>\n</ng-template>\n\n<div *ngIf=\"selection === 'single' && hasHeader\" class=\"igx-calendar__header\">\n    <h5 class=\"igx-calendar__header-year\">{{ formattedYear(headerDate) }}</h5>\n    <h2 class=\"igx-calendar__header-date\">\n        <ng-container *ngTemplateOutlet=\"headerTemplate ? headerTemplate : defaultHeader; context: headerContext\">\n        </ng-container>\n    </h2>\n</div>\n\n<div *ngIf=\"isDefaultView\" class=\"igx-calendar__body\" [@animateView]=\"activeView\" (swiperight)=\"previousMonth()\"\n    (swipeleft)=\"nextMonth()\">\n    <div class=\"igx-calendar-picker\">\n        <div tabindex=\"0\" class=\"igx-calendar-picker__prev\" #prevMonthBtn\n            igxCalendarScrollMonth [startScroll]=\"startPrevMonthScroll\" [stopScroll]=\"stopMonthScroll\">\n            <igx-icon fontSet=\"material\">keyboard_arrow_left</igx-icon>\n        </div>\n        <div>\n            <ng-container *ngTemplateOutlet=\"subheaderTemplate ? subheaderTemplate : defaultMonth; context: context\">\n            </ng-container>\n        </div>\n        <div tabindex=\"0\" class=\"igx-calendar-picker__next\" #nextMonthBtn\n            igxCalendarScrollMonth [startScroll]=\"startNextMonthScroll\" [stopScroll]=\"stopMonthScroll\">\n            <igx-icon fontSet=\"material\">keyboard_arrow_right</igx-icon>\n        </div>\n    </div>\n\n    <igx-days-view [changeDaysView]=\"true\" #days\n                   [animationAction]=\"monthAction\"\n                   [locale]=\"locale\"\n                   [value]=\"value\"\n                   [viewDate]=\"viewDate\"\n                   [weekStart]=\"weekStart\"\n                   [formatOptions]=\"formatOptions\"\n                   [formatViews]=\"formatViews\"\n                   [selection]=\"selection\"\n                   [disabledDates]=\"disabledDates\"\n                   [specialDates]=\"specialDates\"\n                   (onViewChanged)=\"viewChanged($event)\"\n                   (onDateSelection)=\"childClicked($event)\">\n    </igx-days-view>\n</div>\n\n<igx-months-view *ngIf=\"isYearView\" [@animateView]=\"activeView\" #months \n                 [date]=\"viewDate\" \n                 [locale]=\"locale\"\n                 [formatView]=\"formatViews.month\"\n                 [monthFormat]=\"formatOptions.month\" \n                 (onSelection)=\"changeMonth($event)\">\n</igx-months-view>\n\n<igx-years-view *ngIf=\"isDecadeView\" [@animateView]=\"activeView\" #decade \n                [date]=\"viewDate\" \n                [locale]=\"locale\"\n                [formatView]=\"formatViews.year\"\n                [yearFormat]=\"formatOptions.year\" \n                (onSelection)=\"changeYear($event)\">\n</igx-years-view>"
                }] }
    ];
    IgxCalendarComponent.propDecorators = {
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        hasHeader: [{ type: Input }],
        vertical: [{ type: Input }],
        tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
        role: [{ type: HostBinding, args: ['attr.role',] }],
        ariaLabelledBy: [{ type: HostBinding, args: ['attr.aria-labelledby',] }],
        styleVerticalClass: [{ type: HostBinding, args: ['class.igx-calendar--vertical',] }],
        styleClass: [{ type: HostBinding, args: ['class.igx-calendar',] }],
        monthsView: [{ type: ViewChild, args: ['months', { read: IgxMonthsViewComponent },] }],
        monthsBtn: [{ type: ViewChild, args: ['monthsBtn',] }],
        dacadeView: [{ type: ViewChild, args: ['decade', { read: IgxYearsViewComponent },] }],
        daysView: [{ type: ViewChild, args: ['days', { read: IgxDaysViewComponent },] }],
        prevMonthBtn: [{ type: ViewChild, args: ['prevMonthBtn',] }],
        nextMonthBtn: [{ type: ViewChild, args: ['nextMonthBtn',] }],
        headerTemplateDirective: [{ type: ContentChild, args: [forwardRef(function () { return IgxCalendarHeaderTemplateDirective; }), { read: IgxCalendarHeaderTemplateDirective },] }],
        subheaderTemplateDirective: [{ type: ContentChild, args: [forwardRef(function () { return IgxCalendarSubheaderTemplateDirective; }), { read: IgxCalendarSubheaderTemplateDirective },] }],
        onKeydownPageUp: [{ type: HostListener, args: ['keydown.pageup', ['$event'],] }],
        onKeydownPageDown: [{ type: HostListener, args: ['keydown.pagedown', ['$event'],] }],
        onKeydownShiftPageUp: [{ type: HostListener, args: ['keydown.shift.pageup', ['$event'],] }],
        onKeydownShiftPageDown: [{ type: HostListener, args: ['keydown.shift.pagedown', ['$event'],] }],
        onKeydownHome: [{ type: HostListener, args: ['keydown.home', ['$event'],] }],
        onKeydownEnd: [{ type: HostListener, args: ['keydown.end', ['$event'],] }],
        onMouseUp: [{ type: HostListener, args: ['document:mouseup', ['$event'],] }]
    };
    return IgxCalendarComponent;
}(IgxMonthPickerBase));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var NEXT_ID$g = 0;
var IgxMonthPickerComponent = /** @class */ (function (_super) {
    __extends(IgxMonthPickerComponent, _super);
    function IgxMonthPickerComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Sets/gets the `id` of the month picker.
         * If not set, the `id` will have value `"igx-month-picker-0"`.
         */
        _this.id = "igx-month-picker-" + NEXT_ID$g++;
        /**
         * The default css class applied to the component.
         *
         * @hidden
         */
        _this.styleClass = true;
        /**
         * @hidden
         */
        _this.yearAction = '';
        return _this;
    }
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxMonthPickerComponent.prototype.animationDone = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.yearAction = '';
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxMonthPickerComponent.prototype.activeViewDecadeKB = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        _super.prototype.activeViewDecadeKB.call(this, event);
        if (event.key === "ArrowRight" /* RIGHT_ARROW */ || event.key === "Right" /* RIGHT_ARROW_IE */) {
            event.preventDefault();
            this.nextYear();
        }
        if (event.key === "ArrowLeft" /* LEFT_ARROW */ || event.key === "Left" /* LEFT_ARROW_IE */) {
            event.preventDefault();
            this.previousYear();
        }
        requestAnimationFrame(function () {
            if (_this.dacadeView) {
                _this.dacadeView.el.nativeElement.focus();
            }
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxMonthPickerComponent.prototype.activeViewDecade = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        _super.prototype.activeViewDecade.call(this);
        requestAnimationFrame(function () {
            _this.dacadeView.el.nativeElement.focus();
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxMonthPickerComponent.prototype.nextYear = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.yearAction = 'next';
        this.viewDate = this.calendarModel.timedelta(this.viewDate, 'year', 1);
        this.selectDate(this.viewDate);
        this.onSelection.emit(this.selectedDates);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxMonthPickerComponent.prototype.nextYearKB = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
            event.preventDefault();
            event.stopPropagation();
            this.nextYear();
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxMonthPickerComponent.prototype.previousYear = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.yearAction = 'prev';
        this.viewDate = this.calendarModel.timedelta(this.viewDate, 'year', -1);
        this.selectDate(this.viewDate);
        this.onSelection.emit(this.selectedDates);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxMonthPickerComponent.prototype.previousYearKB = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
            event.preventDefault();
            event.stopPropagation();
            this.previousYear();
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxMonthPickerComponent.prototype.selectYear = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        this.viewDate = new Date(event.getFullYear(), event.getMonth(), event.getDate());
        this.activeView = CalendarView.DEFAULT;
        this.selectDate(event);
        this.onSelection.emit(this.selectedDates);
        requestAnimationFrame(function () {
            _this.yearsBtn.nativeElement.focus();
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxMonthPickerComponent.prototype.selectMonth = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.selectDate(event);
        this.onSelection.emit(this.selectedDates);
    };
    /**
     * Selects a date.
     *```typescript
     * this.monPicker.selectDate(new Date(`2018-06-12`));
     *```
     */
    /**
     * Selects a date.
     * ```typescript
     * this.monPicker.selectDate(new Date(`2018-06-12`));
     * ```
     * @param {?} value
     * @return {?}
     */
    IgxMonthPickerComponent.prototype.selectDate = /**
     * Selects a date.
     * ```typescript
     * this.monPicker.selectDate(new Date(`2018-06-12`));
     * ```
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (!value) {
            return new Date();
        }
        // TO DO: to be refactored after discussion on the desired behavior
        _super.prototype.selectDate.call(this, value);
        this.viewDate = value;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    IgxMonthPickerComponent.prototype.writeValue = /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    function (value) {
        // TO DO: to be refactored after discussion on the desired behavior
        if (value) {
            this.viewDate = this.selectedDates = value;
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxMonthPickerComponent.prototype.onKeydownPageUp = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        this.yearAction = 'prev';
        this.viewDate = this.calendarModel.timedelta(this.viewDate, 'year', -1);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxMonthPickerComponent.prototype.onKeydownPageDown = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        this.yearAction = 'next';
        this.viewDate = this.calendarModel.timedelta(this.viewDate, 'year', 1);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxMonthPickerComponent.prototype.onKeydownHome = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.monthsView) {
            this.monthsView.el.nativeElement.focus();
            this.monthsView.onKeydownHome(event);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxMonthPickerComponent.prototype.onKeydownEnd = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.monthsView) {
            this.monthsView.el.nativeElement.focus();
            this.monthsView.onKeydownEnd(event);
        }
    };
    IgxMonthPickerComponent.decorators = [
        { type: Component, args: [{
                    providers: [
                        {
                            multi: true,
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: IgxMonthPickerComponent
                        }
                    ],
                    animations: [
                        trigger('animateView', [
                            transition('void => 0', useAnimation(fadeIn)),
                            transition('void => *', useAnimation(scaleInCenter, {
                                params: {
                                    duration: '.2s',
                                    fromScale: .9
                                }
                            }))
                        ]),
                        trigger('animateChange', [
                            transition('* => prev', useAnimation(slideInLeft, {
                                params: {
                                    fromPosition: 'translateX(-30%)'
                                }
                            })),
                            transition('* => next', useAnimation(slideInRight, {
                                params: {
                                    fromPosition: 'translateX(30%)'
                                }
                            }))
                        ])
                    ],
                    selector: 'igx-month-picker',
                    template: "<div *ngIf=\"isDefaultView\" [@animateView]=\"activeView\" class=\"igx-calendar__body\" (swiperight)=\"previousYear()\" (swipeleft)=\"nextYear()\">\n    <div class=\"igx-calendar-picker\">\n        <div tabindex=\"0\" class=\"igx-calendar-picker__prev\" (click)=\"previousYear()\" (keydown)=\"previousYearKB($event)\">\n            <igx-icon fontSet=\"material\">keyboard_arrow_left</igx-icon>\n        </div>\n        <div>\n            <span tabindex=\"0\" #yearsBtn (keydown)=\"activeViewDecadeKB($event)\" (click)=\"activeViewDecade()\" class=\"igx-calendar-picker__date\">\n                {{ formattedYear(viewDate) }}\n            </span>\n        </div>\n        <div tabindex=\"0\" class=\"igx-calendar-picker__next\" (click)=\"nextYear()\" (keydown)=\"nextYearKB($event)\">\n            <igx-icon fontSet=\"material\">keyboard_arrow_right</igx-icon>\n        </div>\n    </div>\n\n    <igx-months-view [@animateChange]=\"yearAction\" #months\n                     (@animateChange.done)=\"animationDone()\"\n                     [date]=\"viewDate\"\n                     [locale]=\"locale\"\n                     [formatView]=\"formatViews.month\"\n                     [monthFormat]=\"formatOptions.month\"\n                     (onSelection)=\"selectMonth($event)\">\n    </igx-months-view>\n</div>\n<igx-years-view *ngIf=\"isDecadeView\" [@animateView]=\"activeView\" #decade\n                [date]=\"viewDate\"\n                [locale]=\"locale\"\n                [formatView]=\"formatViews.year\"\n                [yearFormat]=\"formatOptions.year\"\n                (onSelection)=\"selectYear($event)\">\n</igx-years-view>\n"
                }] }
    ];
    IgxMonthPickerComponent.propDecorators = {
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        styleClass: [{ type: HostBinding, args: ['class.igx-calendar',] }],
        monthsView: [{ type: ViewChild, args: ['months', { read: IgxMonthsViewComponent },] }],
        dacadeView: [{ type: ViewChild, args: ['decade', { read: IgxYearsViewComponent },] }],
        daysView: [{ type: ViewChild, args: ['days', { read: IgxDaysViewComponent },] }],
        onKeydownPageUp: [{ type: HostListener, args: ['keydown.pageup', ['$event'],] }],
        onKeydownPageDown: [{ type: HostListener, args: ['keydown.pagedown', ['$event'],] }],
        onKeydownHome: [{ type: HostListener, args: ['keydown.home', ['$event'],] }],
        onKeydownEnd: [{ type: HostListener, args: ['keydown.end', ['$event'],] }]
    };
    return IgxMonthPickerComponent;
}(IgxMonthPickerBase));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxCalendarModule = /** @class */ (function () {
    function IgxCalendarModule() {
    }
    IgxCalendarModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        IgxDayItemComponent,
                        IgxDaysViewComponent,
                        IgxCalendarComponent,
                        IgxCalendarHeaderTemplateDirective,
                        IgxCalendarMonthDirective,
                        IgxCalendarYearDirective,
                        IgxCalendarSubheaderTemplateDirective,
                        IgxCalendarScrollMonthDirective,
                        IgxMonthsViewComponent,
                        IgxYearsViewComponent,
                        IgxMonthPickerComponent
                    ],
                    exports: [
                        IgxCalendarComponent,
                        IgxDaysViewComponent,
                        IgxMonthsViewComponent,
                        IgxYearsViewComponent,
                        IgxMonthPickerComponent,
                        IgxCalendarHeaderTemplateDirective,
                        IgxCalendarMonthDirective,
                        IgxCalendarYearDirective,
                        IgxCalendarSubheaderTemplateDirective
                    ],
                    imports: [CommonModule, FormsModule, IgxIconModule]
                },] }
    ];
    return IgxCalendarModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var NEXT_ID$h = 0;
/**
 * IgxCardMedia is container for the card media section.
 * Use it to wrap images and videos.
 */
var IgxCardMediaDirective = /** @class */ (function () {
    function IgxCardMediaDirective() {
        /**
         * @hidden
         */
        this.cssClass = 'igx-card__media';
        /**
         * An \@Input property that sets the `width` and `min-width` style property
         * of the media container. If not provided it will be set to `auto`.
         * ```html
         * <igx-card-media width="300px"></igx-card-media>
         * ```
         */
        this.width = 'auto';
        /**
         * An \@Input property that sets the `height` style property of the media container.
         * If not provided it will be set to `auto`.
         * ```html
         * <igx-card-media height="50%"></igx-card-media>
         * ```
         */
        this.height = 'auto';
        /**
         * An \@Input property that sets the `role` attribute of the media container.
         */
        this.role = 'img';
    }
    IgxCardMediaDirective.decorators = [
        { type: Directive, args: [{
                    // tslint:disable-next-line:directive-selector
                    selector: 'igx-card-media'
                },] }
    ];
    IgxCardMediaDirective.propDecorators = {
        cssClass: [{ type: HostBinding, args: ['class.igx-card__media',] }],
        width: [{ type: HostBinding, args: ['style.width',] }, { type: HostBinding, args: ['style.min-width',] }, { type: Input }],
        height: [{ type: HostBinding, args: ['style.height',] }, { type: Input }],
        role: [{ type: HostBinding, args: ['attr.role',] }, { type: Input }]
    };
    return IgxCardMediaDirective;
}());
/**
 * IgxCardHeader is container for the card header
 */
var IgxCardHeaderComponent = /** @class */ (function () {
    function IgxCardHeaderComponent() {
        /**
         * @hidden
         */
        this.cssClass = 'igx-card-header';
        /**
         * An \@Input property that sets the layout style of the header.
         * By default the header elements(thumbnail and title/subtitle) are aligned horizontally.
         * ```html
         * <igx-card-header [vertical]="true"></igx-card-header>
         * ```
         */
        this.vertical = false;
        /**
         * An \@Input property that sets the value of the `role` attribute of the card header.
         * By default the value is set to `header`.
         * ```html
         * <igx-card-header role="header"></igx-card-header>
         * ```
         */
        this.role = 'header';
    }
    IgxCardHeaderComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-card-header',
                    template: "<div class=\"igx-card-header__thumbnail\">\n    <ng-content select=\"igx-avatar, igx-card-media, [igxCardThumbnail]\"></ng-content>\n</div>\n\n<div class=\"igx-card-header__titles\">\n    <ng-content select=\"\n        [igxCardHeaderTitle],\n        [igxCardHeaderSubtitle],\n        .igx-card-header__title,\n        .igx-card-header__subtitle\">\n    </ng-content>\n</div>\n\n<ng-content></ng-content>\n"
                }] }
    ];
    IgxCardHeaderComponent.propDecorators = {
        cssClass: [{ type: HostBinding, args: ['class.igx-card-header',] }],
        vertical: [{ type: HostBinding, args: ['class.igx-card-header--vertical',] }, { type: Input }],
        role: [{ type: HostBinding, args: ['attr.role',] }]
    };
    return IgxCardHeaderComponent;
}());
/**
 * IgxCardThumbnail is container for the card thumbnail section.
 * Use it to wrap anything you want to be used as a thumbnail.
 */
var IgxCardThumbnailDirective = /** @class */ (function () {
    function IgxCardThumbnailDirective() {
    }
    IgxCardThumbnailDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxCardThumbnail]'
                },] }
    ];
    return IgxCardThumbnailDirective;
}());
/**
 * igxCardHeaderTitle is used to denote the header title in a card.
 * Use it to tag text nodes.
 */
var IgxCardHeaderTitleDirective = /** @class */ (function () {
    function IgxCardHeaderTitleDirective() {
        /**
         * @hidden
         */
        this.cssClass = 'igx-card__header__title';
    }
    IgxCardHeaderTitleDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxCardHeaderTitle]'
                },] }
    ];
    IgxCardHeaderTitleDirective.propDecorators = {
        cssClass: [{ type: HostBinding, args: ['class.igx-card-header__title',] }]
    };
    return IgxCardHeaderTitleDirective;
}());
/**
 * igxCardHeaderSubtitle is used to denote the header subtitle in a card.
 * Use it to tag text nodes.
 */
var IgxCardHeaderSubtitleDirective = /** @class */ (function () {
    function IgxCardHeaderSubtitleDirective() {
        /**
         * @hidden
         */
        this.cssClass = 'igx-card-header__subtitle';
    }
    IgxCardHeaderSubtitleDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxCardHeaderSubtitle]'
                },] }
    ];
    IgxCardHeaderSubtitleDirective.propDecorators = {
        cssClass: [{ type: HostBinding, args: ['class.igx-card-header__subtitle',] }]
    };
    return IgxCardHeaderSubtitleDirective;
}());
/**
 * IgxCardContent is container for the card content.
 */
var IgxCardContentDirective = /** @class */ (function () {
    function IgxCardContentDirective() {
        /**
         * @hidden
         */
        this.cssClass = 'igx-card-content';
    }
    IgxCardContentDirective.decorators = [
        { type: Directive, args: [{
                    // tslint:disable-next-line:directive-selector
                    selector: 'igx-card-content'
                },] }
    ];
    IgxCardContentDirective.propDecorators = {
        cssClass: [{ type: HostBinding, args: ['class.igx-card-content',] }]
    };
    return IgxCardContentDirective;
}());
/**
 * IgxCardFooter is container for the card footer
 */
var IgxCardFooterDirective = /** @class */ (function () {
    function IgxCardFooterDirective() {
        /**
         * An \@Input property that sets the value of the `role` attribute of the card footer.
         * By default the value is set to `footer`.
         * ```html
         * <igx-card-footer role="footer"></igx-card-footer>
         * ```
         */
        this.role = 'footer';
    }
    IgxCardFooterDirective.decorators = [
        { type: Directive, args: [{
                    // tslint:disable-next-line:directive-selector
                    selector: 'igx-card-footer'
                },] }
    ];
    IgxCardFooterDirective.propDecorators = {
        role: [{ type: HostBinding, args: ['attr.role',] }, { type: Input }]
    };
    return IgxCardFooterDirective;
}());
/** @enum {string} */
var IgxCardType = {
    DEFAULT: 'default',
    OUTLINED: 'outlined',
};
var IgxCardComponent = /** @class */ (function () {
    function IgxCardComponent() {
        /**
         * Sets/gets the `id` of the card.
         * If not set, `id` will have value `"igx-card-0"`;
         * ```html
         * <igx-card id = "my-first-card"></igx-card>
         * ```
         * ```typescript
         * let cardId =  this.card.id;
         * ```
         * \@memberof IgxCardComponent
         */
        this.id = "igx-card-" + NEXT_ID$h++;
        /**
         * An \@Input property that sets the value of the `role` attribute of the card.
         * By default the value is set to `group`.
         * ```html
         * <igx-card role="group"></igx-card>
         * ```
         */
        this.role = 'group';
        /**
         * An \@Input property that sets the value of the `type` attribute of the card.
         * By default the value is set to `default`. You can make the card use the
         * outlined style by setting the value to `outlined`.
         * ```html
         * <igx-card type="outlined"></igx-card>
         * ```
         */
        this.type = IgxCardType.DEFAULT;
        /**
         * An \@Input property that sets the value of the `horizontal` attribute of the card.
         * Setting this to `true` will make the different card sections align horizontally,
         * essentially flipping the card to the side.
         * ```html
         * <igx-card [horizontal]="true"></igx-card>
         * ```
         */
        this.horizontal = false;
    }
    Object.defineProperty(IgxCardComponent.prototype, "isOutlinedCard", {
        /**
         * A getter which will return true if the card type is `outlined`.
         */
        get: /**
         * A getter which will return true if the card type is `outlined`.
         * @return {?}
         */
        function () {
            return this.type === IgxCardType.OUTLINED;
        },
        enumerable: true,
        configurable: true
    });
    IgxCardComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-card',
                    template: "<ng-container select='igx-card-media'></ng-container>\n\n<ng-container select='igx-card-header'></ng-container>\n<ng-container select='igx-card-content'>\n    <ng-content></ng-content>\n</ng-container>\n\n<ng-container select='igx-card-actions'></ng-container>\n"
                }] }
    ];
    IgxCardComponent.propDecorators = {
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        role: [{ type: HostBinding, args: ['attr.role',] }, { type: Input }],
        type: [{ type: HostBinding, args: ['class.igx-card',] }, { type: Input }],
        isOutlinedCard: [{ type: HostBinding, args: ['class.igx-card--outlined',] }],
        horizontal: [{ type: HostBinding, args: ['class.igx-card--horizontal',] }, { type: Input }]
    };
    return IgxCardComponent;
}());
/** @enum {string} */
var IgxCardActionsLayout = {
    DEFAULT: 'default',
    JUSTIFY: 'justify',
};
/**
 * IgxCardActions is container for the card actions.
 */
var IgxCardActionsComponent = /** @class */ (function () {
    function IgxCardActionsComponent(card) {
        this.card = card;
        this.isVerticalSet = false;
        /**
         * An \@Input property that sets the layout style of the actions.
         * By default icons and icon buttons, as well as regular buttons
         * are split into two containers, which are then positioned on both ends
         * of the card-actions area.
         * You can justify the elements in those groups so they are positioned equally
         * from one another taking up all the space available along the card actions axis.
         * ```html
         * <igx-card-actions layout="justify"></igx-card-actions>
         * ```
         */
        this.layout = 'default';
        /**
         * An \@Input property that sets order of the buttons the actions area.
         * By default all icons/icon buttons are placed at the end of the action
         * area. Any regular buttons(flat, raised) will appear before the icons/icon buttons
         * placed in the actions area.
         * If you want to reverse their positions so that icons appear first, use the `reverse`
         * attribute.
         * ```html
         * <igx-card-actions [reverse]="true"></igx-card-actions>
         * ```
         */
        this.reverse = false;
    }
    Object.defineProperty(IgxCardActionsComponent.prototype, "isJustifyLayout", {
        /**
         * A getter that returns `true` when the layout has been
         * set to `justify`.
         */
        get: /**
         * A getter that returns `true` when the layout has been
         * set to `justify`.
         * @return {?}
         */
        function () {
            return this.layout === IgxCardActionsLayout.JUSTIFY;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} changes
     * @return {?}
     */
    IgxCardActionsComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        for (var prop in changes) {
            if (prop === 'vertical') {
                this.isVerticalSet = true;
            }
        }
    };
    /**
     * @return {?}
     */
    IgxCardActionsComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.vertical = !this.isVerticalSet && this.card.horizontal;
    };
    IgxCardActionsComponent.decorators = [
        { type: Component, args: [{
                    // tslint:disable-next-line:directive-selector
                    selector: 'igx-card-actions',
                    template: "<div class=\"igx-card-actions__icons\">\n    <ng-content select=\"igx-icon, [igxButton='icon']\"></ng-content>\n</div>\n\n<div #buttons class=\"igx-card-actions__buttons\">\n    <ng-content select=\"[igxButton]\"></ng-content>\n</div>\n\n\n<ng-content></ng-content>\n"
                }] }
    ];
    /** @nocollapse */
    IgxCardActionsComponent.ctorParameters = function () { return [
        { type: IgxCardComponent, decorators: [{ type: Optional }, { type: Inject, args: [IgxCardComponent,] }] }
    ]; };
    IgxCardActionsComponent.propDecorators = {
        layout: [{ type: HostBinding, args: ['class.igx-card-actions',] }, { type: Input }],
        vertical: [{ type: HostBinding, args: ['class.igx-card-actions--vertical',] }, { type: Input }],
        isJustifyLayout: [{ type: HostBinding, args: ['class.igx-card-actions--justify',] }],
        reverse: [{ type: HostBinding, args: ['class.igx-card-actions--reverse',] }, { type: Input }]
    };
    return IgxCardActionsComponent;
}());
/**
 * @hidden
 */
var IgxCardModule = /** @class */ (function () {
    function IgxCardModule() {
    }
    IgxCardModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        IgxCardComponent,
                        IgxCardHeaderComponent,
                        IgxCardMediaDirective,
                        IgxCardContentDirective,
                        IgxCardActionsComponent,
                        IgxCardFooterDirective,
                        IgxCardHeaderTitleDirective,
                        IgxCardHeaderSubtitleDirective,
                        IgxCardThumbnailDirective,
                    ],
                    exports: [
                        IgxCardComponent,
                        IgxCardHeaderComponent,
                        IgxCardMediaDirective,
                        IgxCardContentDirective,
                        IgxCardActionsComponent,
                        IgxCardFooterDirective,
                        IgxCardHeaderTitleDirective,
                        IgxCardHeaderSubtitleDirective,
                        IgxCardThumbnailDirective,
                    ],
                    imports: [CommonModule, IgxButtonModule]
                },] }
    ];
    return IgxCardModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var NEXT_ID$i = 0;
/** @enum {number} */
var Direction = {
    NONE: 0, NEXT: 1, PREV: 2,
};
Direction[Direction.NONE] = 'NONE';
Direction[Direction.NEXT] = 'NEXT';
Direction[Direction.PREV] = 'PREV';
/**
 * **Ignite UI for Angular Carousel** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/carousel.html)
 *
 * The Ignite UI Carousel is used to browse or navigate through a collection of slides. Slides can contain custom
 * content such as images or cards and be used for things such as on-boarding tutorials or page-based interfaces.
 * It can be used as a separate fullscreen element or inside another component.
 *
 * Example:
 * ```html
 * <igx-carousel>
 *   <igx-slide>
 *     <h3>First Slide Header</h3>
 *     <p>First slide Content</p>
 *   <igx-slide>
 *   <igx-slide>
 *     <h3>Second Slide Header</h3>
 *     <p>Second Slide Content</p>
 * </igx-carousel>
 * ```
 */
var IgxCarouselComponent = /** @class */ (function () {
    function IgxCarouselComponent(element) {
        this.element = element;
        /**
         * Returns the `role` attribute of the carousel.
         * ```typescript
         * let carouselRole =  this.carousel.role;
         * ```
         * \@memberof IgxCarouselComponent
         */
        this.role = 'region';
        /**
         * Sets the `id` of the carousel.
         * If not set, the `id` of the first carousel component will be `"igx-carousel-0"`.
         * ```html
         * <igx-carousel id="my-first-carousel"></igx-carousel>
         * ```
         * \@memberof IgxCarouselComponent
         */
        this.id = "igx-carousel-" + NEXT_ID$i++;
        /**
         * Sets whether the carousel should `loop` back to the first slide after reaching the last slide.
         * Default value is `true`.
         * ```html
         * <igx-carousel [loop]="false"></igx-carousel>
         * ```
         * \@memberOf IgxCarouselComponent
         */
        this.loop = true;
        /**
         * Sets whether the carousel will `pause` the slide transitions on user interactions.
         * Default value is `true`.
         * ```html
         *  <igx-carousel [pause]="false"></igx-carousel>
         * ```
         * \@memberOf IgxCarouselComponent
         */
        this.pause = true;
        /**
         * Controls whether the carousel should render the left/right `navigation` buttons.
         * Default value is `true`.
         * ```html
         * <igx-carousel [navigation] = "false"></igx-carousel>
         * ```
         * \@memberOf IgxCarouselComponent
         */
        this.navigation = true;
        /**
         * An event that is emitted after a slide transition has happened.
         * Provides references to the `IgxCarouselComponent` and `IgxSlideComponent` as event arguments.
         * ```html
         * <igx-carousel (onSlideChanged)="onSlideChanged($event)"></igx-carousel>
         * ```
         * \@memberOf IgxCarouselComponent
         */
        this.onSlideChanged = new EventEmitter();
        /**
         * An event that is emitted after a slide has been added to the carousel.
         * Provides references to the `IgxCarouselComponent` and `IgxSlideComponent` as event arguments.
         * ```html
         * <igx-carousel (onSlideAdded)="onSlideAdded($event)"></igx-carousel>
         * ```
         * \@memberOf IgxCarouselComponent
         */
        this.onSlideAdded = new EventEmitter();
        /**
         * An event that is emitted after a slide has been removed from the carousel.
         * Provides references to the `IgxCarouselComponent` and `IgxSlideComponent` as event arguments.
         * ```html
         * <igx-carousel (onSlideRemoved)="onSlideRemoved($event)"></igx-carousel>
         * ```
         * \@memberOf IgxCarouselComponent
         */
        this.onSlideRemoved = new EventEmitter();
        /**
         * An event that is emitted after the carousel has been paused.
         * Provides a reference to the `IgxCarouselComponent` as an event argument.
         * ```html
         * <igx-carousel (onCarouselPaused)="onCarouselPaused($event)"></igx-carousel>
         * ```
         * \@memberOf IgxCarouselComponent
         */
        this.onCarouselPaused = new EventEmitter();
        /**
         * An event that is emitted after the carousel has resumed transitioning between `slides`.
         * Provides a reference to the `IgxCarouselComponent` as an event argument.
         * ```html
         * <igx-carousel (onCarouselPlaying)="onCarouselPlaying($event)"></igx-carousel>
         * ```
         * \@memberOf IgxCarouselComponent
         */
        this.onCarouselPlaying = new EventEmitter();
        /**
         * The collection of `slides` currently in the carousel.
         * ```typescript
         * let slides: IgxSlideComponent[] = this.carousel.slides;
         * ```
         * \@memberOf IgxCarouselComponent
         */
        this.slides = [];
        this._total = 0;
    }
    Object.defineProperty(IgxCarouselComponent.prototype, "interval", {
        /**
         * Returns the time `interval` in milliseconds before the slide changes.
         * ```typescript
         * let timeInterval = this.carousel.interval;
         * ```
         * @memberof IgxCarouselComponent
         */
        get: /**
         * Returns the time `interval` in milliseconds before the slide changes.
         * ```typescript
         * let timeInterval = this.carousel.interval;
         * ```
         * \@memberof IgxCarouselComponent
         * @return {?}
         */
        function () {
            return this._interval;
        },
        /**
         * Sets the time `interval` in milliseconds before the slide changes.
         * If not set, the carousel will not change `slides` automatically.
         * ```html
         * <igx-carousel [interval] = "1000"></carousel>
         * ```
         * @memberof IgxCarouselComponent
         */
        set: /**
         * Sets the time `interval` in milliseconds before the slide changes.
         * If not set, the carousel will not change `slides` automatically.
         * ```html
         * <igx-carousel [interval] = "1000"></carousel>
         * ```
         * \@memberof IgxCarouselComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._interval = +value;
            this._restartInterval();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxCarouselComponent.prototype, "tabIndex", {
        /**
         * Returns the `tabIndex` of the carousel component.
         * ```typescript
         * let tabIndex =  this.carousel.tabIndex;
         * ```
         * @memberof IgxCarouselComponent
         */
        get: /**
         * Returns the `tabIndex` of the carousel component.
         * ```typescript
         * let tabIndex =  this.carousel.tabIndex;
         * ```
         * \@memberof IgxCarouselComponent
         * @return {?}
         */
        function () {
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxCarouselComponent.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        this._destroyed = true;
        if (this._lastInterval) {
            clearInterval(this._lastInterval);
        }
    };
    /**
     * @hidden
     * @memberof IgxCarouselComponent
     */
    /**
     * @hidden
     * \@memberof IgxCarouselComponent
     * @param {?} slide
     * @return {?}
     */
    IgxCarouselComponent.prototype.setAriaLabel = /**
     * @hidden
     * \@memberof IgxCarouselComponent
     * @param {?} slide
     * @return {?}
     */
    function (slide) {
        return "Item " + (slide.index + 1) + " of " + this.total;
    };
    Object.defineProperty(IgxCarouselComponent.prototype, "total", {
        /**
         * Returns the total number of `slides` in the carousel.
         * ```typescript
         * let slideCount =  this.carousel.total;
         * ```
         * @memberOf IgxCarouselComponent
         */
        get: /**
         * Returns the total number of `slides` in the carousel.
         * ```typescript
         * let slideCount =  this.carousel.total;
         * ```
         * \@memberOf IgxCarouselComponent
         * @return {?}
         */
        function () {
            return this._total;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxCarouselComponent.prototype, "current", {
        /**
         * The index of the slide being currently shown.
         * ```typescript
         * let currentSlideNumber =  this.carousel.current;
         * ```
         * @memberOf IgxCarouselComponent
         */
        get: /**
         * The index of the slide being currently shown.
         * ```typescript
         * let currentSlideNumber =  this.carousel.current;
         * ```
         * \@memberOf IgxCarouselComponent
         * @return {?}
         */
        function () {
            return !this._currentSlide ? 0 : this._currentSlide.index;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxCarouselComponent.prototype, "isPlaying", {
        /**
         * Returns a boolean indicating if the carousel is playing.
         * ```typescript
         * let isPlaying =  this.carousel.isPlaying;
         * ```
         * @memberOf IgxCarouselComponent
         */
        get: /**
         * Returns a boolean indicating if the carousel is playing.
         * ```typescript
         * let isPlaying =  this.carousel.isPlaying;
         * ```
         * \@memberOf IgxCarouselComponent
         * @return {?}
         */
        function () {
            return this._playing;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxCarouselComponent.prototype, "isDestroyed", {
        /**
         * Returns Ð° boolean indicating if the carousel is destroyed.
         * ```typescript
         * let isDestroyed =  this.carousel.isDestroyed;
         * ```
         * @memberOf IgxCarouselComponent
         */
        get: /**
         * Returns Ð° boolean indicating if the carousel is destroyed.
         * ```typescript
         * let isDestroyed =  this.carousel.isDestroyed;
         * ```
         * \@memberOf IgxCarouselComponent
         * @return {?}
         */
        function () {
            return this._destroyed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxCarouselComponent.prototype, "nativeElement", {
        /**
         * Returns a reference to the carousel element in the DOM.
         * ```typescript
         * let nativeElement =  this.carousel.nativeElement;
         * ```
         * @memberof IgxCarouselComponent
         */
        get: /**
         * Returns a reference to the carousel element in the DOM.
         * ```typescript
         * let nativeElement =  this.carousel.nativeElement;
         * ```
         * \@memberof IgxCarouselComponent
         * @return {?}
         */
        function () {
            return this.element.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the slide corresponding to the provided `index` or null.
     * ```typescript
     * let slide1 =  this.carousel.get(1);
     * ```
     * @memberOf IgxCarouselComponent
     */
    /**
     * Returns the slide corresponding to the provided `index` or null.
     * ```typescript
     * let slide1 =  this.carousel.get(1);
     * ```
     * \@memberOf IgxCarouselComponent
     * @param {?} index
     * @return {?}
     */
    IgxCarouselComponent.prototype.get = /**
     * Returns the slide corresponding to the provided `index` or null.
     * ```typescript
     * let slide1 =  this.carousel.get(1);
     * ```
     * \@memberOf IgxCarouselComponent
     * @param {?} index
     * @return {?}
     */
    function (index) {
        var e_1, _a;
        try {
            for (var _b = __values(this.slides), _c = _b.next(); !_c.done; _c = _b.next()) {
                var each = _c.value;
                if (each.index === index) {
                    return each;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * Adds a new slide to the carousel.
     * ```typescript
     * this.carousel.add(newSlide);
     * ```
     * @memberOf IgxCarouselComponent
     */
    /**
     * Adds a new slide to the carousel.
     * ```typescript
     * this.carousel.add(newSlide);
     * ```
     * \@memberOf IgxCarouselComponent
     * @param {?} slide
     * @return {?}
     */
    IgxCarouselComponent.prototype.add = /**
     * Adds a new slide to the carousel.
     * ```typescript
     * this.carousel.add(newSlide);
     * ```
     * \@memberOf IgxCarouselComponent
     * @param {?} slide
     * @return {?}
     */
    function (slide) {
        slide.index = this.total;
        this.slides.push(slide);
        this._total += 1;
        if (this.total === 1 || slide.active) {
            this.select(slide);
            if (this.total === 1) {
                this.play();
            }
        }
        else {
            slide.active = false;
        }
        this.onSlideAdded.emit({ carousel: this, slide: slide });
    };
    /**
     * Removes a slide from the carousel.
     * ```typescript
     * this.carousel.remove(slide);
     * ```
     * @memberOf IgxCarouselComponent
     */
    /**
     * Removes a slide from the carousel.
     * ```typescript
     * this.carousel.remove(slide);
     * ```
     * \@memberOf IgxCarouselComponent
     * @param {?} slide
     * @return {?}
     */
    IgxCarouselComponent.prototype.remove = /**
     * Removes a slide from the carousel.
     * ```typescript
     * this.carousel.remove(slide);
     * ```
     * \@memberOf IgxCarouselComponent
     * @param {?} slide
     * @return {?}
     */
    function (slide) {
        if (slide && slide === this.get(slide.index)) { // check if the requested slide for delete is present in the carousel
            if (slide.index === this.current) {
                slide.active = false;
                this.next();
            }
            this.slides.splice(slide.index, 1);
            this._total -= 1;
            if (!this.total) {
                this._currentSlide = null;
                return;
            }
            for (var i = 0; i < this.total; i++) {
                this.slides[i].index = i;
            }
            this.onSlideRemoved.emit({ carousel: this, slide: slide });
        }
    };
    /**
     * Kicks in a transition for a given slide with a given `direction`.
     * ```typescript
     * this.carousel.select(this.carousel.get(2), Direction.NEXT);
     * ```
     * @memberOf IgxCarouselComponent
     */
    /**
     * Kicks in a transition for a given slide with a given `direction`.
     * ```typescript
     * this.carousel.select(this.carousel.get(2), Direction.NEXT);
     * ```
     * \@memberOf IgxCarouselComponent
     * @param {?} slide
     * @param {?=} direction
     * @return {?}
     */
    IgxCarouselComponent.prototype.select = /**
     * Kicks in a transition for a given slide with a given `direction`.
     * ```typescript
     * this.carousel.select(this.carousel.get(2), Direction.NEXT);
     * ```
     * \@memberOf IgxCarouselComponent
     * @param {?} slide
     * @param {?=} direction
     * @return {?}
     */
    function (slide, direction) {
        if (direction === void 0) { direction = Direction.NONE; }
        /** @type {?} */
        var newIndex = slide.index;
        if (direction === Direction.NONE) {
            direction = newIndex > this.current ? Direction.NEXT : Direction.PREV;
        }
        if (slide && slide !== this._currentSlide) {
            this._moveTo(slide, direction);
        }
    };
    /**
     * Transitions to the next slide in the carousel.
     * ```typescript
     * this.carousel.next();
     * ```
     * @memberOf IgxCarouselComponent
     */
    /**
     * Transitions to the next slide in the carousel.
     * ```typescript
     * this.carousel.next();
     * ```
     * \@memberOf IgxCarouselComponent
     * @return {?}
     */
    IgxCarouselComponent.prototype.next = /**
     * Transitions to the next slide in the carousel.
     * ```typescript
     * this.carousel.next();
     * ```
     * \@memberOf IgxCarouselComponent
     * @return {?}
     */
    function () {
        /** @type {?} */
        var index = (this.current + 1) % this.total;
        if (index === 0 && !this.loop) {
            this.stop();
            return;
        }
        return this.select(this.get(index), Direction.NEXT);
    };
    /**
     * Transitions to the previous slide in the carousel.
     * ```typescript
     * this.carousel.prev();
     * ```
     * @memberOf IgxCarouselComponent
     */
    /**
     * Transitions to the previous slide in the carousel.
     * ```typescript
     * this.carousel.prev();
     * ```
     * \@memberOf IgxCarouselComponent
     * @return {?}
     */
    IgxCarouselComponent.prototype.prev = /**
     * Transitions to the previous slide in the carousel.
     * ```typescript
     * this.carousel.prev();
     * ```
     * \@memberOf IgxCarouselComponent
     * @return {?}
     */
    function () {
        /** @type {?} */
        var index = this.current - 1 < 0 ?
            this.total - 1 : this.current - 1;
        if (!this.loop && index === this.total - 1) {
            this.stop();
            return;
        }
        return this.select(this.get(index), Direction.PREV);
    };
    /**
     * Resumes playing of the carousel if in paused state.
     * No operation otherwise.
     * ```typescript
     * this.carousel.play();
     * }
     * ```
     * @memberOf IgxCarouselComponent
     */
    /**
     * Resumes playing of the carousel if in paused state.
     * No operation otherwise.
     * ```typescript
     * this.carousel.play();
     * }
     * ```
     * \@memberOf IgxCarouselComponent
     * @return {?}
     */
    IgxCarouselComponent.prototype.play = /**
     * Resumes playing of the carousel if in paused state.
     * No operation otherwise.
     * ```typescript
     * this.carousel.play();
     * }
     * ```
     * \@memberOf IgxCarouselComponent
     * @return {?}
     */
    function () {
        if (!this._playing) {
            this._playing = true;
            this.onCarouselPlaying.emit(this);
            this._restartInterval();
        }
    };
    /**
     * Stops slide transitions if the `pause` option is set to `true`.
     * No operation otherwise.
     * ```typescript
     *  this.carousel.stop();
     * }
     * ```
     * @memberOf IgxCarouselComponent
     */
    /**
     * Stops slide transitions if the `pause` option is set to `true`.
     * No operation otherwise.
     * ```typescript
     *  this.carousel.stop();
     * }
     * ```
     * \@memberOf IgxCarouselComponent
     * @return {?}
     */
    IgxCarouselComponent.prototype.stop = /**
     * Stops slide transitions if the `pause` option is set to `true`.
     * No operation otherwise.
     * ```typescript
     *  this.carousel.stop();
     * }
     * ```
     * \@memberOf IgxCarouselComponent
     * @return {?}
     */
    function () {
        if (this.pause) {
            this._playing = false;
            this.onCarouselPaused.emit(this);
            this._resetInterval();
        }
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @private
     * @param {?} slide
     * @param {?} direction
     * @return {?}
     */
    IgxCarouselComponent.prototype._moveTo = /**
     * @hidden
     * @private
     * @param {?} slide
     * @param {?} direction
     * @return {?}
     */
    function (slide, direction) {
        if (this._destroyed) {
            return;
        }
        slide.direction = direction;
        slide.active = true;
        if (this._currentSlide) {
            this._currentSlide.direction = direction;
            this._currentSlide.active = false;
        }
        this._currentSlide = slide;
        this.onSlideChanged.emit({ carousel: this, slide: slide });
        this._restartInterval();
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @private
     * @return {?}
     */
    IgxCarouselComponent.prototype._resetInterval = /**
     * @hidden
     * @private
     * @return {?}
     */
    function () {
        if (this._lastInterval) {
            clearInterval(this._lastInterval);
            this._lastInterval = null;
        }
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @private
     * @return {?}
     */
    IgxCarouselComponent.prototype._restartInterval = /**
     * @hidden
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this._resetInterval();
        if (!isNaN(this.interval) && this.interval > 0) {
            this._lastInterval = setInterval(function () {
                /** @type {?} */
                var tick = +_this.interval;
                if (_this._playing && _this.total && !isNaN(tick) && tick > 0) {
                    _this.next();
                }
                else {
                    _this.stop();
                }
            }, this.interval);
        }
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxCarouselComponent.prototype.onKeydownArrowRight = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        this.next();
        requestAnimationFrame(function () { return _this.nativeElement.focus(); });
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxCarouselComponent.prototype.onKeydownArrowLeft = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        this.prev();
        requestAnimationFrame(function () { return _this.nativeElement.focus(); });
    };
    IgxCarouselComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-carousel',
                    template: "<div tabindex=\"0\" aria-label=\"carousel\" class=\"igx-carousel\"\n        (mouseenter)=\"stop()\"\n        (mouseleave)=\"play()\"\n        (swipeleft)=\"next()\"\n        (swiperight)=\"prev()\"\n        (tap)=\"isPlaying ? stop() : play()\">\n    <ul class=\"igx-carousel__indicators\" [hidden]=\"slides.length <= 1\">\n        <li *ngFor=\"let slide of slides\" [attr.aria-label]=\"setAriaLabel(slide)\" [attr.aria-selected]=\"slide.active\" [class.active]=\"slide.active === true\"\n            (click)=\"select(slide)\"></li>\n    </ul>\n    <div class=\"igx-carousel__inner\" role=\"list\">\n        <ng-content></ng-content>\n    </div>\n    <div *ngIf=\"navigation\">\n        <a role=\"button\" tabindex=\"0\" class=\"igx-carousel__arrow--prev\" (click)=\"prev()\" [hidden]=\"!slides.length\">\n            <igx-icon fontSet=\"material\">arrow_back</igx-icon>\n        </a>\n        <a role=\"button\" tabindex=\"0\" class=\"igx-carousel__arrow--next\" (click)=\"next()\" [hidden]=\"!slides.length\">\n            <igx-icon fontSet=\"material\">arrow_forward</igx-icon>\n        </a>\n    </div>\n</div>\n",
                    styles: ["\n    :host {\n        display: block;\n        outline-style: none;\n    }"]
                }] }
    ];
    /** @nocollapse */
    IgxCarouselComponent.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    IgxCarouselComponent.propDecorators = {
        role: [{ type: HostBinding, args: ['attr.role',] }],
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        loop: [{ type: Input }],
        pause: [{ type: Input }],
        interval: [{ type: Input }],
        tabIndex: [{ type: HostBinding, args: ['attr.tabindex',] }],
        navigation: [{ type: Input }],
        onSlideChanged: [{ type: Output }],
        onSlideAdded: [{ type: Output }],
        onSlideRemoved: [{ type: Output }],
        onCarouselPaused: [{ type: Output }],
        onCarouselPlaying: [{ type: Output }],
        onKeydownArrowRight: [{ type: HostListener, args: ['keydown.arrowright',] }],
        onKeydownArrowLeft: [{ type: HostListener, args: ['keydown.arrowleft',] }]
    };
    return IgxCarouselComponent;
}());
/**
 * A slide component that usually holds an image and/or a caption text.
 * IgxSlideComponent is usually a child component of an IgxCarouselComponent.
 *
 * ```
 * <igx-slide [input bindings] >
 *    <ng-content></ng-content>
 * </igx-slide>
 * ```
 *
 * @export
 */
var IgxSlideComponent = /** @class */ (function () {
    function IgxSlideComponent(carousel) {
        this.carousel = carousel;
    }
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxSlideComponent.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.carousel.add(this);
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxSlideComponent.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.carousel.remove(this);
    };
    IgxSlideComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-slide',
                    template: "<div\n    role=\"listitem\"\n    [class.active]=\"active\"\n    class=\"igx-slide\"\n    [attr.aria-selected]=\"active\"\n    [attr.aria-live]=\"active ? 'polite' : null\"\n    [attr.tabIndex]=\"active ? 0 : null\"\n>\n    <ng-content></ng-content>\n</div>\n"
                }] }
    ];
    /** @nocollapse */
    IgxSlideComponent.ctorParameters = function () { return [
        { type: IgxCarouselComponent }
    ]; };
    IgxSlideComponent.propDecorators = {
        index: [{ type: Input }],
        direction: [{ type: Input }],
        active: [{ type: HostBinding, args: ['class.active',] }, { type: Input }]
    };
    return IgxSlideComponent;
}());
/**
 * @hidden
 */
var IgxCarouselModule = /** @class */ (function () {
    function IgxCarouselModule() {
    }
    IgxCarouselModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxCarouselComponent, IgxSlideComponent],
                    exports: [IgxCarouselComponent, IgxSlideComponent],
                    imports: [CommonModule, IgxIconModule]
                },] }
    ];
    return IgxCarouselModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var LabelPosition = {
    BEFORE: 'before',
    AFTER: 'after',
};
/** @type {?} */
var noop$3 = function () { };
/** @type {?} */
var nextId$2 = 0;
/**
 * **Ignite UI for Angular Checkbox** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/checkbox.html)
 *
 * The Ignite UI Checkbox is a selection control that allows users to make a binary choice. It behaves similarly
 * to the native browser checkbox.
 *
 * Example:
 * ```html
 * <igx-checkbox checked="true">
 *   simple checkbox
 * </igx-checkbox>
 * ```
 */
var IgxCheckboxComponent = /** @class */ (function () {
    function IgxCheckboxComponent() {
        /**
         * Sets/gets the `id` of the checkbox component.
         * If not set, the `id` of the first checkbox component will be `"igx-checkbox-0"`.
         * ```html
         * <igx-checkbox id="my-first-checkbox"></igx-checkbox>
         * ```
         * ```typescript
         * let checkboxId =  this.checkbox.id;
         * ```
         * \@memberof IgxCheckboxComponent
         */
        this.id = "igx-checkbox-" + nextId$2++;
        /**
         * Sets/gets the id of the `label` element.
         * If not set, the id of the `label` in the first checkbox component will be `"igx-checkbox-0-label"`.
         * ```html
         * <igx-checkbox labelId = "Label1"></igx-checkbox>
         * ```
         * ```typescript
         * let labelId =  this.checkbox.labelId;
         * ```
         * \@memberof IgxCheckboxComponent
         */
        this.labelId = this.id + "-label";
        /**
         * Sets/gets the value of the `tabindex` attribute.
         * ```html
         * <igx-checkbox [tabindex] = "1"></igx-checkbox>
         * ```
         * ```typescript
         * let tabIndex =  this.checkbox.tabindex;
         * ```
         * \@memberof IgxCheckboxComponent
         */
        this.tabindex = null;
        /**
         *  Sets/gets the position of the `label`.
         *  If not set, the `labelPosition` will have value `"after"`.
         * ```html
         * <igx-checkbox labelPosition = "before"></igx-checkbox>
         * ```
         * ```typescript
         * let labelPosition =  this.checkbox.labelPosition;
         * ```
         * \@memberof IgxCheckboxComponent
         */
        this.labelPosition = LabelPosition.AFTER;
        /**
         * Enables/Disables the ripple effect.
         * If not set, `disableRipple` will have value `false`.
         * ```html
         * <igx-checkbox [disableRipple] = "true"></igx-checkbox>
         * ```
         * ```typescript
         * let isRippleDisabled = this.checkbox.desableRipple;
         * ```
         * \@memberof IgxCheckboxComponent
         */
        this.disableRipple = false;
        /**
         * Sets/gets whether the checkbox is required.
         * If not set, `required` will have value `false`.
         * ```html
         * <igx-checkbox [required] = "true"></igx-checkbox>
         * ```
         * ```typescript
         * let isRequired =  this.checkbox.required;
         * ```
         * \@memberof IgxCheckboxComponent
         */
        this.required = false;
        /**
         * Sets/gets the `aria-labelledby` attribute.
         * If not set, the `aria-labelledby` will be equal to the value of `labelId` attribute.
         * ```html
         * <igx-checkbox aria-labelledby = "Checkbox1"></igx-checkbox>
         * ```
         * ```typescript
         * let ariaLabelledBy =  this.checkbox.ariaLabelledBy;
         * ```
         * \@memberof IgxCheckboxComponent
         */
        this.ariaLabelledBy = this.labelId;
        /**
         * Sets/gets the value of the `aria-label` attribute.
         * ```html
         * <igx-checkbox aria-label = "Checkbox1"></igx-checkbox>
         * ```
         * ```typescript
         * let ariaLabel = this.checkbox.aruaLabel;
         * ```
         * \@memberof IgxCheckboxComponent
         */
        this.ariaLabel = null;
        /**
         * An event that is emitted after the checkbox state is changed.
         * Provides references to the `IgxCheckboxComponent` and the `checked` property as event arguments.
         * \@memberof IgxCheckboxComponent
         */
        this.change = new EventEmitter();
        /**
         * Returns the class of the checkbox component.
         * ```typescript
         * let class =  this.checkbox.cssClass;
         * ```
         * \@memberof IgxCheckboxComponent
         */
        this.cssClass = 'igx-checkbox';
        /**
         * Sets/gets whether the checkbox component is on focus.
         * Default value is `false`.
         * ```typescript
         * this.checkbox.focused =  true;
         * ```
         * ```typescript
         * let isFocused =  this.checkbox.focused;
         * ```
         * \@memberof IgxCheckboxComponent
         */
        this.focused = false;
        /**
         * Sets/gets the checkbox indeterminate visual state.
         * Default value is `false`;
         * ```html
         * <igx-checkbox [indeterminate] = "true"></igx-checkbox>
         * ```
         * ```typescript
         * let isIndeterminate = this.checkbox.indeterminate;
         * ```
         * \@memberof IgxCheckboxComponent
         */
        this.indeterminate = false;
        /**
         * Sets/gets whether the checkbox is checked.
         * Default value is `false`.
         * ```html
         * <igx-checkbox [checked] = "true"></igx-checkbox>
         * ```
         * ```typescript
         * let isChecked =  this.checkbox.checked;
         * ```
         * \@memberof IgxCheckboxComponent
         */
        this.checked = false;
        /**
         * Sets/gets whether the checkbox is disabled.
         * Default value is `false`.
         * ```html
         * <igx-checkbox [disabled] = "true"></igx-checkbox>
         * ```
         * ```typescript
         * let isDesabled = this.checkbox.disabled;
         * ```
         * \@memberof IgxCheckboxComponent
         */
        this.disabled = false;
        /**
         * Sets/gets whether the checkbox should disable all css transitions.
         * Default value is `false`.
         * ```html
         * <igx-checkbox [disableTransitions]="true"></igx-checkbox>
         * ```
         * ```typescript
         * let disableTransitions = this.checkbox.disableTransitions;
         * ```
         * \@memberof IgxCheckboxComponent
         */
        this.disableTransitions = false;
        /**
         * @hidden
         */
        this.inputId = this.id + "-input";
        /**
         * @hidden
         */
        this._onTouchedCallback = noop$3;
        /**
         * @hidden
         */
        this._onChangeCallback = noop$3;
    }
    /**
     * If `disabled` is `false`, switches the `checked` state.
     * ```typescript
     * this.checkbox.toggle();
     * ```
     * @memberof IgxCheckboxComponent
     */
    /**
     * If `disabled` is `false`, switches the `checked` state.
     * ```typescript
     * this.checkbox.toggle();
     * ```
     * \@memberof IgxCheckboxComponent
     * @return {?}
     */
    IgxCheckboxComponent.prototype.toggle = /**
     * If `disabled` is `false`, switches the `checked` state.
     * ```typescript
     * this.checkbox.toggle();
     * ```
     * \@memberof IgxCheckboxComponent
     * @return {?}
     */
    function () {
        if (this.disabled) {
            return;
        }
        this.indeterminate = false;
        this.focused = false;
        this.checked = !this.checked;
        this.change.emit({ checked: this.checked, checkbox: this });
        this._onChangeCallback(this.checked);
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxCheckboxComponent.prototype._onCheckboxChange = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // We have to stop the original checkbox change event
        // from bubbling up since we emit our own change event
        event.stopPropagation();
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxCheckboxComponent.prototype._onCheckboxClick = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // Since the original checkbox is hidden and the label
        // is used for styling and to change the checked state of the checkbox,
        // we need to prevent the checkbox click event from bubbling up
        // as it gets triggered on label click
        event.stopPropagation();
        if (isIE()) {
            this.nativeCheckbox.nativeElement.blur();
        }
        this.toggle();
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxCheckboxComponent.prototype._onLabelClick = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // We use a span element as a placeholder label
        // in place of the native label, we need to emit
        // the change event separately here alongside
        // the click event emitted on click
        this.toggle();
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxCheckboxComponent.prototype.onFocus = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.focused = true;
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxCheckboxComponent.prototype.onBlur = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.focused = false;
        this._onTouchedCallback();
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    IgxCheckboxComponent.prototype.writeValue = /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this._value = value;
        this.checked = !!this._value;
    };
    Object.defineProperty(IgxCheckboxComponent.prototype, "labelClass", {
        /**
         *@hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            switch (this.labelPosition) {
                case LabelPosition.BEFORE:
                    return this.cssClass + "__label--before";
                case LabelPosition.AFTER:
                default:
                    return this.cssClass + "__label";
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    IgxCheckboxComponent.prototype.registerOnChange = /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._onChangeCallback = fn; };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    IgxCheckboxComponent.prototype.registerOnTouched = /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._onTouchedCallback = fn; };
    /** @hidden */
    /**
     * @hidden
     * @return {?}
     */
    IgxCheckboxComponent.prototype.getEditElement = /**
     * @hidden
     * @return {?}
     */
    function () {
        return this.nativeCheckbox.nativeElement;
    };
    IgxCheckboxComponent.decorators = [
        { type: Component, args: [{
                    providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: IgxCheckboxComponent, multi: true }],
                    selector: 'igx-checkbox',
                    preserveWhitespaces: false,
                    template: "<input #checkbox class=\"igx-checkbox__input\"\n    type=\"checkbox\"\n    [id]=\"inputId\"\n    [name]=\"name\"\n    [value]=\"value\"\n    [tabindex]=\"tabindex\"\n    [disabled]=\"disabled\"\n    [indeterminate]=\"indeterminate\"\n    [checked]=\"checked\"\n    [required]=\"required\"\n    [attr.aria-checked]=\"checked\"\n    [attr.aria-labelledby]=\"ariaLabelledBy\"\n    [attr.aria-label]=\"ariaLabel\"\n    (change)=\"_onCheckboxChange($event)\"\n    (click)=\"_onCheckboxClick($event)\"\n    (focus)=\"onFocus($event)\"\n    (blur)=\"onBlur($event)\" />\n\n<label #label class=\"igx-checkbox__composite\"\n    igxRipple\n    igxRippleTarget=\".igx-checkbox__ripple\"\n    [igxRippleDisabled]=\"disableRipple\"\n    [igxRippleCentered]=\"true\"\n    [igxRippleDuration]=\"300\"\n    [attr.for]=\"inputId\">\n    <svg class=\"igx-checkbox__composite-mark\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M4.1,12.7 9,17.6 20.3,6.3\" />\n    </svg>\n    <div class=\"igx-checkbox__ripple\"></div>\n</label>\n\n<span #placeholderLabel role=\"label\"\n    [class]=\"labelClass\"\n    [id]=\"labelId\"\n    (click)=\"_onLabelClick($event)\">\n    <ng-content></ng-content>\n</span>\n"
                }] }
    ];
    IgxCheckboxComponent.propDecorators = {
        nativeCheckbox: [{ type: ViewChild, args: ['checkbox',] }],
        nativeLabel: [{ type: ViewChild, args: ['label',] }],
        placeholderLabel: [{ type: ViewChild, args: ['placeholderLabel',] }],
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        labelId: [{ type: Input }],
        value: [{ type: Input }],
        name: [{ type: Input }],
        tabindex: [{ type: Input }],
        labelPosition: [{ type: Input }],
        disableRipple: [{ type: Input }],
        required: [{ type: Input }],
        ariaLabelledBy: [{ type: Input, args: ['aria-labelledby',] }],
        ariaLabel: [{ type: Input, args: ['aria-label',] }],
        change: [{ type: Output }],
        cssClass: [{ type: HostBinding, args: ['class.igx-checkbox',] }],
        focused: [{ type: HostBinding, args: ['class.igx-checkbox--focused',] }],
        indeterminate: [{ type: HostBinding, args: ['class.igx-checkbox--indeterminate',] }, { type: Input }],
        checked: [{ type: HostBinding, args: ['class.igx-checkbox--checked',] }, { type: Input }],
        disabled: [{ type: HostBinding, args: ['class.igx-checkbox--disabled',] }, { type: Input }],
        disableTransitions: [{ type: HostBinding, args: ['class.igx-checkbox--plain',] }, { type: Input }]
    };
    return IgxCheckboxComponent;
}());
/** @type {?} */
var IGX_CHECKBOX_REQUIRED_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(function () { return IgxCheckboxRequiredDirective; }),
    multi: true
};
/* tslint:disable directive-selector */
var IgxCheckboxRequiredDirective = /** @class */ (function (_super) {
    __extends(IgxCheckboxRequiredDirective, _super);
    function IgxCheckboxRequiredDirective() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    IgxCheckboxRequiredDirective.decorators = [
        { type: Directive, args: [{
                    selector: "igx-checkbox[required][formControlName],\n    igx-checkbox[required][formControl],\n    igx-checkbox[required][ngModel]",
                    providers: [IGX_CHECKBOX_REQUIRED_VALIDATOR]
                },] }
    ];
    return IgxCheckboxRequiredDirective;
}(CheckboxRequiredValidator));
/**
 * @hidden
 */
var IgxCheckboxModule = /** @class */ (function () {
    function IgxCheckboxModule() {
    }
    IgxCheckboxModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxCheckboxComponent, IgxCheckboxRequiredDirective],
                    exports: [IgxCheckboxComponent, IgxCheckboxRequiredDirective],
                    imports: [IgxRippleModule]
                },] }
    ];
    return IgxCheckboxModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var CHIP_ID = 0;
var IgxChipComponent = /** @class */ (function (_super) {
    __extends(IgxChipComponent, _super);
    function IgxChipComponent(cdr, elementRef, renderer, _displayDensityOptions) {
        var _this = _super.call(this, _displayDensityOptions) || this;
        _this.cdr = cdr;
        _this.elementRef = elementRef;
        _this.renderer = renderer;
        _this._displayDensityOptions = _displayDensityOptions;
        /**
         * An \@Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-chip [id]="'igx-chip-1'"></igx-chip>
         * ```
         */
        _this.id = "igx-chip-" + CHIP_ID++;
        /**
         * An \@Input property that defines if the `IgxChipComponent` can be dragged in order to change it's position.
         * By default it is set to false.
         * ```html
         * <igx-chip [id]="'igx-chip-1'" [draggable]="true"></igx-chip>
         * ```
         */
        _this.draggable = false;
        /**
         * An \@Input property that defines if the `IgxChipComponent` should render remove button and throw remove events.
         * By default it is set to false.
         * ```html
         * <igx-chip [id]="'igx-chip-1'" [draggable]="true" [removable]="true"></igx-chip>
         * ```
         */
        _this.removable = false;
        /**
         * An \@Input property that defines if the `IgxChipComponent` can be selected on click or through navigation,
         * By default it is set to false.
         * ```html
         * <igx-chip [id]="chip.id" [draggable]="true" [removable]="true" [selectable]="true"></igx-chip>
         * ```
         */
        _this.selectable = false;
        /**
         * @hidden
         */
        _this.class = '';
        /**
         * An \@Input property that defines if the `IgxChipComponent` is disabled. When disabled it restricts user interactions
         * like focusing on click or tab, selection on click or Space, dragging.
         * By default it is set to false.
         * ```html
         * <igx-chip [id]="chip.id" [disabled]="true"></igx-chip>
         * ```
         */
        _this.disabled = false;
        /**
         * Emits an event when the `IgxChipComponent` moving starts.
         * Returns the moving `IgxChipComponent`.
         * ```typescript
         * moveStarted(event: IBaseChipEventArgs){
         *     let movingChip = event.owner;
         * }
         * ```
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onMoveStart)="moveStarted($event)">
         * ```
         */
        _this.onMoveStart = new EventEmitter();
        /**
         * Emits an event when the `IgxChipComponent` moving ends.
         * Returns the moved `IgxChipComponent`.
         * ```typescript
         * moveEnded(event: IBaseChipEventArgs){
         *     let movedChip = event.owner;
         * }
         * ```
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onMoveEnd)="moveEnded($event)">
         * ```
         */
        _this.onMoveEnd = new EventEmitter();
        /**
         * Emits an event when the `IgxChipComponent` is removed.
         * Returns the removed `IgxChipComponent`.
         * ```typescript
         * remove(event: IBaseChipEventArgs){
         *     let removedChip = event.owner;
         * }
         * ```
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onRemove)="remove($event)">
         * ```
         */
        _this.onRemove = new EventEmitter();
        /**
         * Emits an event when the `IgxChipComponent` is clicked.
         * Returns the clicked `IgxChipComponent`, whether the event should be canceled.
         * ```typescript
         * chipClick(event: IChipClickEventArgs){
         *     let clickedChip = event.owner;
         * }
         * ```
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onClick)="chipClick($event)">
         * ```
         */
        _this.onClick = new EventEmitter();
        /**
         * Emits event when the `IgxChipComponent` is selected/deselected.
         * Returns the selected chip reference, whether the event should be canceled, what is the next selection state and
         * when the event is triggered by interaction `originalEvent` is provided, otherwise `originalEvent` is `null`.
         * ```typescript
         * chipSelect(event: IChipSelectEventArgs){
         *     let selectedChip = event.owner;
         * }
         * ```
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onSelection)="chipSelect($event)">
         * ```
         */
        _this.onSelection = new EventEmitter();
        /**
         * Emits an event when the `IgxChipComponent` keyboard navigation is being used.
         * Returns the focused/selected `IgxChipComponent`, whether the event should be canceled,
         * if the `alt`, `shift` or `control` key is pressed and the pressed key name.
         * ```typescript
         * chipKeyDown(event: IChipKeyDownEventArgs){
         *     let keyDown = event.key;
         * }
         * ```
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onKeyDown)="chipKeyDown($event)">
         * ```
         */
        _this.onKeyDown = new EventEmitter();
        /**
         * Emits an event when the `IgxChipComponent` has entered the `IgxChipsAreaComponent`.
         * Returns the target `IgxChipComponent`, the drag `IgxChipComponent`, as  well as
         * the original drop event arguments.
         * ```typescript
         * chipEnter(event: IChipEnterDragAreaEventArgs){
         *     let targetChip = event.targetChip;
         * }
         * ```
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [draggable]="true" (onDragEnter)="chipEnter($event)">
         * ```
         */
        _this.onDragEnter = new EventEmitter();
        _this._selected = false;
        _this._selectedItemClass = 'igx-chip__item--selected';
        _this._movedWhileRemoving = false;
        return _this;
    }
    Object.defineProperty(IgxChipComponent.prototype, "selected", {
        /**
         * Returns if the `IgxChipComponent` is selected.
         * ```typescript
         * @ViewChild('myChip')
         * public chip: IgxChipComponent;
         * selectedChip(){
         *     let selectedChip = this.chip.selected;
         * }
         * ```
         */
        get: /**
         * Returns if the `IgxChipComponent` is selected.
         * ```typescript
         * \@ViewChild('myChip')
         * public chip: IgxChipComponent;
         * selectedChip(){
         *     let selectedChip = this.chip.selected;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this._selected;
        },
        /**
         * Sets the `IgxChipComponent` selected state.
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [selectable]="true" [selected]="true">
         * ```
         */
        set: /**
         * Sets the `IgxChipComponent` selected state.
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [selectable]="true" [selected]="true">
         * ```
         * @param {?} newValue
         * @return {?}
         */
        function (newValue) {
            this.changeSelection(newValue);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxChipComponent.prototype, "color", {
        /**
         * Returns the background color of the `IgxChipComponent`.
         * ```typescript
         * @ViewChild('myChip')
         * public chip: IgxChipComponent;
         * ngAfterViewInit(){
         *     let chipColor = this.chip.color;
         * }
         * ```
         */
        get: /**
         * Returns the background color of the `IgxChipComponent`.
         * ```typescript
         * \@ViewChild('myChip')
         * public chip: IgxChipComponent;
         * ngAfterViewInit(){
         *     let chipColor = this.chip.color;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this.chipArea.nativeElement.style.backgroundColor;
        },
        /**
         * An @Input property that sets the `IgxChipComponent` background color.
         * The `color` property supports string, rgb, hex.
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [color]="'#ff0000'"></igx-chip>
         * ```
         */
        set: /**
         * An \@Input property that sets the `IgxChipComponent` background color.
         * The `color` property supports string, rgb, hex.
         * ```html
         * <igx-chip #myChip [id]="'igx-chip-1'" [color]="'#ff0000'"></igx-chip>
         * ```
         * @param {?} newColor
         * @return {?}
         */
        function (newColor) {
            this.chipArea.nativeElement.style.backgroundColor = newColor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxChipComponent.prototype, "hostClass", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            /** @type {?} */
            var classes = [this.getComponentDensityClass('igx-chip')];
            classes.push(this.disabled ? 'igx-chip--disabled' : '');
            // The custom classes should be at the end.
            classes.push(this.class);
            return classes.join(' ');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxChipComponent.prototype, "removeButtonTemplate", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.removeIcon || this.defaultRemoveIcon;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxChipComponent.prototype, "selectIconTemplate", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.selectIcon || this.defaultSelectIcon;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxChipComponent.prototype, "ghostClass", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.getComponentDensityClass('igx-chip__ghost');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxChipComponent.prototype, "chipTabindex", {
        get: /**
         * @return {?}
         */
        function () {
            return !this.disabled ? 0 : '';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} condition
     * @return {?}
     */
    IgxChipComponent.prototype.selectClass = /**
     * @hidden
     * @param {?} condition
     * @return {?}
     */
    function (condition) {
        var _a;
        /** @type {?} */
        var SELECT_CLASS = 'igx-chip__select';
        return _a = {},
            _a[SELECT_CLASS] = condition,
            _a[SELECT_CLASS + "--hidden"] = !condition,
            _a;
    };
    /**
     * @protected
     * @param {?} newValue
     * @param {?=} srcEvent
     * @return {?}
     */
    IgxChipComponent.prototype.changeSelection = /**
     * @protected
     * @param {?} newValue
     * @param {?=} srcEvent
     * @return {?}
     */
    function (newValue, srcEvent) {
        if (srcEvent === void 0) { srcEvent = null; }
        /** @type {?} */
        var onSelectArgs = {
            originalEvent: srcEvent,
            owner: this,
            selected: false,
            cancel: false
        };
        if (newValue && !this._selected) {
            onSelectArgs.selected = true;
            this.onSelection.emit(onSelectArgs);
            if (!onSelectArgs.cancel) {
                this.renderer.addClass(this.chipArea.nativeElement, this._selectedItemClass);
                this._selected = newValue;
            }
        }
        else if (!newValue && this._selected) {
            this.onSelection.emit(onSelectArgs);
            if (!onSelectArgs.cancel) {
                this.renderer.removeClass(this.chipArea.nativeElement, this._selectedItemClass);
                this._selected = newValue;
            }
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxChipComponent.prototype.onChipKeyDown = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var keyDownArgs = {
            originalEvent: event,
            owner: this,
            cancel: false
        };
        this.onKeyDown.emit(keyDownArgs);
        if (keyDownArgs.cancel) {
            return;
        }
        if ((event.key === 'Delete' || event.key === 'Del') && this.removable) {
            this.onRemove.emit({
                originalEvent: event,
                owner: this
            });
        }
        if ((event.key === ' ' || event.key === 'Spacebar') && this.selectable && !this.disabled) {
            this.changeSelection(!this.selected, event);
        }
        if (event.key !== 'Tab') {
            event.preventDefault();
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxChipComponent.prototype.onRemoveBtnKeyDown = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.key === ' ' || event.key === 'Spacebar' || event.key === 'Enter') {
            this.onRemove.emit({
                originalEvent: event,
                owner: this
            });
            event.preventDefault();
            event.stopPropagation();
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    IgxChipComponent.prototype.onRemoveMouseDown = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.stopPropagation();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxChipComponent.prototype.onRemoveClick = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onRemove.emit({
            originalEvent: event,
            owner: this
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxChipComponent.prototype.onRemoveTouchMove = /**
     * @hidden
     * @return {?}
     */
    function () {
        // We don't remove chip if user starting touch interacting on the remove button moves the chip
        this._movedWhileRemoving = true;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxChipComponent.prototype.onRemoveTouchEnd = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this._movedWhileRemoving) {
            this.onRemoveClick(event);
        }
        this._movedWhileRemoving = false;
    };
    /**
     * @hidden
     */
    // -----------------------------
    // Start chip igxDrag behaviour
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    // -----------------------------
    // Start chip igxDrag behaviour
    IgxChipComponent.prototype.onChipDragStart = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    // -----------------------------
    // Start chip igxDrag behaviour
    function (event) {
        this.onMoveStart.emit({
            originalEvent: event.originalEvent,
            owner: this
        });
        event.cancel = !this.draggable || this.disabled;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxChipComponent.prototype.onChipDragEnd = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.dragDir.dropFinished();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxChipComponent.prototype.onChipMoveEnd = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // moveEnd is triggered after return animation has finished. This happen when we drag and release the chip.
        this.onMoveEnd.emit({
            originalEvent: event.originalEvent,
            owner: this
        });
        if (this.selected) {
            this.chipArea.nativeElement.focus();
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxChipComponent.prototype.onChipDragClicked = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var clickEventArgs = {
            originalEvent: event.originalEvent,
            owner: this,
            cancel: false
        };
        this.onClick.emit(clickEventArgs);
        if (!clickEventArgs.cancel && this.selectable && !this.disabled) {
            this.changeSelection(!this.selected, event.originalEvent);
        }
    };
    // End chip igxDrag behaviour
    /**
     * @hidden
     */
    // -----------------------------
    // Start chip igxDrop behaviour
    // End chip igxDrag behaviour
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    // -----------------------------
    // Start chip igxDrop behaviour
    IgxChipComponent.prototype.onChipDragEnterHandler = 
    // End chip igxDrag behaviour
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    // -----------------------------
    // Start chip igxDrop behaviour
    function (event) {
        if (this.dragDir === event.drag || !event.dragData || !event.dragData.chip) {
            return;
        }
        /** @type {?} */
        var eventArgs = {
            owner: this,
            dragChip: event.dragData.chip,
            originalEvent: event
        };
        this.onDragEnter.emit(eventArgs);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxChipComponent.prototype.onChipDrop = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // Cancel the default drop logic
        event.cancel = true;
    };
    IgxChipComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-chip',
                    template: "<div #chipArea class=\"igx-chip__item\"\n    [attr.tabindex]=\"chipTabindex\"\n    (keydown)=\"onChipKeyDown($event)\"\n    [igxDrag]=\"{chip: this}\"\n    [hideBaseOnDrag]=\"true\"\n    [animateOnRelease]=\"true\"\n    [ghostImageClass]=\"ghostClass\"\n    (dragStart)=\"onChipDragStart($event)\"\n    (dragEnd)=\"onChipDragEnd()\"\n    (returnMoveEnd)=\"onChipMoveEnd($event)\"\n    (dragClicked)=\"onChipDragClicked($event)\"\n    igxDrop\n    (onEnter)=\"onChipDragEnterHandler($event)\"\n    (onDrop)=\"onChipDrop($event)\">\n\n    <div [ngClass]=\"selectClass(selected)\">\n        <ng-container *ngTemplateOutlet=\"selectIconTemplate\"></ng-container>\n    </div>\n\n    <ng-content select=\"igx-prefix,[igxPrefix]\"></ng-content>\n\n    <div class=\"igx-chip__content\">\n        <ng-content></ng-content>\n    </div>\n\n    <ng-content select=\"igx-suffix,[igxSuffix]\"></ng-content>\n\n    <div class=\"igx-chip__remove\" *ngIf=\"removable\"\n        tabindex=\"0\"\n        (keydown)=\"onRemoveBtnKeyDown($event)\"\n        (pointerdown)=\"onRemoveMouseDown($event)\"\n        (mousedown)=\"onRemoveMouseDown($event)\"\n        (click)=\"onRemoveClick($event)\"\n        (touchmove)=\"onRemoveTouchMove()\"\n        (touchend)=\"onRemoveTouchEnd($event)\">\n        <ng-container *ngTemplateOutlet=\"removeButtonTemplate\"></ng-container>\n    </div>\n</div>\n\n<ng-template #defaultSelectIcon>\n    <igx-icon>done</igx-icon>\n</ng-template>\n\n<ng-template #defaultRemoveIcon>\n    <igx-icon>cancel</igx-icon>\n</ng-template>\n"
                }] }
    ];
    /** @nocollapse */
    IgxChipComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: Renderer2 },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
    ]; };
    IgxChipComponent.propDecorators = {
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        data: [{ type: Input }],
        draggable: [{ type: Input }],
        removable: [{ type: Input }],
        removeIcon: [{ type: Input }],
        selectable: [{ type: Input }],
        selectIcon: [{ type: Input }],
        class: [{ type: Input }],
        disabled: [{ type: Input }],
        selected: [{ type: Input }],
        color: [{ type: Input }],
        onMoveStart: [{ type: Output }],
        onMoveEnd: [{ type: Output }],
        onRemove: [{ type: Output }],
        onClick: [{ type: Output }],
        onSelection: [{ type: Output }],
        onKeyDown: [{ type: Output }],
        onDragEnter: [{ type: Output }],
        hostClass: [{ type: HostBinding, args: ['attr.class',] }],
        chipArea: [{ type: ViewChild, args: ['chipArea', { read: ElementRef },] }],
        dragDir: [{ type: ViewChild, args: ['chipArea', { read: IgxDragDirective },] }],
        defaultRemoveIcon: [{ type: ViewChild, args: ['defaultRemoveIcon', { read: TemplateRef },] }],
        defaultSelectIcon: [{ type: ViewChild, args: ['defaultSelectIcon', { read: TemplateRef },] }]
    };
    return IgxChipComponent;
}(DisplayDensityBase));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxChipsAreaComponent = /** @class */ (function () {
    function IgxChipsAreaComponent(cdr, element, _iterableDiffers) {
        this.cdr = cdr;
        this.element = element;
        this._iterableDiffers = _iterableDiffers;
        /**
         * @hidden
         */
        this.class = '';
        /**
         * Emits an event when `IgxChipComponent`s in the `IgxChipsAreaComponent` should be reordered.
         * Returns an array of `IgxChipComponent`s.
         * ```html
         * <igx-chips-area #chipsArea [width]="'300'" [height]="'10'" (onReorder)="changedOrder($event)"></igx-chips-area>
         * ```
         * ```typescript
         * public changedOrder(event: IChipsAreaReorderEventArgs){
         *      let chips: IgxChipComponent[] = event.chipsArray;
         * }
         * ```
         */
        this.onReorder = new EventEmitter();
        /**
         * Emits an event when an `IgxChipComponent` in the `IgxChipsAreaComponent` is selected/deselected.
         * Fired after the chips area is initialized if there are initially selected chips as well.
         * Returns an array of selected `IgxChipComponent`s and the `IgxChipAreaComponent`.
         * ```html
         * <igx-chips-area #chipsArea [width]="'300'" [height]="'10'" (onSelection)="selection($event)"></igx-chips-area>
         * ```
         * ```typescript
         * public selection(event: IChipsAreaSelectEventArgs){
         *      let selectedChips: IgxChipComponent[] = event.newSelection;
         * }
         */
        this.onSelection = new EventEmitter();
        /**
         * Emits an event when an `IgxChipComponent` in the `IgxChipsAreaComponent` is moved.
         * ```html
         * <igx-chips-area #chipsArea [width]="'300'" [height]="'10'" (onMoveStart)="moveStart($event)"></igx-chips-area>
         * ```
         * ```typescript
         * moveStart(event: IBaseChipsAreaEventArgs){
         *      let chipArea = event.owner;
         * }
         * ```
         */
        this.onMoveStart = new EventEmitter();
        /**
         * Emits an event after an `IgxChipComponent` in the `IgxChipsAreaComponent` is moved.
         * ```html
         * <igx-chips-area #chipsArea [width]="'300'" [height]="'10'" (onMoveEnd)="moveEnd($event)"></igx-chips-area>
         * ```
         * ```typescript
         * moveEnd(event: IBaseChipsAreaEventArgs){
         *      let chipArea = event.owner;
         * }
         * ```
         */
        this.onMoveEnd = new EventEmitter();
        this._differ = null;
        this.selectedChips = [];
        this.destroy$ = new Subject$1();
        this._differ = this._iterableDiffers.find([]).create(null);
    }
    Object.defineProperty(IgxChipsAreaComponent.prototype, "hostClass", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            /** @type {?} */
            var classes = ['igx-chip-area'];
            classes.push(this.class);
            return classes.join(' ');
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxChipsAreaComponent.prototype.ngAfterViewInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        // If we have initially selected chips through their inputs, we need to get them, because we cannot listen to their events yet.
        if (this.chipsList.length) {
            this.selectedChips = this.chipsList.filter(function (item) { return item.selected; });
            if (this.selectedChips.length) {
                this.onSelection.emit({
                    originalEvent: null,
                    newSelection: this.selectedChips,
                    owner: this
                });
            }
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxChipsAreaComponent.prototype.ngDoCheck = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.chipsList) {
            /** @type {?} */
            var changes = this._differ.diff(this.chipsList.toArray());
            if (changes) {
                changes.forEachAddedItem(function (addedChip) {
                    addedChip.item.onMoveStart.pipe(takeUntil(_this.destroy$)).subscribe(function (args) {
                        _this.onChipMoveStart(args);
                    });
                    addedChip.item.onMoveEnd.pipe(takeUntil(_this.destroy$)).subscribe(function (args) {
                        _this.onChipMoveEnd(args);
                    });
                    addedChip.item.onDragEnter.pipe(takeUntil(_this.destroy$)).subscribe(function (args) {
                        _this.onChipDragEnter(args);
                    });
                    addedChip.item.onKeyDown.pipe(takeUntil(_this.destroy$)).subscribe(function (args) {
                        _this.onChipKeyDown(args);
                    });
                    if (addedChip.item.selectable) {
                        addedChip.item.onSelection.pipe(takeUntil(_this.destroy$)).subscribe(function (args) {
                            _this.onChipSelectionChange(args);
                        });
                    }
                });
                this.modifiedChipsArray = this.chipsList.toArray();
            }
        }
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxChipsAreaComponent.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.destroy$.next(true);
        this.destroy$.complete();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} event
     * @return {?}
     */
    IgxChipsAreaComponent.prototype.onChipKeyDown = /**
     * @hidden
     * @protected
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        /** @type {?} */
        var orderChanged = false;
        /** @type {?} */
        var chipsArray = this.chipsList.toArray();
        /** @type {?} */
        var dragChipIndex = chipsArray.findIndex(function (el) { return el === event.owner; });
        if (event.originalEvent.shiftKey === true) {
            if (event.originalEvent.key === 'ArrowLeft' || event.originalEvent.key === 'Left') {
                orderChanged = this.positionChipAtIndex(dragChipIndex, dragChipIndex - 1, false, event.originalEvent);
                if (orderChanged) {
                    setTimeout(function () {
                        _this.chipsList.toArray()[dragChipIndex - 1].chipArea.nativeElement.focus();
                    });
                }
            }
            else if (event.originalEvent.key === 'ArrowRight' || event.originalEvent.key === 'Right') {
                orderChanged = this.positionChipAtIndex(dragChipIndex, dragChipIndex + 1, true, event.originalEvent);
            }
        }
        else {
            if ((event.originalEvent.key === 'ArrowLeft' || event.originalEvent.key === 'Left') && dragChipIndex > 0) {
                chipsArray[dragChipIndex - 1].chipArea.nativeElement.focus();
            }
            else if ((event.originalEvent.key === 'ArrowRight' || event.originalEvent.key === 'Right') &&
                dragChipIndex < chipsArray.length - 1) {
                chipsArray[dragChipIndex + 1].chipArea.nativeElement.focus();
            }
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} event
     * @return {?}
     */
    IgxChipsAreaComponent.prototype.onChipMoveStart = /**
     * @hidden
     * @protected
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onMoveStart.emit({
            originalEvent: event.originalEvent,
            owner: this
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} event
     * @return {?}
     */
    IgxChipsAreaComponent.prototype.onChipMoveEnd = /**
     * @hidden
     * @protected
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onMoveEnd.emit({
            originalEvent: event.originalEvent,
            owner: this
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} event
     * @return {?}
     */
    IgxChipsAreaComponent.prototype.onChipDragEnter = /**
     * @hidden
     * @protected
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var dropChipRect = event.owner.elementRef.nativeElement.getBoundingClientRect();
        /** @type {?} */
        var dropChipIndex = this.chipsList.toArray().findIndex(function (el) { return el === event.owner; });
        /** @type {?} */
        var dragChipIndex = this.chipsList.toArray().findIndex(function (el) { return el === event.dragChip; });
        if (dragChipIndex < dropChipIndex) {
            // from the left to right
            this.positionChipAtIndex(dragChipIndex, dropChipIndex, true, event.originalEvent);
        }
        else {
            // from the right to left
            this.positionChipAtIndex(dragChipIndex, dropChipIndex, false, event.originalEvent);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} chipIndex
     * @param {?} targetIndex
     * @param {?} shiftRestLeft
     * @param {?} originalEvent
     * @return {?}
     */
    IgxChipsAreaComponent.prototype.positionChipAtIndex = /**
     * @hidden
     * @protected
     * @param {?} chipIndex
     * @param {?} targetIndex
     * @param {?} shiftRestLeft
     * @param {?} originalEvent
     * @return {?}
     */
    function (chipIndex, targetIndex, shiftRestLeft, originalEvent) {
        if (chipIndex < 0 || this.chipsList.length <= chipIndex ||
            targetIndex < 0 || this.chipsList.length <= targetIndex) {
            return false;
        }
        /** @type {?} */
        var chipsArray = this.chipsList.toArray();
        /** @type {?} */
        var result = [];
        for (var i = 0; i < chipsArray.length; i++) {
            if (shiftRestLeft) {
                if (chipIndex <= i && i < targetIndex) {
                    result.push(chipsArray[i + 1]);
                }
                else if (i === targetIndex) {
                    result.push(chipsArray[chipIndex]);
                }
                else {
                    result.push(chipsArray[i]);
                }
            }
            else {
                if (targetIndex < i && i <= chipIndex) {
                    result.push(chipsArray[i - 1]);
                }
                else if (i === targetIndex) {
                    result.push(chipsArray[chipIndex]);
                }
                else {
                    result.push(chipsArray[i]);
                }
            }
        }
        this.modifiedChipsArray = result;
        /** @type {?} */
        var eventData = {
            chipsArray: this.modifiedChipsArray,
            originalEvent: originalEvent,
            owner: this
        };
        this.onReorder.emit(eventData);
        return true;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} event
     * @return {?}
     */
    IgxChipsAreaComponent.prototype.onChipSelectionChange = /**
     * @hidden
     * @protected
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.selected) {
            this.selectedChips.push(event.owner);
        }
        else if (!event.selected) {
            this.selectedChips = this.selectedChips.filter(function (chip) {
                return chip.id !== event.owner.id;
            });
        }
        this.onSelection.emit({
            originalEvent: event.originalEvent,
            newSelection: this.selectedChips,
            owner: this
        });
    };
    IgxChipsAreaComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-chips-area',
                    template: "<ng-content></ng-content>\n"
                }] }
    ];
    /** @nocollapse */
    IgxChipsAreaComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: IterableDiffers }
    ]; };
    IgxChipsAreaComponent.propDecorators = {
        class: [{ type: Input }],
        hostClass: [{ type: HostBinding, args: ['attr.class',] }],
        width: [{ type: HostBinding, args: ['style.width.px',] }, { type: Input }],
        height: [{ type: HostBinding, args: ['style.height.px',] }, { type: Input }],
        onReorder: [{ type: Output }],
        onSelection: [{ type: Output }],
        onMoveStart: [{ type: Output }],
        onMoveEnd: [{ type: Output }],
        chipsList: [{ type: ContentChildren, args: [IgxChipComponent,] }]
    };
    return IgxChipsAreaComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxChipsModule = /** @class */ (function () {
    function IgxChipsModule() {
    }
    IgxChipsModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        IgxChipsAreaComponent,
                        IgxChipComponent
                    ],
                    exports: [
                        IgxChipsAreaComponent,
                        IgxChipComponent,
                        IgxPrefixDirective,
                        IgxSuffixDirective
                    ],
                    imports: [
                        CommonModule,
                        IgxRippleModule,
                        IgxIconModule,
                        IgxButtonModule,
                        IgxAvatarModule,
                        IgxDragDropModule,
                        IgxPrefixModule,
                        IgxSuffixModule
                    ]
                },] }
    ];
    return IgxChipsModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxComboHeaderDirective = /** @class */ (function () {
    function IgxComboHeaderDirective() {
    }
    IgxComboHeaderDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxComboHeader]'
                },] }
    ];
    return IgxComboHeaderDirective;
}());
/**
 * @hidden
 */
var IgxComboFooterDirective = /** @class */ (function () {
    function IgxComboFooterDirective() {
    }
    IgxComboFooterDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxComboFooter]'
                },] }
    ];
    return IgxComboFooterDirective;
}());
/**
 * @hidden
 */
var IgxComboItemDirective = /** @class */ (function () {
    function IgxComboItemDirective() {
    }
    IgxComboItemDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxComboItem]'
                },] }
    ];
    return IgxComboItemDirective;
}());
/**
 * @hidden
 */
var IgxComboEmptyDirective = /** @class */ (function () {
    function IgxComboEmptyDirective() {
    }
    IgxComboEmptyDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxComboEmpty]'
                },] }
    ];
    return IgxComboEmptyDirective;
}());
/**
 * @hidden
 */
var IgxComboHeaderItemDirective = /** @class */ (function () {
    function IgxComboHeaderItemDirective() {
    }
    IgxComboHeaderItemDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxComboHeaderItem]'
                },] }
    ];
    return IgxComboHeaderItemDirective;
}());
/**
 * @hidden
 */
var IgxComboAddItemDirective = /** @class */ (function () {
    function IgxComboAddItemDirective() {
    }
    IgxComboAddItemDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxComboAddItem]'
                },] }
    ];
    return IgxComboAddItemDirective;
}());
/**
 * @hidden
 */
var IgxComboToggleIconDirective = /** @class */ (function () {
    function IgxComboToggleIconDirective() {
    }
    IgxComboToggleIconDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxComboToggleIcon]'
                },] }
    ];
    return IgxComboToggleIconDirective;
}());
/**
 * @hidden
 */
var IgxComboClearIconDirective = /** @class */ (function () {
    function IgxComboClearIconDirective() {
    }
    IgxComboClearIconDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxComboClearIcon]'
                },] }
    ];
    return IgxComboClearIconDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var  /**
 * @hidden
 */
IgxComboAPIService = /** @class */ (function () {
    function IgxComboAPIService() {
        this.disableTransitions = false;
    }
    /**
     * @param {?} combo
     * @return {?}
     */
    IgxComboAPIService.prototype.register = /**
     * @param {?} combo
     * @return {?}
     */
    function (combo) {
        this.combo = combo;
    };
    /**
     * @return {?}
     */
    IgxComboAPIService.prototype.clear = /**
     * @return {?}
     */
    function () {
        this.combo = null;
    };
    Object.defineProperty(IgxComboAPIService.prototype, "item_focusable", {
        get: /**
         * @return {?}
         */
        function () {
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxComboAPIService.prototype, "isRemote", {
        get: /**
         * @return {?}
         */
        function () {
            return this.combo.isRemote;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    IgxComboAPIService.prototype.add_custom_item = /**
     * @return {?}
     */
    function () {
        if (!this.combo) {
            return;
        }
        this.combo.addItemToCollection();
    };
    Object.defineProperty(IgxComboAPIService.prototype, "comboID", {
        get: /**
         * @return {?}
         */
        function () {
            return this.combo.id;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} itemID
     * @param {?=} event
     * @return {?}
     */
    IgxComboAPIService.prototype.set_selected_item = /**
     * @param {?} itemID
     * @param {?=} event
     * @return {?}
     */
    function (itemID, event) {
        /** @type {?} */
        var selected = this.combo.isItemSelected(itemID);
        if (itemID === null || itemID === undefined) {
            return;
        }
        if (!selected) {
            this.combo.selectItems([itemID], false, event);
        }
        else {
            this.combo.deselectItems([itemID], event);
        }
    };
    /**
     * @param {?} itemID
     * @return {?}
     */
    IgxComboAPIService.prototype.is_item_selected = /**
     * @param {?} itemID
     * @return {?}
     */
    function (itemID) {
        return this.combo.isItemSelected(itemID);
    };
    return IgxComboAPIService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxComboItemComponent = /** @class */ (function (_super) {
    __extends(IgxComboItemComponent, _super);
    function IgxComboItemComponent(comboAPI, dropDown, elementRef, selection) {
        var _this = _super.call(this, dropDown, elementRef, null, selection) || this;
        _this.comboAPI = comboAPI;
        _this.dropDown = dropDown;
        _this.elementRef = elementRef;
        _this.selection = selection;
        /**
         * Gets the height of a list item
         * @hidden
         */
        _this.itemHeight = '';
        return _this;
    }
    Object.defineProperty(IgxComboItemComponent.prototype, "itemID", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.comboAPI.isRemote ? JSON.stringify(this.value) : this.value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxComboItemComponent.prototype, "comboID", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.comboAPI.comboID;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxComboItemComponent.prototype, "disableTransitions", {
        /**
         * @hidden
         * @internal
         */
        get: /**
         * @hidden
         * \@internal
         * @return {?}
         */
        function () {
            return this.comboAPI.disableTransitions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxComboItemComponent.prototype, "selected", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.comboAPI.is_item_selected(this.itemID);
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this.isHeader) {
                return;
            }
            this._selected = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} direction
     * @return {?}
     */
    IgxComboItemComponent.prototype.isVisible = /**
     * @hidden
     * @param {?} direction
     * @return {?}
     */
    function (direction) {
        /** @type {?} */
        var rect = this.element.nativeElement.getBoundingClientRect();
        /** @type {?} */
        var parentDiv = this.element.nativeElement.parentElement.parentElement.getBoundingClientRect();
        if (direction === Navigate.Down) {
            return rect.y + rect.height <= parentDiv.y + parentDiv.height;
        }
        return rect.y >= parentDiv.y;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    IgxComboItemComponent.prototype.clicked = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.comboAPI.disableTransitions = false;
        if (this.disabled || this.isHeader) {
            /** @type {?} */
            var focusedItem = this.dropDown.items.find(function (item) { return item.focused; });
            if (this.dropDown.allowItemsFocus && focusedItem) {
                focusedItem.element.nativeElement.focus({ preventScroll: true });
            }
            return;
        }
        this.dropDown.navigateItem(this.index);
        this.comboAPI.set_selected_item(this.itemID, event);
    };
    /**
     * @return {?}
     */
    IgxComboItemComponent.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
    };
    IgxComboItemComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-combo-item',
                    template: "<ng-container *ngIf=\"!isHeader\">\n    <igx-checkbox [checked]=\"selected\" disableRipple=\"true\" [disableTransitions]=\"disableTransitions\" disabled=\"true\" class=\"igx-combo__checkbox\"></igx-checkbox>\n</ng-container>\n<ng-content></ng-content>"
                }] }
    ];
    /** @nocollapse */
    IgxComboItemComponent.ctorParameters = function () { return [
        { type: IgxComboAPIService },
        { type: undefined, decorators: [{ type: Inject, args: [IGX_DROPDOWN_BASE,] }] },
        { type: ElementRef },
        { type: IgxSelectionAPIService, decorators: [{ type: Inject, args: [IgxSelectionAPIService,] }] }
    ]; };
    IgxComboItemComponent.propDecorators = {
        itemHeight: [{ type: Input }, { type: HostBinding, args: ['style.height.px',] }],
        clicked: [{ type: HostListener, args: ['click', ['$event'],] }]
    };
    return IgxComboItemComponent;
}(IgxDropDownItemComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var IGX_COMBO_COMPONENT = 'IgxComboComponentToken';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxComboAddItemComponent = /** @class */ (function (_super) {
    __extends(IgxComboAddItemComponent, _super);
    function IgxComboAddItemComponent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(IgxComboAddItemComponent.prototype, "selected", {
        get: /**
         * @return {?}
         */
        function () {
            return false;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?=} event
     * @return {?}
     */
    IgxComboAddItemComponent.prototype.clicked = /**
     * @param {?=} event
     * @return {?}
     */
    function (event) {
        this.comboAPI.disableTransitions = false;
        this.comboAPI.add_custom_item();
    };
    IgxComboAddItemComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-combo-add-item',
                    template: '<ng-content></ng-content>',
                    providers: [{ provide: IgxComboItemComponent, useExisting: IgxComboAddItemComponent }]
                }] }
    ];
    return IgxComboAddItemComponent;
}(IgxComboItemComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxComboDropDownComponent = /** @class */ (function (_super) {
    __extends(IgxComboDropDownComponent, _super);
    function IgxComboDropDownComponent(elementRef, cdr, selection, combo, comboAPI) {
        var _this = _super.call(this, elementRef, cdr, selection) || this;
        _this.elementRef = elementRef;
        _this.cdr = cdr;
        _this.selection = selection;
        _this.combo = combo;
        _this.comboAPI = comboAPI;
        /**
         * @hidden
         * \@internal
         */
        _this.children = null;
        _this.scrollHandler = function () {
            _this.comboAPI.disableTransitions = true;
        };
        return _this;
    }
    Object.defineProperty(IgxComboDropDownComponent.prototype, "scrollContainer", {
        get: /**
         * @protected
         * @return {?}
         */
        function () {
            return this.virtDir.dc.location.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxComboDropDownComponent.prototype, "isScrolledToLast", {
        get: /**
         * @protected
         * @return {?}
         */
        function () {
            /** @type {?} */
            var scrollTop = this.virtDir.getVerticalScroll().scrollTop;
            /** @type {?} */
            var scrollHeight = this.virtDir.getVerticalScroll().scrollHeight;
            return Math.floor(scrollTop + this.virtDir.igxForContainerSize) === scrollHeight;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxComboDropDownComponent.prototype, "lastVisibleIndex", {
        get: /**
         * @protected
         * @return {?}
         */
        function () {
            return this.combo.totalItemCount ?
                Math.floor(this.combo.itemsMaxHeight / this.combo.itemHeight) :
                this.items.length - 1;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @return {?}
     */
    IgxComboDropDownComponent.prototype.onFocus = /**
     * @hidden \@internal
     * @return {?}
     */
    function () {
        this.focusedItem = this._focusedItem || this.items[0];
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @param {?=} evt
     * @return {?}
     */
    IgxComboDropDownComponent.prototype.onBlur = /**
     * @hidden \@internal
     * @param {?=} evt
     * @return {?}
     */
    function (evt) {
        this.focusedItem = null;
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @return {?}
     */
    IgxComboDropDownComponent.prototype.onToggleOpened = /**
     * @hidden \@internal
     * @return {?}
     */
    function () {
        this.onOpened.emit();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxComboDropDownComponent.prototype.navigateFirst = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.navigateItem(this.virtDir.igxForOf.findIndex(function (e) { return !e.isHeader; }));
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxComboDropDownComponent.prototype.navigatePrev = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (this._focusedItem && this._focusedItem.index === 0 && this.virtDir.state.startIndex === 0) {
            this.combo.focusSearchInput(false);
        }
        else {
            _super.prototype.navigatePrev.call(this);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxComboDropDownComponent.prototype.navigateNext = /**
     * @hidden
     * @return {?}
     */
    function () {
        /** @type {?} */
        var lastIndex = this.combo.totalItemCount ? this.combo.totalItemCount - 1 : this.virtDir.igxForOf.length - 1;
        if (this._focusedItem && this._focusedItem.index === lastIndex) {
            this.focusAddItemButton();
        }
        else {
            _super.prototype.navigateNext.call(this);
        }
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @param {?} item
     * @return {?}
     */
    IgxComboDropDownComponent.prototype.selectItem = /**
     * @hidden \@internal
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (item === null || item === undefined) {
            return;
        }
        this.comboAPI.set_selected_item(item.itemID);
        this._focusedItem = item;
    };
    /**
     * @private
     * @return {?}
     */
    IgxComboDropDownComponent.prototype.focusAddItemButton = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.combo.isAddButtonVisible()) {
            this.focusedItem = this.items[this.items.length - 1];
        }
    };
    /**
     * @protected
     * @param {?} newItem
     * @return {?}
     */
    IgxComboDropDownComponent.prototype.scrollToHiddenItem = /**
     * @protected
     * @param {?} newItem
     * @return {?}
     */
    function (newItem) { };
    Object.defineProperty(IgxComboDropDownComponent.prototype, "sortedChildren", {
        get: /**
         * @protected
         * @return {?}
         */
        function () {
            if (this.children !== undefined) {
                return this.children.toArray()
                    .sort(function (a, b) {
                    return a.index - b.index;
                });
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxComboDropDownComponent.prototype, "items", {
        /**
         * Get all non-header items
         *
         * ```typescript
         * let myDropDownItems = this.dropdown.items;
         * ```
         */
        get: /**
         * Get all non-header items
         *
         * ```typescript
         * let myDropDownItems = this.dropdown.items;
         * ```
         * @return {?}
         */
        function () {
            var e_1, _a;
            /** @type {?} */
            var items = [];
            if (this.children !== undefined) {
                /** @type {?} */
                var sortedChildren = (/** @type {?} */ (this.sortedChildren));
                try {
                    for (var sortedChildren_1 = __values(sortedChildren), sortedChildren_1_1 = sortedChildren_1.next(); !sortedChildren_1_1.done; sortedChildren_1_1 = sortedChildren_1.next()) {
                        var child = sortedChildren_1_1.value;
                        if (!child.isHeader) {
                            items.push(child);
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (sortedChildren_1_1 && !sortedChildren_1_1.done && (_a = sortedChildren_1.return)) _a.call(sortedChildren_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            return items;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @return {?}
     */
    IgxComboDropDownComponent.prototype.updateScrollPosition = /**
     * @hidden \@internal
     * @return {?}
     */
    function () {
        this.virtDir.getVerticalScroll().scrollTop = this._scrollPosition;
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @param {?} key
     * @return {?}
     */
    IgxComboDropDownComponent.prototype.onItemActionKey = /**
     * @hidden \@internal
     * @param {?} key
     * @return {?}
     */
    function (key) {
        switch (key) {
            case DropDownActionKey.ENTER:
                this.handleEnter();
                break;
            case DropDownActionKey.SPACE:
                this.handleSpace();
                break;
            case DropDownActionKey.ESCAPE:
                this.close();
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxComboDropDownComponent.prototype.handleEnter = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.isAddItemFocused()) {
            this.combo.addItemToCollection();
        }
        else {
            this.close();
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxComboDropDownComponent.prototype.handleSpace = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.isAddItemFocused()) {
            return;
        }
        else {
            this.selectItem(this.focusedItem);
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxComboDropDownComponent.prototype.isAddItemFocused = /**
     * @private
     * @return {?}
     */
    function () {
        return this.focusedItem instanceof IgxComboAddItemComponent;
    };
    /**
     * @return {?}
     */
    IgxComboDropDownComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.virtDir.getVerticalScroll().addEventListener('scroll', this.scrollHandler);
    };
    /**
     *@hidden @internal
     */
    /**
     * @hidden \@internal
     * @return {?}
     */
    IgxComboDropDownComponent.prototype.ngOnDestroy = /**
     * @hidden \@internal
     * @return {?}
     */
    function () {
        this.virtDir.getVerticalScroll().removeEventListener('scroll', this.scrollHandler);
        this.destroy$.next(true);
        this.destroy$.complete();
    };
    IgxComboDropDownComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-combo-drop-down',
                    template: "<div class=\"igx-drop-down__list\" igxToggle [style.width]=\"width\" [style.height]=\"height\"\n[style.maxHeight]=\"maxHeight\" [attr.id]=\"this.listId\" role=\"listbox\"\n    (onOpening)=\"onToggleOpening($event)\" (onOpened)=\"onToggleOpened()\"\n    (onClosing)=\"onToggleClosing($event)\" (onClosed)=\"onToggleClosed()\">\n    <ng-container *ngIf=\"!collapsed\">\n        <ng-content></ng-content>\n    </ng-container>\n</div>\n",
                    providers: [{ provide: IGX_DROPDOWN_BASE, useExisting: IgxComboDropDownComponent }]
                }] }
    ];
    /** @nocollapse */
    IgxComboDropDownComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ChangeDetectorRef },
        { type: IgxSelectionAPIService },
        { type: undefined, decorators: [{ type: Inject, args: [IGX_COMBO_COMPONENT,] }] },
        { type: IgxComboAPIService }
    ]; };
    IgxComboDropDownComponent.propDecorators = {
        children: [{ type: ContentChildren, args: [IgxComboItemComponent, { descendants: true },] }]
    };
    return IgxComboDropDownComponent;
}(IgxDropDownComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxComboFilteringPipe = /** @class */ (function () {
    function IgxComboFilteringPipe(combo) {
        this.combo = combo;
    }
    /**
     * @param {?} collection
     * @param {?} expressions
     * @param {?} logic
     * @return {?}
     */
    IgxComboFilteringPipe.prototype.transform = /**
     * @param {?} collection
     * @param {?} expressions
     * @param {?} logic
     * @return {?}
     */
    function (collection, expressions, logic) {
        /** @type {?} */
        var filteringExpressionsTree = new FilteringExpressionsTree(logic);
        filteringExpressionsTree.filteringOperands = expressions;
        /** @type {?} */
        var state$$1 = { expressionsTree: filteringExpressionsTree, strategy: new SimpleFilteringStrategy() };
        state$$1.expressionsTree.filteringOperands = this.combo.filteringExpressions;
        if (!state$$1.expressionsTree.filteringOperands.length) {
            return collection;
        }
        /** @type {?} */
        var result = DataUtil.filter(cloneArray(collection), state$$1);
        return result;
    };
    IgxComboFilteringPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'comboFiltering'
                },] }
    ];
    /** @nocollapse */
    IgxComboFilteringPipe.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [IGX_COMBO_COMPONENT,] }] }
    ]; };
    return IgxComboFilteringPipe;
}());
/**
 * @hidden
 */
var /**
 * @hidden
 */
SimpleFilteringStrategy = /** @class */ (function (_super) {
    __extends(SimpleFilteringStrategy, _super);
    function SimpleFilteringStrategy() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {?} rec
     * @param {?} expr
     * @return {?}
     */
    SimpleFilteringStrategy.prototype.findMatchByExpression = /**
     * @param {?} rec
     * @param {?} expr
     * @return {?}
     */
    function (rec, expr) {
        /** @type {?} */
        var cond = expr.condition;
        /** @type {?} */
        var val = expr.fieldName === undefined ? rec : rec[expr.fieldName];
        return cond.logic(val, expr.searchVal, expr.ignoreCase);
    };
    return SimpleFilteringStrategy;
}(FilteringStrategy));
/**
 * @hidden
 */
var IgxComboSortingPipe = /** @class */ (function () {
    function IgxComboSortingPipe() {
    }
    /**
     * @param {?} collection
     * @param {?} expressions
     * @return {?}
     */
    IgxComboSortingPipe.prototype.transform = /**
     * @param {?} collection
     * @param {?} expressions
     * @return {?}
     */
    function (collection, expressions) {
        if (!expressions.length) {
            return collection;
        }
        /** @type {?} */
        var result = DataUtil.sort(cloneArray(collection), expressions);
        return result;
    };
    IgxComboSortingPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'comboSorting',
                    pure: true
                },] }
    ];
    /** @nocollapse */
    IgxComboSortingPipe.ctorParameters = function () { return []; };
    return IgxComboSortingPipe;
}());
/**
 * @hidden
 */
var IgxComboGroupingPipe = /** @class */ (function () {
    function IgxComboGroupingPipe(combo) {
        this.combo = combo;
    }
    /**
     * @param {?} collection
     * @param {?} groupKey
     * @return {?}
     */
    IgxComboGroupingPipe.prototype.transform = /**
     * @param {?} collection
     * @param {?} groupKey
     * @return {?}
     */
    function (collection, groupKey) {
        var _a;
        this.combo.filteredData = collection;
        if ((!groupKey && groupKey !== 0) || !collection.length) {
            return collection;
        }
        /** @type {?} */
        var data = cloneArray(collection);
        /** @type {?} */
        var inserts = 0;
        /** @type {?} */
        var currentHeader = null;
        for (var i = 0; i < collection.length; i++) {
            /** @type {?} */
            var insertFlag = 0;
            if (currentHeader !== collection[i][groupKey]) {
                currentHeader = collection[i][groupKey];
                insertFlag = 1;
            }
            if (insertFlag) {
                data.splice(i + inserts, 0, (_a = {},
                    _a[this.combo.valueKey] = currentHeader,
                    _a[this.combo.groupKey] = currentHeader,
                    _a.isHeader = true,
                    _a));
                inserts++;
            }
        }
        return data;
    };
    IgxComboGroupingPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'comboGrouping'
                },] }
    ];
    /** @nocollapse */
    IgxComboGroupingPipe.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [IGX_COMBO_COMPONENT,] }] }
    ]; };
    return IgxComboGroupingPipe;
}());
/**
 * @hidden
 */
var IgxComboFilterConditionPipe = /** @class */ (function () {
    function IgxComboFilterConditionPipe() {
    }
    /**
     * @param {?} value
     * @return {?}
     */
    IgxComboFilterConditionPipe.prototype.transform = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return value.split(/(?=[A-Z])/).join(' ');
    };
    IgxComboFilterConditionPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'filterCondition',
                    pure: true
                },] }
    ];
    return IgxComboFilterConditionPipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Custom strategy to provide the combo with callback on initial positioning
 */
var /**
 * Custom strategy to provide the combo with callback on initial positioning
 */
ComboConnectedPositionStrategy = /** @class */ (function (_super) {
    __extends(ComboConnectedPositionStrategy, _super);
    function ComboConnectedPositionStrategy(callback) {
        var _this = _super.call(this) || this;
        _this._callback = callback;
        return _this;
    }
    /**
     * @param {?} contentElement
     * @param {?} size
     * @param {?=} document
     * @param {?=} initialCall
     * @return {?}
     */
    ComboConnectedPositionStrategy.prototype.position = /**
     * @param {?} contentElement
     * @param {?} size
     * @param {?=} document
     * @param {?=} initialCall
     * @return {?}
     */
    function (contentElement, size, document, initialCall) {
        if (initialCall) {
            this._callback();
        }
        _super.prototype.position.call(this, contentElement, size);
    };
    return ComboConnectedPositionStrategy;
}(ConnectedPositioningStrategy));
/** @enum {string} */
var DataTypes = {
    EMPTY: 'empty',
    PRIMITIVE: 'primitive',
    COMPLEX: 'complex',
    PRIMARYKEY: 'valueKey',
};
/** @enum {number} */
var IgxComboState = {
    /**
     * Combo with initial state.
     */
    INITIAL: 0,
    /**
     * Combo with valid state.
     */
    VALID: 1,
    /**
     * Combo with invalid state.
     */
    INVALID: 2,
};
IgxComboState[IgxComboState.INITIAL] = 'INITIAL';
IgxComboState[IgxComboState.VALID] = 'VALID';
IgxComboState[IgxComboState.INVALID] = 'INVALID';
/** @type {?} */
var NEXT_ID$j = 0;
/** @type {?} */
var noop$4 = function () { };
var IgxComboComponent = /** @class */ (function (_super) {
    __extends(IgxComboComponent, _super);
    function IgxComboComponent(elementRef, cdr, selection, comboAPI, _displayDensityOptions, injector) {
        var _this = _super.call(this, _displayDensityOptions) || this;
        _this.elementRef = elementRef;
        _this.cdr = cdr;
        _this.selection = selection;
        _this.comboAPI = comboAPI;
        _this._displayDensityOptions = _displayDensityOptions;
        _this.injector = injector;
        /**
         * @hidden \@internal
         */
        _this.customValueFlag = true;
        /**
         * @hidden \@internal
         */
        _this.defaultFallbackGroup = 'Other';
        _this.stringFilters = IgxStringFilteringOperand;
        _this.booleanFilters = IgxBooleanFilteringOperand;
        _this._filteringLogic = FilteringLogic.Or;
        _this._filteringExpressions = [];
        _this._sortingExpressions = [];
        _this._groupKey = '';
        _this._prevInputValue = '';
        _this._dataType = '';
        _this.ngControl = null;
        _this.destroy$ = new Subject();
        _this._data = [];
        _this._filteredData = [];
        _this._onChangeCallback = noop$4;
        _this.overlaySettings = {
            scrollStrategy: new AbsoluteScrollStrategy(),
            modal: false,
            closeOnOutsideClick: true,
            excludePositionTarget: true
        };
        _this._value = '';
        /**
         * @hidden \@internal
         */
        _this.searchInput = null;
        /**
         * @hidden \@internal
         */
        _this.comboInput = null;
        /**
         * The custom template, if any, that should be used when rendering ITEMS in the combo list
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.itemTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboItem>
         *          <div class="custom-item" let-item let-key="valueKey">
         *              <div class="custom-item__name">{{ item[key] }}</div>
         *              <div class="custom-item__cost">{{ item.cost }}</div>
         *          </div>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        _this.itemTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the HEADER for the combo items list
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.headerTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboHeader>
         *          <div class="combo__header">
         *              This is a custom header
         *          </div>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        _this.headerTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the FOOTER for the combo items list
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.footerTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboFooter>
         *          <div class="combo__footer">
         *              This is a custom footer
         *          </div>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        _this.footerTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering HEADER ITEMS for groups in the combo list
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.headerItemTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboHeaderItem let-item let-key="groupKey">
         *          <div class="custom-item--group">Group header for {{ item[key] }}</div>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        _this.headerItemTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the ADD BUTTON in the combo drop down
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.addItemTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboAddItem>
         *          <button class="combo__add-button">
         *              Click to add item
         *          </button>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        _this.addItemTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the ADD BUTTON in the combo drop down
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.emptyTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboEmpty>
         *          <div class="combo--emtpy">
         *              There are no items to display
         *          </div>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        _this.emptyTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the combo TOGGLE(open/close) button
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.toggleIconTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboToggleIcon let-collapsed>
         *          <igx-icon>{{ collapsed ? 'remove_circle' : 'remove_circle_outline'}}</igx-icon>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        _this.toggleIconTemplate = null;
        /**
         * The custom template, if any, that should be used when rendering the combo CLEAR button
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.combo.clearIconTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-combo #combo>
         *      ...
         *      <ng-template igxComboClearIcon>
         *          <igx-icon>clear</igx-icon>
         *      </ng-template>
         *  </igx-combo>
         * ```
         */
        _this.clearIconTemplate = null;
        _this.dropdownContainer = null;
        /**
         * Emitted when item selection is changing, before the selection completes
         *
         * ```html
         * <igx-combo (onSelectionChange)='handleSelection()'></igx-combo>
         * ```
         */
        _this.onSelectionChange = new EventEmitter();
        /**
         * Emitted before the dropdown is opened
         *
         * ```html
         * <igx-combo onOpening='handleOpening($event)'></igx-combo>
         * ```
         */
        _this.onOpening = new EventEmitter();
        /**
         * Emitted after the dropdown is opened
         *
         * ```html
         * <igx-combo (onOpened)='handleOpened()'></igx-combo>
         * ```
         */
        _this.onOpened = new EventEmitter();
        /**
         * Emitted before the dropdown is closed
         *
         * ```html
         * <igx-combo (onClosing)='handleClosing($event)'></igx-combo>
         * ```
         */
        _this.onClosing = new EventEmitter();
        /**
         * Emitted after the dropdown is closed
         *
         * ```html
         * <igx-combo (onClosed)='handleClosed()'></igx-combo>
         * ```
         */
        _this.onClosed = new EventEmitter();
        /**
         * Emitted when an item is being added to the data collection
         *
         * ```html
         * <igx-combo (onAddition)='handleAdditionEvent()'></igx-combo>
         * ```
         */
        _this.onAddition = new EventEmitter();
        /**
         * Emitted when the value of the search input changes (e.g. typing, pasting, clear, etc.)
         *
         * ```html
         * <igx-combo (onSearchInput)='handleSearchInputEvent()'></igx-combo>
         * ```
         */
        _this.onSearchInput = new EventEmitter();
        /**
         * Emitted when new chunk of data is loaded from the virtualization
         *
         * ```html
         * <igx-combo (onDataPreLoad)='handleDataPreloadEvent()'></igx-combo>
         * ```
         */
        _this.onDataPreLoad = new EventEmitter();
        /**
         * Gets/gets combo id.
         *
         * ```typescript
         * // get
         * let id = this.combo.id;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-combo [id]='combo1'></igx-combo>
         * ```
         */
        _this.id = "igx-combo-" + NEXT_ID$j++;
        /**
         * @hidden \@internal
         */
        _this.cssClass = 'igx-combo'; // Independent of display density, at the time being
        // Independent of display density, at the time being
        /**
         * @hidden \@internal
         */
        _this.role = 'combobox';
        /**
         * Controls whether custom values can be added to the collection
         *
         * ```typescript
         * // get
         * let comboAllowsCustomValues = this.combo.allowCustomValues;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-combo [allowCustomValues]='true'></igx-combo>
         * ```
         */
        _this.allowCustomValues = false;
        /**
         * Configures the drop down list height
         *
         * ```typescript
         * // get
         * let myComboItemsMaxHeight = this.combo.itemsMaxHeight;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-combo [itemsMaxHeight]='320'></igx-combo>
         * ```
         */
        _this.itemsMaxHeight = 480;
        /**
         * Configures the drop down list item height
         *
         * ```typescript
         * // get
         * let myComboItemHeight = this.combo.itemHeight;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-combo [itemHeight]='32'></igx-combo>
         * ```
         */
        _this.itemHeight = 48;
        /**
         * @hidden \@internal
         */
        _this.filteringLogic = FilteringLogic.Or;
        /**
         * Defines the placeholder value for the combo value field
         *
         * ```typescript
         * // get
         * let myComboPlaceholder = this.combo.placeholder;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-combo [placeholder]='newPlaceHolder'></igx-combo>
         * ```
         */
        _this.placeholder = '';
        /**
         * Defines the placeholder value for the combo dropdown search field
         *
         * ```typescript
         * // get
         * let myComboSearchPlaceholder = this.combo.searchPlaceholder;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-combo [searchPlaceholder]='newPlaceHolder'></igx-combo>
         * ```
         */
        _this.searchPlaceholder = 'Enter a Search Term';
        /**
         * An \@Input property that enabled/disables filtering in the list. The default is `true`.
         * ```html
         * <igx-combo [filterable]="'false'">
         * ```
         */
        _this.filterable = true;
        /**
         * An \@Input property that enabled/disables combo. The default is `false`.
         * ```html
         * <igx-combo [disabled]="'true'">
         * ```
         */
        _this.disabled = false;
        /**
         * An \@Input property that sets how the combo will be styled.
         * The allowed values are `line`, `box`, `border` and `search`. The default is `box`.
         * ```html
         * <igx-combo [type]="'line'">
         * ```
         */
        _this.type = 'box';
        /**
         * Gets/Sets if control is valid, when used in a form
         *
         * ```typescript
         * // get
         * let valid = this.combo.valid;
         * ```
         * ```typescript
         * // set
         * this.combo.valid = IgxComboState.INVALID;
         * ```
         */
        _this.valid = IgxComboState.INITIAL;
        /**
         * @hidden \@internal
         */
        _this.searchValue = '';
        _this.onStatusChanged = function () {
            if ((_this.ngControl.control.touched || _this.ngControl.control.dirty) &&
                (_this.ngControl.control.validator || _this.ngControl.control.asyncValidator)) {
                _this.valid = _this.ngControl.valid ? IgxComboState.VALID : IgxComboState.INVALID;
            }
        };
        _this.comboAPI.register(_this);
        return _this;
    }
    Object.defineProperty(IgxComboComponent.prototype, "displaySearchInput", {
        /**
         * @hidden @internal
         */
        get: /**
         * @hidden \@internal
         * @return {?}
         */
        function () {
            return this.filterable || this.allowCustomValues;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxComboComponent.prototype, "oldEmptyTemplate", {
        /**
         * @hidden @internal
         */
        set: /**
         * @hidden \@internal
         * @private
         * @param {?} template
         * @return {?}
         */
        function (template) {
            if (template) {
                this.emptyTemplate = template;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxComboComponent.prototype, "oldHeaderTemplate", {
        /**
         * @hidden @internal
         */
        set: /**
         * @hidden \@internal
         * @private
         * @param {?} template
         * @return {?}
         */
        function (template) {
            if (template) {
                this.headerTemplate = template;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxComboComponent.prototype, "oldFooterTemplate", {
        /**
         * @hidden @internal
         */
        set: /**
         * @hidden \@internal
         * @private
         * @param {?} template
         * @return {?}
         */
        function (template) {
            if (template) {
                this.footerTemplate = template;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxComboComponent.prototype, "oldItemTemplate", {
        /**
         * @hidden @internal
         */
        set: /**
         * @hidden \@internal
         * @private
         * @param {?} template
         * @return {?}
         */
        function (template) {
            if (template) {
                this.itemTemplate = template;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxComboComponent.prototype, "oldAddItemTemplate", {
        /**
         * @hidden @internal
         */
        set: /**
         * @hidden \@internal
         * @private
         * @param {?} template
         * @return {?}
         */
        function (template) {
            if (template) {
                this.addItemTemplate = template;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxComboComponent.prototype, "oldHeaderItemTemplate", {
        /**
         * @hidden @internal
         */
        set: /**
         * @hidden \@internal
         * @private
         * @param {?} template
         * @return {?}
         */
        function (template) {
            if (template) {
                this.headerItemTemplate = template;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxComboComponent.prototype, "validClass", {
        /**
         * @hidden @internal
         */
        get: /**
         * @hidden \@internal
         * @return {?}
         */
        function () {
            return this.valid === IgxComboState.VALID;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxComboComponent.prototype, "invalidClass", {
        /**
         * @hidden @internal
         */
        get: /**
         * @hidden \@internal
         * @return {?}
         */
        function () {
            return this.valid === IgxComboState.INVALID;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxComboComponent.prototype, "ariaExpanded", {
        /**
         * @hidden @internal
         */
        get: /**
         * @hidden \@internal
         * @return {?}
         */
        function () {
            return !this.dropdown.collapsed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxComboComponent.prototype, "hasPopUp", {
        /**
         * @hidden @internal
         */
        get: /**
         * @hidden \@internal
         * @return {?}
         */
        function () {
            return 'listbox';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxComboComponent.prototype, "ariaOwns", {
        /**
         * @hidden @internal
         */
        get: /**
         * @hidden \@internal
         * @return {?}
         */
        function () {
            return this.dropdown.id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxComboComponent.prototype, "inputEmpty", {
        /**
         * @hidden @internal
         */
        get: /**
         * @hidden \@internal
         * @return {?}
         */
        function () {
            return !this.value && !this.placeholder;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxComboComponent.prototype, "data", {
        /**
         * Combo data source.
         *
         * ```html
         * <!--set-->
         * <igx-combo [data]='items'></igx-combo>
         * ```
         */
        get: /**
         * Combo data source.
         *
         * ```html
         * <!--set-->
         * <igx-combo [data]='items'></igx-combo>
         * ```
         * @return {?}
         */
        function () {
            return this._data;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._data = (val) ? val : [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxComboComponent.prototype, "displayKey", {
        /**
         * Combo text data source propery.
         *
         * ```typescript
         * // get
         * let myComboDisplayKey = this.combo.displayKey;
         *
         * // set
         * this.combo.displayKey = 'val';
         *
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-combo [displayKey]='mydisplayKey'></igx-combo>
         * ```
         */
        get: /**
         * Combo text data source propery.
         *
         * ```typescript
         * // get
         * let myComboDisplayKey = this.combo.displayKey;
         *
         * // set
         * this.combo.displayKey = 'val';
         *
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-combo [displayKey]='mydisplayKey'></igx-combo>
         * ```
         * @return {?}
         */
        function () {
            return this._displayKey ? this._displayKey : this.valueKey;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._displayKey = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxComboComponent.prototype, "groupKey", {
        /**
         * The item property by which items should be grouped inside the items list. Not usable if data is not of type Object[].
         *
         * ```typescript
         * // get
         * let currentGroupKey = this.combo.groupKey;
         * ```
         */
        get: /**
         * The item property by which items should be grouped inside the items list. Not usable if data is not of type Object[].
         *
         * ```typescript
         * // get
         * let currentGroupKey = this.combo.groupKey;
         * ```
         * @return {?}
         */
        function () {
            return this._groupKey;
        },
        /**
         * The item property by which items should be grouped inside the items list. Not usable if data is not of type Object[].
         *
         * ```html
         * <!--set-->
         * <igx-combo [groupKey]='newGroupKey'></igx-combo>
         * ```
         */
        set: /**
         * The item property by which items should be grouped inside the items list. Not usable if data is not of type Object[].
         *
         * ```html
         * <!--set-->
         * <igx-combo [groupKey]='newGroupKey'></igx-combo>
         * ```
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this.clearSorting(this._groupKey);
            this._groupKey = val;
            this.sort(this._groupKey);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    IgxComboComponent.prototype.onArrowDown = /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        event.stopPropagation();
        this.open();
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    IgxComboComponent.prototype.onInputClick = /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.stopPropagation();
        event.preventDefault();
        this.toggle();
    };
    Object.defineProperty(IgxComboComponent.prototype, "virtualizationState", {
        /**
         * Defines the current state of the virtualized data. It contains `startIndex` and `chunkSize`
         *
         * ```typescript
         * // get
         * let state = this.combo.virtualizationState;
         * ```
        */
        get: /**
         * Defines the current state of the virtualized data. It contains `startIndex` and `chunkSize`
         *
         * ```typescript
         * // get
         * let state = this.combo.virtualizationState;
         * ```
         * @return {?}
         */
        function () {
            return this.virtDir.state;
        },
        /**
         * Sets the current state of the virtualized data.
         *
         * ```typescript
         * // set
         * this.combo.virtualizationState(state);
         * ```
         */
        set: /**
         * Sets the current state of the virtualized data.
         *
         * ```typescript
         * // set
         * this.combo.virtualizationState(state);
         * ```
         * @param {?} state
         * @return {?}
         */
        function (state$$1) {
            this.virtDir.state = state$$1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxComboComponent.prototype, "totalItemCount", {
        /**
         * Gets total count of the virtual data items, when using remote service.
         *
         * ```typescript
         * // get
         * let count = this.combo.totalItemCount;
         * ```
        */
        get: /**
         * Gets total count of the virtual data items, when using remote service.
         *
         * ```typescript
         * // get
         * let count = this.combo.totalItemCount;
         * ```
         * @return {?}
         */
        function () {
            return this.virtDir.totalItemCount;
        },
        /**
         * Sets total count of the virtual data items, when using remote service.
         *
         * ```typescript
         * // set
         * this.combo.totalItemCount(remoteService.count);
         * ```
         */
        set: /**
         * Sets total count of the virtual data items, when using remote service.
         *
         * ```typescript
         * // set
         * this.combo.totalItemCount(remoteService.count);
         * ```
         * @param {?} count
         * @return {?}
         */
        function (count) {
            this.virtDir.totalItemCount = count;
            this.cdr.detectChanges();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxComboComponent.prototype, "filteringExpressions", {
        /**
         * @hidden @internal
         */
        get: /**
         * @hidden \@internal
         * @return {?}
         */
        function () {
            return this.filterable ? this._filteringExpressions : [];
        },
        /**
         * @hidden @internal
         */
        set: /**
         * @hidden \@internal
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._filteringExpressions = value;
            this.cdr.markForCheck();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxComboComponent.prototype, "sortingExpressions", {
        /**
         * @hidden @internal
         */
        get: /**
         * @hidden \@internal
         * @return {?}
         */
        function () {
            return this._sortingExpressions;
        },
        /**
         * @hidden @internal
         */
        set: /**
         * @hidden \@internal
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._sortingExpressions = value;
            this.cdr.markForCheck();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @protected
     * @param {?=} field
     * @return {?}
     */
    IgxComboComponent.prototype.clearSorting = /**
     * @protected
     * @param {?=} field
     * @return {?}
     */
    function (field) {
        if (field === undefined || field === null) {
            this.sortingExpressions = [];
            return;
        }
        /** @type {?} */
        var currentState = cloneArray(this.sortingExpressions);
        /** @type {?} */
        var index = currentState.findIndex(function (expr) { return expr.fieldName === field; });
        if (index > -1) {
            currentState.splice(index, 1);
            this.sortingExpressions = currentState;
        }
    };
    Object.defineProperty(IgxComboComponent.prototype, "value", {
        /**
         * The text displayed in the combo input
         *
         * ```typescript
         * // get
         * let comboValue = this.combo.value;
         * ```
         */
        get: /**
         * The text displayed in the combo input
         *
         * ```typescript
         * // get
         * let comboValue = this.combo.value;
         * ```
         * @return {?}
         */
        function () {
            return this._value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxComboComponent.prototype, "filteredData", {
        /**
         * @hidden @internal
         */
        get: /**
         * @hidden \@internal
         * @return {?}
         */
        function () {
            return this.filterable ? this._filteredData : this.data;
        },
        /**
         * @hidden @internal
         */
        set: /**
         * @hidden \@internal
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._filteredData = this.groupKey ? (val || []).filter(function (e) { return e.isHeader !== true; }) : val;
            this.checkMatch();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    IgxComboComponent.prototype.handleKeyUp = /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.key === 'ArrowDown' || event.key === 'Down') {
            this.dropdown.focusedItem = this.dropdown.items[0];
            this.dropdownContainer.nativeElement.focus();
        }
        else if (event.key === 'Escape' || event.key === 'Esc') {
            this.toggle();
        }
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    IgxComboComponent.prototype.handleKeyDown = /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.key === 'ArrowUp' || event.key === 'Up') {
            event.preventDefault();
            event.stopPropagation();
            this.close();
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxComboComponent.prototype.checkMatch = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var displayKey = this.displayKey;
        /** @type {?} */
        var matchFn = function (e) {
            /** @type {?} */
            var value = displayKey ? e[displayKey] : e;
            return value.toString().toLowerCase() === _this.searchValue.trim().toLowerCase();
        };
        /** @type {?} */
        var itemMatch = this.filteredData.some(matchFn);
        this.customValueFlag = this.allowCustomValues && !itemMatch;
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @param {?=} event
     * @return {?}
     */
    IgxComboComponent.prototype.handleInputChange = /**
     * @hidden \@internal
     * @param {?=} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        /** @type {?} */
        var cdrFlag = false;
        /** @type {?} */
        var vContainer = this.virtDir;
        if (event !== undefined && this._prevInputValue === event) {
            // Nothing has changed
            return;
        }
        else {
            this._prevInputValue = event !== undefined ? event : '';
        }
        if (event !== undefined) {
            // Do not scroll if not scrollable
            if (vContainer.isScrollable()) {
                vContainer.scrollTo(0);
            }
            else {
                cdrFlag = true;
            }
            this.onSearchInput.emit(event);
        }
        else {
            cdrFlag = true;
        }
        if (this.filterable) {
            this.filter();
            // If there was no scroll before filtering, check if there is after and detect changes
            if (cdrFlag) {
                vContainer.onChunkLoad.pipe(take(1)).subscribe(function () {
                    if (vContainer.isScrollable()) {
                        _this.cdr.detectChanges();
                    }
                });
            }
        }
        else {
            this.checkMatch();
        }
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @param {?} fieldName
     * @param {?=} dir
     * @param {?=} ignoreCase
     * @param {?=} strategy
     * @return {?}
     */
    IgxComboComponent.prototype.sort = /**
     * @hidden \@internal
     * @param {?} fieldName
     * @param {?=} dir
     * @param {?=} ignoreCase
     * @param {?=} strategy
     * @return {?}
     */
    function (fieldName, dir, ignoreCase, strategy) {
        if (dir === void 0) { dir = SortingDirection.Asc; }
        if (ignoreCase === void 0) { ignoreCase = true; }
        if (strategy === void 0) { strategy = DefaultSortingStrategy.instance(); }
        if (!fieldName) {
            return;
        }
        /** @type {?} */
        var sortingState = cloneArray(this.sortingExpressions, true);
        this.prepare_sorting_expression(sortingState, fieldName, dir, ignoreCase, strategy);
        this.sortingExpressions = sortingState;
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @param {?} val
     * @return {?}
     */
    IgxComboComponent.prototype.getValueByValueKey = /**
     * @hidden \@internal
     * @param {?} val
     * @return {?}
     */
    function (val) {
        var _this = this;
        if (!val && val !== 0) {
            return undefined;
        }
        return this.valueKey ?
            this.data.filter(function (e) { return e[_this.valueKey] === val; })[0] :
            this.data.filter(function (e) { return e === val; });
    };
    /**
     * @protected
     * @param {?} state
     * @param {?} fieldName
     * @param {?} dir
     * @param {?} ignoreCase
     * @param {?} strategy
     * @return {?}
     */
    IgxComboComponent.prototype.prepare_sorting_expression = /**
     * @protected
     * @param {?} state
     * @param {?} fieldName
     * @param {?} dir
     * @param {?} ignoreCase
     * @param {?} strategy
     * @return {?}
     */
    function (state$$1, fieldName, dir, ignoreCase, strategy) {
        if (dir === SortingDirection.None) {
            state$$1.splice(state$$1.findIndex(function (expr) { return expr.fieldName === fieldName; }), 1);
            return;
        }
        /** @type {?} */
        var expression = state$$1.find(function (expr) { return expr.fieldName === fieldName; });
        if (!expression) {
            state$$1.push({ fieldName: fieldName, dir: dir, ignoreCase: ignoreCase, strategy: strategy });
        }
        else {
            Object.assign(expression, { fieldName: fieldName, dir: dir, ignoreCase: ignoreCase });
        }
    };
    Object.defineProperty(IgxComboComponent.prototype, "dataType", {
        /**
         * @hidden @internal
         */
        get: /**
         * @hidden \@internal
         * @return {?}
         */
        function () {
            if (this.valueKey) {
                return DataTypes.COMPLEX;
            }
            return DataTypes.PRIMITIVE;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxComboComponent.prototype, "isRemote", {
        /**
         * @hidden @internal
         */
        get: /**
         * @hidden \@internal
         * @return {?}
         */
        function () {
            return this.totalItemCount > 0 &&
                this.valueKey &&
                this.dataType === DataTypes.COMPLEX;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * If the data source is remote, returns JSON.stringify(itemID)
     * @hidden
     * @internal
     */
    /**
     * If the data source is remote, returns JSON.stringify(itemID)
     * @hidden
     * \@internal
     * @private
     * @param {?} itemID
     * @return {?}
     */
    IgxComboComponent.prototype._stringifyItemID = /**
     * If the data source is remote, returns JSON.stringify(itemID)
     * @hidden
     * \@internal
     * @private
     * @param {?} itemID
     * @return {?}
     */
    function (itemID) {
        return this.isRemote && typeof itemID === 'object' ? JSON.stringify(itemID) : itemID;
    };
    /**
     * @private
     * @param {?} itemID
     * @return {?}
     */
    IgxComboComponent.prototype._parseItemID = /**
     * @private
     * @param {?} itemID
     * @return {?}
     */
    function (itemID) {
        return this.isRemote && typeof itemID === 'string' ? JSON.parse(itemID) : itemID;
    };
    /**
     * Returns if the specified itemID is selected
     * @hidden
     * @internal
     */
    /**
     * Returns if the specified itemID is selected
     * @hidden
     * \@internal
     * @param {?} item
     * @return {?}
     */
    IgxComboComponent.prototype.isItemSelected = /**
     * Returns if the specified itemID is selected
     * @hidden
     * \@internal
     * @param {?} item
     * @return {?}
     */
    function (item) {
        return this.selection.is_item_selected(this.id, this._stringifyItemID(item));
    };
    /**
     * Triggers change detection on the combo view
     */
    /**
     * Triggers change detection on the combo view
     * @return {?}
     */
    IgxComboComponent.prototype.triggerCheck = /**
     * Triggers change detection on the combo view
     * @return {?}
     */
    function () {
        this.cdr.detectChanges();
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @return {?}
     */
    IgxComboComponent.prototype.isAddButtonVisible = /**
     * @hidden \@internal
     * @return {?}
     */
    function () {
        // This should always return a boolean value. If this.searchValue was '', it returns '' instead of false;
        return this.searchValue !== '' && this.customValueFlag;
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @param {?} evt
     * @return {?}
     */
    IgxComboComponent.prototype.handleSelectAll = /**
     * @hidden \@internal
     * @param {?} evt
     * @return {?}
     */
    function (evt) {
        if (evt.checked) {
            this.selectAllItems();
        }
        else {
            this.deselectAllItems();
        }
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @return {?}
     */
    IgxComboComponent.prototype.addItemToCollection = /**
     * @hidden \@internal
     * @return {?}
     */
    function () {
        var _a, _b;
        if (!this.searchValue) {
            return;
        }
        /** @type {?} */
        var newValue = this.searchValue.trim();
        /** @type {?} */
        var addedItem = this.displayKey ? (_a = {},
            _a[this.valueKey] = newValue,
            _a[this.displayKey] = newValue,
            _a) : newValue;
        if (this.groupKey) {
            Object.assign(addedItem, (_b = {}, _b[this.groupKey] = this.defaultFallbackGroup, _b));
        }
        /** @type {?} */
        var oldCollection = this.data;
        /** @type {?} */
        var newCollection = __spread(this.data);
        newCollection.push(addedItem);
        /** @type {?} */
        var args = {
            oldCollection: oldCollection, addedItem: addedItem, newCollection: newCollection
        };
        this.onAddition.emit(args);
        this.data.push(addedItem);
        // If you mutate the array, no pipe is invoked and the display isn't updated;
        // if you replace the array, the pipe executes and the display is updated.
        this.data = cloneArray(this.data);
        this.selectItems([addedItem], false);
        this.customValueFlag = false;
        this.searchInput.nativeElement.focus();
        this.dropdown.focusedItem = null;
        this.handleInputChange();
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @param {?=} opening
     * @return {?}
     */
    IgxComboComponent.prototype.focusSearchInput = /**
     * @hidden \@internal
     * @param {?=} opening
     * @return {?}
     */
    function (opening) {
        if (this.displaySearchInput && this.searchInput) {
            this.searchInput.nativeElement.focus();
        }
        else {
            if (opening) {
                this.dropdownContainer.nativeElement.focus();
            }
            else {
                this.comboInput.nativeElement.focus();
                this.toggle();
            }
        }
    };
    /**
     * @protected
     * @param {?} searchVal
     * @param {?} condition
     * @param {?} ignoreCase
     * @param {?=} fieldName
     * @return {?}
     */
    IgxComboComponent.prototype.prepare_filtering_expression = /**
     * @protected
     * @param {?} searchVal
     * @param {?} condition
     * @param {?} ignoreCase
     * @param {?=} fieldName
     * @return {?}
     */
    function (searchVal, condition, ignoreCase, fieldName) {
        /** @type {?} */
        var newArray = __spread(this.filteringExpressions);
        /** @type {?} */
        var expression = newArray.find(function (expr) { return expr.fieldName === fieldName; });
        /** @type {?} */
        var newExpression = { fieldName: fieldName, searchVal: searchVal, condition: condition, ignoreCase: ignoreCase };
        if (!expression) {
            newArray.push(newExpression);
        }
        else {
            Object.assign(expression, newExpression);
        }
        if (this.groupKey) {
            /** @type {?} */
            var expression2 = newArray.find(function (expr) { return expr.fieldName === 'isHeader'; });
            /** @type {?} */
            var headerExpression = {
                fieldName: 'isHeader', searchVale: '',
                condition: IgxBooleanFilteringOperand.instance().condition('true'), ignoreCase: true
            };
            if (!expression2) {
                newArray.push(headerExpression);
            }
            else {
                Object.assign(expression2, headerExpression);
            }
        }
        this.filteringExpressions = newArray;
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @return {?}
     */
    IgxComboComponent.prototype.onBlur = /**
     * @hidden \@internal
     * @return {?}
     */
    function () {
        if (this.collapsed) {
            if (this.ngControl && !this.ngControl.valid) {
                this.valid = IgxComboState.INVALID;
            }
            else {
                this.valid = IgxComboState.INITIAL;
            }
        }
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @return {?}
     */
    IgxComboComponent.prototype.filter = /**
     * @hidden \@internal
     * @return {?}
     */
    function () {
        this.prepare_filtering_expression(this.searchValue.trim(), IgxStringFilteringOperand.instance().condition('contains'), true, this.dataType === DataTypes.PRIMITIVE ? undefined : this.displayKey);
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @return {?}
     */
    IgxComboComponent.prototype.ngOnInit = /**
     * @hidden \@internal
     * @return {?}
     */
    function () {
        var _this = this;
        this.ngControl = this.injector.get(NgControl, null);
        this._positionCallback = function () { return _this.dropdown.updateScrollPosition(); };
        this.overlaySettings.positionStrategy = new ComboConnectedPositionStrategy(this._positionCallback);
        this.overlaySettings.positionStrategy.settings.target = this.elementRef.nativeElement;
        this.selection.set(this.id, new Set());
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @return {?}
     */
    IgxComboComponent.prototype.ngAfterViewInit = /**
     * @hidden \@internal
     * @return {?}
     */
    function () {
        this.filteredData = __spread(this.data);
        if (this.ngControl) {
            this.ngControl.statusChanges.pipe(takeUntil(this.destroy$)).subscribe(this.onStatusChanged);
        }
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @return {?}
     */
    IgxComboComponent.prototype.ngOnDestroy = /**
     * @hidden \@internal
     * @return {?}
     */
    function () {
        this.destroy$.next();
        this.destroy$.complete();
        this.comboAPI.clear();
        this.selection.clear(this.id);
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    IgxComboComponent.prototype.dataLoading = /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onDataPreLoad.emit(event);
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @param {?} value
     * @return {?}
     */
    IgxComboComponent.prototype.writeValue = /**
     * @hidden \@internal
     * @param {?} value
     * @return {?}
     */
    function (value) {
        // selectItems can handle Array<any>, no valueKey is needed;
        this.selectItems(value, true);
        this.cdr.markForCheck();
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @param {?} fn
     * @return {?}
     */
    IgxComboComponent.prototype.registerOnChange = /**
     * @hidden \@internal
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._onChangeCallback = fn;
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @param {?} fn
     * @return {?}
     */
    IgxComboComponent.prototype.registerOnTouched = /**
     * @hidden \@internal
     * @param {?} fn
     * @return {?}
     */
    function (fn) { };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @param {?} isDisabled
     * @return {?}
     */
    IgxComboComponent.prototype.setDisabledState = /**
     * @hidden \@internal
     * @param {?} isDisabled
     * @return {?}
     */
    function (isDisabled) {
        this.disabled = isDisabled;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxComboComponent.prototype.getEditElement = /**
     * @hidden
     * @return {?}
     */
    function () {
        return this.comboInput.nativeElement;
    };
    Object.defineProperty(IgxComboComponent.prototype, "template", {
        /**
         * @hidden @internal
         */
        get: /**
         * @hidden \@internal
         * @return {?}
         */
        function () {
            this._dataType = this.dataType;
            if (this.itemTemplate) {
                return this.itemTemplate;
            }
            if (this._dataType === DataTypes.COMPLEX) {
                return this.complexTemplate;
            }
            return this.primitiveTemplate;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxComboComponent.prototype, "context", {
        /**
         * @hidden @internal
         */
        get: /**
         * @hidden \@internal
         * @return {?}
         */
        function () {
            return {
                $implicit: this
            };
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    IgxComboComponent.prototype.handleClearItems = /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.deselectAllItems(true, event);
        event.stopPropagation();
    };
    /**
     * A method that opens/closes the combo.
     *
     *```html
     *<button (click)="combo.toggle()">Toggle Combo</button>
     *<igx-combo #combo></igx-combo>
     *```
     */
    /**
     * A method that opens/closes the combo.
     *
     * ```html
     * <button (click)="combo.toggle()">Toggle Combo</button>
     * <igx-combo #combo></igx-combo>
     * ```
     * @return {?}
     */
    IgxComboComponent.prototype.toggle = /**
     * A method that opens/closes the combo.
     *
     * ```html
     * <button (click)="combo.toggle()">Toggle Combo</button>
     * <igx-combo #combo></igx-combo>
     * ```
     * @return {?}
     */
    function () {
        this.dropdown.toggle(this.overlaySettings);
    };
    /**
     * A method that opens the combo.
     *
     *```html
     *<button (click)="combo.open()">Open Combo</button>
     *<igx-combo #combo></igx-combo>
     *```
     */
    /**
     * A method that opens the combo.
     *
     * ```html
     * <button (click)="combo.open()">Open Combo</button>
     * <igx-combo #combo></igx-combo>
     * ```
     * @return {?}
     */
    IgxComboComponent.prototype.open = /**
     * A method that opens the combo.
     *
     * ```html
     * <button (click)="combo.open()">Open Combo</button>
     * <igx-combo #combo></igx-combo>
     * ```
     * @return {?}
     */
    function () {
        this.dropdown.open(this.overlaySettings);
    };
    /**
     * A method that closes the combo.
     *
     *```html
     *<button (click)="combo.close()">Close Combo</button>
     *<igx-combo #combo></igx-combo>
     *```
     */
    /**
     * A method that closes the combo.
     *
     * ```html
     * <button (click)="combo.close()">Close Combo</button>
     * <igx-combo #combo></igx-combo>
     * ```
     * @return {?}
     */
    IgxComboComponent.prototype.close = /**
     * A method that closes the combo.
     *
     * ```html
     * <button (click)="combo.close()">Close Combo</button>
     * <igx-combo #combo></igx-combo>
     * ```
     * @return {?}
     */
    function () {
        this.dropdown.close();
    };
    Object.defineProperty(IgxComboComponent.prototype, "collapsed", {
        /**
         * Gets drop down state.
         *
         * ```typescript
         * let state = this.combo.collapsed;
         * ```
        */
        get: /**
         * Gets drop down state.
         *
         * ```typescript
         * let state = this.combo.collapsed;
         * ```
         * @return {?}
         */
        function () {
            return this.dropdown.collapsed;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Get current selection state
     * @returns Array of selected items
     * ```typescript
     * let selectedItems = this.combo.selectedItems();
     * ```
     */
    /**
     * Get current selection state
     * @return {?} Array of selected items
     * ```typescript
     * let selectedItems = this.combo.selectedItems();
     * ```
     */
    IgxComboComponent.prototype.selectedItems = /**
     * Get current selection state
     * @return {?} Array of selected items
     * ```typescript
     * let selectedItems = this.combo.selectedItems();
     * ```
     */
    function () {
        var _this = this;
        /** @type {?} */
        var items = Array.from(this.selection.get(this.id));
        return this.isRemote ? items.map(function (item) { return _this._parseItemID(item); }) : items;
    };
    /**
     * Select defined items
     * @param newItems new items to be selected
     * @param clearCurrentSelection if true clear previous selected items
     * ```typescript
     * this.combo.selectItems(["New York", "New Jersey"]);
     * ```
     */
    /**
     * Select defined items
     * @param {?} newItems new items to be selected
     * @param {?=} clearCurrentSelection if true clear previous selected items
     * ```typescript
     * this.combo.selectItems(["New York", "New Jersey"]);
     * ```
     * @param {?=} event
     * @return {?}
     */
    IgxComboComponent.prototype.selectItems = /**
     * Select defined items
     * @param {?} newItems new items to be selected
     * @param {?=} clearCurrentSelection if true clear previous selected items
     * ```typescript
     * this.combo.selectItems(["New York", "New Jersey"]);
     * ```
     * @param {?=} event
     * @return {?}
     */
    function (newItems, clearCurrentSelection, event) {
        if (newItems) {
            /** @type {?} */
            var newSelection = this.selection.add_items(this.id, newItems, clearCurrentSelection);
            this.setSelection(newSelection, event);
        }
    };
    /**
     * Deselect defined items
     * @param items items to deselected
     * ```typescript
     * this.combo.deselectItems(["New York", "New Jersey"]);
     * ```
     */
    /**
     * Deselect defined items
     * @param {?} items items to deselected
     * ```typescript
     * this.combo.deselectItems(["New York", "New Jersey"]);
     * ```
     * @param {?=} event
     * @return {?}
     */
    IgxComboComponent.prototype.deselectItems = /**
     * Deselect defined items
     * @param {?} items items to deselected
     * ```typescript
     * this.combo.deselectItems(["New York", "New Jersey"]);
     * ```
     * @param {?=} event
     * @return {?}
     */
    function (items, event) {
        if (items) {
            /** @type {?} */
            var newSelection = this.selection.delete_items(this.id, items);
            this.setSelection(newSelection, event);
        }
    };
    /**
     * Select all (filtered) items
     * @param ignoreFilter if set to true, selects all items, otherwise selects only the filtered ones.
     * ```typescript
     * this.combo.selectAllItems();
     * ```
     */
    /**
     * Select all (filtered) items
     * @param {?=} ignoreFilter if set to true, selects all items, otherwise selects only the filtered ones.
     * ```typescript
     * this.combo.selectAllItems();
     * ```
     * @param {?=} event
     * @return {?}
     */
    IgxComboComponent.prototype.selectAllItems = /**
     * Select all (filtered) items
     * @param {?=} ignoreFilter if set to true, selects all items, otherwise selects only the filtered ones.
     * ```typescript
     * this.combo.selectAllItems();
     * ```
     * @param {?=} event
     * @return {?}
     */
    function (ignoreFilter, event) {
        /** @type {?} */
        var allVisible = this.selection.get_all_ids(ignoreFilter ? this.data : this.filteredData);
        /** @type {?} */
        var newSelection = this.selection.add_items(this.id, allVisible);
        this.setSelection(newSelection, event);
    };
    /**
     * Deselect all (filtered) items
     * @param ignoreFilter if set to true, deselects all items, otherwise deselects only the filtered ones.
     * ```typescript
     * this.combo.deselectAllItems();
     * ```
     */
    /**
     * Deselect all (filtered) items
     * @param {?=} ignoreFilter if set to true, deselects all items, otherwise deselects only the filtered ones.
     * ```typescript
     * this.combo.deselectAllItems();
     * ```
     * @param {?=} event
     * @return {?}
     */
    IgxComboComponent.prototype.deselectAllItems = /**
     * Deselect all (filtered) items
     * @param {?=} ignoreFilter if set to true, deselects all items, otherwise deselects only the filtered ones.
     * ```typescript
     * this.combo.deselectAllItems();
     * ```
     * @param {?=} event
     * @return {?}
     */
    function (ignoreFilter, event) {
        /** @type {?} */
        var newSelection = this.selection.get_empty();
        if (this.filteredData.length !== this.data.length && !ignoreFilter) {
            newSelection = this.selection.delete_items(this.id, this.selection.get_all_ids(this.filteredData));
        }
        this.setSelection(newSelection, event);
    };
    /**
     * Selects/Deselects an item using it's valueKey value
     * @param itemID the valueKey of the specified item
     * @param select If the item should be selected (true) or deselcted (false)
     *
     * ```typescript
     * items: { field: string, region: string}[] = data;
     * this.combo.setSelectedItem('Connecticut', true);
     * // combo.valueKey === 'field'
     * // items[n] === { field: 'Connecticut', state: 'New England'}
     * ```
     */
    /**
     * Selects/Deselects an item using it's valueKey value
     * @param {?} itemID the valueKey of the specified item
     * @param {?=} select If the item should be selected (true) or deselcted (false)
     *
     * ```typescript
     * items: { field: string, region: string}[] = data;
     * this.combo.setSelectedItem('Connecticut', true);
     * // combo.valueKey === 'field'
     * // items[n] === { field: 'Connecticut', state: 'New England'}
     * ```
     * @param {?=} event
     * @return {?}
     */
    IgxComboComponent.prototype.setSelectedItem = /**
     * Selects/Deselects an item using it's valueKey value
     * @param {?} itemID the valueKey of the specified item
     * @param {?=} select If the item should be selected (true) or deselcted (false)
     *
     * ```typescript
     * items: { field: string, region: string}[] = data;
     * this.combo.setSelectedItem('Connecticut', true);
     * // combo.valueKey === 'field'
     * // items[n] === { field: 'Connecticut', state: 'New England'}
     * ```
     * @param {?=} event
     * @return {?}
     */
    function (itemID, select, event) {
        if (select === void 0) { select = true; }
        if (itemID === null || itemID === undefined) {
            return;
        }
        /** @type {?} */
        var itemValue = this.getValueByValueKey(itemID);
        if (itemValue !== null && itemValue !== undefined) {
            if (select) {
                this.selectItems([itemValue], false, event);
            }
            else {
                this.deselectItems([itemValue], event);
            }
        }
    };
    /**
     * @protected
     * @param {?} newSelection
     * @param {?=} event
     * @return {?}
     */
    IgxComboComponent.prototype.setSelection = /**
     * @protected
     * @param {?} newSelection
     * @param {?=} event
     * @return {?}
     */
    function (newSelection, event) {
        var _this = this;
        /** @type {?} */
        var oldSelectionEmit = Array.from(this.selection.get(this.id) || []);
        /** @type {?} */
        var newSelectionEmit = Array.from(newSelection || []);
        /** @type {?} */
        var args = {
            newSelection: newSelectionEmit,
            oldSelection: oldSelectionEmit,
            event: event,
            cancel: false
        };
        this.onSelectionChange.emit(args);
        if (!args.cancel) {
            this.selection.select_items(this.id, args.newSelection, true);
            this._value = this.dataType !== DataTypes.PRIMITIVE ?
                args.newSelection.map(function (id) { return _this._parseItemID(id)[_this.displayKey]; }).join(', ') :
                args.newSelection.join(', ');
            this._onChangeCallback(args.newSelection);
        }
    };
    /**
     * Event handlers
     * @hidden
     * @internal
     */
    /**
     * Event handlers
     * @hidden
     * \@internal
     * @param {?} event
     * @return {?}
     */
    IgxComboComponent.prototype.handleOpening = /**
     * Event handlers
     * @hidden
     * \@internal
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onOpening.emit(event);
        if (event.cancel) {
            return;
        }
        this.handleInputChange();
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @return {?}
     */
    IgxComboComponent.prototype.handleOpened = /**
     * @hidden \@internal
     * @return {?}
     */
    function () {
        this.triggerCheck();
        this.focusSearchInput(true);
        this.onOpened.emit();
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    IgxComboComponent.prototype.handleClosing = /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onClosing.emit(event);
        if (event.cancel) {
            return;
        }
        this.searchValue = '';
    };
    /**
     * @hidden @internal
     */
    /**
     * @hidden \@internal
     * @return {?}
     */
    IgxComboComponent.prototype.handleClosed = /**
     * @hidden \@internal
     * @return {?}
     */
    function () {
        this.comboInput.nativeElement.focus();
        this.onClosed.emit();
    };
    IgxComboComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-combo',
                    template: "<ng-template #complex let-display let-data=\"data\" let-key=\"displayKey\">\n    {{display[key]}}\n</ng-template>\n<ng-template #primitive let-display>\n    {{display}}\n</ng-template>\n<ng-template #empty>\n    <span>The list is empty</span>\n</ng-template>\n<ng-template #addItemDefault let-control>\n    <button igxButton=\"flat\" igxRipple>Add item</button>\n</ng-template>\n<ng-template #headerItemBase let-item let-key=\"valueKey\" let-groupKey=\"groupKey\">\n    {{ item[key] }}\n</ng-template>\n\n<igx-input-group [displayDensity]=\"displayDensity\" [type]=\"type\" (click)=\"onInputClick($event)\">\n    <ng-container ngProjectAs=\"[igxLabel]\">\n        <ng-content select=\"[igxLabel]\"></ng-content>\n    </ng-container>\n    <ng-container ngProjectAs=\"igx-prefix\">\n        <ng-content select=\"igx-prefix\"></ng-content>\n    </ng-container>\n    <ng-container ngProjectAs=\"igx-hint, [igxHint]\">\n            <ng-content select=\"igx-hint, [igxHint]\"></ng-content>\n        </ng-container>\n    <input igxInput #comboInput name=\"comboInput\" type=\"text\" [value]=\"value\" readonly [placeholder]=\"placeholder\"\n        [disabled]=\"disabled\" (blur)=\"onBlur()\" />\n    <ng-container ngProjectAs=\"igx-suffix\">\n        <ng-content select=\"igx-suffix\"></ng-content>\n    </ng-container>\n    <igx-suffix *ngIf=\"value.length\" aria-label=\"Clear Selection\" class=\"igx-combo__clear-button\" igxRipple (click)=\"handleClearItems($event)\">\n        <ng-container *ngIf=\"clearIconTemplate\">\n            <ng-container *ngTemplateOutlet=\"clearIconTemplate\"></ng-container>\n        </ng-container>\n        <igx-icon *ngIf=\"!clearIconTemplate\" fontSet=\"material\">clear</igx-icon>\n    </igx-suffix>\n    <igx-suffix igxButton=\"icon\" class=\"igx-combo__toggle-button\" igxRipple>\n        <ng-container *ngIf=\"toggleIconTemplate\">\n            <ng-container *ngTemplateOutlet=\"toggleIconTemplate; context: {$implicit: this.collapsed}\"></ng-container>\n        </ng-container>\n        <igx-icon *ngIf=\"!toggleIconTemplate\" fontSet=\"material\">{{ dropdown.collapsed ? 'arrow_drop_down' : 'arrow_drop_up'}}</igx-icon>\n    </igx-suffix>\n</igx-input-group>\n<igx-combo-drop-down #igxComboDropDown class=\"igx-combo__drop-down\" [width]=\"itemsWidth || '100%'\" (onOpening)=\"handleOpening($event)\"\n    (onClosing)=\"handleClosing($event)\" (onOpened)=\"handleOpened()\" (onClosed)=\"handleClosed()\">\n    <igx-input-group *ngIf=\"displaySearchInput\" [displayDensity]=\"displayDensity\" class=\"igx-combo__search\">\n        <input class=\"igx-combo-input\" igxInput #searchInput name=\"searchInput\" autocomplete=\"off\" type=\"text\"\n            [(ngModel)]=\"searchValue\" (ngModelChange)=\"handleInputChange($event)\" (keyup)=\"handleKeyUp($event)\"\n            (keydown)=\"handleKeyDown($event)\" (focus)=\"dropdown.onBlur($event)\" [placeholder]=\"searchPlaceholder\"\n            aria-autocomplete=\"both\" [attr.aria-owns]=\"dropdown.id\" [attr.aria-labelledby]=\"ariaLabelledBy\" />\n    </igx-input-group>\n    <ng-container *ngTemplateOutlet=\"headerTemplate\">\n    </ng-container>\n    <div #dropdownItemContainer class=\"igx-combo__content\" [style.overflow]=\"'hidden'\" [style.maxHeight.px]=\"itemsMaxHeight\"\n        [igxDropDownItemNavigation]=\"dropdown\" (focus)=\"dropdown.onFocus()\" [tabindex]=\"dropdown.collapsed ? -1 : 0\"\n        role=\"listbox\" [attr.id]=\"dropdown.id\">\n        <ng-template igxFor let-item let-index=\"index\" [igxForOf]=\"data | comboFiltering:filteringExpressions:filteringLogic | comboSorting:sortingExpressions | comboGrouping:groupKey\"\n            [igxForScrollOrientation]=\"'vertical'\" [igxForContainerSize]=\"itemsMaxHeight\" [igxForItemSize]=\"itemHeight\"\n            (onChunkPreload)=\"dataLoading($event)\">\n            <igx-combo-item  [itemHeight]='itemHeight' [value]=\"item\" isHeader={{item.isHeader}} role=\"option\" [index]=\"index\">\n                <ng-container *ngIf=\"item.isHeader\">\n                    <ng-container *ngTemplateOutlet=\"headerItemTemplate ? headerItemTemplate : headerItemBase; context: {$implicit: item, data: data, valueKey: valueKey, groupKey: groupKey, displayKey: displayKey}\"></ng-container>\n                </ng-container>\n                <ng-container *ngIf=\"!item.isHeader\">\n                    <ng-container #listItem *ngTemplateOutlet=\"template; context: {$implicit: item, data: data, valueKey: valueKey, displayKey: displayKey};\"></ng-container>\n                </ng-container>\n            </igx-combo-item>\n        </ng-template>\n    </div>\n    <div class=\"igx-combo__add\" *ngIf=\"filteredData.length === 0 || isAddButtonVisible()\">\n        <div class=\"igx-combo__empty\" *ngIf=\"filteredData.length === 0\">\n            <ng-container *ngTemplateOutlet=\"emptyTemplate ? emptyTemplate : empty\">\n            </ng-container>\n        </div>\n        <igx-combo-add-item [itemHeight]='itemHeight' *ngIf=\"isAddButtonVisible()\" [tabindex]=\"dropdown.collapsed ? -1 : customValueFlag ? 1 : -1\"\n            class=\"igx-combo__add-item\" igxRipple role=\"button\" aria-label=\"Add Item\" [index]=\"virtualScrollContainer.igxForOf.length\">\n            <ng-container *ngTemplateOutlet=\"addItemTemplate ? addItemTemplate : addItemDefault\">\n            </ng-container>\n        </igx-combo-add-item>\n    </div>\n    <ng-container *ngTemplateOutlet=\"footerTemplate\">\n    </ng-container>\n</igx-combo-drop-down>",
                    providers: [
                        IgxComboAPIService,
                        { provide: IGX_COMBO_COMPONENT, useExisting: IgxComboComponent },
                        { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(function () { return IgxComboComponent; }), multi: true }
                    ]
                }] }
    ];
    /** @nocollapse */
    IgxComboComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ChangeDetectorRef },
        { type: IgxSelectionAPIService },
        { type: IgxComboAPIService },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] },
        { type: Injector, decorators: [{ type: Optional }] }
    ]; };
    IgxComboComponent.propDecorators = {
        virtDir: [{ type: ViewChild, args: [IgxForOfDirective, { read: IgxForOfDirective },] }],
        dropdown: [{ type: ViewChild, args: [IgxComboDropDownComponent, { read: IgxComboDropDownComponent },] }],
        searchInput: [{ type: ViewChild, args: ['searchInput',] }],
        comboInput: [{ type: ViewChild, args: ['comboInput',] }],
        itemTemplate: [{ type: ContentChild, args: [IgxComboItemDirective, { read: TemplateRef },] }],
        headerTemplate: [{ type: ContentChild, args: [IgxComboHeaderDirective, { read: TemplateRef },] }],
        footerTemplate: [{ type: ContentChild, args: [IgxComboFooterDirective, { read: TemplateRef },] }],
        headerItemTemplate: [{ type: ContentChild, args: [IgxComboHeaderItemDirective, { read: TemplateRef },] }],
        addItemTemplate: [{ type: ContentChild, args: [IgxComboAddItemDirective, { read: TemplateRef },] }],
        emptyTemplate: [{ type: ContentChild, args: [IgxComboEmptyDirective, { read: TemplateRef },] }],
        toggleIconTemplate: [{ type: ContentChild, args: [IgxComboToggleIconDirective, { read: TemplateRef },] }],
        clearIconTemplate: [{ type: ContentChild, args: [IgxComboClearIconDirective, { read: TemplateRef },] }],
        primitiveTemplate: [{ type: ViewChild, args: ['primitive', { read: TemplateRef },] }],
        complexTemplate: [{ type: ViewChild, args: ['complex', { read: TemplateRef },] }],
        virtualScrollContainer: [{ type: ViewChild, args: [IgxForOfDirective,] }],
        oldEmptyTemplate: [{ type: ContentChild, args: ['emptyTemplate', { read: TemplateRef },] }],
        oldHeaderTemplate: [{ type: ContentChild, args: ['headerTemplate', { read: TemplateRef },] }],
        oldFooterTemplate: [{ type: ContentChild, args: ['footerTemplate', { read: TemplateRef },] }],
        oldItemTemplate: [{ type: ContentChild, args: ['itemTemplate', { read: TemplateRef },] }],
        oldAddItemTemplate: [{ type: ContentChild, args: ['addItemTemplate', { read: TemplateRef },] }],
        oldHeaderItemTemplate: [{ type: ContentChild, args: ['headerItemTemplate', { read: TemplateRef },] }],
        dropdownContainer: [{ type: ViewChild, args: ['dropdownItemContainer',] }],
        onSelectionChange: [{ type: Output }],
        onOpening: [{ type: Output }],
        onOpened: [{ type: Output }],
        onClosing: [{ type: Output }],
        onClosed: [{ type: Output }],
        onAddition: [{ type: Output }],
        onSearchInput: [{ type: Output }],
        onDataPreLoad: [{ type: Output }],
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        width: [{ type: HostBinding, args: ['style.width',] }, { type: Input }],
        validClass: [{ type: HostBinding, args: ['class.igx-input-group--valid',] }],
        invalidClass: [{ type: HostBinding, args: ['class.igx-input-group--invalid',] }],
        cssClass: [{ type: HostBinding, args: ['class.igx-combo',] }],
        role: [{ type: HostBinding, args: ["attr.role",] }],
        ariaExpanded: [{ type: HostBinding, args: ['attr.aria-expanded',] }],
        hasPopUp: [{ type: HostBinding, args: ['attr.aria-haspopup',] }],
        ariaOwns: [{ type: HostBinding, args: ['attr.aria-owns',] }],
        allowCustomValues: [{ type: Input }],
        itemsMaxHeight: [{ type: Input }],
        itemsWidth: [{ type: Input }],
        itemHeight: [{ type: Input }],
        placeholder: [{ type: Input }],
        searchPlaceholder: [{ type: Input }],
        data: [{ type: Input }],
        valueKey: [{ type: Input }],
        displayKey: [{ type: Input }],
        groupKey: [{ type: Input }],
        filterable: [{ type: Input }],
        ariaLabelledBy: [{ type: Input }, { type: HostBinding, args: ['attr.aria-labelledby',] }],
        disabled: [{ type: Input }],
        type: [{ type: Input }],
        onArrowDown: [{ type: HostListener, args: ['keydown.ArrowDown', ['$event'],] }, { type: HostListener, args: ['keydown.Alt.ArrowDown', ['$event'],] }]
    };
    __decorate([
        DeprecateProperty("Setting combo item template with '#emptyTemplate' is deprecated.\n" +
            "Use `igxComboEmpty` directive instead."),
        __metadata("design:type", TemplateRef),
        __metadata("design:paramtypes", [TemplateRef])
    ], IgxComboComponent.prototype, "oldEmptyTemplate", null);
    __decorate([
        DeprecateProperty("Setting combo item template with '#headerTemplate' is deprecated.\n" +
            "Use `igxComboHeader` directive instead."),
        __metadata("design:type", TemplateRef),
        __metadata("design:paramtypes", [TemplateRef])
    ], IgxComboComponent.prototype, "oldHeaderTemplate", null);
    __decorate([
        DeprecateProperty("Setting combo item template with '#footerTemplate' is deprecated.\n" +
            "Use `igxComboFooter` directive instead."),
        __metadata("design:type", TemplateRef),
        __metadata("design:paramtypes", [TemplateRef])
    ], IgxComboComponent.prototype, "oldFooterTemplate", null);
    __decorate([
        DeprecateProperty("Setting combo item template with '#itemTemplate' is deprecated.\n" +
            "Use `igxComboItem` directive instead."),
        __metadata("design:type", TemplateRef),
        __metadata("design:paramtypes", [TemplateRef])
    ], IgxComboComponent.prototype, "oldItemTemplate", null);
    __decorate([
        DeprecateProperty("Setting combo item template with '#addItemTemplate' is deprecated.\n" +
            "Use `igxComboAddItem` directive instead."),
        __metadata("design:type", TemplateRef),
        __metadata("design:paramtypes", [TemplateRef])
    ], IgxComboComponent.prototype, "oldAddItemTemplate", null);
    __decorate([
        DeprecateProperty("Setting combo item template with '#headerItemTemplate' is deprecated.\n" +
            "Use `igxComboHeaderItem` directive instead."),
        __metadata("design:type", TemplateRef),
        __metadata("design:paramtypes", [TemplateRef])
    ], IgxComboComponent.prototype, "oldHeaderItemTemplate", null);
    return IgxComboComponent;
}(DisplayDensityBase));
/**
 * @hidden
 */
var IgxComboModule = /** @class */ (function () {
    function IgxComboModule() {
    }
    IgxComboModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxComboComponent, IgxComboItemComponent, IgxComboFilterConditionPipe, IgxComboGroupingPipe,
                        IgxComboFilteringPipe, IgxComboSortingPipe, IgxComboDropDownComponent, IgxComboAddItemComponent,
                        IgxComboItemDirective,
                        IgxComboEmptyDirective,
                        IgxComboHeaderItemDirective,
                        IgxComboHeaderDirective,
                        IgxComboFooterDirective,
                        IgxComboAddItemDirective,
                        IgxComboToggleIconDirective,
                        IgxComboClearIconDirective],
                    exports: [IgxComboComponent, IgxComboItemComponent, IgxComboDropDownComponent, IgxComboAddItemComponent,
                        IgxComboItemDirective,
                        IgxComboEmptyDirective,
                        IgxComboHeaderItemDirective,
                        IgxComboHeaderDirective,
                        IgxComboFooterDirective,
                        IgxComboAddItemDirective,
                        IgxComboToggleIconDirective,
                        IgxComboClearIconDirective],
                    imports: [IgxRippleModule, CommonModule, IgxInputGroupModule, FormsModule, ReactiveFormsModule,
                        IgxForOfModule, IgxToggleModule, IgxCheckboxModule, IgxDropDownModule, IgxButtonModule, IgxIconModule],
                    providers: [IgxSelectionAPIService]
                },] }
    ];
    return IgxComboModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 * @abstract
 */
var DatePickerUtil = /** @class */ (function () {
    function DatePickerUtil() {
    }
    /**
     * This method generates date parts structure based on editor mask and locale.
     * @param maskValue: string
     * @param locale: string
     * @returns array containing information about date parts - type, position, format
     */
    /**
     * This method generates date parts structure based on editor mask and locale.
     * @param {?} maskValue
     * @param {?=} locale
     * @return {?} array containing information about date parts - type, position, format
     */
    DatePickerUtil.parseDateFormat = /**
     * This method generates date parts structure based on editor mask and locale.
     * @param {?} maskValue
     * @param {?=} locale
     * @return {?} array containing information about date parts - type, position, format
     */
    function (maskValue, locale) {
        if (locale === void 0) { locale = DatePickerUtil.DEFAULT_LOCALE; }
        /** @type {?} */
        var dateStruct = [];
        if (maskValue === undefined && !isIE()) {
            dateStruct = DatePickerUtil.getDefaultLocaleMask(locale);
        }
        else {
            /** @type {?} */
            var mask = (maskValue) ? maskValue : DatePickerUtil.SHORT_DATE_MASK;
            /** @type {?} */
            var maskArray = Array.from(mask);
            /** @type {?} */
            var monthInitPosition = mask.indexOf("M" /* MonthChar */);
            /** @type {?} */
            var dayInitPosition = mask.indexOf("d" /* DayChar */);
            /** @type {?} */
            var yearInitPosition = mask.indexOf("y" /* YearChar */);
            if (yearInitPosition !== -1) {
                dateStruct.push({
                    type: "year" /* Year */,
                    initialPosition: yearInitPosition,
                    formatType: DatePickerUtil.getYearFormatType(mask)
                });
            }
            if (monthInitPosition !== -1) {
                dateStruct.push({
                    type: "month" /* Month */,
                    initialPosition: monthInitPosition,
                    formatType: DatePickerUtil.getMonthFormatType(mask)
                });
            }
            if (dayInitPosition !== -1) {
                dateStruct.push({
                    type: "day" /* Day */,
                    initialPosition: dayInitPosition,
                    formatType: DatePickerUtil.getDayFormatType(mask)
                });
            }
            for (var i = 0; i < maskArray.length; i++) {
                if (!DatePickerUtil.isDateChar(maskArray[i])) {
                    dateStruct.push({
                        type: DatePickerUtil.SEPARATOR,
                        initialPosition: i,
                        value: maskArray[i]
                    });
                }
            }
            dateStruct.sort(function (a, b) { return a.initialPosition - b.initialPosition; });
            DatePickerUtil.fillDatePartsPositions(dateStruct);
        }
        return dateStruct;
    };
    /**
     * This method generates input mask based on date parts.
     * @param dateStruct array
     * @returns input mask
     */
    /**
     * This method generates input mask based on date parts.
     * @param {?} dateStruct array
     * @return {?} input mask
     */
    DatePickerUtil.getInputMask = /**
     * This method generates input mask based on date parts.
     * @param {?} dateStruct array
     * @return {?} input mask
     */
    function (dateStruct) {
        /** @type {?} */
        var inputMask = [];
        for (var i = 0; i < dateStruct.length; i++) {
            if (dateStruct[i].type === DatePickerUtil.SEPARATOR) {
                inputMask.push(dateStruct[i].value);
            }
            else if (dateStruct[i].type === "day" /* Day */ || dateStruct[i].type === "month" /* Month */) {
                inputMask.push('00');
            }
            else if (dateStruct[i].type === "year" /* Year */) {
                switch (dateStruct[i].formatType) {
                    case "numeric" /* Numeric */: {
                        inputMask.push('0000');
                        break;
                    }
                    case "2-digit" /* TwoDigits */: {
                        inputMask.push('00');
                        break;
                    }
                }
            }
        }
        return inputMask.join('');
    };
    /**
     * This method generates editor mask.
     * @param dateStruct
     * @returns editor mask
     */
    /**
     * This method generates editor mask.
     * @param {?} dateStruct
     * @return {?} editor mask
     */
    DatePickerUtil.getMask = /**
     * This method generates editor mask.
     * @param {?} dateStruct
     * @return {?} editor mask
     */
    function (dateStruct) {
        /** @type {?} */
        var mask = [];
        for (var i = 0; i < dateStruct.length; i++) {
            switch (dateStruct[i].formatType) {
                case "numeric" /* Numeric */: {
                    if (dateStruct[i].type === "day" /* Day */) {
                        mask.push('d');
                    }
                    else if (dateStruct[i].type === "month" /* Month */) {
                        mask.push('M');
                    }
                    else {
                        mask.push('yyyy');
                    }
                    break;
                }
                case "2-digit" /* TwoDigits */: {
                    if (dateStruct[i].type === "day" /* Day */) {
                        mask.push('dd');
                    }
                    else if (dateStruct[i].type === "month" /* Month */) {
                        mask.push('MM');
                    }
                    else {
                        mask.push('yy');
                    }
                }
            }
            if (dateStruct[i].type === DatePickerUtil.SEPARATOR) {
                mask.push(dateStruct[i].value);
            }
        }
        return mask.join('');
    };
    /**
     * This method parses an input string base on date parts and returns a date and its validation state.
     * @param dateFormatParts
     * @param prevDateValue
     * @param inputValue
     * @returns object containing a date and its validation state
     */
    /**
     * This method parses an input string base on date parts and returns a date and its validation state.
     * @param {?} dateFormatParts
     * @param {?} prevDateValue
     * @param {?} inputValue
     * @return {?} object containing a date and its validation state
     */
    DatePickerUtil.parseDateArray = /**
     * This method parses an input string base on date parts and returns a date and its validation state.
     * @param {?} dateFormatParts
     * @param {?} prevDateValue
     * @param {?} inputValue
     * @return {?} object containing a date and its validation state
     */
    function (dateFormatParts, prevDateValue, inputValue) {
        /** @type {?} */
        var dayStr = DatePickerUtil.getDayValueFromInput(dateFormatParts, inputValue);
        /** @type {?} */
        var monthStr = DatePickerUtil.getMonthValueFromInput(dateFormatParts, inputValue);
        /** @type {?} */
        var yearStr = DatePickerUtil.getYearValueFromInput(dateFormatParts, inputValue);
        /** @type {?} */
        var yearFormat = DatePickerUtil.getDateFormatPart(dateFormatParts, "year" /* Year */).formatType;
        /** @type {?} */
        var day = (dayStr !== '') ? parseInt(dayStr, 10) : 1;
        /** @type {?} */
        var month = (monthStr !== '') ? parseInt(monthStr, 10) - 1 : 0;
        /** @type {?} */
        var year;
        if (yearStr === '') {
            year = (yearFormat === "2-digit" /* TwoDigits */) ? '00' : '2000';
        }
        else {
            year = yearStr;
        }
        /** @type {?} */
        var yearPrefix;
        if (prevDateValue) {
            /** @type {?} */
            var originalYear = prevDateValue.getFullYear().toString();
            if (originalYear.length === 4) {
                yearPrefix = originalYear.substring(0, 2);
            }
        }
        else {
            yearPrefix = '20';
        }
        /** @type {?} */
        var fullYear = (yearFormat === "2-digit" /* TwoDigits */) ? yearPrefix.concat(year) : year;
        if ((month < 0) || (month > 11) || (month === NaN)) {
            return { state: "invalid" /* Invalid */, value: inputValue };
        }
        if ((day < 1) || (day > DatePickerUtil.daysInMonth(fullYear, month + 1)) || (day === NaN)) {
            return { state: "invalid" /* Invalid */, value: inputValue };
        }
        return { state: "valid" /* Valid */, date: new Date(fullYear, month, day) };
    };
    /**
     * @param {?} mask
     * @return {?}
     */
    DatePickerUtil.maskToPromptChars = /**
     * @param {?} mask
     * @return {?}
     */
    function (mask) {
        /** @type {?} */
        var result = mask.replace(/0|L/g, DatePickerUtil.PROMPT_CHAR);
        return result;
    };
    /**
     * This method replaces prompt chars with empty string.
     * @param value
     */
    /**
     * This method replaces prompt chars with empty string.
     * @param {?} value
     * @return {?}
     */
    DatePickerUtil.trimUnderlines = /**
     * This method replaces prompt chars with empty string.
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var result = value.replace(/_/g, '');
        return result;
    };
    /**
     * This method is used for spinning date parts.
     * @param dateFormatParts
     * @param inputValue
     * @param position
     * @param delta
     * @param isSpinLoop
     * @return modified text input
     */
    /**
     * This method is used for spinning date parts.
     * @param {?} dateFormatParts
     * @param {?} inputValue
     * @param {?} position
     * @param {?} delta
     * @param {?} isSpinLoop
     * @return {?} modified text input
     */
    DatePickerUtil.getModifiedDateInput = /**
     * This method is used for spinning date parts.
     * @param {?} dateFormatParts
     * @param {?} inputValue
     * @param {?} position
     * @param {?} delta
     * @param {?} isSpinLoop
     * @return {?} modified text input
     */
    function (dateFormatParts, inputValue, position, delta, isSpinLoop) {
        /** @type {?} */
        var datePart = DatePickerUtil.getDatePartOnPosition(dateFormatParts, position);
        /** @type {?} */
        var datePartType = datePart.type;
        /** @type {?} */
        var datePartFormatType = datePart.formatType;
        /** @type {?} */
        var newValue;
        /** @type {?} */
        var datePartValue = DatePickerUtil.getDateValueFromInput(dateFormatParts, datePartType, inputValue);
        newValue = parseInt(datePartValue, 10);
        /** @type {?} */
        var maxValue;
        /** @type {?} */
        var minValue;
        /** @type {?} */
        var minMax = DatePickerUtil.getMinMaxValue(dateFormatParts, datePart, inputValue);
        minValue = minMax.min;
        maxValue = minMax.max;
        if (isNaN(newValue)) {
            if (minValue === 'infinite') {
                newValue = 2000;
            }
            else {
                newValue = minValue;
            }
        }
        /** @type {?} */
        var tempValue = newValue;
        tempValue += delta;
        // Infinite loop for full years
        if (maxValue === 'infinite' && minValue === 'infinite') {
            newValue = tempValue;
        }
        if (isSpinLoop) {
            if (tempValue > maxValue) {
                tempValue = minValue;
            }
            if (tempValue < minValue) {
                tempValue = maxValue;
            }
            newValue = tempValue;
        }
        else {
            if (tempValue <= maxValue && tempValue >= minValue) {
                newValue = tempValue;
            }
        }
        /** @type {?} */
        var startIdx = datePart.position[0];
        /** @type {?} */
        var endIdx = datePart.position[1];
        /** @type {?} */
        var start = inputValue.slice(0, startIdx);
        /** @type {?} */
        var end = inputValue.slice(endIdx, inputValue.length);
        /** @type {?} */
        var changedPart;
        /** @type {?} */
        var prefix = DatePickerUtil.getNumericFormatPrefix(datePartFormatType);
        changedPart = (newValue < 10) ? "" + prefix + newValue : "" + newValue;
        return "" + start + changedPart + end;
    };
    /**
     * This method returns date input with prompt chars.
     * @param dateFormatParts
     * @param date
     * @param inputValue
     * @returns date input including prompt chars
     */
    /**
     * This method returns date input with prompt chars.
     * @param {?} dateFormatParts
     * @param {?} date
     * @param {?} inputValue
     * @return {?} date input including prompt chars
     */
    DatePickerUtil.addPromptCharsEditMode = /**
     * This method returns date input with prompt chars.
     * @param {?} dateFormatParts
     * @param {?} date
     * @param {?} inputValue
     * @return {?} date input including prompt chars
     */
    function (dateFormatParts, date, inputValue) {
        /** @type {?} */
        var dateArray = Array.from(inputValue);
        for (var i = 0; i < dateFormatParts.length; i++) {
            if (dateFormatParts[i].formatType === "numeric" /* Numeric */) {
                if ((dateFormatParts[i].type === "day" /* Day */ && date.getDate() < 10)
                    || (dateFormatParts[i].type === "month" /* Month */ && date.getMonth() + 1 < 10)) {
                    dateArray.splice(dateFormatParts[i].position[0], 0, DatePickerUtil.PROMPT_CHAR);
                    dateArray.join('');
                }
            }
        }
        return dateArray.join('');
    };
    /**
     * This method checks if date input is done.
     * @param dateFormatParts
     * @param input
     * @returns input completeness
     */
    /**
     * This method checks if date input is done.
     * @param {?} dateFormatParts
     * @param {?} input
     * @return {?} input completeness
     */
    DatePickerUtil.checkForCompleteDateInput = /**
     * This method checks if date input is done.
     * @param {?} dateFormatParts
     * @param {?} input
     * @return {?} input completeness
     */
    function (dateFormatParts, input) {
        /** @type {?} */
        var dayValue = DatePickerUtil.getDayValueFromInput(dateFormatParts, input);
        /** @type {?} */
        var monthValue = DatePickerUtil.getMonthValueFromInput(dateFormatParts, input);
        /** @type {?} */
        var yearValue = DatePickerUtil.getYearValueFromInput(dateFormatParts, input);
        /** @type {?} */
        var dayStr = DatePickerUtil.getDayValueFromInput(dateFormatParts, input, false);
        /** @type {?} */
        var monthStr = DatePickerUtil.getMonthValueFromInput(dateFormatParts, input, false);
        if (DatePickerUtil.isFullInput(dayValue, dayStr)
            && DatePickerUtil.isFullInput(monthValue, monthStr)
            && DatePickerUtil.isFullYearInput(dateFormatParts, yearValue)) {
            return 'complete';
        }
        else if (dayValue === '' && monthValue === '' && yearValue === '') {
            return 'empty';
        }
        else if (dayValue === '' || monthValue === '' || yearValue === '') {
            return 'partial';
        }
        return '';
    };
    /**
     * @private
     * @param {?} format
     * @return {?}
     */
    DatePickerUtil.getYearFormatType = /**
     * @private
     * @param {?} format
     * @return {?}
     */
    function (format) {
        switch (format.match(new RegExp("y" /* YearChar */, 'g')).length) {
            case 1: {
                // y (2020)
                return "numeric" /* Numeric */;
            }
            case 4: {
                // yyyy (2020)
                return "numeric" /* Numeric */;
            }
            case 2: {
                // yy (20)
                return "2-digit" /* TwoDigits */;
            }
        }
    };
    /**
     * @private
     * @param {?} format
     * @return {?}
     */
    DatePickerUtil.getMonthFormatType = /**
     * @private
     * @param {?} format
     * @return {?}
     */
    function (format) {
        switch (format.match(new RegExp("M" /* MonthChar */, 'g')).length) {
            case 1: {
                // M (8)
                return "numeric" /* Numeric */;
            }
            case 2: {
                // MM (08)
                return "2-digit" /* TwoDigits */;
            }
        }
    };
    /**
     * @private
     * @param {?} format
     * @return {?}
     */
    DatePickerUtil.getDayFormatType = /**
     * @private
     * @param {?} format
     * @return {?}
     */
    function (format) {
        switch (format.match(new RegExp("d" /* DayChar */, 'g')).length) {
            case 1: {
                // d (6)
                return "numeric" /* Numeric */;
            }
            case 2: {
                // dd (06)
                return "2-digit" /* TwoDigits */;
            }
        }
    };
    /**
     * @private
     * @param {?} locale
     * @return {?}
     */
    DatePickerUtil.getDefaultLocaleMask = /**
     * @private
     * @param {?} locale
     * @return {?}
     */
    function (locale) {
        /** @type {?} */
        var dateStruct = [];
        /** @type {?} */
        var formatter = new Intl.DateTimeFormat(locale);
        /** @type {?} */
        var formatToParts = formatter.formatToParts(new Date());
        for (var i = 0; i < formatToParts.length; i++) {
            if (formatToParts[i].type === DatePickerUtil.SEPARATOR) {
                dateStruct.push({
                    type: DatePickerUtil.SEPARATOR,
                    value: formatToParts[i].value
                });
            }
            else {
                dateStruct.push({
                    type: formatToParts[i].type,
                });
            }
        }
        /** @type {?} */
        var formatterOptions = formatter.resolvedOptions();
        for (var i = 0; i < dateStruct.length; i++) {
            switch (dateStruct[i].type) {
                case "day" /* Day */: {
                    dateStruct[i].formatType = formatterOptions.day;
                    break;
                }
                case "month" /* Month */: {
                    dateStruct[i].formatType = formatterOptions.month;
                    break;
                }
                case "year" /* Year */: {
                    dateStruct[i].formatType = formatterOptions.month;
                    break;
                }
            }
        }
        DatePickerUtil.fillDatePartsPositions(dateStruct);
        return dateStruct;
    };
    /**
     * @private
     * @param {?} char
     * @return {?}
     */
    DatePickerUtil.isDateChar = /**
     * @private
     * @param {?} char
     * @return {?}
     */
    function (char) {
        return (char === "y" /* YearChar */ || char === "M" /* MonthChar */ || char === "d" /* DayChar */);
    };
    /**
     * @private
     * @param {?} formatType
     * @return {?}
     */
    DatePickerUtil.getNumericFormatPrefix = /**
     * @private
     * @param {?} formatType
     * @return {?}
     */
    function (formatType) {
        switch (formatType) {
            case "2-digit" /* TwoDigits */: {
                return '0';
            }
            case "numeric" /* Numeric */: {
                return DatePickerUtil.PROMPT_CHAR;
            }
        }
    };
    /**
     * @private
     * @param {?} dateFormatParts
     * @param {?} datePart
     * @param {?} inputValue
     * @return {?}
     */
    DatePickerUtil.getMinMaxValue = /**
     * @private
     * @param {?} dateFormatParts
     * @param {?} datePart
     * @param {?} inputValue
     * @return {?}
     */
    function (dateFormatParts, datePart, inputValue) {
        /** @type {?} */
        var maxValue;
        /** @type {?} */
        var minValue;
        switch (datePart.type) {
            case "month" /* Month */: {
                minValue = 1;
                maxValue = DatePickerUtil.NUMBER_OF_MONTHS;
                break;
            }
            case "day" /* Day */: {
                minValue = 1;
                maxValue = DatePickerUtil.daysInMonth(DatePickerUtil.getFullYearFromString(DatePickerUtil.getDateFormatPart(dateFormatParts, "year" /* Year */), inputValue), parseInt(DatePickerUtil.getMonthValueFromInput(dateFormatParts, inputValue), 10));
                break;
            }
            case "year" /* Year */: {
                if (datePart.formatType === "2-digit" /* TwoDigits */) {
                    minValue = 0;
                    maxValue = 99;
                }
                else {
                    // Infinite loop
                    minValue = 'infinite';
                    maxValue = 'infinite';
                }
                break;
            }
        }
        return { min: minValue, max: maxValue };
    };
    /**
     * @private
     * @param {?} fullYear
     * @param {?} month
     * @return {?}
     */
    DatePickerUtil.daysInMonth = /**
     * @private
     * @param {?} fullYear
     * @param {?} month
     * @return {?}
     */
    function (fullYear, month) {
        return new Date(fullYear, month, 0).getDate();
    };
    /**
     * @private
     * @param {?} dateFormatParts
     * @param {?} type
     * @param {?} inputValue
     * @param {?=} trim
     * @return {?}
     */
    DatePickerUtil.getDateValueFromInput = /**
     * @private
     * @param {?} dateFormatParts
     * @param {?} type
     * @param {?} inputValue
     * @param {?=} trim
     * @return {?}
     */
    function (dateFormatParts, type, inputValue, trim) {
        if (trim === void 0) { trim = true; }
        /** @type {?} */
        var partPosition = DatePickerUtil.getDateFormatPart(dateFormatParts, type).position;
        /** @type {?} */
        var result = inputValue.substring(partPosition[0], partPosition[1]);
        return (trim) ? DatePickerUtil.trimUnderlines(result) : result;
    };
    /**
     * @private
     * @param {?} dateFormatParts
     * @param {?} inputValue
     * @param {?=} trim
     * @return {?}
     */
    DatePickerUtil.getDayValueFromInput = /**
     * @private
     * @param {?} dateFormatParts
     * @param {?} inputValue
     * @param {?=} trim
     * @return {?}
     */
    function (dateFormatParts, inputValue, trim) {
        if (trim === void 0) { trim = true; }
        return DatePickerUtil.getDateValueFromInput(dateFormatParts, "day" /* Day */, inputValue, trim);
    };
    /**
     * @private
     * @param {?} dateFormatParts
     * @param {?} inputValue
     * @param {?=} trim
     * @return {?}
     */
    DatePickerUtil.getMonthValueFromInput = /**
     * @private
     * @param {?} dateFormatParts
     * @param {?} inputValue
     * @param {?=} trim
     * @return {?}
     */
    function (dateFormatParts, inputValue, trim) {
        if (trim === void 0) { trim = true; }
        return DatePickerUtil.getDateValueFromInput(dateFormatParts, "month" /* Month */, inputValue, trim);
    };
    /**
     * @private
     * @param {?} dateFormatParts
     * @param {?} inputValue
     * @param {?=} trim
     * @return {?}
     */
    DatePickerUtil.getYearValueFromInput = /**
     * @private
     * @param {?} dateFormatParts
     * @param {?} inputValue
     * @param {?=} trim
     * @return {?}
     */
    function (dateFormatParts, inputValue, trim) {
        if (trim === void 0) { trim = true; }
        return DatePickerUtil.getDateValueFromInput(dateFormatParts, "year" /* Year */, inputValue, trim);
    };
    /**
     * @private
     * @param {?} dateFormatParts
     * @param {?} type
     * @return {?}
     */
    DatePickerUtil.getDateFormatPart = /**
     * @private
     * @param {?} dateFormatParts
     * @param {?} type
     * @return {?}
     */
    function (dateFormatParts, type) {
        /** @type {?} */
        var result = dateFormatParts.filter(function (datePart) { return (datePart.type === type); })[0];
        return result;
    };
    /**
     * @private
     * @param {?} value
     * @param {?} input
     * @return {?}
     */
    DatePickerUtil.isFullInput = /**
     * @private
     * @param {?} value
     * @param {?} input
     * @return {?}
     */
    function (value, input) {
        return (value !== '' && input.length === 2 && input.charAt(1) !== DatePickerUtil.PROMPT_CHAR);
    };
    /**
     * @private
     * @param {?} dateFormatParts
     * @param {?} value
     * @return {?}
     */
    DatePickerUtil.isFullYearInput = /**
     * @private
     * @param {?} dateFormatParts
     * @param {?} value
     * @return {?}
     */
    function (dateFormatParts, value) {
        switch (DatePickerUtil.getDateFormatPart(dateFormatParts, "year" /* Year */).formatType) {
            case "numeric" /* Numeric */: {
                return (value !== '' && value.length === 4);
            }
            case "2-digit" /* TwoDigits */: {
                return (value !== '' && value.length === 2);
            }
            default: {
                return false;
            }
        }
    };
    /**
     * @private
     * @param {?} dateFormatParts
     * @param {?} position
     * @return {?}
     */
    DatePickerUtil.getDatePartOnPosition = /**
     * @private
     * @param {?} dateFormatParts
     * @param {?} position
     * @return {?}
     */
    function (dateFormatParts, position) {
        /** @type {?} */
        var result = dateFormatParts.filter(function (element) {
            return element.position[0] <= position && position <= element.position[1] && element.type !== DatePickerUtil.SEPARATOR;
        })[0];
        return result;
    };
    /**
     * @private
     * @param {?} yearPart
     * @param {?} inputValue
     * @return {?}
     */
    DatePickerUtil.getFullYearFromString = /**
     * @private
     * @param {?} yearPart
     * @param {?} inputValue
     * @return {?}
     */
    function (yearPart, inputValue) {
        return parseInt(inputValue.substring(yearPart.position[0], yearPart.position[1]), 10);
    };
    /**
     * @private
     * @param {?} dateArray
     * @return {?}
     */
    DatePickerUtil.fillDatePartsPositions = /**
     * @private
     * @param {?} dateArray
     * @return {?}
     */
    function (dateArray) {
        /** @type {?} */
        var currentPos = 0;
        for (var i = 0; i < dateArray.length; i++) {
            // Day|Month part positions
            if (dateArray[i].type === "day" /* Day */ || dateArray[i].type === "month" /* Month */) {
                // Offset 2 positions for number
                dateArray[i].position = [currentPos, currentPos + 2];
                currentPos += 2;
            }
            else if (dateArray[i].type === "year" /* Year */) {
                // Year part positions
                switch (dateArray[i].formatType) {
                    case "numeric" /* Numeric */: {
                        // Offset 4 positions for full year
                        dateArray[i].position = [currentPos, currentPos + 4];
                        currentPos += 4;
                        break;
                    }
                    case "2-digit" /* TwoDigits */: {
                        // Offset 2 positions for short year
                        dateArray[i].position = [currentPos, currentPos + 2];
                        currentPos += 2;
                        break;
                    }
                }
            }
            else if (dateArray[i].type === DatePickerUtil.SEPARATOR) {
                // Separator positions
                dateArray[i].position = [currentPos, currentPos + 1];
                currentPos++;
            }
        }
    };
    DatePickerUtil.SHORT_DATE_MASK = 'MM/dd/yy';
    DatePickerUtil.SEPARATOR = 'literal';
    DatePickerUtil.NUMBER_OF_MONTHS = 12;
    DatePickerUtil.PROMPT_CHAR = '_';
    DatePickerUtil.DEFAULT_LOCALE = 'en';
    return DatePickerUtil;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 * @type {?}
 */
var IGX_DATE_PICKER_COMPONENT = 'IgxDatePickerComponentToken';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var DatePickerDisplayValuePipe = /** @class */ (function () {
    function DatePickerDisplayValuePipe(_datePicker) {
        this._datePicker = _datePicker;
    }
    /**
     * @param {?} value
     * @param {?=} args
     * @return {?}
     */
    DatePickerDisplayValuePipe.prototype.transform = /**
     * @param {?} value
     * @param {?=} args
     * @return {?}
     */
    function (value, args) {
        if (value !== '') {
            if (value === DatePickerUtil.maskToPromptChars(this._datePicker.inputMask)) {
                return '';
            }
            this._datePicker.rawDateString = value;
            return DatePickerUtil.trimUnderlines(value);
        }
        return '';
    };
    DatePickerDisplayValuePipe.decorators = [
        { type: Pipe, args: [{
                    name: 'displayValue'
                },] }
    ];
    /** @nocollapse */
    DatePickerDisplayValuePipe.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [IGX_DATE_PICKER_COMPONENT,] }] }
    ]; };
    return DatePickerDisplayValuePipe;
}());
/**
 * @hidden
 */
var DatePickerInputValuePipe = /** @class */ (function () {
    function DatePickerInputValuePipe(_datePicker) {
        this._datePicker = _datePicker;
    }
    /**
     * @param {?} value
     * @param {?=} args
     * @return {?}
     */
    DatePickerInputValuePipe.prototype.transform = /**
     * @param {?} value
     * @param {?=} args
     * @return {?}
     */
    function (value, args) {
        if (this._datePicker.invalidDate !== '') {
            return this._datePicker.invalidDate;
        }
        else {
            if (this._datePicker.value === null || this._datePicker.value === undefined) {
                return DatePickerUtil.maskToPromptChars(this._datePicker.inputMask);
            }
            else {
                return DatePickerUtil.addPromptCharsEditMode(this._datePicker.dateFormatParts, this._datePicker.value, value);
            }
        }
    };
    DatePickerInputValuePipe.decorators = [
        { type: Pipe, args: [{
                    name: 'inputValue'
                },] }
    ];
    /** @nocollapse */
    DatePickerInputValuePipe.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [IGX_DATE_PICKER_COMPONENT,] }] }
    ]; };
    return DatePickerInputValuePipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxDatePickerTemplateDirective = /** @class */ (function () {
    function IgxDatePickerTemplateDirective(template) {
        this.template = template;
    }
    IgxDatePickerTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxDatePickerTemplate]'
                },] }
    ];
    /** @nocollapse */
    IgxDatePickerTemplateDirective.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return IgxDatePickerTemplateDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var InteractionMode = {
    DropDown: 'dropdown',
    Dialog: 'dialog',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxCalendarContainerComponent = /** @class */ (function () {
    function IgxCalendarContainerComponent() {
        this.mode = InteractionMode.Dialog;
        this.vertical = false;
        this.onClose = new EventEmitter();
        this.onTodaySelection = new EventEmitter();
        this.styleClass = 'igx-date-picker';
    }
    Object.defineProperty(IgxCalendarContainerComponent.prototype, "dropdownCSS", {
        get: /**
         * @return {?}
         */
        function () {
            return this.mode === InteractionMode.DropDown;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxCalendarContainerComponent.prototype, "verticalCSS", {
        get: /**
         * @return {?}
         */
        function () {
            return this.vertical && this.mode === InteractionMode.Dialog;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} event
     * @return {?}
     */
    IgxCalendarContainerComponent.prototype.onEscape = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        this.onClose.emit();
    };
    Object.defineProperty(IgxCalendarContainerComponent.prototype, "isReadonly", {
        /**
         * Returns whether the date-picker is in readonly dialog mode.
         *
         * @hidden
        */
        get: /**
         * Returns whether the date-picker is in readonly dialog mode.
         *
         * @hidden
         * @return {?}
         */
        function () {
            return this.mode === InteractionMode.Dialog;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Emits close event for the calendar.
     */
    /**
     * Emits close event for the calendar.
     * @return {?}
     */
    IgxCalendarContainerComponent.prototype.closeCalendar = /**
     * Emits close event for the calendar.
     * @return {?}
     */
    function () {
        this.onClose.emit();
    };
    /**
    * Emits today selection event for the calendar.
    */
    /**
     * Emits today selection event for the calendar.
     * @return {?}
     */
    IgxCalendarContainerComponent.prototype.triggerTodaySelection = /**
     * Emits today selection event for the calendar.
     * @return {?}
     */
    function () {
        this.onTodaySelection.emit();
    };
    IgxCalendarContainerComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-calendar-container',
                    template: "<igx-calendar #calendar></igx-calendar>\n<div class=\"igx-date-picker__buttons\" *ngIf=\"isReadonly &&\n    (cancelButtonLabel || todayButtonLabel)\">\n    <button #closeButton *ngIf=\"cancelButtonLabel\" igxButton=\"flat\" igxRipple (click)=\"closeCalendar()\">\n        {{ cancelButtonLabel }}\n    </button>\n    <button #todayButton *ngIf=\"todayButtonLabel\" igxButton=\"flat\" igxRipple (click)=\"triggerTodaySelection()\">\n        {{ todayButtonLabel }}\n    </button>\n</div>",
                    styles: [':host {display: block;}']
                }] }
    ];
    IgxCalendarContainerComponent.propDecorators = {
        calendar: [{ type: ViewChild, args: ['calendar',] }],
        mode: [{ type: Input }],
        vertical: [{ type: Input }],
        cancelButtonLabel: [{ type: Input }],
        todayButtonLabel: [{ type: Input }],
        onClose: [{ type: Output }],
        onTodaySelection: [{ type: Output }],
        styleClass: [{ type: HostBinding, args: ['class.igx-date-picker',] }],
        dropdownCSS: [{ type: HostBinding, args: ['class.igx-date-picker--dropdown',] }],
        verticalCSS: [{ type: HostBinding, args: ['class.igx-date-picker--vertical',] }],
        onEscape: [{ type: HostListener, args: ['keydown.esc', ['$event'],] }, { type: HostListener, args: ['keydown.alt.arrowup', ['$event'],] }]
    };
    return IgxCalendarContainerComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var NEXT_ID$k = 0;
/** @enum {string} */
var PredefinedFormatOptions = {
    ShortDate: 'shortDate',
    MediumDate: 'mediumDate',
    LongDate: 'longDate',
    FullDate: 'fullDate',
};
/**
 * **Ignite UI for Angular Date Picker** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/date_picker.html)
 *
 * The Ignite UI Date Picker displays a popup calendar that lets users select a single date.
 *
 * Example:
 * ```html
 * <igx-date-picker [(ngModel)]="selectedDate"></igx-date-picker>
 * ```
 */
var IgxDatePickerComponent = /** @class */ (function () {
    function IgxDatePickerComponent(_overlayService, element, _cdr, _moduleRef) {
        this._overlayService = _overlayService;
        this.element = element;
        this._cdr = _cdr;
        this._moduleRef = _moduleRef;
        /**
         * An \@Input property that sets the `IgxDatePickerComponent` label.
         * The default label is 'Date'.
         * ```html
         * <igx-date-picker [label]="Calendar"></igx-date-picker>
         * ```
         */
        this.label = 'Date';
        /**
         * An \@Input property that sets the `IgxDatePickerComponent` label visibility.
         * By default the visibility is set to true.
         * <igx-date-picker [labelVisibility]="false"></igx-date-picker>
         */
        this.labelVisibility = true;
        /**
         * An \@Input property that sets on which day the week starts.
         * ```html
         * <igx-date-picker [weekStart]="WEEKDAYS.FRIDAY" cancelButtonLabel="cancel" todayButtonLabel="today"></igx-date-picker>
         * ```
         */
        this.weekStart = WEEKDAYS.SUNDAY;
        /**
         * An \@Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-date-picker [id]="'igx-date-picker-3'" cancelButtonLabel="cancel" todayButtonLabel="today"></igx-date-picker>
         * ```
         */
        this.id = "igx-date-picker-" + NEXT_ID$k++;
        /**
         * An \@Input property that sets the orientation of the `IgxDatePickerComponent` header.
         * ```html
         * <igx-date-picker [vertical]="'true'" cancelButtonLabel="cancel" todayButtonLabel="today"></igx-date-picker>
         * ```
         */
        this.vertical = false;
        /**
         * An \@Input property that sets whether `IgxDatePickerComponent` is in dialog or drop down mode.
         * ```html
         * <igx-date-picker mode="dropdown"></igx-date-picker>
         * ```
         */
        this.mode = InteractionMode.Dialog;
        /**
         * An \@Input property that sets whether the `IgxDatePickerComponent` date parts would spin continuously or stop when min/max is reached.
         * ```html
         * <igx-date-picker [isSpinLoop]="false"></igx-date-picker>
         * ```
         */
        this.isSpinLoop = true;
        /**
         * An event that is emitted when the `IgxDatePickerComponent` calendar is opened.
         * ```typescript
         * public open(event){
         *    alert("The date-picker calendar has been opened!");
         * }
         * ```
         * ```html
         * <igx-date-picker (onOpen)="open($event)" cancelButtonLabel="cancel" todayButtonLabel="today"></igx-date-picker>
         * ```
         */
        this.onOpen = new EventEmitter();
        /**
         * "An event that is emitted when the `IgxDatePickerComponent` is closed.
         * ```typescript
         * public close(event){
         *    alert("The date-picker has been closed!");
         * }
         * ```
         * ```html
         * <igx-date-picker (onClose)="close($event)" cancelButtonLabel="cancel" todayButtonLabel="today"></igx-date-picker>
         * ```
         */
        this.onClose = new EventEmitter();
        /**
         * An \@Output property that is fired when selection is made in the calendar.
         * ```typescript
         * public selection(event){
         *    alert("A date has been selected!");
         * }
         * ```
         * ```html
         * <igx-date-picker (onSelection)="selection($event)" cancelButtonLabel="cancel" todayButtonLabel="today"></igx-date-picker>
         * ```
         */
        this.onSelection = new EventEmitter();
        /**
         * An \@Output property that fires when the user types/spins to a disabled date in the date-picker editor.
         * ```typescript
         * public onDisabledDate(event){
         *    alert("This date is disabled!");
         * }
         * ```
         * ```html
         * <igx-date-picker (onDisabledDate)="onDisabledDate($event)"></igx-date-picker>
         * ```
         */
        this.onDisabledDate = new EventEmitter();
        /**
         * An \@Output property that fires when the user types/spins invalid date in the date-picker editor.
         * ```typescript
         * public onValidationFailed(event){
         *    alert("This date is not valid!");
         * }
         * ```
         * ```html
         * <igx-date-picker (onValidationFailed)="onValidationFailed($event)"></igx-date-picker>
         * ```
         */
        this.onValidationFailed = new EventEmitter();
        this.hasHeader = true;
        this.collapsed = true;
        this.displayValuePipe = new DatePickerDisplayValuePipe(this);
        this.inputValuePipe = new DatePickerInputValuePipe(this);
        this.dateFormatParts = [];
        this.isEmpty = true;
        this.invalidDate = '';
        this.spinDelta = 1;
        this.defaultLocale = 'en';
        this.calendarHeight = 400;
        this._formatOptions = {
            day: 'numeric',
            month: 'short',
            weekday: 'short',
            year: 'numeric'
        };
        this._formatViews = {
            day: false,
            month: true,
            year: false
        };
        this._destroy$ = new Subject();
        this._disabledDates = null;
        this._specialDates = null;
        this._onTouchedCallback = function () { };
        this._onChangeCallback = function () { };
    }
    Object.defineProperty(IgxDatePickerComponent.prototype, "formatOptions", {
        /**
         *Returns the format options of the `IgxDatePickerComponent`.
         *```typescript
         *@ViewChild("MyDatePicker")
         *public datePicker: IgxDatePickerComponent;
         *ngAfterViewInit(){
         *    let formatOptions = this.datePicker.formatOptions;
         *}
         *```
         */
        get: /**
         * Returns the format options of the `IgxDatePickerComponent`.
         * ```typescript
         * \@ViewChild("MyDatePicker")
         * public datePicker: IgxDatePickerComponent;
         * ngAfterViewInit(){
         *    let formatOptions = this.datePicker.formatOptions;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this._formatOptions;
        },
        /**
         *Sets the format options of the `IgxDatePickerComponent`.
         *```typescript
         *public Options;
         *@ViewChild("MyDatePicker")
         *public datePicker: IgxDatePickerComponent;
         *ngAfterViewInit(){
         *    this.Options = {
         *        day: "numeric",
         *        month: "long",
         *        weekday: "long",
         *        year: "numeric"
         *    }
         *this.datePicker.formatOptions = this.Options;
         *}
         *```
         */
        set: /**
         * Sets the format options of the `IgxDatePickerComponent`.
         * ```typescript
         * public Options;
         * \@ViewChild("MyDatePicker")
         * public datePicker: IgxDatePickerComponent;
         * ngAfterViewInit(){
         *    this.Options = {
         *        day: "numeric",
         *        month: "long",
         *        weekday: "long",
         *        year: "numeric"
         *    }
         * this.datePicker.formatOptions = this.Options;
         * }
         * ```
         * @param {?} formatOptions
         * @return {?}
         */
        function (formatOptions) {
            this._formatOptions = Object.assign(this._formatOptions, formatOptions);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDatePickerComponent.prototype, "format", {
        /**
         *Returns the date display format of the `IgxDatePickerComponent` in dropdown mode.
         *```typescript
         *@ViewChild("MyDatePicker")
         *public datePicker: IgxDatePickerComponent;
         *ngAfterViewInit(){
         *    let format = this.datePicker.format;
         *}
         *```
         */
        get: /**
         * Returns the date display format of the `IgxDatePickerComponent` in dropdown mode.
         * ```typescript
         * \@ViewChild("MyDatePicker")
         * public datePicker: IgxDatePickerComponent;
         * ngAfterViewInit(){
         *    let format = this.datePicker.format;
         * }
         * ```
         * @return {?}
         */
        function () {
            return (this._format === undefined) ? PredefinedFormatOptions.ShortDate : this._format;
        },
        /**
        *Sets the date format of the `IgxDatePickerComponent` when in editable dropdown mode.
        *```typescript
        *@ViewChild("MyDatePicker")
        *public datePicker: IgxDatePickerComponent;
        *this.datePicker.format = 'yyyy-M-d';
        *}
        *```
        */
        set: /**
         * Sets the date format of the `IgxDatePickerComponent` when in editable dropdown mode.
         * ```typescript
         * \@ViewChild("MyDatePicker")
         * public datePicker: IgxDatePickerComponent;
         * this.datePicker.format = 'yyyy-M-d';
         * }
         * ```
         * @param {?} format
         * @return {?}
         */
        function (format) {
            this._format = format;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDatePickerComponent.prototype, "formatViews", {
        /**
         *Returns the format views of the `IgxDatePickerComponent`.
         *```typescript
         *@ViewChild("MyDatePicker")
         *public datePicker: IgxDatePickerComponent;
         *ngAfterViewInit(){
         *    let formatViews = this.datePicker.formatViews;
         *}
         *```
         */
        get: /**
         * Returns the format views of the `IgxDatePickerComponent`.
         * ```typescript
         * \@ViewChild("MyDatePicker")
         * public datePicker: IgxDatePickerComponent;
         * ngAfterViewInit(){
         *    let formatViews = this.datePicker.formatViews;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this._formatViews;
        },
        /**
         *Sets the format views of the `IgxDatePickerComponent`.
         *```typescript
         *public Views;
         *@ViewChild("MyDatePicker")
         *public datePicker: IgxDatePickerComponent;
         *ngAfterViewInit(){
         *    this.Views = {day:false, month: false, year:false};
         *    this.datePicker.formatViews = this.Views;
         *}
         *```
         */
        set: /**
         * Sets the format views of the `IgxDatePickerComponent`.
         * ```typescript
         * public Views;
         * \@ViewChild("MyDatePicker")
         * public datePicker: IgxDatePickerComponent;
         * ngAfterViewInit(){
         *    this.Views = {day:false, month: false, year:false};
         *    this.datePicker.formatViews = this.Views;
         * }
         * ```
         * @param {?} formatViews
         * @return {?}
         */
        function (formatViews) {
            this._formatViews = Object.assign(this._formatViews, formatViews);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDatePickerComponent.prototype, "disabledDates", {
        /**
         * Gets the disabled dates descriptors.
         * ```typescript
         * let disabledDates = this.datepicker.disabledDates;
         * ```
         */
        get: /**
         * Gets the disabled dates descriptors.
         * ```typescript
         * let disabledDates = this.datepicker.disabledDates;
         * ```
         * @return {?}
         */
        function () {
            return this._disabledDates;
        },
        /**
         * Sets the disabled dates' descriptors.
         * ```typescript
         *@ViewChild("MyDatePicker")
         *public datePicker: IgxDatePickerComponent;
         *ngAfterViewInit(){
         *    this.datePicker.disabledDates = [
         *     {type: DateRangeType.Between, dateRange: [new Date("2020-1-1"), new Date("2020-1-15")]},
         *     {type: DateRangeType.Weekends}];
         *}
         *```
         */
        set: /**
         * Sets the disabled dates' descriptors.
         * ```typescript
         * \@ViewChild("MyDatePicker")
         * public datePicker: IgxDatePickerComponent;
         * ngAfterViewInit(){
         *    this.datePicker.disabledDates = [
         *     {type: DateRangeType.Between, dateRange: [new Date("2020-1-1"), new Date("2020-1-15")]},
         *     {type: DateRangeType.Weekends}];
         * }
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._disabledDates = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDatePickerComponent.prototype, "specialDates", {
        /**
         * Gets the special dates descriptors.
         * ```typescript
         * let specialDates = this.datepicker.specialDates;
         * ```
         */
        get: /**
         * Gets the special dates descriptors.
         * ```typescript
         * let specialDates = this.datepicker.specialDates;
         * ```
         * @return {?}
         */
        function () {
            return this._specialDates;
        },
        /**
         * Sets the special dates' descriptors.
         * ```typescript
         *@ViewChild("MyDatePicker")
         *public datePicker: IgxDatePickerComponent;
         *ngAfterViewInit(){
         *    this.datePicker.specialDates = [
         *     {type: DateRangeType.Between, dateRange: [new Date("2020-1-1"), new Date("2020-1-15")]},
         *     {type: DateRangeType.Weekends}];
         *}
         *```
         */
        set: /**
         * Sets the special dates' descriptors.
         * ```typescript
         * \@ViewChild("MyDatePicker")
         * public datePicker: IgxDatePickerComponent;
         * ngAfterViewInit(){
         *    this.datePicker.specialDates = [
         *     {type: DateRangeType.Between, dateRange: [new Date("2020-1-1"), new Date("2020-1-15")]},
         *     {type: DateRangeType.Weekends}];
         * }
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._specialDates = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDatePickerComponent.prototype, "modalOverlaySettings", {
        get: /**
         * @return {?}
         */
        function () {
            return this._modalOverlay;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._modalOverlay = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDatePickerComponent.prototype, "dropDownOverlaySettings", {
        get: /**
         * @return {?}
         */
        function () {
            return this._dropDownOverlay;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._dropDownOverlay = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDatePickerComponent.prototype, "displayData", {
        /**
         *Returns the formatted date when `IgxDatePickerComponent` is in dialog mode.
         *```typescript
         *@ViewChild("MyDatePicker")
         *public datePicker: IgxDatePickerComponent;
         *public selection(event){
         *    let selectedDate = this.datePicker.displayData;
         *    alert(selectedDate);
         *}
         *```
         *```html
         *<igx-date-picker #MyDatePicker (onSelection)="selection()" todayButtonLabel="today"></igx-date-picker>
         *```
         */
        get: /**
         * Returns the formatted date when `IgxDatePickerComponent` is in dialog mode.
         * ```typescript
         * \@ViewChild("MyDatePicker")
         * public datePicker: IgxDatePickerComponent;
         * public selection(event){
         *    let selectedDate = this.datePicker.displayData;
         *    alert(selectedDate);
         * }
         * ```
         * ```html
         * <igx-date-picker #MyDatePicker (onSelection)="selection()" todayButtonLabel="today"></igx-date-picker>
         * ```
         * @return {?}
         */
        function () {
            if (this.value) {
                return this._customFormatChecker(this.formatter, this.value);
            }
            return '';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDatePickerComponent.prototype, "transformedDate", {
        /**
         hidden
         */
        get: /**
         * hidden
         * @return {?}
         */
        function () {
            if (this._value) {
                this._transformedDate = (this._isInEditMode) ? this._getEditorDate(this._value) : this._getDisplayDate(this._value);
                this.isEmpty = false;
            }
            else {
                this._transformedDate = (this._isInEditMode) ? DatePickerUtil.maskToPromptChars(this.inputMask) : '';
            }
            return this._transformedDate;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._transformedDate = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDatePickerComponent.prototype, "template", {
        /**
         * Gets the input group template.
         * ```typescript
         * let template = this.template();
         * ```
         * @memberof IgxDatePickerComponent
         */
        get: /**
         * Gets the input group template.
         * ```typescript
         * let template = this.template();
         * ```
         * \@memberof IgxDatePickerComponent
         * @return {?}
         */
        function () {
            if (this.datePickerTemplateDirective) {
                return this.datePickerTemplateDirective.template;
            }
            return (this.mode === InteractionMode.Dialog) ? this.readOnlyDatePickerTemplate : this.editableDatePickerTemplate;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDatePickerComponent.prototype, "context", {
        /**
         * Gets the context passed to the input group template.
         * @memberof IgxDatePickerComponent
         */
        get: /**
         * Gets the context passed to the input group template.
         * \@memberof IgxDatePickerComponent
         * @return {?}
         */
        function () {
            var _this = this;
            return {
                disabled: this.disabled,
                disabledDates: this.disabledDates,
                displayData: this.displayData,
                format: this.format,
                isSpinLoop: this.isSpinLoop,
                label: this.label,
                labelVisibility: this.labelVisibility,
                locale: this.locale,
                mask: this.mask,
                mode: this.mode,
                specialDates: this.specialDates,
                value: this.value,
                openDialog: function () { _this.openDialog(); }
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDatePickerComponent.prototype, "value", {
        /**
         *An @Input property that gets/sets the selected date.
         *```typescript
         *public date: Date = new Date();
         *```
         *```html
         *<igx-date-picker [value]="date"></igx-date-picker>
         *```
         */
        get: /**
         * An \@Input property that gets/sets the selected date.
         * ```typescript
         * public date: Date = new Date();
         * ```
         * ```html
         * <igx-date-picker [value]="date"></igx-date-picker>
         * ```
         * @return {?}
         */
        function () {
            return this._value;
        },
        set: /**
         * @param {?} date
         * @return {?}
         */
        function (date) {
            this._value = date;
            this._onChangeCallback(date);
        },
        enumerable: true,
        configurable: true
    });
    /**
    * @hidden
    */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxDatePickerComponent.prototype.onSpaceClick = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.openDialog();
        event.preventDefault();
    };
    /**
     *Method that sets the selected date.
     *```typescript
     *public date = new Date();
     *@ViewChild("MyDatePicker")
     *public datePicker: IgxDatePickerComponent;
     *ngAfterViewInit(){
     *    this.datePicker.writeValue(this.date);
     *}
     *```
     *@param value The date you want to select.
     *@memberOf {@link IgxDatePickerComponent}
     */
    /**
     * Method that sets the selected date.
     * ```typescript
     * public date = new Date();
     * \@ViewChild("MyDatePicker")
     * public datePicker: IgxDatePickerComponent;
     * ngAfterViewInit(){
     *    this.datePicker.writeValue(this.date);
     * }
     * ```
     * \@memberOf {\@link IgxDatePickerComponent}
     * @param {?} value The date you want to select.
     * @return {?}
     */
    IgxDatePickerComponent.prototype.writeValue = /**
     * Method that sets the selected date.
     * ```typescript
     * public date = new Date();
     * \@ViewChild("MyDatePicker")
     * public datePicker: IgxDatePickerComponent;
     * ngAfterViewInit(){
     *    this.datePicker.writeValue(this.date);
     * }
     * ```
     * \@memberOf {\@link IgxDatePickerComponent}
     * @param {?} value The date you want to select.
     * @return {?}
     */
    function (value) {
        this.value = value;
        this._cdr.markForCheck();
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    IgxDatePickerComponent.prototype.registerOnChange = /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._onChangeCallback = fn; };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    IgxDatePickerComponent.prototype.registerOnTouched = /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._onTouchedCallback = fn; };
    /** @hidden */
    /**
     * @hidden
     * @return {?}
     */
    IgxDatePickerComponent.prototype.getEditElement = /**
     * @hidden
     * @return {?}
     */
    function () {
        /** @type {?} */
        var inputElement;
        if (this.mode === InteractionMode.DropDown) {
            inputElement = (this.editableInput) ? this.editableInput : this.input;
        }
        else {
            inputElement = (this.readonlyInput) ? this.readonlyInput : this.input;
        }
        return (inputElement) ? inputElement.nativeElement : null;
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxDatePickerComponent.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        this._positionSettings = {
            openAnimation: fadeIn,
            closeAnimation: fadeOut
        };
        /** @type {?} */
        var outlet = (this.outlet !== undefined) ? this.outlet : this.outletDirective;
        this._dropDownOverlaySettings = {
            closeOnOutsideClick: true,
            modal: false,
            scrollStrategy: new AbsoluteScrollStrategy(),
            positionStrategy: new AutoPositionStrategy(this._positionSettings),
            outlet: outlet
        };
        this._modalOverlaySettings = {
            closeOnOutsideClick: true,
            modal: true,
            outlet: outlet
        };
        this._overlayService.onOpening.pipe(filter(function (overlay) { return overlay.id === _this._componentID; }), takeUntil(this._destroy$)).subscribe(function (eventArgs) {
            _this._onOpening(eventArgs);
        });
        this._overlayService.onOpened.pipe(filter(function (overlay) { return overlay.id === _this._componentID; }), takeUntil(this._destroy$)).subscribe(function (eventArgs) {
            _this._onOpened(eventArgs);
        });
        this._overlayService.onClosed.pipe(filter(function (overlay) { return overlay.id === _this._componentID; }), takeUntil(this._destroy$)).subscribe(function () {
            _this._onClosed();
        });
        if (this.mode === InteractionMode.DropDown) {
            this.dateFormatParts = DatePickerUtil.parseDateFormat(this.mask, this.locale);
            if (this.mask === undefined) {
                this.mask = DatePickerUtil.getMask(this.dateFormatParts);
            }
            this.inputMask = DatePickerUtil.getInputMask(this.dateFormatParts);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxDatePickerComponent.prototype.ngAfterViewInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.mode === InteractionMode.DropDown && this.editableInput) {
            fromEvent(this.editableInput.nativeElement, 'keydown').pipe(throttle(function () { return interval(0, animationFrameScheduler); }), takeUntil(this._destroy$)).subscribe(function (res) { return _this.onKeyDown(res); });
        }
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxDatePickerComponent.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (this._componentID) {
            this._overlayService.hide(this._componentID);
        }
        this._destroy$.next(true);
        this._destroy$.complete();
    };
    /**
     *Selects today's date from calendar and change the input field value, @calendar.viewDate and @calendar.value.
     *```typescript
     *@ViewChild("MyDatePicker")
     *public datePicker: IgxDatePickerComponent;
     *ngAfterViewInit(){
     *this.datePicker.triggerTodaySelection();
     *}
     *```
     *@memberOf {@link IgxDatePickerComponent}
     */
    /**
     * Selects today's date from calendar and change the input field value, \@calendar.viewDate and \@calendar.value.
     * ```typescript
     * \@ViewChild("MyDatePicker")
     * public datePicker: IgxDatePickerComponent;
     * ngAfterViewInit(){
     * this.datePicker.triggerTodaySelection();
     * }
     * ```
     * \@memberOf {\@link IgxDatePickerComponent}
     * @return {?}
     */
    IgxDatePickerComponent.prototype.triggerTodaySelection = /**
     * Selects today's date from calendar and change the input field value, \@calendar.viewDate and \@calendar.value.
     * ```typescript
     * \@ViewChild("MyDatePicker")
     * public datePicker: IgxDatePickerComponent;
     * ngAfterViewInit(){
     * this.datePicker.triggerTodaySelection();
     * }
     * ```
     * \@memberOf {\@link IgxDatePickerComponent}
     * @return {?}
     */
    function () {
        /** @type {?} */
        var today = new Date(Date.now());
        this.handleSelection(today);
    };
    /**
     * Change the calendar selection and calling this method will emit the @calendar.onSelection event,
     * which will fire @handleSelection method.
     *```typescript
     *@ViewChild("MyDatePicker")
     *public datePicker: IgxDatePickerComponent;
     *ngAfterViewInit(){
     *this.datePicker.selectDate(this.date);
     *}
     * ```
     * @param date passed date that has to be set to the calendar.
     * @memberOf {@link IgxDatePickerComponent}
     */
    /**
     * Change the calendar selection and calling this method will emit the \@calendar.onSelection event,
     * which will fire \@handleSelection method.
     * ```typescript
     * \@ViewChild("MyDatePicker")
     * public datePicker: IgxDatePickerComponent;
     * ngAfterViewInit(){
     * this.datePicker.selectDate(this.date);
     * }
     * ```
     * \@memberOf {\@link IgxDatePickerComponent}
     * @param {?} date passed date that has to be set to the calendar.
     * @return {?}
     */
    IgxDatePickerComponent.prototype.selectDate = /**
     * Change the calendar selection and calling this method will emit the \@calendar.onSelection event,
     * which will fire \@handleSelection method.
     * ```typescript
     * \@ViewChild("MyDatePicker")
     * public datePicker: IgxDatePickerComponent;
     * ngAfterViewInit(){
     * this.datePicker.selectDate(this.date);
     * }
     * ```
     * \@memberOf {\@link IgxDatePickerComponent}
     * @param {?} date passed date that has to be set to the calendar.
     * @return {?}
     */
    function (date) {
        this.value = date;
        this.onSelection.emit(date);
        this._onChangeCallback(date);
    };
    /**
     * Deselects the calendar date.
     *```typescript
     *@ViewChild("MyDatePicker")
     *public datePicker: IgxDatePickerComponent;
     *ngAfterViewInit(){
     *this.datePicker.deselectDate();
     *}
     * ```
     * @memberOf {@link IgxDatePickerComponent}
     */
    /**
     * Deselects the calendar date.
     * ```typescript
     * \@ViewChild("MyDatePicker")
     * public datePicker: IgxDatePickerComponent;
     * ngAfterViewInit(){
     * this.datePicker.deselectDate();
     * }
     * ```
     * \@memberOf {\@link IgxDatePickerComponent}
     * @return {?}
     */
    IgxDatePickerComponent.prototype.deselectDate = /**
     * Deselects the calendar date.
     * ```typescript
     * \@ViewChild("MyDatePicker")
     * public datePicker: IgxDatePickerComponent;
     * ngAfterViewInit(){
     * this.datePicker.deselectDate();
     * }
     * ```
     * \@memberOf {\@link IgxDatePickerComponent}
     * @return {?}
     */
    function () {
        this.value = null;
        if (this.calendar) {
            this.calendar.deselectDate();
        }
        this._onChangeCallback(null);
    };
    /**
     * Open the calendar.
     *
     * @hidden
     */
    /**
     * Open the calendar.
     *
     * @hidden
     * @return {?}
     */
    IgxDatePickerComponent.prototype.openDialog = /**
     * Open the calendar.
     *
     * @hidden
     * @return {?}
     */
    function () {
        if (!this.collapsed) {
            return;
        }
        switch (this.mode) {
            case InteractionMode.Dialog: {
                this.hasHeader = true;
                /** @type {?} */
                var modalOverlay = (this.modalOverlaySettings !== undefined) ? this._modalOverlay : this._modalOverlaySettings;
                this._componentID = this._overlayService.attach(IgxCalendarContainerComponent, modalOverlay, this._moduleRef);
                this._overlayService.show(this._componentID, modalOverlay);
                break;
            }
            case InteractionMode.DropDown: {
                this.hasHeader = false;
                /** @type {?} */
                var dropDownOverlay = void 0;
                // dropdown overlay settings are modified via input
                if (this.dropDownOverlaySettings !== undefined) {
                    dropDownOverlay = this._dropDownOverlay;
                }
                else {
                    dropDownOverlay = this._dropDownOverlaySettings;
                    /** @type {?} */
                    var dropDownTarget = void 0;
                    if (this.editableInputGroup) {
                        dropDownTarget = this.editableInputGroup.nativeElement;
                    }
                    else {
                        if (this.templateDropDownTarget) {
                            // if the date picker is re-templated, set an element marked with #dropDownTarget as a target to the drop-down
                            dropDownTarget = this.templateDropDownTarget.nativeElement;
                        }
                        else {
                            throw new Error('There is no target element for the dropdown to attach. Mark an element with #dropDownTarget.');
                        }
                    }
                    dropDownOverlay.positionStrategy.settings.target = dropDownTarget;
                }
                this._componentID = this._overlayService.attach(IgxCalendarContainerComponent, dropDownOverlay, this._moduleRef);
                this._overlayService.show(this._componentID, dropDownOverlay);
                break;
            }
        }
    };
    /**
     * Close the calendar.
     *
     * @hidden
     */
    /**
     * Close the calendar.
     *
     * @hidden
     * @return {?}
     */
    IgxDatePickerComponent.prototype.closeCalendar = /**
     * Close the calendar.
     *
     * @hidden
     * @return {?}
     */
    function () {
        this._overlayService.hide(this._componentID);
    };
    /**
     * Clear the input field, date picker value and calendar selection.
     *
     * @hidden
     */
    /**
     * Clear the input field, date picker value and calendar selection.
     *
     * @hidden
     * @return {?}
     */
    IgxDatePickerComponent.prototype.clear = /**
     * Clear the input field, date picker value and calendar selection.
     *
     * @hidden
     * @return {?}
     */
    function () {
        this.isEmpty = true;
        this.invalidDate = '';
        this.deselectDate();
        this._setCursorPosition(0);
    };
    /**
     * Evaluates when @calendar.onSelection event was fired
     * and update the input value.
     *
     * @param event selected value from calendar.
     *
     * @hidden
     */
    /**
     * Evaluates when \@calendar.onSelection event was fired
     * and update the input value.
     *
     * @hidden
     * @param {?} date
     * @return {?}
     */
    IgxDatePickerComponent.prototype.handleSelection = /**
     * Evaluates when \@calendar.onSelection event was fired
     * and update the input value.
     *
     * @hidden
     * @param {?} date
     * @return {?}
     */
    function (date) {
        if (this.value) {
            date.setHours(this.value.getHours());
            date.setMinutes(this.value.getMinutes());
            date.setSeconds(this.value.getSeconds());
            date.setMilliseconds(this.value.getMilliseconds());
        }
        this.value = date;
        this.calendar.viewDate = date;
        this._onChangeCallback(date);
        this.closeCalendar();
        this.onSelection.emit(date);
    };
    /**
    * Evaluates when the input blur event was fired
    * and re-calculate the date picker value.
    *
    * @param event
    *
    * @hidden
    */
    /**
     * Evaluates when the input blur event was fired
     * and re-calculate the date picker value.
     *
     * @hidden
     * @param {?} event
     *
     * @return {?}
     */
    IgxDatePickerComponent.prototype.onBlur = /**
     * Evaluates when the input blur event was fired
     * and re-calculate the date picker value.
     *
     * @hidden
     * @param {?} event
     *
     * @return {?}
     */
    function (event) {
        this._isInEditMode = false;
        this.calculateDate(event.target.value, event.type);
    };
    /**
    * Evaluates when the input focus event was fired
    * and re-calculate the editor text.
    *
    * @param event
    * @hidden
    */
    /**
     * Evaluates when the input focus event was fired
     * and re-calculate the editor text.
     *
     * @hidden
     * @return {?}
     */
    IgxDatePickerComponent.prototype.onFocus = /**
     * Evaluates when the input focus event was fired
     * and re-calculate the editor text.
     *
     * @hidden
     * @return {?}
     */
    function () {
        this._isInEditMode = true;
        if (this.value && this.invalidDate === '') {
            this._transformedDate = this._getEditorDate(this.value);
        }
    };
    /**
    * Evaluates when the keydown event was fired for up/down keys
    * to provide spinning of date parts.
    *
    * @param event
    *
    * @hidden
    */
    /**
     * Evaluates when the keydown event was fired for up/down keys
     * to provide spinning of date parts.
     *
     * @hidden
     * @param {?} event
     *
     * @return {?}
     */
    IgxDatePickerComponent.prototype.onKeyDown = /**
     * Evaluates when the keydown event was fired for up/down keys
     * to provide spinning of date parts.
     *
     * @hidden
     * @param {?} event
     *
     * @return {?}
     */
    function (event) {
        switch (event.key) {
            case "ArrowUp" /* UP_ARROW */:
            case "Up" /* UP_ARROW_IE */:
                event.preventDefault();
                event.stopPropagation();
                this.spinValue(event.target.value, 1, event.type);
                break;
            case "ArrowDown" /* DOWN_ARROW */:
            case "Down" /* DOWN_ARROW_IE */:
                if (event.altKey) {
                    this.openDialog();
                }
                else {
                    event.preventDefault();
                    event.stopPropagation();
                    this.spinValue(event.target.value, -1, event.type);
                }
                break;
            default:
                break;
        }
    };
    /**
    * Evaluates when the mouse wheel event was fired
    * to provide spinning of date parts.
    *
    * @param event
    *
    * @hidden
    */
    /**
     * Evaluates when the mouse wheel event was fired
     * to provide spinning of date parts.
     *
     * @hidden
     * @param {?} event
     *
     * @return {?}
     */
    IgxDatePickerComponent.prototype.onWheel = /**
     * Evaluates when the mouse wheel event was fired
     * to provide spinning of date parts.
     *
     * @hidden
     * @param {?} event
     *
     * @return {?}
     */
    function (event) {
        if (this._isInEditMode) {
            event.preventDefault();
            event.stopPropagation();
            /** @type {?} */
            var sign = (event.deltaY > 0) ? -1 : 1;
            this.spinValue(event.target.value, sign, event.type);
        }
    };
    /**
    * Evaluates when input event was fired in editor.
    *
    * @param event
    *
    * @hidden
    */
    /**
     * Evaluates when input event was fired in editor.
     *
     * @hidden
     * @param {?} event
     *
     * @return {?}
     */
    IgxDatePickerComponent.prototype.onInput = /**
     * Evaluates when input event was fired in editor.
     *
     * @hidden
     * @param {?} event
     *
     * @return {?}
     */
    function (event) {
        var _this = this;
        /** @type {?} */
        var targetValue = event.target.value;
        /** @type {?} */
        var cursorPosition = this._getCursorPosition();
        /** @type {?} */
        var checkInput = DatePickerUtil.checkForCompleteDateInput(this.dateFormatParts, targetValue);
        this._isInEditMode = true;
        if (targetValue !== DatePickerUtil.maskToPromptChars(this.inputMask)) {
            this.isEmpty = false;
        }
        // If all date parts are completed, change the date-picker value, stay in edit mode
        if (checkInput === 'complete' && event.inputType !== 'deleteContentBackward') {
            this._transformedDate = targetValue;
            this.calculateDate(targetValue, event.type);
            this._setCursorPosition(cursorPosition);
        }
        else if (checkInput === 'partial') {
            // While editing, if one date part is deleted, date-picker value is set to null, the remaining input stays intact.
            this.deselectDate();
            requestAnimationFrame(function () {
                _this.getEditElement().value = targetValue;
                _this._setCursorPosition(cursorPosition);
            });
        }
        else if (checkInput === 'empty') {
            // Total clean-up as input is deleted.
            this.isEmpty = true;
            this.deselectDate();
        }
    };
    /**
     * @private
     * @param {?} dateString
     * @param {?} invokedByEvent
     * @return {?}
     */
    IgxDatePickerComponent.prototype.calculateDate = /**
     * @private
     * @param {?} dateString
     * @param {?} invokedByEvent
     * @return {?}
     */
    function (dateString, invokedByEvent) {
        if (dateString !== '') {
            /** @type {?} */
            var prevDateValue = this.value;
            /** @type {?} */
            var inputValue = (invokedByEvent === 'blur') ? this.rawDateString : dateString;
            /** @type {?} */
            var newDateArray = DatePickerUtil.parseDateArray(this.dateFormatParts, prevDateValue, inputValue);
            if (newDateArray.state === "valid" /* Valid */) {
                /** @type {?} */
                var newValue = newDateArray.date;
                // Restore the time part if any
                if (prevDateValue) {
                    newValue.setHours(prevDateValue.getHours());
                    newValue.setMinutes(prevDateValue.getMinutes());
                    newValue.setSeconds(prevDateValue.getSeconds());
                    newValue.setMilliseconds(prevDateValue.getMilliseconds());
                }
                if (this.disabledDates === null
                    || (this.disabledDates !== null && !isDateInRanges(newValue, this.disabledDates))) {
                    this.value = newValue;
                    this.invalidDate = '';
                    this._onChangeCallback(newValue);
                }
                else {
                    /** @type {?} */
                    var args = {
                        datePicker: this,
                        currentValue: newValue,
                    };
                    this.onDisabledDate.emit(args);
                }
            }
            else {
                /** @type {?} */
                var args = {
                    datePicker: this,
                    prevValue: prevDateValue
                };
                this.invalidDate = dateString;
                this.onValidationFailed.emit(args);
            }
        }
    };
    /**
     * @private
     * @param {?} inputValue
     * @param {?} sign
     * @param {?} eventType
     * @return {?}
     */
    IgxDatePickerComponent.prototype.spinValue = /**
     * @private
     * @param {?} inputValue
     * @param {?} sign
     * @param {?} eventType
     * @return {?}
     */
    function (inputValue, sign, eventType) {
        this._isInEditMode = true;
        this.isEmpty = false;
        /** @type {?} */
        var cursorPosition = this._getCursorPosition();
        /** @type {?} */
        var modifiedInputValue = DatePickerUtil.getModifiedDateInput(this.dateFormatParts, inputValue, cursorPosition, this.spinDelta * sign, this.isSpinLoop);
        this.getEditElement().value = modifiedInputValue;
        this._setCursorPosition(cursorPosition);
        /** @type {?} */
        var checkInput = DatePickerUtil.checkForCompleteDateInput(this.dateFormatParts, modifiedInputValue);
        if (checkInput === 'complete') {
            this._isInEditMode = true;
            this.calculateDate(modifiedInputValue, eventType);
            this._setCursorPosition(cursorPosition);
        }
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    IgxDatePickerComponent.prototype._onOpening = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this._initializeCalendarContainer(event.componentRef.instance);
        this.collapsed = false;
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    IgxDatePickerComponent.prototype._onOpened = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this._onTouchedCallback();
        this.onOpen.emit(this);
        if (this.calendar) {
            this._focusCalendarDate();
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxDatePickerComponent.prototype._onClosed = /**
     * @private
     * @return {?}
     */
    function () {
        this.collapsed = true;
        this._componentID = null;
        this.onClose.emit(this);
        if (this.getEditElement()) {
            this.getEditElement().focus();
        }
    };
    /**
     * @private
     * @param {?} componentInstance
     * @return {?}
     */
    IgxDatePickerComponent.prototype._initializeCalendarContainer = /**
     * @private
     * @param {?} componentInstance
     * @return {?}
     */
    function (componentInstance) {
        var _this = this;
        this.calendar = componentInstance.calendar;
        /** @type {?} */
        var isVertical = (this.vertical && this.mode === InteractionMode.Dialog);
        this.calendar.hasHeader = this.hasHeader;
        this.calendar.formatOptions = this.formatOptions;
        this.calendar.formatViews = this.formatViews;
        this.calendar.locale = this.locale;
        this.calendar.vertical = isVertical;
        this.calendar.weekStart = this.weekStart;
        this.calendar.specialDates = this.specialDates;
        this.calendar.disabledDates = this.disabledDates;
        this.calendar.headerTemplate = this.headerTemplate;
        this.calendar.subheaderTemplate = this.subheaderTemplate;
        this.calendar.onSelection.pipe(takeUntil(this._destroy$)).subscribe(function (ev) { return _this.handleSelection(ev); });
        if (this.value) {
            this.calendar.value = this.value;
            this.calendar.viewDate = this.value;
        }
        componentInstance.mode = this.mode;
        componentInstance.vertical = isVertical;
        componentInstance.cancelButtonLabel = this.cancelButtonLabel;
        componentInstance.todayButtonLabel = this.todayButtonLabel;
        componentInstance.onClose.pipe(takeUntil(this._destroy$)).subscribe(function () { return _this.closeCalendar(); });
        componentInstance.onTodaySelection.pipe(takeUntil(this._destroy$)).subscribe(function () { return _this.triggerTodaySelection(); });
    };
    // Focus a date, after the calendar appearance into DOM.
    // Focus a date, after the calendar appearance into DOM.
    /**
     * @private
     * @return {?}
     */
    IgxDatePickerComponent.prototype._focusCalendarDate = 
    // Focus a date, after the calendar appearance into DOM.
    /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        requestAnimationFrame(function () {
            _this.calendar.daysView.focusActiveDate();
        });
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    IgxDatePickerComponent.prototype._setLocaleToDate = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return value.toLocaleDateString(this.locale);
    };
    /**
     * @private
     * @return {?}
     */
    IgxDatePickerComponent.prototype._getCursorPosition = /**
     * @private
     * @return {?}
     */
    function () {
        return this.getEditElement().selectionStart;
    };
    /**
     * @private
     * @param {?} start
     * @param {?=} end
     * @return {?}
     */
    IgxDatePickerComponent.prototype._setCursorPosition = /**
     * @private
     * @param {?} start
     * @param {?=} end
     * @return {?}
     */
    function (start, end) {
        var _this = this;
        if (end === void 0) { end = start; }
        requestAnimationFrame(function () {
            _this.getEditElement().setSelectionRange(start, end);
        });
    };
    /**
     * Apply custom user formatter upon date.
     * @param formatter custom formatter function.
     * @param date passed date
     */
    /**
     * Apply custom user formatter upon date.
     * @private
     * @param {?} formatter custom formatter function.
     * @param {?} date passed date
     * @return {?}
     */
    IgxDatePickerComponent.prototype._customFormatChecker = /**
     * Apply custom user formatter upon date.
     * @private
     * @param {?} formatter custom formatter function.
     * @param {?} date passed date
     * @return {?}
     */
    function (formatter, date) {
        return this.formatter ? this.formatter(date) : this._setLocaleToDate(date);
    };
    /*
    * Transforms the date according to the specified format when `IgxDatePickerComponent` is in edit mode
    * using @angular/common formatDate method: https://angular.io/api/common/formatDate
    * @param  value: string | number | Date
    * @returns formatted string
    */
    /*
        * Transforms the date according to the specified format when `IgxDatePickerComponent` is in edit mode
        * using @angular/common formatDate method: https://angular.io/api/common/formatDate
        * @param  value: string | number | Date
        * @returns formatted string
        */
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    IgxDatePickerComponent.prototype._getDisplayDate = /*
        * Transforms the date according to the specified format when `IgxDatePickerComponent` is in edit mode
        * using @angular/common formatDate method: https://angular.io/api/common/formatDate
        * @param  value: string | number | Date
        * @returns formatted string
        */
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (this.format && !this.formatter) {
            /** @type {?} */
            var locale = this.locale || this.defaultLocale;
            return formatDate(value, this.format, locale);
        }
        else {
            return this._customFormatChecker(this.formatter, value);
        }
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    IgxDatePickerComponent.prototype._getEditorDate = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var locale = this.locale || this.defaultLocale;
        /** @type {?} */
        var changedValue = (value) ? formatDate(value, this.mask, locale) : '';
        return DatePickerUtil.addPromptCharsEditMode(this.dateFormatParts, this.value, changedValue);
    };
    IgxDatePickerComponent.decorators = [
        { type: Component, args: [{
                    providers: [{
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: IgxDatePickerComponent,
                            multi: true
                        }],
                    // tslint:disable-next-line:component-selector
                    selector: 'igx-date-picker',
                    template: "<ng-template #readOnlyDatePickerTemplate>\n    <igx-input-group (click)=\"openDialog()\">\n        <igx-prefix>\n            <igx-icon>today</igx-icon>\n        </igx-prefix>\n        <label *ngIf=\"labelVisibility\" igxLabel>{{label}}</label>\n        <input #readonlyInput class=\"igx-date-picker__input-date\" igxInput [value]=\"displayData || ''\"\n            [disabled]=\"disabled\" readonly />\n    </igx-input-group>\n</ng-template>\n\n<ng-template #editableDatePickerTemplate>\n    <igx-input-group #editableInputGroup [supressInputAutofocus]=\"true\">\n        <igx-prefix (click)=\"openDialog()\">\n            <igx-icon>today</igx-icon>\n        </igx-prefix>\n        <label *ngIf=\"labelVisibility\" igxLabel>{{label}}</label>\n        <input #editableInput class=\"igx-date-picker__input-date\" igxInput type=\"text\" [value]=\"transformedDate\"\n            [igxMask]=\"inputMask\" [placeholder]=\"mask\" [disabled]=\"disabled\" [displayValuePipe]=\"displayValuePipe\"\n            [focusedValuePipe]=\"inputValuePipe\" (blur)=\"onBlur($event)\" (wheel)=\"onWheel($event)\"\n            (input)=\"onInput($event)\" (focus)=\"onFocus()\" />\n        <igx-suffix *ngIf=\"!isEmpty\" (click)=\"clear()\">\n            <igx-icon>clear</igx-icon>\n        </igx-suffix>\n    </igx-input-group>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template; context: context\"></ng-container>\n<div igxOverlayOutlet #datePickerOutlet></div>",
                    styles: ["\n        :host {\n            display: block;\n        }\n    "]
                }] }
    ];
    /** @nocollapse */
    IgxDatePickerComponent.ctorParameters = function () { return [
        { type: IgxOverlayService, decorators: [{ type: Inject, args: [IgxOverlayService,] }] },
        { type: ElementRef },
        { type: ChangeDetectorRef },
        { type: NgModuleRef }
    ]; };
    IgxDatePickerComponent.propDecorators = {
        label: [{ type: Input }],
        labelVisibility: [{ type: Input }],
        locale: [{ type: Input }],
        weekStart: [{ type: Input }],
        formatOptions: [{ type: Input }],
        format: [{ type: Input }],
        mask: [{ type: Input }],
        formatViews: [{ type: Input }],
        disabledDates: [{ type: Input }],
        specialDates: [{ type: Input }],
        modalOverlaySettings: [{ type: Input }],
        dropDownOverlaySettings: [{ type: Input }],
        value: [{ type: Input }],
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        formatter: [{ type: Input }],
        disabled: [{ type: Input }],
        vertical: [{ type: Input }],
        todayButtonLabel: [{ type: Input }],
        cancelButtonLabel: [{ type: Input }],
        mode: [{ type: Input }],
        isSpinLoop: [{ type: Input }],
        outlet: [{ type: Input }],
        onOpen: [{ type: Output }],
        onClose: [{ type: Output }],
        onSelection: [{ type: Output }],
        onDisabledDate: [{ type: Output }],
        onValidationFailed: [{ type: Output }],
        outletDirective: [{ type: ViewChild, args: ['datePickerOutlet', { read: ElementRef },] }],
        readOnlyDatePickerTemplate: [{ type: ViewChild, args: ['readOnlyDatePickerTemplate', { read: TemplateRef },] }],
        editableDatePickerTemplate: [{ type: ViewChild, args: ['editableDatePickerTemplate', { read: TemplateRef },] }],
        editableInputGroup: [{ type: ViewChild, args: ['editableInputGroup', { read: ElementRef },] }],
        templateDropDownTarget: [{ type: ContentChild, args: ['dropDownTarget', { read: ElementRef },] }],
        editableInput: [{ type: ViewChild, args: ['editableInput', { read: ElementRef },] }],
        readonlyInput: [{ type: ViewChild, args: ['readonlyInput', { read: ElementRef },] }],
        input: [{ type: ContentChild, args: [IgxInputDirective,] }],
        datePickerTemplateDirective: [{ type: ContentChild, args: [IgxDatePickerTemplateDirective, { read: IgxDatePickerTemplateDirective },] }],
        headerTemplate: [{ type: ContentChild, args: [IgxCalendarHeaderTemplateDirective, { read: IgxCalendarHeaderTemplateDirective },] }],
        subheaderTemplate: [{ type: ContentChild, args: [IgxCalendarSubheaderTemplateDirective, { read: IgxCalendarSubheaderTemplateDirective },] }],
        onSpaceClick: [{ type: HostListener, args: ['keydown.spacebar', ['$event'],] }, { type: HostListener, args: ['keydown.space', ['$event'],] }]
    };
    return IgxDatePickerComponent;
}());
/**
 * @hidden
 */
var IgxDatePickerModule = /** @class */ (function () {
    function IgxDatePickerModule() {
    }
    IgxDatePickerModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxDatePickerComponent, IgxCalendarContainerComponent,
                        IgxDatePickerTemplateDirective, DatePickerDisplayValuePipe, DatePickerInputValuePipe],
                    exports: [IgxDatePickerComponent, IgxDatePickerTemplateDirective, DatePickerDisplayValuePipe, DatePickerInputValuePipe],
                    imports: [CommonModule, IgxIconModule, IgxInputGroupModule, IgxCalendarModule, IgxButtonModule, IgxRippleModule, IgxMaskModule],
                    entryComponents: [IgxCalendarContainerComponent]
                },] }
    ];
    return IgxDatePickerModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxDialogTitleDirective = /** @class */ (function () {
    function IgxDialogTitleDirective() {
        this.defaultStyle = true;
    }
    IgxDialogTitleDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'igx-dialog-title,[igxDialogTitle]'
                },] }
    ];
    IgxDialogTitleDirective.propDecorators = {
        defaultStyle: [{ type: HostBinding, args: ['class.igx-dialog__window-title',] }]
    };
    return IgxDialogTitleDirective;
}());
/**
 * @hidden
 */
var IgxDialogActionsDirective = /** @class */ (function () {
    function IgxDialogActionsDirective() {
        this.defaultClass = true;
    }
    IgxDialogActionsDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'igx-dialog-actions,[igxDialogActions]'
                },] }
    ];
    IgxDialogActionsDirective.propDecorators = {
        defaultClass: [{ type: HostBinding, args: ['class.igx-dialog__window-actions',] }]
    };
    return IgxDialogActionsDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var DIALOG_ID = 0;
/**
 * **Ignite UI for Angular Dialog Window** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/dialog.html)
 *
 * The Ignite UI Dialog Window presents a dialog window to the user which can simply display messages or display
 * more complicated visuals such as a user sign-in form.  It also provides a right and left button
 * which can be used for custom actions.
 *
 * Example:
 * ```html
 * <button (click)="form.open()">Show Dialog</button>
 * <igx-dialog #form title="Sign In" rightButtonLabel="OK">
 *   <div>
 *     <input type="text" igxInput/>
 *     <label igxLabel>Username</label>
 *   </div>
 *   <div>
 *     <input type="password" igxInput/>
 *     <label igxLabel>Password</label>
 *   </div>
 * </igx-dialog>
 * ```
 */
var IgxDialogComponent = /** @class */ (function () {
    function IgxDialogComponent(elementRef, navService) {
        this.elementRef = elementRef;
        this.navService = navService;
        /**
         * An \@Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-dialog [id]="'igx-dialog-56'" #alert title="Notification" leftButtonLabel="OK" (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.id = "igx-dialog-" + DIALOG_ID++;
        /**
         * An \@Input property controlling the `title` of the dialog.
         * ```html
         * <igx-dialog title="Notification" #alert leftButtonLabel="OK" (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.title = '';
        /**
         *  An \@Input property controlling the `message` of the dialog.
         * ```html
         * <igx-dialog message="Your email was sent!" #alert leftButtonLabel="OK" (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.message = '';
        /**
         * An \@Input property to set the `label` of the left button of the dialog.
         * ```html
         * <igx-dialog leftButtonLabel="OKAY" #alert title="Notification"  (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.leftButtonLabel = '';
        /**
         * An \@Input property to set the left button `type`. The types are `flat`, `raised` and `fab`.
         * The `flat` type button is a rectangle and doesn't have a shadow. <br>
         * The `raised` type button is also a rectangle but has a shadow. <br>
         * The `fab` type button is a circle with a shadow. <br>
         * The default value is `flat`.
         * ```html
         * <igx-dialog leftButtonType="raised" leftButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.leftButtonType = 'flat';
        /**
         * An \@Input property to set the left button color. The property accepts all valid CSS color property values.
         * ```html
         * <igx-dialog leftButtonColor="yellow" leftButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.leftButtonColor = '';
        /**
         * An \@Input property to set the left button `background-color`. The property accepts all valid CSS color property values.
         * ```html
         * <igx-dialog leftButtonBackgroundColor="black" leftButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.leftButtonBackgroundColor = '';
        /**
         * An \@Input property to set the left button `ripple`. The `ripple` animates a click/tap to a component as a series of fading waves.
         * The property accepts all valid CSS color property values.
         * ```html
         * <igx-dialog leftButtonRipple="green" leftButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.leftButtonRipple = '';
        /**
         * An \@Input property to set the `label` of the right button of the dialog.
         * ```html
         * <igx-dialog rightButtonLabel="OKAY" #alert title="Notification"  (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.rightButtonLabel = '';
        /**
         * An \@Input property to set the right button `type`. The types are `flat`, `raised` and `fab`.
         * The `flat` type button is a rectangle and doesn't have a shadow. <br>
         * The `raised` type button is also a rectangle but has a shadow. <br>
         * The `fab` type button is a circle with a shadow. <br>
         * The default value is `flat`.
         * ```html
         * <igx-dialog rightButtonType="fab" rightButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.rightButtonType = 'flat';
        /**
         * An \@Input property to set the right button `color`. The property accepts all valid CSS color property values.
         * ```html
         * <igx-dialog rightButtonColor="yellow" rightButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.rightButtonColor = '';
        /**
         * An \@Input property to set the right button `background-color`. The property accepts all valid CSS color property values.
         * ```html
         * <igx-dialog rightButtonBackgroundColor="black" rightButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.rightButtonBackgroundColor = '';
        /**
         * An \@Input property to set the right button `ripple`.
         * ```html
         * <igx-dialog rightButtonRipple="green" rightButtonLabel="OKAY" #alert (onLeftButtonSelect)="alert.close()"></igx-dialog>
         * ```
         */
        this.rightButtonRipple = '';
        /**
         * An event that is emitted when the dialog is opened.
         * ```html
         * <igx-dialog (onOpen)="onDialogOpenHandler($event)" (onLeftButtonSelect)="dialog.close()" rightButtonLabel="OK">
         * </igx-dialog>
         * ```
         */
        this.onOpen = new EventEmitter();
        /**
         * An event that is emitted when the dialog is closed.
         * ```html
         * <igx-dialog (onClose)="onDialogCloseHandler($event)" title="Confirmation" leftButtonLabel="Cancel" rightButtonLabel="OK">
         * </igx-dialog>
         * ```
         */
        this.onClose = new EventEmitter();
        /**
         * An event that is emitted when the left button is clicked.
         * ```html
         * <igx-dialog (onLeftButtonSelect)="onDialogOKSelected($event)" #dialog leftButtonLabel="OK" rightButtonLabel="Cancel">
         * </igx-dialog>
         * ```
         */
        this.onLeftButtonSelect = new EventEmitter();
        /**
         * An event that is emitted when the right button is clicked.
         * ```html
         * <igx-dialog (onRightButtonSelect)="onDialogOKSelected($event)"
         * #dialog title="Confirmation" (onLeftButtonSelect)="dialog.close()" rightButtonLabel="OK"
         * rightButtonRipple="#4CAF50" closeOnOutsideSelect="true">
         * </igx-dialog>
         * ```
         */
        this.onRightButtonSelect = new EventEmitter();
        this._animaitonSettings = {
            openAnimation: useAnimation(slideInBottom, { params: { fromPosition: 'translateY(100%)' } }),
            closeAnimation: useAnimation(slideOutTop, { params: { toPosition: 'translateY(-100%)' } })
        };
        this._closeOnOutsideSelect = false;
        this._isModal = true;
        this.destroy$ = new Subject();
        /**
         * The default `tabindex` attribute for the component
         *
         * @hidden
         */
        this.tabindex = -1;
        this._titleId = IgxDialogComponent.NEXT_ID++ + '_title';
        this._overlayDefaultSettings = {
            positionStrategy: new GlobalPositionStrategy(this._animaitonSettings),
            scrollStrategy: new NoOpScrollStrategy(),
            modal: this.isModal,
            closeOnOutsideClick: this.closeOnOutsideSelect
        };
    }
    Object.defineProperty(IgxDialogComponent.prototype, "isModal", {
        get: /**
         * @return {?}
         */
        function () {
            return this._isModal;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._overlayDefaultSettings.modal = val;
            this._isModal = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDialogComponent.prototype, "closeOnOutsideSelect", {
        /**
         * An @Input property that allows you to enable the "close on click outside the dialog". By default it's disabled.
         *```html
         *<igx-dialog closeOnOutsideSelect="true" leftButtonLabel="Cancel" (onLeftButtonSelect)="dialog.close()"
         *rightButtonLabel="OK" rightButtonRipple="#4CAF50" (onRightButtonSelect)="onDialogOKSelected($event)">
         *</igx-dialog>
         *```
         */
        get: /**
         * An \@Input property that allows you to enable the "close on click outside the dialog". By default it's disabled.
         * ```html
         * <igx-dialog closeOnOutsideSelect="true" leftButtonLabel="Cancel" (onLeftButtonSelect)="dialog.close()"
         * rightButtonLabel="OK" rightButtonRipple="#4CAF50" (onRightButtonSelect)="onDialogOKSelected($event)">
         * </igx-dialog>
         * ```
         * @return {?}
         */
        function () {
            return this._closeOnOutsideSelect;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._overlayDefaultSettings.closeOnOutsideClick = val;
            this._closeOnOutsideSelect = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDialogComponent.prototype, "element", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDialogComponent.prototype, "state", {
        /**
         * Returns the value of state. Possible state values are "open" or "close".
         *```typescript
         *@ViewChild("MyDialog")
         *public dialog: IgxDialogComponent;
         *ngAfterViewInit() {
         *    let dialogState = this.dialog.state;
         *}
         *```
         */
        get: /**
         * Returns the value of state. Possible state values are "open" or "close".
         * ```typescript
         * \@ViewChild("MyDialog")
         * public dialog: IgxDialogComponent;
         * ngAfterViewInit() {
         *    let dialogState = this.dialog.state;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this.isOpen ? 'open' : 'close';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDialogComponent.prototype, "isOpen", {
        /**
         * Returns whether the dialog is visible to the end user.
         *```typescript
         *@ViewChild("MyDialog")
         *public dialog: IgxDialogComponent;
         *ngAfterViewInit() {
         *    let dialogOpen = this.dialog.isOpen;
         *}
         * ```
         */
        get: /**
         * Returns whether the dialog is visible to the end user.
         * ```typescript
         * \@ViewChild("MyDialog")
         * public dialog: IgxDialogComponent;
         * ngAfterViewInit() {
         *    let dialogOpen = this.dialog.isOpen;
         * }
         * ```
         * @return {?}
         */
        function () {
            return !this.toggleRef.collapsed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDialogComponent.prototype, "isCollapsed", {
        get: /**
         * @return {?}
         */
        function () {
            return this.toggleRef.collapsed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDialogComponent.prototype, "role", {
        /**
         *Returns the value of the role of the dialog. The valid values are `dialog`, `alertdialog`, `alert`.
         *```typescript
         *@ViewChild("MyDialog")
         *public dialog: IgxDialogComponent;
         *ngAfterViewInit() {
         *    let dialogRole = this.dialog.role;
         *}
         * ```
         */
        get: /**
         * Returns the value of the role of the dialog. The valid values are `dialog`, `alertdialog`, `alert`.
         * ```typescript
         * \@ViewChild("MyDialog")
         * public dialog: IgxDialogComponent;
         * ngAfterViewInit() {
         *    let dialogRole = this.dialog.role;
         * }
         * ```
         * @return {?}
         */
        function () {
            if (this.leftButtonLabel !== '' && this.rightButtonLabel !== '') {
                return 'dialog';
            }
            else if (this.leftButtonLabel !== '' ||
                this.rightButtonLabel !== '') {
                return 'alertdialog';
            }
            else {
                return 'alert';
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDialogComponent.prototype, "titleId", {
        /**
         *Returns the value of the title id.
         *```typescript
         *@ViewChild("MyDialog")
         *public dialog: IgxDialogComponent;
         *ngAfterViewInit() {
         *    let dialogTitle = this.dialog.titleId;
         *}
         * ```
         */
        get: /**
         * Returns the value of the title id.
         * ```typescript
         * \@ViewChild("MyDialog")
         * public dialog: IgxDialogComponent;
         * ngAfterViewInit() {
         *    let dialogTitle = this.dialog.titleId;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this._titleId;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    IgxDialogComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.toggleRef.onClosing.pipe(takeUntil(this.destroy$)).subscribe(function () { return _this.emitCloseFromDialog(); });
    };
    /**
     * @private
     * @return {?}
     */
    IgxDialogComponent.prototype.emitCloseFromDialog = /**
     * @private
     * @return {?}
     */
    function () {
        this.onClose.emit({ dialog: this, event: null });
    };
    /**
     * A method that opens the dialog.
     * @memberOf {@link IgxDialogComponent}
     *```html
     *<button (click)="dialog.open() igxButton="raised" igxButtonColor="white" igxRipple="white">Trigger Dialog</button>
     *<igx-dialog #dialog></igx-dialog>
     *```
     */
    /**
     * A method that opens the dialog.
     * \@memberOf {\@link IgxDialogComponent}
     * ```html
     * <button (click)="dialog.open() igxButton="raised" igxButtonColor="white" igxRipple="white">Trigger Dialog</button>
     * <igx-dialog #dialog></igx-dialog>
     * ```
     * @param {?=} overlaySettings
     * @return {?}
     */
    IgxDialogComponent.prototype.open = /**
     * A method that opens the dialog.
     * \@memberOf {\@link IgxDialogComponent}
     * ```html
     * <button (click)="dialog.open() igxButton="raised" igxButtonColor="white" igxRipple="white">Trigger Dialog</button>
     * <igx-dialog #dialog></igx-dialog>
     * ```
     * @param {?=} overlaySettings
     * @return {?}
     */
    function (overlaySettings) {
        if (overlaySettings === void 0) { overlaySettings = this._overlayDefaultSettings; }
        this.toggleRef.open(overlaySettings);
        this.onOpen.emit({ dialog: this, event: null });
        if (!this.leftButtonLabel && !this.rightButtonLabel) {
            this.toggleRef.element.focus();
        }
    };
    /**
     *A method that that closes the dialog.
     *@memberOf {@link IgxDialogComponent}
     *```html
     *<button (click)="dialog.close() igxButton="raised" igxButtonColor="white" igxRipple="white">Trigger Dialog</button>
     *<igx-dialog #dialog></igx-dialog>
     *```
     */
    /**
     * A method that that closes the dialog.
     * \@memberOf {\@link IgxDialogComponent}
     * ```html
     * <button (click)="dialog.close() igxButton="raised" igxButtonColor="white" igxRipple="white">Trigger Dialog</button>
     * <igx-dialog #dialog></igx-dialog>
     * ```
     * @return {?}
     */
    IgxDialogComponent.prototype.close = /**
     * A method that that closes the dialog.
     * \@memberOf {\@link IgxDialogComponent}
     * ```html
     * <button (click)="dialog.close() igxButton="raised" igxButtonColor="white" igxRipple="white">Trigger Dialog</button>
     * <igx-dialog #dialog></igx-dialog>
     * ```
     * @return {?}
     */
    function () {
        // `onClose` will emit from `toggleRef.onClosing` subscription
        this.toggleRef.close();
    };
    /**
     * A method that opens/closes the dialog.
     *@memberOf {@link IgxDialogComponent}
     *```html
     *<button (click)="dialog.toggle() igxButton="raised" igxButtonColor="white" igxRipple="white">Trigger Dialog</button>
     *<igx-dialog #dialog></igx-dialog>
     *```
     */
    /**
     * A method that opens/closes the dialog.
     * \@memberOf {\@link IgxDialogComponent}
     * ```html
     * <button (click)="dialog.toggle() igxButton="raised" igxButtonColor="white" igxRipple="white">Trigger Dialog</button>
     * <igx-dialog #dialog></igx-dialog>
     * ```
     * @return {?}
     */
    IgxDialogComponent.prototype.toggle = /**
     * A method that opens/closes the dialog.
     * \@memberOf {\@link IgxDialogComponent}
     * ```html
     * <button (click)="dialog.toggle() igxButton="raised" igxButtonColor="white" igxRipple="white">Trigger Dialog</button>
     * <igx-dialog #dialog></igx-dialog>
     * ```
     * @return {?}
     */
    function () {
        this.isOpen ? this.close() : this.open();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxDialogComponent.prototype.onDialogSelected = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.stopPropagation();
        if (this.isOpen &&
            this.closeOnOutsideSelect &&
            event.target.classList.contains(IgxDialogComponent.DIALOG_CLASS)) {
            this.close();
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxDialogComponent.prototype.onInternalLeftButtonSelect = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onLeftButtonSelect.emit({ dialog: this, event: event });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxDialogComponent.prototype.onInternalRightButtonSelect = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onRightButtonSelect.emit({ dialog: this, event: event });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxDialogComponent.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (this.navService && this.id) {
            this.navService.add(this.id, this);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxDialogComponent.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (this.navService && this.id) {
            this.navService.remove(this.id);
        }
    };
    IgxDialogComponent.NEXT_ID = 1;
    IgxDialogComponent.DIALOG_CLASS = 'igx-dialog';
    IgxDialogComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-dialog',
                    template: "<div tabindex=\"0\" #dialog class=\"igx-dialog\" igxToggle (click)=\"onDialogSelected($event)\">\n    <div #dialogWindow class=\"igx-dialog__window\"  [attr.role]=\"role\" [attr.aria-labelledby]=\"titleId\">\n\n        <div *ngIf=\"title\" [attr.id]=\"titleId\" class=\"igx-dialog__window-title\">\n            {{ title }}\n        </div>\n        <ng-content *ngIf=\"!title\" select=\"igx-dialog-title,[igxDialogTitle]\"></ng-content>\n\n        <div class=\"igx-dialog__window-content\" *ngIf=\"message\">{{ message }}</div>\n        <ng-content *ngIf=\"!message\"></ng-content>\n\n        <div *ngIf=\"leftButtonLabel || rightButtonLabel\" class=\"igx-dialog__window-actions\">\n            <button *ngIf=\"leftButtonLabel\" type=\"button\" [igxFocus]=\"isOpen\" igxButton=\"{{ leftButtonType }}\" igxButtonColor=\"{{ leftButtonColor }}\" igxButtonBackground=\"{{ leftButtonBackgroundColor }}\"\n                igxRipple=\"{{ leftButtonRipple }}\" (click)=\"onInternalLeftButtonSelect($event)\">\n                {{ leftButtonLabel }}\n            </button>\n            <button *ngIf=\"rightButtonLabel\" type=\"button\" [igxFocus]=\"isOpen\" igxButton=\"{{ rightButtonType }}\" igxButtonColor=\"{{ rightButtonColor }}\" igxButtonBackground=\"{{ rightButtonBackgroundColor }}\"\n                igxRipple=\"{{ rightButtonRipple }}\" (click)=\"onInternalRightButtonSelect($event)\">\n                {{ rightButtonLabel }}\n            </button>\n        </div>\n        <ng-content *ngIf=\"!leftButtonLabel && !rightButtonLabel\" select=\"igx-dialog-actions,[igxDialogActions]\"></ng-content>\n\n    </div>\n</div>\n"
                }] }
    ];
    /** @nocollapse */
    IgxDialogComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: IgxNavigationService, decorators: [{ type: Optional }] }
    ]; };
    IgxDialogComponent.propDecorators = {
        toggleRef: [{ type: ViewChild, args: [IgxToggleDirective,] }],
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        isModal: [{ type: Input }],
        title: [{ type: Input }],
        message: [{ type: Input }],
        leftButtonLabel: [{ type: Input }],
        leftButtonType: [{ type: Input }],
        leftButtonColor: [{ type: Input }],
        leftButtonBackgroundColor: [{ type: Input }],
        leftButtonRipple: [{ type: Input }],
        rightButtonLabel: [{ type: Input }],
        rightButtonType: [{ type: Input }],
        rightButtonColor: [{ type: Input }],
        rightButtonBackgroundColor: [{ type: Input }],
        rightButtonRipple: [{ type: Input }],
        closeOnOutsideSelect: [{ type: Input }],
        onOpen: [{ type: Output }],
        onClose: [{ type: Output }],
        onLeftButtonSelect: [{ type: Output }],
        onRightButtonSelect: [{ type: Output }],
        tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
        isOpen: [{ type: Input }],
        isCollapsed: [{ type: HostBinding, args: ['class.igx-dialog--hidden',] }],
        role: [{ type: Input }],
        titleId: [{ type: Input }]
    };
    return IgxDialogComponent;
}());
/**
 * @hidden
 */
var IgxDialogModule = /** @class */ (function () {
    function IgxDialogModule() {
    }
    IgxDialogModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxDialogComponent, IgxDialogTitleDirective, IgxDialogActionsDirective],
                    exports: [IgxDialogComponent, IgxDialogTitleDirective, IgxDialogActionsDirective],
                    imports: [CommonModule, IgxToggleModule, IgxButtonModule, IgxRippleModule, IgxFocusModule]
                },] }
    ];
    return IgxDialogModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var clear = function (el) { return el === 0 || Boolean(el); };
/** @type {?} */
var first$1 = function (arr) { return arr[0]; };
/** @type {?} */
var last = function (arr) { return arr[arr.length - 1]; };
var IgxSummaryOperand = /** @class */ (function () {
    function IgxSummaryOperand() {
    }
    /**
     * Counts all the records in the data source.
     * If filtering is applied, counts only the filtered records.
     * ```typescript
     * IgxSummaryOperand.count(dataSource);
     * ```
     * @memberof IgxSummaryOperand
     */
    /**
     * Counts all the records in the data source.
     * If filtering is applied, counts only the filtered records.
     * ```typescript
     * IgxSummaryOperand.count(dataSource);
     * ```
     * \@memberof IgxSummaryOperand
     * @param {?} data
     * @return {?}
     */
    IgxSummaryOperand.count = /**
     * Counts all the records in the data source.
     * If filtering is applied, counts only the filtered records.
     * ```typescript
     * IgxSummaryOperand.count(dataSource);
     * ```
     * \@memberof IgxSummaryOperand
     * @param {?} data
     * @return {?}
     */
    function (data) {
        return data.length;
    };
    /**
     * Executes the static `count` method and returns `IgxSummaryResult[]`.
     * ```typescript
     * interface IgxSummaryResult {
     *   key: string;
     *   label: string;
     *   summaryResult: any;
     * }
     * ```
     * Can be overridden in the inherited classes to provide customization for the `summary`.
     * ```typescript
     * class CustomSummary extends IgxSummaryOperand {
     *   constructor() {
     *     super();
     *   }
     *   public operate(data?: any[]): IgxSummaryResult[] {
     *     const result = [];
     *     result.push({
     *       key: "test",
     *       label: "Test",
     *       summaryResult: IgxSummaryOperand.count(data)
     *     });
     *     return result;
     *   }
     * }
     * this.grid.getColumnByName('ColumnName').summaries = CustomSummary;
     * ```
     * @memberof IgxSummaryOperand
     */
    /**
     * Executes the static `count` method and returns `IgxSummaryResult[]`.
     * ```typescript
     * interface IgxSummaryResult {
     *   key: string;
     *   label: string;
     *   summaryResult: any;
     * }
     * ```
     * Can be overridden in the inherited classes to provide customization for the `summary`.
     * ```typescript
     * class CustomSummary extends IgxSummaryOperand {
     *   constructor() {
     *     super();
     *   }
     *   public operate(data?: any[]): IgxSummaryResult[] {
     *     const result = [];
     *     result.push({
     *       key: "test",
     *       label: "Test",
     *       summaryResult: IgxSummaryOperand.count(data)
     *     });
     *     return result;
     *   }
     * }
     * this.grid.getColumnByName('ColumnName').summaries = CustomSummary;
     * ```
     * \@memberof IgxSummaryOperand
     * @param {?=} data
     * @return {?}
     */
    IgxSummaryOperand.prototype.operate = /**
     * Executes the static `count` method and returns `IgxSummaryResult[]`.
     * ```typescript
     * interface IgxSummaryResult {
     *   key: string;
     *   label: string;
     *   summaryResult: any;
     * }
     * ```
     * Can be overridden in the inherited classes to provide customization for the `summary`.
     * ```typescript
     * class CustomSummary extends IgxSummaryOperand {
     *   constructor() {
     *     super();
     *   }
     *   public operate(data?: any[]): IgxSummaryResult[] {
     *     const result = [];
     *     result.push({
     *       key: "test",
     *       label: "Test",
     *       summaryResult: IgxSummaryOperand.count(data)
     *     });
     *     return result;
     *   }
     * }
     * this.grid.getColumnByName('ColumnName').summaries = CustomSummary;
     * ```
     * \@memberof IgxSummaryOperand
     * @param {?=} data
     * @return {?}
     */
    function (data) {
        if (data === void 0) { data = []; }
        return [{
                key: 'count',
                label: 'Count',
                summaryResult: IgxSummaryOperand.count(data)
            }];
    };
    return IgxSummaryOperand;
}());
// @dynamic
var  
// @dynamic
IgxNumberSummaryOperand = /** @class */ (function (_super) {
    __extends(IgxNumberSummaryOperand, _super);
    function IgxNumberSummaryOperand() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the minimum numeric value in the provided data records.
     * If filtering is applied, returns the minimum value in the filtered data records.
     * ```typescript
     * IgxNumberSummaryOperand.min(data);
     * ```
     * @memberof IgxNumberSummaryOperand
     */
    /**
     * Returns the minimum numeric value in the provided data records.
     * If filtering is applied, returns the minimum value in the filtered data records.
     * ```typescript
     * IgxNumberSummaryOperand.min(data);
     * ```
     * \@memberof IgxNumberSummaryOperand
     * @param {?} data
     * @return {?}
     */
    IgxNumberSummaryOperand.min = /**
     * Returns the minimum numeric value in the provided data records.
     * If filtering is applied, returns the minimum value in the filtered data records.
     * ```typescript
     * IgxNumberSummaryOperand.min(data);
     * ```
     * \@memberof IgxNumberSummaryOperand
     * @param {?} data
     * @return {?}
     */
    function (data) {
        return data.length && data.filter(clear).length ? data.filter(clear).reduce(function (a, b) { return Math.min(a, b); }) : 0;
    };
    /**
     * Returns the maximum numeric value in the provided data records.
     * If filtering is applied, returns the maximum value in the filtered data records.
     * ```typescript
     * IgxNumberSummaryOperand.max(data);
     * ```
     * @memberof IgxNumberSummaryOperand
     */
    /**
     * Returns the maximum numeric value in the provided data records.
     * If filtering is applied, returns the maximum value in the filtered data records.
     * ```typescript
     * IgxNumberSummaryOperand.max(data);
     * ```
     * \@memberof IgxNumberSummaryOperand
     * @param {?} data
     * @return {?}
     */
    IgxNumberSummaryOperand.max = /**
     * Returns the maximum numeric value in the provided data records.
     * If filtering is applied, returns the maximum value in the filtered data records.
     * ```typescript
     * IgxNumberSummaryOperand.max(data);
     * ```
     * \@memberof IgxNumberSummaryOperand
     * @param {?} data
     * @return {?}
     */
    function (data) {
        return data.length && data.filter(clear).length ? data.filter(clear).reduce(function (a, b) { return Math.max(a, b); }) : 0;
    };
    /**
     * Returns the sum of the numeric values in the provided data records.
     * If filtering is applied, returns the sum of the numeric values in the data records.
     * ```typescript
     * IgxNumberSummaryOperand.sum(data);
     * ```
     * @memberof IgxNumberSummaryOperand
     */
    /**
     * Returns the sum of the numeric values in the provided data records.
     * If filtering is applied, returns the sum of the numeric values in the data records.
     * ```typescript
     * IgxNumberSummaryOperand.sum(data);
     * ```
     * \@memberof IgxNumberSummaryOperand
     * @param {?} data
     * @return {?}
     */
    IgxNumberSummaryOperand.sum = /**
     * Returns the sum of the numeric values in the provided data records.
     * If filtering is applied, returns the sum of the numeric values in the data records.
     * ```typescript
     * IgxNumberSummaryOperand.sum(data);
     * ```
     * \@memberof IgxNumberSummaryOperand
     * @param {?} data
     * @return {?}
     */
    function (data) {
        return data.length && data.filter(clear).length ? data.filter(clear).reduce(function (a, b) { return +a + +b; }) : 0;
    };
    /**
     * Returns the average numeric value in the data provided data records.
     * If filtering is applied, returns the average numeric value in the filtered data records.
     * ```typescript
     * IgxSummaryOperand.average(data);
     * ```
     * @memberof IgxNumberSummaryOperand
     */
    /**
     * Returns the average numeric value in the data provided data records.
     * If filtering is applied, returns the average numeric value in the filtered data records.
     * ```typescript
     * IgxSummaryOperand.average(data);
     * ```
     * \@memberof IgxNumberSummaryOperand
     * @param {?} data
     * @return {?}
     */
    IgxNumberSummaryOperand.average = /**
     * Returns the average numeric value in the data provided data records.
     * If filtering is applied, returns the average numeric value in the filtered data records.
     * ```typescript
     * IgxSummaryOperand.average(data);
     * ```
     * \@memberof IgxNumberSummaryOperand
     * @param {?} data
     * @return {?}
     */
    function (data) {
        return data.length && data.filter(clear).length ? this.sum(data) / this.count(data) : 0;
    };
    /**
     * Executes the static methods and returns `IgxSummaryResult[]`.
     * ```typescript
     * interface IgxSummaryResult {
     *   key: string;
     *   label: string;
     *   summaryResult: any;
     * }
     * ```
     * Can be overridden in the inherited classes to provide customization for the `summary`.
     * ```typescript
     * class CustomNumberSummary extends IgxNumberSummaryOperand {
     *   constructor() {
     *     super();
     *   }
     *   public operate(data?: any[]): IgxSummaryResult[] {
     *     const result = [];
     *     result.push({
     *       key: "avg",
     *       label: "Avg",
     *       summaryResult: IgxNumberSummaryOperand.average(data)
     *     });
     *     result.push({
     *       key: "max",
     *       label: "Max",
     *       summaryResult: IgxNumberSummaryOperand.max(data)
     *     });
     *     return result;
     *   }
     * }
     * this.grid.getColumnByName('ColumnName').summaries = CustomNumberSummary;
     * ```
     * @memberof IgxNumberSummaryOperand
     */
    /**
     * Executes the static methods and returns `IgxSummaryResult[]`.
     * ```typescript
     * interface IgxSummaryResult {
     *   key: string;
     *   label: string;
     *   summaryResult: any;
     * }
     * ```
     * Can be overridden in the inherited classes to provide customization for the `summary`.
     * ```typescript
     * class CustomNumberSummary extends IgxNumberSummaryOperand {
     *   constructor() {
     *     super();
     *   }
     *   public operate(data?: any[]): IgxSummaryResult[] {
     *     const result = [];
     *     result.push({
     *       key: "avg",
     *       label: "Avg",
     *       summaryResult: IgxNumberSummaryOperand.average(data)
     *     });
     *     result.push({
     *       key: "max",
     *       label: "Max",
     *       summaryResult: IgxNumberSummaryOperand.max(data)
     *     });
     *     return result;
     *   }
     * }
     * this.grid.getColumnByName('ColumnName').summaries = CustomNumberSummary;
     * ```
     * \@memberof IgxNumberSummaryOperand
     * @param {?=} data
     * @return {?}
     */
    IgxNumberSummaryOperand.prototype.operate = /**
     * Executes the static methods and returns `IgxSummaryResult[]`.
     * ```typescript
     * interface IgxSummaryResult {
     *   key: string;
     *   label: string;
     *   summaryResult: any;
     * }
     * ```
     * Can be overridden in the inherited classes to provide customization for the `summary`.
     * ```typescript
     * class CustomNumberSummary extends IgxNumberSummaryOperand {
     *   constructor() {
     *     super();
     *   }
     *   public operate(data?: any[]): IgxSummaryResult[] {
     *     const result = [];
     *     result.push({
     *       key: "avg",
     *       label: "Avg",
     *       summaryResult: IgxNumberSummaryOperand.average(data)
     *     });
     *     result.push({
     *       key: "max",
     *       label: "Max",
     *       summaryResult: IgxNumberSummaryOperand.max(data)
     *     });
     *     return result;
     *   }
     * }
     * this.grid.getColumnByName('ColumnName').summaries = CustomNumberSummary;
     * ```
     * \@memberof IgxNumberSummaryOperand
     * @param {?=} data
     * @return {?}
     */
    function (data) {
        if (data === void 0) { data = []; }
        /** @type {?} */
        var result = _super.prototype.operate.call(this, data);
        result.push({
            key: 'min',
            label: 'Min',
            summaryResult: IgxNumberSummaryOperand.min(data)
        });
        result.push({
            key: 'max',
            label: 'Max',
            summaryResult: IgxNumberSummaryOperand.max(data)
        });
        result.push({
            key: 'sum',
            label: 'Sum',
            summaryResult: IgxNumberSummaryOperand.sum(data)
        });
        result.push({
            key: 'average',
            label: 'Avg',
            summaryResult: IgxNumberSummaryOperand.average(data)
        });
        return result;
    };
    return IgxNumberSummaryOperand;
}(IgxSummaryOperand));
// @dynamic
var  
// @dynamic
IgxDateSummaryOperand = /** @class */ (function (_super) {
    __extends(IgxDateSummaryOperand, _super);
    function IgxDateSummaryOperand() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the latest date value in the data records.
     * If filtering is applied, returns the latest date value in the filtered data records.
     * ```typescript
     * IgxDateSummaryOperand.latest(data);
     * ```
     * @memberof IgxDateSummaryOperand
     */
    /**
     * Returns the latest date value in the data records.
     * If filtering is applied, returns the latest date value in the filtered data records.
     * ```typescript
     * IgxDateSummaryOperand.latest(data);
     * ```
     * \@memberof IgxDateSummaryOperand
     * @param {?} data
     * @return {?}
     */
    IgxDateSummaryOperand.latest = /**
     * Returns the latest date value in the data records.
     * If filtering is applied, returns the latest date value in the filtered data records.
     * ```typescript
     * IgxDateSummaryOperand.latest(data);
     * ```
     * \@memberof IgxDateSummaryOperand
     * @param {?} data
     * @return {?}
     */
    function (data) {
        return data.length && data.filter(clear).length ?
            first$1(data.filter(clear).sort(function (a, b) { return new Date(b).valueOf() - new Date(a).valueOf(); })) : undefined;
    };
    /**
     * Returns the earliest date value in the data records.
     * If filtering is applied, returns the latest date value in the filtered data records.
     * ```typescript
     * IgxDateSummaryOperand.earliest(data);
     * ```
     * @memberof IgxDateSummaryOperand
     */
    /**
     * Returns the earliest date value in the data records.
     * If filtering is applied, returns the latest date value in the filtered data records.
     * ```typescript
     * IgxDateSummaryOperand.earliest(data);
     * ```
     * \@memberof IgxDateSummaryOperand
     * @param {?} data
     * @return {?}
     */
    IgxDateSummaryOperand.earliest = /**
     * Returns the earliest date value in the data records.
     * If filtering is applied, returns the latest date value in the filtered data records.
     * ```typescript
     * IgxDateSummaryOperand.earliest(data);
     * ```
     * \@memberof IgxDateSummaryOperand
     * @param {?} data
     * @return {?}
     */
    function (data) {
        return data.length && data.filter(clear).length ?
            last(data.filter(clear).sort(function (a, b) { return new Date(b).valueOf() - new Date(a).valueOf(); })) : undefined;
    };
    /**
     * Executes the static methods and returns `IgxSummaryResult[]`.
     * ```typescript
     * interface IgxSummaryResult {
     *   key: string;
     *   label: string;
     *   summaryResult: any;
     * }
     * ```
     * Can be overridden in the inherited classes to provide customization for the `summary`.
     * ```typescript
     * class CustomDateSummary extends IgxDateSummaryOperand {
     *   constructor() {
     *     super();
     *   }
     *   public operate(data?: any[]): IgxSummaryResult[] {
     *     const result = [];
     *     result.push({
     *       key: "latest",
     *       label: "Latest Date",
     *       summaryResult: IgxDateSummaryOperand.latest(data)
     *     });
     *     return result;
     *   }
     * }
     * this.grid.getColumnByName('ColumnName').summaries = CustomDateSummary;
     * ```
     * @memberof IgxDateSummaryOperand
     */
    /**
     * Executes the static methods and returns `IgxSummaryResult[]`.
     * ```typescript
     * interface IgxSummaryResult {
     *   key: string;
     *   label: string;
     *   summaryResult: any;
     * }
     * ```
     * Can be overridden in the inherited classes to provide customization for the `summary`.
     * ```typescript
     * class CustomDateSummary extends IgxDateSummaryOperand {
     *   constructor() {
     *     super();
     *   }
     *   public operate(data?: any[]): IgxSummaryResult[] {
     *     const result = [];
     *     result.push({
     *       key: "latest",
     *       label: "Latest Date",
     *       summaryResult: IgxDateSummaryOperand.latest(data)
     *     });
     *     return result;
     *   }
     * }
     * this.grid.getColumnByName('ColumnName').summaries = CustomDateSummary;
     * ```
     * \@memberof IgxDateSummaryOperand
     * @param {?=} data
     * @return {?}
     */
    IgxDateSummaryOperand.prototype.operate = /**
     * Executes the static methods and returns `IgxSummaryResult[]`.
     * ```typescript
     * interface IgxSummaryResult {
     *   key: string;
     *   label: string;
     *   summaryResult: any;
     * }
     * ```
     * Can be overridden in the inherited classes to provide customization for the `summary`.
     * ```typescript
     * class CustomDateSummary extends IgxDateSummaryOperand {
     *   constructor() {
     *     super();
     *   }
     *   public operate(data?: any[]): IgxSummaryResult[] {
     *     const result = [];
     *     result.push({
     *       key: "latest",
     *       label: "Latest Date",
     *       summaryResult: IgxDateSummaryOperand.latest(data)
     *     });
     *     return result;
     *   }
     * }
     * this.grid.getColumnByName('ColumnName').summaries = CustomDateSummary;
     * ```
     * \@memberof IgxDateSummaryOperand
     * @param {?=} data
     * @return {?}
     */
    function (data) {
        if (data === void 0) { data = []; }
        /** @type {?} */
        var result = _super.prototype.operate.call(this, data);
        result.push({
            key: 'earliest',
            label: 'Earliest',
            summaryResult: IgxDateSummaryOperand.earliest(data)
        });
        result.push({
            key: 'latest',
            label: 'Latest',
            summaryResult: IgxDateSummaryOperand.latest(data)
        });
        return result;
    };
    return IgxDateSummaryOperand;
}(IgxSummaryOperand));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// TODO: Refactor - export in a separate file
var 
// TODO: Refactor - export in a separate file
IgxRow = /** @class */ (function () {
    function IgxRow(id, index, data) {
        this.id = id;
        this.index = index;
        this.data = data;
    }
    /**
     * @return {?}
     */
    IgxRow.prototype.createEditEventArgs = /**
     * @return {?}
     */
    function () {
        return {
            rowID: this.id,
            oldValue: __assign({}, this.data),
            newValue: this.newData,
            cancel: false
        };
    };
    return IgxRow;
}());
var IgxCell = /** @class */ (function () {
    function IgxCell(id, rowIndex, column, value, editValue, rowData) {
        this.id = id;
        this.rowIndex = rowIndex;
        this.column = column;
        this.value = value;
        this.editValue = editValue;
        this.rowData = rowData;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    IgxCell.prototype.castToNumber = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (this.column.dataType === 'number' && !this.column.inlineEditorTemplate) {
            /** @type {?} */
            var v = parseFloat(value);
            return !isNaN(v) && isFinite(v) ? v : 0;
        }
        return value;
    };
    /**
     * @return {?}
     */
    IgxCell.prototype.createEditEventArgs = /**
     * @return {?}
     */
    function () {
        return {
            rowID: this.id.rowID,
            cellID: this.id,
            oldValue: this.value,
            newValue: this.editValue,
            cancel: false
        };
    };
    return IgxCell;
}());
var IgxGridCRUDService = /** @class */ (function () {
    function IgxGridCRUDService() {
        this.cell = null;
        this.row = null;
    }
    /**
     * @param {?} cell
     * @return {?}
     */
    IgxGridCRUDService.prototype.createCell = /**
     * @param {?} cell
     * @return {?}
     */
    function (cell) {
        return new IgxCell(cell.cellID, cell.rowIndex, cell.column, cell.value, cell.value, cell.row.rowData);
    };
    /**
     * @param {?} cell
     * @return {?}
     */
    IgxGridCRUDService.prototype.createRow = /**
     * @param {?} cell
     * @return {?}
     */
    function (cell) {
        return new IgxRow(cell.id.rowID, cell.rowIndex, cell.rowData);
    };
    /**
     * @param {?} rowID
     * @return {?}
     */
    IgxGridCRUDService.prototype.sameRow = /**
     * @param {?} rowID
     * @return {?}
     */
    function (rowID) {
        return this.row.id === rowID;
    };
    /**
     * @param {?} cell
     * @return {?}
     */
    IgxGridCRUDService.prototype.sameCell = /**
     * @param {?} cell
     * @return {?}
     */
    function (cell) {
        return (this.cell.id.rowID === cell.id.rowID &&
            this.cell.id.columnID === cell.id.columnID);
    };
    Object.defineProperty(IgxGridCRUDService.prototype, "inEditMode", {
        get: /**
         * @return {?}
         */
        function () {
            return !!this.cell;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridCRUDService.prototype, "rowEditing", {
        get: /**
         * @return {?}
         */
        function () {
            return this.grid.rowEditable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridCRUDService.prototype, "primaryKey", {
        get: /**
         * @return {?}
         */
        function () {
            return this.grid.primaryKey;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    IgxGridCRUDService.prototype.beginRowEdit = /**
     * @return {?}
     */
    function () {
        this.row = this.createRow(this.cell);
        /** @type {?} */
        var args = {
            rowID: this.row.id,
            oldValue: this.row.data,
            cancel: false
        };
        this.grid.onRowEditEnter.emit(args);
        if (args.cancel) {
            this.endRowEdit();
            return;
        }
        this.row.transactionState = this.grid.transactions.getAggregatedValue(this.row.id, true);
        this.grid.transactions.startPending();
        this.grid.openRowOverlay(this.row.id);
    };
    /**
     * @return {?}
     */
    IgxGridCRUDService.prototype.endRowEdit = /**
     * @return {?}
     */
    function () {
        this.row = null;
    };
    /**
     * @param {?} cell
     * @return {?}
     */
    IgxGridCRUDService.prototype.begin = /**
     * @param {?} cell
     * @return {?}
     */
    function (cell) {
        this.cell = this.createCell(cell);
        this.cell.primaryKey = this.primaryKey;
        /** @type {?} */
        var args = {
            cellID: this.cell.id,
            rowID: this.cell.id.rowID,
            oldValue: this.cell.value,
            cancel: false
        };
        this.grid.onCellEditEnter.emit(args);
        if (args.cancel) {
            this.end();
            return;
        }
        if (this.rowEditing) {
            if (!this.row) {
                this.beginRowEdit();
                return;
            }
            if (this.row && !this.sameRow(this.cell.id.rowID)) {
                this.grid.endEdit(true);
                this.cell = this.createCell(cell);
                this.beginRowEdit();
                return;
            }
        }
    };
    /**
     * @return {?}
     */
    IgxGridCRUDService.prototype.end = /**
     * @return {?}
     */
    function () {
        this.cell = null;
    };
    /**
     * @param {?} rowIndex
     * @param {?} columnIndex
     * @return {?}
     */
    IgxGridCRUDService.prototype.isInEditMode = /**
     * @param {?} rowIndex
     * @param {?} columnIndex
     * @return {?}
     */
    function (rowIndex, columnIndex) {
        if (!this.cell) {
            return false;
        }
        return this.cell.column.index === columnIndex && this.cell.rowIndex === rowIndex;
    };
    IgxGridCRUDService.decorators = [
        { type: Injectable }
    ];
    return IgxGridCRUDService;
}());
var IgxGridSelectionService = /** @class */ (function () {
    function IgxGridSelectionService(zone) {
        this.zone = zone;
        this.dragMode = false;
        this.keyboardState = (/** @type {?} */ ({}));
        this.pointerState = (/** @type {?} */ ({}));
        this.selection = new Map();
        this.temp = new Map();
        this._ranges = new Set();
        this.initPointerState();
        this.initKeyboardState();
    }
    Object.defineProperty(IgxGridSelectionService.prototype, "ranges", {
        /**
         * Returns the current selected ranges in the grid from both
         * keyboard and pointer interactions
         */
        get: /**
         * Returns the current selected ranges in the grid from both
         * keyboard and pointer interactions
         * @return {?}
         */
        function () {
            // The last action was keyboard + shift selection -> add it
            if (this.keyboardState.range) {
                this._ranges.add(JSON.stringify(this.keyboardState.range));
            }
            /** @type {?} */
            var ranges = Array.from(this._ranges).map(function (range) { return JSON.parse(range); });
            // No ranges but we have a focused cell -> add it
            if (!ranges.length && this.activeElement) {
                ranges.push(this.generateRange(this.activeElement));
            }
            return ranges;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Resets the keyboard state
     */
    /**
     * Resets the keyboard state
     * @return {?}
     */
    IgxGridSelectionService.prototype.initKeyboardState = /**
     * Resets the keyboard state
     * @return {?}
     */
    function () {
        this.keyboardState.node = null;
        this.keyboardState.shift = false;
        this.keyboardState.range = null;
        this.keyboardState.active = false;
    };
    /**
     * Resets the pointer state
     */
    /**
     * Resets the pointer state
     * @return {?}
     */
    IgxGridSelectionService.prototype.initPointerState = /**
     * Resets the pointer state
     * @return {?}
     */
    function () {
        this.pointerState.node = null;
        this.pointerState.ctrl = false;
        this.pointerState.shift = false;
        this.pointerState.range = null;
    };
    /**
     * Adds a single node.
     * Single clicks | Ctrl + single clicks on cells is the usual case.
     */
    /**
     * Adds a single node.
     * Single clicks | Ctrl + single clicks on cells is the usual case.
     * @param {?} node
     * @return {?}
     */
    IgxGridSelectionService.prototype.add = /**
     * Adds a single node.
     * Single clicks | Ctrl + single clicks on cells is the usual case.
     * @param {?} node
     * @return {?}
     */
    function (node) {
        this.selection.has(node.row) ? this.selection.get(node.row).add(node.column) :
            this.selection.set(node.row, new Set()).get(node.row).add(node.column);
        this._ranges.add(JSON.stringify(this.generateRange(node)));
    };
    /**
     * @param {?} node
     * @return {?}
     */
    IgxGridSelectionService.prototype.remove = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        if (this.selection.has(node.row)) {
            this.selection.get(node.row).delete(node.column);
        }
        if (this.isActiveNode(node)) {
            this.activeElement = null;
        }
        this._ranges.delete(JSON.stringify(this.generateRange(node)));
    };
    /**
     * @param {?} node
     * @return {?}
     */
    IgxGridSelectionService.prototype.isInMap = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        return (this.selection.has(node.row) && this.selection.get(node.row).has(node.column)) ||
            (this.temp.has(node.row) && this.temp.get(node.row).has(node.column));
    };
    /**
     * @param {?} node
     * @return {?}
     */
    IgxGridSelectionService.prototype.selected = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        return this.isActiveNode(node) || this.isInMap(node);
    };
    /**
     * @param {?} node
     * @return {?}
     */
    IgxGridSelectionService.prototype.isActiveNode = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        if (this.activeElement) {
            return this.activeElement.column === node.column && this.activeElement.row === node.row;
        }
        return false;
    };
    /**
     * @param {?} node
     * @param {?=} state
     * @return {?}
     */
    IgxGridSelectionService.prototype.addRangeMeta = /**
     * @param {?} node
     * @param {?=} state
     * @return {?}
     */
    function (node, state$$1) {
        this._ranges.add(JSON.stringify(this.generateRange(node, state$$1)));
    };
    /**
     * @param {?} node
     * @param {?=} state
     * @return {?}
     */
    IgxGridSelectionService.prototype.removeRangeMeta = /**
     * @param {?} node
     * @param {?=} state
     * @return {?}
     */
    function (node, state$$1) {
        this._ranges.delete(JSON.stringify(this.generateRange(node, state$$1)));
    };
    /**
     * Generates a new selection range from the given `node`.
     * If `state` is passed instead it will generate the range based on the passed `node`
     * and the start node of the `state`.
     */
    /**
     * Generates a new selection range from the given `node`.
     * If `state` is passed instead it will generate the range based on the passed `node`
     * and the start node of the `state`.
     * @param {?} node
     * @param {?=} state
     * @return {?}
     */
    IgxGridSelectionService.prototype.generateRange = /**
     * Generates a new selection range from the given `node`.
     * If `state` is passed instead it will generate the range based on the passed `node`
     * and the start node of the `state`.
     * @param {?} node
     * @param {?=} state
     * @return {?}
     */
    function (node, state$$1) {
        if (!state$$1) {
            return {
                rowStart: node.row,
                rowEnd: node.row,
                columnStart: node.column,
                columnEnd: node.column
            };
        }
        var _a = state$$1.node, row = _a.row, column = _a.column;
        /** @type {?} */
        var rowStart = Math.min(node.row, row);
        /** @type {?} */
        var rowEnd = Math.max(node.row, row);
        /** @type {?} */
        var columnStart = Math.min(node.column, column);
        /** @type {?} */
        var columnEnd = Math.max(node.column, column);
        return { rowStart: rowStart, rowEnd: rowEnd, columnStart: columnStart, columnEnd: columnEnd };
    };
    /**
     *
     */
    /**
     *
     * @param {?} node
     * @param {?} shift
     * @param {?} shiftTab
     * @return {?}
     */
    IgxGridSelectionService.prototype.keyboardStateOnKeydown = /**
     *
     * @param {?} node
     * @param {?} shift
     * @param {?} shiftTab
     * @return {?}
     */
    function (node, shift, shiftTab) {
        this.keyboardState.active = true;
        this.initPointerState();
        this.keyboardState.shift = shift && !shiftTab;
        // Kb navigation with shift and no previous node.
        // Clear the current selection init the start node.
        if (this.keyboardState.shift && !this.keyboardState.node) {
            this.clear();
            this.keyboardState.node = node;
        }
    };
    /**
     * @param {?} node
     * @param {?} emitter
     * @return {?}
     */
    IgxGridSelectionService.prototype.keyboardStateOnFocus = /**
     * @param {?} node
     * @param {?} emitter
     * @return {?}
     */
    function (node, emitter) {
        /** @type {?} */
        var kbState = this.keyboardState;
        // Focus triggered by keyboard navigation
        if (kbState.active) {
            // Start generating a range if shift is hold
            if (kbState.shift) {
                this.dragSelect(node, kbState);
                kbState.range = this.generateRange(node, kbState);
                emitter.emit(this.generateRange(node, kbState));
                return;
            }
            this.initKeyboardState();
            this.clear();
            this.add(node);
        }
    };
    /**
     * @param {?} node
     * @param {?} shift
     * @param {?} ctrl
     * @return {?}
     */
    IgxGridSelectionService.prototype.pointerDown = /**
     * @param {?} node
     * @param {?} shift
     * @param {?} ctrl
     * @return {?}
     */
    function (node, shift, ctrl) {
        if (this.keyboardState.range) {
            this._ranges.add(JSON.stringify(this.keyboardState.range));
        }
        this.initKeyboardState();
        this.pointerState.ctrl = ctrl;
        this.pointerState.shift = shift;
        // No ctrl key pressed - no multiple selection
        if (!ctrl) {
            this.clear();
        }
        if (shift) {
            // No previously 'clicked' node. Use the last active node.
            if (!this.pointerState.node) {
                this.pointerState.node = this.activeElement;
            }
            this.pointerDownShiftKey(node);
            this.clearTextSelection();
            return;
        }
        this.removeRangeMeta(node);
        this.pointerState.node = node;
    };
    /**
     * @param {?} node
     * @return {?}
     */
    IgxGridSelectionService.prototype.pointerDownShiftKey = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        this.clear();
        this.selectRange(node, this.pointerState);
    };
    /**
     * @param {?} target
     * @param {?} source
     * @return {?}
     */
    IgxGridSelectionService.prototype.mergeMap = /**
     * @param {?} target
     * @param {?} source
     * @return {?}
     */
    function (target, source) {
        /** @type {?} */
        var iterator = source.entries();
        /** @type {?} */
        var pair = iterator.next();
        /** @type {?} */
        var key;
        /** @type {?} */
        var value;
        var _loop_1 = function () {
            var _a;
            _a = __read(pair.value, 2), key = _a[0], value = _a[1];
            if (target.has(key)) {
                /** @type {?} */
                var newValue_1 = target.get(key);
                value.forEach(function (record) { return newValue_1.add(record); });
                target.set(key, newValue_1);
            }
            else {
                target.set(key, value);
            }
            pair = iterator.next();
        };
        while (!pair.done) {
            _loop_1();
        }
    };
    /**
     * @param {?} node
     * @param {?} dragEnabled
     * @return {?}
     */
    IgxGridSelectionService.prototype.pointerEnter = /**
     * @param {?} node
     * @param {?} dragEnabled
     * @return {?}
     */
    function (node, dragEnabled) {
        this.dragMode = dragEnabled;
        if (!this.dragMode) {
            return false;
        }
        this.clearTextSelection();
        // If the users triggers a drag-like event by first clicking outside the grid cells
        // and then enters in the grid body we may not have a initial pointer starting node.
        // Assume the first pointerenter node is where we start.
        if (!this.pointerState.node) {
            this.pointerState.node = node;
        }
        this.pointerState.ctrl ? this.blah(node, this.pointerState) :
            this.dragSelect(node, this.pointerState);
        return true;
    };
    /**
     * @param {?} node
     * @param {?} emitter
     * @return {?}
     */
    IgxGridSelectionService.prototype.pointerUp = /**
     * @param {?} node
     * @param {?} emitter
     * @return {?}
     */
    function (node, emitter) {
        var _this = this;
        if (this.dragMode) {
            this.addRangeMeta(node, this.pointerState);
            this.mergeMap(this.selection, this.temp);
            this.zone.runTask(function () { return emitter.emit(_this.generateRange(node, _this.pointerState)); });
            this.temp.clear();
            this.dragMode = false;
            return true;
        }
        if (this.pointerState.shift) {
            this.clearTextSelection();
            emitter.emit(this.generateRange(node, this.pointerState));
            this.addRangeMeta(node, this.pointerState);
            return true;
        }
        this.add(node);
        return false;
    };
    /**
     * @param {?} node
     * @param {?} state
     * @return {?}
     */
    IgxGridSelectionService.prototype.selectRange = /**
     * @param {?} node
     * @param {?} state
     * @return {?}
     */
    function (node, state$$1) {
        var _a = this.generateRange(node, state$$1), rowStart = _a.rowStart, rowEnd = _a.rowEnd, columnStart = _a.columnStart, columnEnd = _a.columnEnd;
        for (var i = rowStart; i <= rowEnd; i++) {
            for (var j = (/** @type {?} */ (columnStart)); j <= columnEnd; j++) {
                this.selection.has(i) ? this.selection.get(i).add(j) :
                    this.selection.set(i, new Set()).get(i).add(j);
            }
        }
    };
    /**
     * @param {?} node
     * @param {?} state
     * @return {?}
     */
    IgxGridSelectionService.prototype.blah = /**
     * @param {?} node
     * @param {?} state
     * @return {?}
     */
    function (node, state$$1) {
        this.temp.clear();
        var _a = this.generateRange(node, state$$1), rowStart = _a.rowStart, rowEnd = _a.rowEnd, columnStart = _a.columnStart, columnEnd = _a.columnEnd;
        for (var i = rowStart; i <= rowEnd; i++) {
            for (var j = (/** @type {?} */ (columnStart)); j <= columnEnd; j++) {
                this.temp.has(i) ? this.temp.get(i).add(j) :
                    this.temp.set(i, new Set()).get(i).add(j);
            }
        }
    };
    /**
     * @param {?} node
     * @param {?} state
     * @return {?}
     */
    IgxGridSelectionService.prototype.dragSelect = /**
     * @param {?} node
     * @param {?} state
     * @return {?}
     */
    function (node, state$$1) {
        if (!this.pointerState.ctrl) {
            this.selection.clear();
        }
        this.selectRange(node, state$$1);
    };
    /**
     * @return {?}
     */
    IgxGridSelectionService.prototype.clear = /**
     * @return {?}
     */
    function () {
        this.selection.clear();
        this.temp.clear();
        this._ranges.clear();
    };
    /**
     * @return {?}
     */
    IgxGridSelectionService.prototype.clearTextSelection = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var selection = window.getSelection();
        if (selection) {
            selection.removeAllRanges();
        }
    };
    IgxGridSelectionService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    IgxGridSelectionService.ctorParameters = function () { return [
        { type: NgZone }
    ]; };
    return IgxGridSelectionService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @template T
 */
var IgxRowComponent = /** @class */ (function () {
    function IgxRowComponent(gridAPI, crudService, selectionService, selection, element, cdr) {
        this.gridAPI = gridAPI;
        this.crudService = crudService;
        this.selectionService = selectionService;
        this.selection = selection;
        this.element = element;
        this.cdr = cdr;
        /**
         * @hidden
         */
        this.role = 'row';
        /**
         * @hidden
         */
        this.dragging = false;
        /**
         * @hidden
         */
        this.focused = false;
        /**
         * @hidden
         * \@internal
         */
        this.defaultCssClass = 'igx-grid__tr';
        /**
         * @hidden
         */
        this._rowSelection = false;
    }
    Object.defineProperty(IgxRowComponent.prototype, "rowData", {
        /**
         *  The data passed to the row component.
         *
         * ```typescript
         * // get the row data for the first selected row
         * let selectedRowData = this.grid.selectedRows[0].rowData;
         * ```
         */
        get: /**
         *  The data passed to the row component.
         *
         * ```typescript
         * // get the row data for the first selected row
         * let selectedRowData = this.grid.selectedRows[0].rowData;
         * ```
         * @return {?}
         */
        function () {
            if (this.inEditMode) {
                return Object.assign({}, this._rowData, this.grid.transactions.getAggregatedValue(this.rowID, false));
            }
            return this._rowData;
        },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            this._rowData = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxRowComponent.prototype, "dataRowIndex", {
        get: /**
         * @return {?}
         */
        function () {
            return this.index;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxRowComponent.prototype, "styleClasses", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.resolveClasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxRowComponent.prototype, "columns", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.grid.visibleColumns;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxRowComponent.prototype, "pinnedColumns", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.grid.pinnedColumns;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxRowComponent.prototype, "unpinnedColumns", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.grid.unpinnedColumns;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxRowComponent.prototype, "rowSelectable", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.grid.rowSelectable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxRowComponent.prototype, "showRowCheckboxes", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.grid.showRowCheckboxes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxRowComponent.prototype, "dirty", {
        /** @hidden */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            /** @type {?} */
            var row = this.grid.transactions.getState(this.rowID);
            if (row) {
                return row.type === TransactionType.ADD || row.type === TransactionType.UPDATE;
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxRowComponent.prototype, "rowDraggable", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.grid.rowDraggable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxRowComponent.prototype, "added", {
        /** @hidden */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            /** @type {?} */
            var row = this.grid.transactions.getState(this.rowID);
            if (row) {
                return row.type === TransactionType.ADD;
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxRowComponent.prototype, "deleted", {
        /** @hidden */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.gridAPI.row_deleted_transaction(this.rowID);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxRowComponent.prototype, "inEditMode", {
        // TODO: Refactor
        get: 
        // TODO: Refactor
        /**
         * @return {?}
         */
        function () {
            if (this.grid.rowEditable) {
                /** @type {?} */
                var editRowState = this.crudService.row;
                return (editRowState && editRowState.id === this.rowID) || false;
            }
            else {
                return false;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxRowComponent.prototype, "grid", {
        /**
         * Get a reference to the grid that contains the selected row.
         *
         * ```typescript
         * handleRowSelection(event) {
         *  // the grid on which the onRowSelectionChange event was triggered
         *  const grid = event.row.grid;
         * }
         * ```
         *
         * ```html
         *  <igx-grid
         *    [data]="data"
         *    (onRowSelectionChange)="handleRowSelection($event)">
         *  </igx-grid>
         * ```
         */
        get: /**
         * Get a reference to the grid that contains the selected row.
         *
         * ```typescript
         * handleRowSelection(event) {
         *  // the grid on which the onRowSelectionChange event was triggered
         *  const grid = event.row.grid;
         * }
         * ```
         *
         * ```html
         *  <igx-grid
         *    [data]="data"
         *    (onRowSelectionChange)="handleRowSelection($event)">
         *  </igx-grid>
         * ```
         * @return {?}
         */
        function () {
            return this.gridAPI.grid;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxRowComponent.prototype, "rowID", {
        /**
         * Gets the ID of the row.
         * A row in the grid is identified either by:
         * - primaryKey data value,
         * - the whole rowData, if the primaryKey is omitted.
         *
         * ```typescript
         * let rowID = this.grid.selectedRows[2].rowID;
         * ```
         */
        get: /**
         * Gets the ID of the row.
         * A row in the grid is identified either by:
         * - primaryKey data value,
         * - the whole rowData, if the primaryKey is omitted.
         *
         * ```typescript
         * let rowID = this.grid.selectedRows[2].rowID;
         * ```
         * @return {?}
         */
        function () {
            /** @type {?} */
            var primaryKey = this.grid.primaryKey;
            return primaryKey ? this._rowData[primaryKey] : this._rowData;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxRowComponent.prototype, "nativeElement", {
        /**
         * The native DOM element representing the row. Could be null in certain environments.
         *
         * ```typescript
         * // get the nativeElement of the second selected row
         * let selectedRowNativeElement = this.grid.selectedRows[1].nativeElement;
         * ```
         */
        get: /**
         * The native DOM element representing the row. Could be null in certain environments.
         *
         * ```typescript
         * // get the nativeElement of the second selected row
         * let selectedRowNativeElement = this.grid.selectedRows[1].nativeElement;
         * ```
         * @return {?}
         */
        function () {
            return this.element.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxRowComponent.prototype.onCheckboxClick = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var newSelection = (event.checked) ?
            this.selection.add_item(this.gridID, this.rowID) :
            this.selection.delete_item(this.gridID, this.rowID);
        this.grid.triggerRowSelectionChange(newSelection, this, event);
    };
    /**
     * Updates the specified row object and the data source record with the passed value.
     * This method emits `onEditDone` event.
     *
     * ```typescript
     * // update the second selected row's value
     * let newValue = "Apple";
     * this.grid.selectedRows[1].update(newValue);
     * ```
     */
    /**
     * Updates the specified row object and the data source record with the passed value.
     * This method emits `onEditDone` event.
     *
     * ```typescript
     * // update the second selected row's value
     * let newValue = "Apple";
     * this.grid.selectedRows[1].update(newValue);
     * ```
     * @param {?} value
     * @return {?}
     */
    IgxRowComponent.prototype.update = /**
     * Updates the specified row object and the data source record with the passed value.
     * This method emits `onEditDone` event.
     *
     * ```typescript
     * // update the second selected row's value
     * let newValue = "Apple";
     * this.grid.selectedRows[1].update(newValue);
     * ```
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var crudService = this.crudService;
        if (crudService.inEditMode && crudService.cell.id.rowID === this.rowID) {
            this.grid.endEdit(false);
        }
        /** @type {?} */
        var row = new IgxRow(this.rowID, this.index, this.rowData);
        this.gridAPI.update_row(row, value);
        this.cdr.markForCheck();
    };
    /**
     * Removes the specified row from the grid's data source.
     * This method emits `onRowDeleted` event.
     *
     * ```typescript
     * // delete the third selected row from the grid
     * this.grid.selectedRows[2].delete();
     * ```
     */
    /**
     * Removes the specified row from the grid's data source.
     * This method emits `onRowDeleted` event.
     *
     * ```typescript
     * // delete the third selected row from the grid
     * this.grid.selectedRows[2].delete();
     * ```
     * @return {?}
     */
    IgxRowComponent.prototype.delete = /**
     * Removes the specified row from the grid's data source.
     * This method emits `onRowDeleted` event.
     *
     * ```typescript
     * // delete the third selected row from the grid
     * this.grid.selectedRows[2].delete();
     * ```
     * @return {?}
     */
    function () {
        this.grid.deleteRowById(this.rowID);
    };
    Object.defineProperty(IgxRowComponent.prototype, "rowCheckboxAriaLabel", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.grid.primaryKey ?
                this.isSelected ? 'Deselect row with key ' + this.rowID : 'Select row with key ' + this.rowID :
                this.isSelected ? 'Deselect row' : 'Select row';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxRowComponent.prototype.ngDoCheck = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.isSelected = this.rowSelectable ?
            this.grid.allRowsSelected ? true : this.selection.is_item_selected(this.gridID, this.rowID) :
            this.selection.is_item_selected(this.gridID, this.rowID);
        this.cdr.markForCheck();
        if (this.checkboxElement) {
            this.checkboxElement.checked = this.isSelected;
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    IgxRowComponent.prototype.resolveClasses = /**
     * @hidden
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var indexClass = this.index % 2 ? this.grid.evenRowCSS : this.grid.oddRowCSS;
        /** @type {?} */
        var selectedClass = this.isSelected ? 'igx-grid__tr--selected' : '';
        /** @type {?} */
        var editClass = this.inEditMode ? 'igx-grid__tr--edit' : '';
        /** @type {?} */
        var dirtyClass = this.dirty ? 'igx-grid__tr--edited' : '';
        /** @type {?} */
        var deletedClass = this.deleted ? 'igx-grid__tr--deleted' : '';
        /** @type {?} */
        var mrlClass = this.grid.hasColumnLayouts ? 'igx-grid__tr--mrl' : '';
        /** @type {?} */
        var dragClass = this.dragging ? 'igx-grid__tr--drag' : '';
        return (this.defaultCssClass + " " + indexClass + " " + selectedClass + " " + editClass + " " + dirtyClass + "\n         " + deletedClass + " " + mrlClass + " " + dragClass).trim();
    };
    Object.defineProperty(IgxRowComponent.prototype, "resolveDragIndicatorClasses", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            /** @type {?} */
            var defaultDragIndicatorCssClass = 'igx-grid__drag-indicator';
            /** @type {?} */
            var dragIndicatorOff = this.grid.rowDragging && !this.dragging ? 'igx-grid__drag-indicator--off' : '';
            return defaultDragIndicatorCssClass + " " + dragIndicatorOff;
        },
        enumerable: true,
        configurable: true
    });
    IgxRowComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-row',
                    template: "<ng-container *ngIf=\"grid.groupingExpressions.length > 0\">\n    <div class=\"igx-grid__row-indentation igx-grid__row-indentation--level-{{grid.groupingExpressions.length}}\"></div>\n</ng-container>\n<ng-container *ngIf=\"rowDraggable\">\n    <div [class]=\"resolveDragIndicatorClasses\" [igxRowDrag]=\"this\">\n        <ng-container *ngTemplateOutlet=\"this.grid.dragIndicatorIconTemplate ? this.grid.dragIndicatorIconTemplate : this.grid.dragIndicatorIconBase\"></ng-container>\n    </div>\n</ng-container>\n<ng-container *ngIf=\"showRowCheckboxes\">\n    <div class=\"igx-grid__cbx-selection\">\n        <igx-checkbox [checked]=\"isSelected\" [disabled]=\"deleted\" (change)=\"onCheckboxClick($event)\" disableRipple=\"true\" [disableTransitions]=\"grid.disableTransitions\" [aria-label]=\"rowCheckboxAriaLabel\"></igx-checkbox>\n    </div>\n</ng-container>\n\n<ng-container *ngIf=\"!grid.hasColumnLayouts\">\n    <ng-container *ngIf=\"pinnedColumns.length > 0\">\n        <igx-grid-cell *ngFor=\"let col of pinnedColumns | igxNotGrouped\"\n            class=\"igx-grid__td igx-grid__td--fw igx-grid__td--pinned\"\n            [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n            [ngClass]=\"col.cellClasses | igxCellStyles:rowData[col.field]:rowData:col.field\"\n            [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n            [column]=\"col\"\n            [formatter]=\"col.formatter\"\n            [row]=\"this\"\n            [lastPinned]=\"col.isLastPinned\"\n            [style.min-height.px]=\"grid.rowHeight || 32\"\n            [rowData]=\"rowData\"\n            [style.min-width.px]=\"col.width\"\n            [style.flex-basis.px]=\"col.width\"\n            [width]=\"col.getCellWidth()\"\n            [visibleColumnIndex]=\"col.visibleIndex\"\n            [value]=\"rowData[col.field]\"\n            [cellTemplate]=\"col.bodyTemplate\">\n        </igx-grid-cell>\n    </ng-container>\n    <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\" [igxForScrollContainer]=\"grid.parentVirtDir\" [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth' [igxForSizePropName]='\"calcWidth\"' [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n        <igx-grid-cell\n            class=\"igx-grid__td igx-grid__td--fw\"\n            [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n            [ngClass]=\"col.cellClasses | igxCellStyles:rowData[col.field]:rowData:col.field\"\n            [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n            [column]=\"col\"\n            [formatter]=\"col.formatter\"\n            [row]=\"this\"\n            [style.min-height.px]=\"grid.rowHeight || 32\"\n            [rowData]=\"rowData\"\n            [style.min-width.px]=\"col.width\"\n            [style.flex-basis.px]=\"col.width\"\n            [width]=\"col.getCellWidth()\"\n            [visibleColumnIndex]=\"col.visibleIndex\"\n            [value]=\"rowData[col.field]\"\n            [cellTemplate]=\"col.bodyTemplate\">\n        </igx-grid-cell>\n    </ng-template>\n</ng-container>\n\n<ng-container *ngIf=\"grid.hasColumnLayouts\">\n    <ng-container *ngIf=\"pinnedColumns.length > 0\">\n        <div *ngFor=\"let col of pinnedColumns | igxTopLevel\" class=\"igx-grid__mrl-block\"\n        [ngClass]=\"{'igx-grid__th--pinned-last': col.hasLastPinnedChildColumn}\"\n        [ngStyle]=\"{'grid-template-rows':col.getGridTemplate(true, false),\n        'grid-template-columns':col.getGridTemplate(false, false),\n        'z-index': col.pinned ? 1 : null,\n        '-ms-grid-rows':col.getGridTemplate(true, true),\n        '-ms-grid-columns':col.getGridTemplate(false, true)}\">\n            <igx-grid-cell *ngFor=\"let child of col.children\"\n                class=\"igx-grid__td igx-grid__td--fw igx-grid__td--pinned\"\n                [class.igx-grid__td--number]=\"child.dataType === 'number'\"\n                [ngClass]=\"child.cellClasses | igxCellStyles:rowData[child.field]:rowData:child.field\"\n                [editMode]=\"child.editable && crudService.isInEditMode(index, child.index)\"\n                [column]=\"child\"\n                [formatter]=\"child.formatter\"\n                [row]=\"this\"\n                [style.min-height.px]=\"grid.rowHeight || 32\"\n                [rowData]=\"rowData\"\n                [visibleColumnIndex]=\"child.visibleIndex\"\n                [value]=\"rowData[child.field]\"\n                [cellTemplate]=\"child.bodyTemplate\"></igx-grid-cell>\n        </div>\n    </ng-container>\n    <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\" [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth' [igxForSizePropName]='\"calcWidth\"' [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n        <div class=\"igx-grid__mrl-block\"\n        [ngStyle]=\"{'grid-template-rows':col.getGridTemplate(true, false),\n     'grid-template-columns':col.getGridTemplate(false, false),\n     '-ms-grid-rows':col.getGridTemplate(true, true),\n     '-ms-grid-columns':col.getGridTemplate(false, true)}\">\n            <igx-grid-cell *ngFor=\"let child of col.children\"\n                class=\"igx-grid__td igx-grid__td--fw\"\n                [class.igx-grid__td--number]=\"child.dataType === 'number'\"\n                [ngClass]=\"child.cellClasses | igxCellStyles:rowData[child.field]:rowData:child.field\"\n                [editMode]=\"child.editable && crudService.isInEditMode(index, child.index)\"\n                [column]=\"child\"\n                [formatter]=\"child.formatter\"\n                [row]=\"this\"\n                [style.min-height.px]=\"grid.rowHeight || 32\"\n                [rowData]=\"rowData\"\n                [visibleColumnIndex]=\"child.visibleIndex\"\n                [value]=\"rowData[child.field]\"\n                [cellTemplate]=\"child.bodyTemplate\"></igx-grid-cell>\n        </div>\n    </ng-template>\n</ng-container>\n"
                }] }
    ];
    /** @nocollapse */
    IgxRowComponent.ctorParameters = function () { return [
        { type: GridBaseAPIService },
        { type: IgxGridCRUDService },
        { type: IgxGridSelectionService },
        { type: IgxSelectionAPIService },
        { type: ElementRef },
        { type: ChangeDetectorRef }
    ]; };
    IgxRowComponent.propDecorators = {
        rowData: [{ type: Input }],
        index: [{ type: Input }],
        gridID: [{ type: Input }],
        virtDirRow: [{ type: ViewChild, args: ['igxDirRef', { read: IgxGridForOfDirective },] }],
        checkboxElement: [{ type: ViewChild, args: [forwardRef(function () { return IgxCheckboxComponent; }), { read: IgxCheckboxComponent },] }],
        cells: [{ type: ViewChildren, args: [forwardRef(function () { return IgxGridCellComponent; }),] }],
        role: [{ type: HostBinding, args: ['attr.role',] }],
        dataRowIndex: [{ type: HostBinding, args: ['attr.data-rowIndex',] }],
        styleClasses: [{ type: HostBinding, args: ['class',] }],
        isSelected: [{ type: HostBinding, args: ['attr.aria-selected',] }]
    };
    return IgxRowComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxColumnResizingService = /** @class */ (function () {
    function IgxColumnResizingService(zone) {
        this.zone = zone;
        /**
         * @hidden
         */
        this.resizeCursor = null;
        /**
         * @hidden
         */
        this.showResizer = false;
    }
    Object.defineProperty(IgxColumnResizingService.prototype, "resizerHeight", {
        /**
         *@hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            /** @type {?} */
            var height = this.column.grid.getVisibleContentHeight();
            // Column height multiplier in case there are Column Layouts. The resizer height need to take into account rowStart.
            /** @type {?} */
            var columnHeightMultiplier = 1;
            if (this.column.parent && this.column.parent.columnLayout) {
                columnHeightMultiplier = this.column.grid.multiRowLayoutRowSize - this.column.rowStart + 1;
            }
            if (this.column.level !== 0) {
                height -= this.column.topLevelParent.headerGroup.height - this.column.headerGroup.height * columnHeightMultiplier;
            }
            return height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnResizingService.prototype, "restrictResizeMin", {
        /**
         * Returns the minimal possible width to which the column can be resized.
         */
        get: /**
         * Returns the minimal possible width to which the column can be resized.
         * @return {?}
         */
        function () {
            /** @type {?} */
            var columnLayoutMultiplier = this.column.grid.hasColumnLayouts ? this.column.gridColumnSpan : 1;
            /** @type {?} */
            var actualMinWidth = parseFloat(this.column.minWidth);
            /** @type {?} */
            var defaultMinWidth = parseFloat(this.column.defaultMinWidth) * columnLayoutMultiplier;
            /** @type {?} */
            var minWidth = Number.isNaN(actualMinWidth) || actualMinWidth < defaultMinWidth ? defaultMinWidth : actualMinWidth;
            minWidth = minWidth < parseFloat(this.column.width) ? minWidth : parseFloat(this.column.width);
            return this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width - minWidth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnResizingService.prototype, "restrictResizeMax", {
        /**
         * Returns the maximal possible width to which the column can be resized.
         */
        get: /**
         * Returns the maximal possible width to which the column can be resized.
         * @return {?}
         */
        function () {
            /** @type {?} */
            var actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
            if (this.column.pinned) {
                /** @type {?} */
                var pinnedMaxWidth = this.pinnedMaxWidth =
                    this.column.grid.calcPinnedContainerMaxWidth - this.column.grid.getPinnedWidth(true) + actualWidth;
                if (this.column.maxWidth && parseFloat(this.column.maxWidth) < pinnedMaxWidth) {
                    this.pinnedMaxWidth = this.column.maxWidth;
                    return parseFloat(this.column.maxWidth) - actualWidth;
                }
                else {
                    return pinnedMaxWidth - actualWidth;
                }
            }
            else {
                if (this.column.maxWidth) {
                    return parseFloat(this.column.maxWidth) - actualWidth;
                }
                else {
                    return Number.MAX_SAFE_INTEGER;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Autosizes the column to the longest currently visible cell value, including the header cell.
     * If the column has a predifined maxWidth and the autosized column width will become bigger than it,
     * then the column is sized to its maxWidth.
     * If the column is pinned and the autosized column width will cause the pinned area to become bigger
     * than the maximum allowed pinned area width (80% of the total grid width), autosizing will be deismissed.
     */
    /**
     * Autosizes the column to the longest currently visible cell value, including the header cell.
     * If the column has a predifined maxWidth and the autosized column width will become bigger than it,
     * then the column is sized to its maxWidth.
     * If the column is pinned and the autosized column width will cause the pinned area to become bigger
     * than the maximum allowed pinned area width (80% of the total grid width), autosizing will be deismissed.
     * @return {?}
     */
    IgxColumnResizingService.prototype.autosizeColumnOnDblClick = /**
     * Autosizes the column to the longest currently visible cell value, including the header cell.
     * If the column has a predifined maxWidth and the autosized column width will become bigger than it,
     * then the column is sized to its maxWidth.
     * If the column is pinned and the autosized column width will cause the pinned area to become bigger
     * than the maximum allowed pinned area width (80% of the total grid width), autosizing will be deismissed.
     * @return {?}
     */
    function () {
        /** @type {?} */
        var currentColWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        /** @type {?} */
        var size = this.column.getLargestCellWidth();
        if (this.column.pinned) {
            /** @type {?} */
            var newPinnedWidth = this.column.grid.getPinnedWidth(true) - currentColWidth + parseFloat(size);
            if (newPinnedWidth <= this.column.grid.calcPinnedContainerMaxWidth) {
                this.column.width = size;
            }
        }
        else if (this.column.maxWidth && (parseFloat(size) > parseFloat(this.column.maxWidth))) {
            this.column.width = parseFloat(this.column.maxWidth) + 'px';
        }
        else if (parseFloat(size) < parseFloat(this.column.defaultMinWidth)) {
            this.column.width = this.column.defaultMinWidth + 'px';
        }
        else {
            this.column.width = size;
        }
        this.zone.run(function () { });
        this.column.grid.reflow();
        this.column.grid.onColumnResized.emit({
            column: this.column,
            prevWidth: currentColWidth.toString(),
            newWidth: this.column.width
        });
    };
    /**
     * Resizes the column regaridng to the column minWidth and maxWidth.
     */
    /**
     * Resizes the column regaridng to the column minWidth and maxWidth.
     * @param {?} event
     * @return {?}
     */
    IgxColumnResizingService.prototype.resizeColumn = /**
     * Resizes the column regaridng to the column minWidth and maxWidth.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.showResizer = false;
        /** @type {?} */
        var diff = event.clientX - this.startResizePos;
        /** @type {?} */
        var currentColWidth = parseFloat(this.column.width);
        /** @type {?} */
        var actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        currentColWidth = Number.isNaN(currentColWidth) || (currentColWidth < actualWidth) ? actualWidth : currentColWidth;
        /** @type {?} */
        var colMinWidth = this.getColMinWidth(this.column);
        /** @type {?} */
        var colMaxWidth = this.getColMaxWidth(this.column);
        if (this.column.grid.hasColumnLayouts) {
            this.resizeColumnLayoutFor(this.column, diff);
        }
        else {
            if (currentColWidth + diff < colMinWidth) {
                this.column.width = colMinWidth + 'px';
            }
            else if (colMaxWidth && (currentColWidth + diff > colMaxWidth)) {
                this.column.width = colMaxWidth + 'px';
            }
            else {
                this.column.width = (currentColWidth + diff) + 'px';
            }
        }
        this.zone.run(function () { });
        this.column.grid.reflow();
        if (currentColWidth !== parseFloat(this.column.width)) {
            this.column.grid.onColumnResized.emit({
                column: this.column,
                prevWidth: currentColWidth.toString(),
                newWidth: this.column.width
            });
        }
        this.isColumnResizing = false;
    };
    /**
     * @protected
     * @param {?} column
     * @return {?}
     */
    IgxColumnResizingService.prototype.getColMinWidth = /**
     * @protected
     * @param {?} column
     * @return {?}
     */
    function (column) {
        /** @type {?} */
        var currentColWidth = parseFloat(column.width);
        /** @type {?} */
        var actualWidth = column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        currentColWidth = Number.isNaN(currentColWidth) || (currentColWidth < actualWidth) ? actualWidth : currentColWidth;
        /** @type {?} */
        var columnLayoutMultiplier = column.grid.hasColumnLayouts ? column.gridColumnSpan : 1;
        /** @type {?} */
        var actualMinWidth = parseFloat(column.minWidth);
        /** @type {?} */
        var defaultMinWidth = parseFloat(column.defaultMinWidth) * columnLayoutMultiplier;
        /** @type {?} */
        var colMinWidth = Number.isNaN(actualMinWidth) || actualMinWidth < defaultMinWidth ? defaultMinWidth : actualMinWidth;
        return colMinWidth < currentColWidth ? colMinWidth : currentColWidth;
    };
    /**
     * @protected
     * @param {?} column
     * @return {?}
     */
    IgxColumnResizingService.prototype.getColMaxWidth = /**
     * @protected
     * @param {?} column
     * @return {?}
     */
    function (column) {
        return column.pinned ? parseFloat(this.pinnedMaxWidth) : parseFloat(column.maxWidth);
    };
    /**
     * @protected
     * @param {?} column
     * @param {?} diff
     * @return {?}
     */
    IgxColumnResizingService.prototype.resizeColumnLayoutFor = /**
     * @protected
     * @param {?} column
     * @param {?} diff
     * @return {?}
     */
    function (column, diff) {
        var _this = this;
        /** @type {?} */
        var relativeColumns = column.getResizableColUnderEnd();
        /** @type {?} */
        var combinedSpan = relativeColumns.reduce(function (acc, col) { return acc + col.spanUsed; }, 0);
        if (column.pinned) {
            /** @type {?} */
            var pinnedWidth = this.column.grid.getPinnedWidth(true);
            /** @type {?} */
            var maxPinnedWidth = this.column.grid.calcPinnedContainerMaxWidth;
            if (pinnedWidth + diff > maxPinnedWidth) {
                diff = maxPinnedWidth - pinnedWidth;
            }
        }
        // Resize first those who might reach min/max width
        /** @type {?} */
        var columnsToResize = __spread(relativeColumns);
        /** @type {?} */
        var updatedDiff = diff;
        /** @type {?} */
        var updatedCombinedSpan = combinedSpan;
        /** @type {?} */
        var setMinMaxCols = false;
        var _loop_1 = function () {
            // Cycle them until there are not ones that reach min/max size, because the diff accumulates after each cycle.
            // This is because we can have at first 2 cols reaching min width and then after
            // recalculating the diff there might be 1 more that reaches min width.
            setMinMaxCols = false;
            /** @type {?} */
            var newCombinedSpan = updatedCombinedSpan;
            /** @type {?} */
            var newColsToResize = [];
            columnsToResize.forEach(function (col) {
                /** @type {?} */
                var currentResizeWidth = parseFloat(col.target.calcWidth);
                /** @type {?} */
                var resizeScaled = (diff / updatedCombinedSpan) * col.target.gridColumnSpan;
                /** @type {?} */
                var minWidth = _this.getColMinWidth(col.target);
                /** @type {?} */
                var maxWidth = _this.getColMaxWidth(col.target);
                if (currentResizeWidth + resizeScaled < minWidth) {
                    col.target.width = minWidth + 'px';
                    updatedDiff += (currentResizeWidth - minWidth);
                    newCombinedSpan -= col.spanUsed;
                    setMinMaxCols = true;
                }
                else if (maxWidth && (currentResizeWidth + resizeScaled > maxWidth)) {
                    col.target.width = maxWidth + 'px';
                    updatedDiff -= (maxWidth - currentResizeWidth);
                    newCombinedSpan -= col.spanUsed;
                    setMinMaxCols = true;
                }
                else {
                    // Save new ones that can be resized
                    newColsToResize.push(col);
                }
            });
            updatedCombinedSpan = newCombinedSpan;
            columnsToResize = newColsToResize;
        };
        do {
            _loop_1();
        } while (setMinMaxCols);
        // Those left that don't reach min/max size resize them normally.
        columnsToResize.forEach(function (col) {
            /** @type {?} */
            var currentResizeWidth = parseFloat(col.target.calcWidth);
            /** @type {?} */
            var resizeScaled = (updatedDiff / updatedCombinedSpan) * col.target.gridColumnSpan;
            col.target.width = (currentResizeWidth + resizeScaled) + 'px';
        });
    };
    IgxColumnResizingService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    IgxColumnResizingService.ctorParameters = function () { return [
        { type: NgZone }
    ]; };
    return IgxColumnResizingService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var DEFAULT_DATE_FORMAT = 'mediumDate';
/** @type {?} */
var DEBOUNCE_TIME = 200;
/**
 * @hidden
 */
var IgxResizeHandleDirective = /** @class */ (function () {
    function IgxResizeHandleDirective(zone, element, colResizingService) {
        this.zone = zone;
        this.element = element;
        this.colResizingService = colResizingService;
        /**
         * @hidden
         */
        this._dblClick = false;
        /**
         * @hidden
         */
        this.destroy$ = new Subject();
    }
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxResizeHandleDirective.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.destroy$.next(true);
        this.destroy$.complete();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxResizeHandleDirective.prototype.ngAfterViewInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.column.columnGroup && this.column.resizable) {
            this.zone.runOutsideAngular(function () {
                fromEvent(_this.element.nativeElement, 'mousedown').pipe(debounceTime(DEBOUNCE_TIME), takeUntil(_this.destroy$)).subscribe(function (event) {
                    if (_this._dblClick) {
                        _this._dblClick = false;
                        return;
                    }
                    if (event.button === 0) {
                        _this._onResizeAreaMouseDown(event);
                        _this.column.grid.resizeLine.resizer.onMousedown(event);
                    }
                });
            });
            fromEvent(this.element.nativeElement, 'mouseup').pipe(debounceTime(DEBOUNCE_TIME), takeUntil(this.destroy$)).subscribe(function () {
                _this.colResizingService.showResizer = false;
                _this.column.grid.cdr.detectChanges();
            });
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxResizeHandleDirective.prototype.onMouseOver = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.colResizingService.resizeCursor = 'col-resize';
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxResizeHandleDirective.prototype.onDoubleClick = /**
     * @hidden
     * @return {?}
     */
    function () {
        this._dblClick = true;
        this.colResizingService.column = this.column;
        this.colResizingService.autosizeColumnOnDblClick();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @private
     * @param {?} event
     * @return {?}
     */
    IgxResizeHandleDirective.prototype._onResizeAreaMouseDown = /**
     * @hidden
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.colResizingService.column = this.column;
        this.colResizingService.isColumnResizing = true;
        this.colResizingService.startResizePos = event.clientX;
        this.colResizingService.showResizer = true;
        this.column.grid.cdr.detectChanges();
    };
    IgxResizeHandleDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxResizeHandle]'
                },] }
    ];
    /** @nocollapse */
    IgxResizeHandleDirective.ctorParameters = function () { return [
        { type: NgZone },
        { type: ElementRef },
        { type: IgxColumnResizingService }
    ]; };
    IgxResizeHandleDirective.propDecorators = {
        column: [{ type: Input, args: ['igxResizeHandle',] }],
        onMouseOver: [{ type: HostListener, args: ['mouseover',] }],
        onDoubleClick: [{ type: HostListener, args: ['dblclick',] }]
    };
    return IgxResizeHandleDirective;
}());
/**
 * @hidden
 */
var IgxColumnResizerDirective = /** @class */ (function () {
    function IgxColumnResizerDirective(element, document, zone) {
        var _this = this;
        this.element = element;
        this.document = document;
        this.zone = zone;
        this.restrictHResizeMin = Number.MIN_SAFE_INTEGER;
        this.restrictHResizeMax = Number.MAX_SAFE_INTEGER;
        this.resizeEnd = new Subject();
        this.resizeStart = new Subject();
        this.resize = new Subject();
        this._destroy = new Subject();
        this.resizeStart.pipe(map(function (event) { return event.clientX; }), takeUntil(this._destroy), switchMap(function (offset) { return _this.resize.pipe(map(function (event) { return event.clientX - offset; }), takeUntil(_this.resizeEnd), takeUntil(_this._destroy)); })).subscribe(function (pos) {
            /** @type {?} */
            var left = _this._left + pos;
            /** @type {?} */
            var min = _this._left - _this.restrictHResizeMin;
            /** @type {?} */
            var max = _this._left + _this.restrictHResizeMax;
            _this.left = left < min ? min : left;
            if (left > max) {
                _this.left = max;
            }
        });
    }
    /**
     * @return {?}
     */
    IgxColumnResizerDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.zone.runOutsideAngular(function () {
            fromEvent(_this.document.defaultView, 'mousemove').pipe(throttle(function () { return interval(0, animationFrameScheduler); }), takeUntil(_this._destroy)).subscribe(function (res) { return _this.onMousemove(res); });
            fromEvent(_this.document.defaultView, 'mouseup').pipe(takeUntil(_this._destroy))
                .subscribe(function (res) { return _this.onMouseup(res); });
        });
    };
    /**
     * @return {?}
     */
    IgxColumnResizerDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._destroy.next(true);
        this._destroy.complete();
    };
    Object.defineProperty(IgxColumnResizerDirective.prototype, "left", {
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            var _this = this;
            requestAnimationFrame(function () { return _this.element.nativeElement.style.left = val + 'px'; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnResizerDirective.prototype, "top", {
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            var _this = this;
            requestAnimationFrame(function () { return _this.element.nativeElement.style.top = val + 'px'; });
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} event
     * @return {?}
     */
    IgxColumnResizerDirective.prototype.onMouseup = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.resizeEnd.next(event);
        this.resizeEnd.complete();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    IgxColumnResizerDirective.prototype.onMousedown = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        /** @type {?} */
        var parent = this.element.nativeElement.parentElement.parentElement;
        this.left = this._left = event.clientX - parent.getBoundingClientRect().left;
        this.top = event.target.getBoundingClientRect().top - parent.getBoundingClientRect().top;
        this.resizeStart.next(event);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    IgxColumnResizerDirective.prototype.onMousemove = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        this.resize.next(event);
    };
    IgxColumnResizerDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxResizer]'
                },] }
    ];
    /** @nocollapse */
    IgxColumnResizerDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: NgZone }
    ]; };
    IgxColumnResizerDirective.propDecorators = {
        restrictHResizeMin: [{ type: Input }],
        restrictHResizeMax: [{ type: Input }],
        resizeEnd: [{ type: Output }],
        resizeStart: [{ type: Output }],
        resize: [{ type: Output }]
    };
    return IgxColumnResizerDirective;
}());
var IgxFilterCellTemplateDirective = /** @class */ (function () {
    function IgxFilterCellTemplateDirective(template) {
        this.template = template;
    }
    IgxFilterCellTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxFilterCellTemplate]'
                },] }
    ];
    /** @nocollapse */
    IgxFilterCellTemplateDirective.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return IgxFilterCellTemplateDirective;
}());
var IgxCellTemplateDirective = /** @class */ (function () {
    function IgxCellTemplateDirective(template) {
        this.template = template;
    }
    IgxCellTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxCell]'
                },] }
    ];
    /** @nocollapse */
    IgxCellTemplateDirective.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return IgxCellTemplateDirective;
}());
var IgxCellHeaderTemplateDirective = /** @class */ (function () {
    function IgxCellHeaderTemplateDirective(template) {
        this.template = template;
    }
    IgxCellHeaderTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxHeader]'
                },] }
    ];
    /** @nocollapse */
    IgxCellHeaderTemplateDirective.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return IgxCellHeaderTemplateDirective;
}());
/**
 * @hidden
 */
var IgxCellFooterTemplateDirective = /** @class */ (function () {
    function IgxCellFooterTemplateDirective(template) {
        this.template = template;
    }
    IgxCellFooterTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxFooter]'
                },] }
    ];
    /** @nocollapse */
    IgxCellFooterTemplateDirective.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return IgxCellFooterTemplateDirective;
}());
var IgxCellEditorTemplateDirective = /** @class */ (function () {
    function IgxCellEditorTemplateDirective(template) {
        this.template = template;
    }
    IgxCellEditorTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxCellEditor]'
                },] }
    ];
    /** @nocollapse */
    IgxCellEditorTemplateDirective.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return IgxCellEditorTemplateDirective;
}());
/**
 * @hidden
 */
var IgxColumnMovingService = /** @class */ (function () {
    function IgxColumnMovingService() {
    }
    Object.defineProperty(IgxColumnMovingService.prototype, "column", {
        get: /**
         * @return {?}
         */
        function () {
            return this._column;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            if (val) {
                this._column = val;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnMovingService.prototype, "icon", {
        get: /**
         * @return {?}
         */
        function () {
            return this._icon;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            if (val) {
                this._icon = val;
            }
        },
        enumerable: true,
        configurable: true
    });
    IgxColumnMovingService.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    /** @nocollapse */ IgxColumnMovingService.ngInjectableDef = defineInjectable({ factory: function IgxColumnMovingService_Factory() { return new IgxColumnMovingService(); }, token: IgxColumnMovingService, providedIn: "root" });
    return IgxColumnMovingService;
}());
/** @enum {number} */
var DropPosition = {
    BeforeDropTarget: 0,
    AfterDropTarget: 1,
    None: 2,
};
DropPosition[DropPosition.BeforeDropTarget] = 'BeforeDropTarget';
DropPosition[DropPosition.AfterDropTarget] = 'AfterDropTarget';
DropPosition[DropPosition.None] = 'None';
/**
 * @hidden
 */
var IgxColumnMovingDragDirective = /** @class */ (function (_super) {
    __extends(IgxColumnMovingDragDirective, _super);
    function IgxColumnMovingDragDirective(_element, _zone, _renderer, _cdr, cms) {
        var _this = _super.call(this, _cdr, _element, _zone, _renderer) || this;
        _this.cms = cms;
        _this._ghostImageClass = 'igx-grid__drag-ghost-image';
        _this.dragGhostImgIconClass = 'igx-grid__drag-ghost-image-icon';
        _this.dragGhostImgIconGroupClass = 'igx-grid__drag-ghost-image-icon-group';
        return _this;
    }
    Object.defineProperty(IgxColumnMovingDragDirective.prototype, "data", {
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._column = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnMovingDragDirective.prototype, "column", {
        get: /**
         * @return {?}
         */
        function () {
            return this._column;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnMovingDragDirective.prototype, "draggable", {
        get: /**
         * @return {?}
         */
        function () {
            return this.column && (this.column.movable || (this.column.groupable && !this.column.columnGroup));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnMovingDragDirective.prototype, "icon", {
        get: /**
         * @return {?}
         */
        function () {
            return this.cms.icon;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    IgxColumnMovingDragDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._unsubscribe();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    IgxColumnMovingDragDirective.prototype.onEscape = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.cms.cancelDrop = true;
        this.onPointerUp(event);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    IgxColumnMovingDragDirective.prototype.onPointerDown = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        if (!this.draggable || event.target.getAttribute('draggable') === 'false') {
            return;
        }
        event.preventDefault();
        event.stopPropagation();
        this._removeOnDestroy = false;
        this.cms.column = this.column;
        this.ghostImageClass = this._ghostImageClass;
        _super.prototype.onPointerDown.call(this, event);
        this.cms.isColumnMoving = true;
        this.column.grid.cdr.detectChanges();
        /** @type {?} */
        var args = {
            source: this.column
        };
        this.column.grid.onColumnMovingStart.emit(args);
        this.subscription$ = fromEvent(this.column.grid.document.defaultView, 'keydown').subscribe(function (ev) {
            if (ev.key === "Escape" /* ESCAPE */ || ev.key === "Esc" /* ESCAPE_IE */) {
                _this.onEscape(ev);
            }
        });
    };
    /**
     * @param {?} event
     * @return {?}
     */
    IgxColumnMovingDragDirective.prototype.onPointerMove = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        _super.prototype.onPointerMove.call(this, event);
        if (this._dragStarted && this.dragGhost && !this.column.grid.draggedColumn) {
            this.column.grid.draggedColumn = this.column;
            this.column.grid.cdr.detectChanges();
        }
        if (this.cms.isColumnMoving) {
            /** @type {?} */
            var args = {
                source: this.column,
                cancel: false
            };
            this.column.grid.onColumnMoving.emit(args);
            if (args.cancel) {
                this.onEscape(event);
            }
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    IgxColumnMovingDragDirective.prototype.onPointerUp = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        // Run it explicitly inside the zone because sometimes onPointerUp executes after the code below.
        this.zone.run(function () {
            _super.prototype.onPointerUp.call(_this, event);
            _this.cms.isColumnMoving = false;
            _this.column.grid.draggedColumn = null;
            _this.column.grid.cdr.detectChanges();
        });
        this._unsubscribe();
    };
    /**
     * @protected
     * @param {?} event
     * @return {?}
     */
    IgxColumnMovingDragDirective.prototype.createDragGhost = /**
     * @protected
     * @param {?} event
     * @return {?}
     */
    function (event) {
        _super.prototype.createDragGhost.call(this, event);
        /** @type {?} */
        var pageX;
        /** @type {?} */
        var pageY;
        if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
            pageX = event.pageX;
            pageY = event.pageY;
        }
        else {
            pageX = event.touches[0].pageX;
            pageY = event.touches[0].pageY;
        }
        this.dragGhost.style.height = null;
        this.dragGhost.style.minWidth = null;
        this.dragGhost.style.flexBasis = null;
        this.dragGhost.style.position = null;
        /** @type {?} */
        var icon = document.createElement('i');
        /** @type {?} */
        var text = document.createTextNode('block');
        icon.appendChild(text);
        icon.classList.add('material-icons');
        this.cms.icon = icon;
        /** @type {?} */
        var hostElemLeft = this.dragGhostHost ? this.dragGhostHost.getBoundingClientRect().left : 0;
        /** @type {?} */
        var hostElemTop = this.dragGhostHost ? this.dragGhostHost.getBoundingClientRect().top : 0;
        if (!this.column.columnGroup) {
            this.renderer.addClass(icon, this.dragGhostImgIconClass);
            this.dragGhost.insertBefore(icon, this.dragGhost.firstElementChild);
            this.left = this._dragStartX = pageX - ((this.dragGhost.getBoundingClientRect().width / 3) * 2) - hostElemLeft;
            this.top = this._dragStartY = pageY - ((this.dragGhost.getBoundingClientRect().height / 3) * 2) - hostElemTop;
        }
        else {
            this.dragGhost.insertBefore(icon, this.dragGhost.childNodes[0]);
            this.renderer.addClass(icon, this.dragGhostImgIconGroupClass);
            this.dragGhost.children[0].style.paddingLeft = '0px';
            this.left = this._dragStartX = pageX - ((this.dragGhost.getBoundingClientRect().width / 3) * 2) - hostElemLeft;
            this.top = this._dragStartY = pageY - ((this.dragGhost.getBoundingClientRect().height / 3) * 2) - hostElemTop;
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxColumnMovingDragDirective.prototype._unsubscribe = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.subscription$) {
            this.subscription$.unsubscribe();
            this.subscription$ = null;
        }
    };
    IgxColumnMovingDragDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxColumnMovingDrag]'
                },] }
    ];
    /** @nocollapse */
    IgxColumnMovingDragDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: NgZone },
        { type: Renderer2 },
        { type: ChangeDetectorRef },
        { type: IgxColumnMovingService }
    ]; };
    IgxColumnMovingDragDirective.propDecorators = {
        data: [{ type: Input, args: ['igxColumnMovingDrag',] }]
    };
    return IgxColumnMovingDragDirective;
}(IgxDragDirective));
/**
 * @hidden
 */
var IgxColumnMovingDropDirective = /** @class */ (function (_super) {
    __extends(IgxColumnMovingDropDirective, _super);
    function IgxColumnMovingDropDirective(elementRef, renderer, zone, cms) {
        var _this = _super.call(this, elementRef, renderer, zone) || this;
        _this.elementRef = elementRef;
        _this.renderer = renderer;
        _this.zone = zone;
        _this.cms = cms;
        _this._dropIndicator = null;
        _this._lastDropIndicator = null;
        _this._dragLeave = new Subject();
        _this._dropIndicatorClass = 'igx-grid__th-drop-indicator--active';
        return _this;
    }
    Object.defineProperty(IgxColumnMovingDropDirective.prototype, "data", {
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            if (val instanceof IgxColumnComponent) {
                this._column = val;
            }
            if (val instanceof IgxGridForOfDirective) {
                this._hVirtDir = val;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnMovingDropDirective.prototype, "column", {
        get: /**
         * @return {?}
         */
        function () {
            return this._column;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnMovingDropDirective.prototype, "isDropTarget", {
        get: /**
         * @return {?}
         */
        function () {
            return this._column && this._column.grid.hasMovableColumns && this.cms.column.movable && !this.cms.column.disablePinning;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnMovingDropDirective.prototype, "horizontalScroll", {
        get: /**
         * @return {?}
         */
        function () {
            if (this._hVirtDir) {
                return this._hVirtDir;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    IgxColumnMovingDropDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._dragLeave.next(true);
        this._dragLeave.complete();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    IgxColumnMovingDropDirective.prototype.onDragOver = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.isDropTarget &&
            this.cms.column !== this.column &&
            this.cms.column.level === this.column.level &&
            this.cms.column.parent === this.column.parent) {
            if (this._lastDropIndicator) {
                this.renderer.removeClass(this._dropIndicator, this._dropIndicatorClass);
            }
            /** @type {?} */
            var clientRect = this.elementRef.nativeElement.getBoundingClientRect();
            /** @type {?} */
            var pos = clientRect.left + clientRect.width / 2;
            /** @type {?} */
            var parent_1 = this.elementRef.nativeElement.parentElement;
            if (event.detail.pageX < pos) {
                this._dropPos = DropPosition.BeforeDropTarget;
                this._lastDropIndicator = this._dropIndicator = parent_1.firstElementChild;
            }
            else {
                this._dropPos = DropPosition.AfterDropTarget;
                this._lastDropIndicator = this._dropIndicator = parent_1.lastElementChild;
            }
            if (this.cms.icon.innerText !== 'block') {
                this.renderer.addClass(this._dropIndicator, this._dropIndicatorClass);
            }
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    IgxColumnMovingDropDirective.prototype.onDragEnter = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        /** @type {?} */
        var drag = event.detail.owner;
        if (!(drag instanceof IgxColumnMovingDragDirective)) {
            return;
        }
        if (this.column && this.cms.column.grid.id !== this.column.grid.id) {
            this.cms.icon.innerText = 'block';
            return;
        }
        if (this.isDropTarget &&
            this.cms.column !== this.column &&
            this.cms.column.level === this.column.level &&
            this.cms.column.parent === this.column.parent) {
            if (!this.column.pinned || (this.column.pinned && this.cms.column.pinned)) {
                this.cms.icon.innerText = 'swap_horiz';
            }
            if (!this.cms.column.pinned && this.column.pinned) {
                /** @type {?} */
                var nextPinnedWidth = this.column.grid.getPinnedWidth(true) + parseFloat(this.cms.column.width);
                if (nextPinnedWidth <= this.column.grid.calcPinnedContainerMaxWidth) {
                    this.cms.icon.innerText = 'lock';
                }
                else {
                    this.cms.icon.innerText = 'block';
                }
            }
        }
        else {
            this.cms.icon.innerText = 'block';
        }
        if (this.horizontalScroll) {
            this.cms.icon.innerText = event.target.id === 'right' ? 'arrow_forward' : 'arrow_back';
            interval(100).pipe(takeUntil(this._dragLeave)).subscribe(function () {
                _this.cms.column.grid.wheelHandler();
                event.target.id === 'right' ? _this.horizontalScroll.getHorizontalScroll().scrollLeft += 15 :
                    _this.horizontalScroll.getHorizontalScroll().scrollLeft -= 15;
            });
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    IgxColumnMovingDropDirective.prototype.onDragLeave = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var drag = event.detail.owner;
        if (!(drag instanceof IgxColumnMovingDragDirective)) {
            return;
        }
        this.cms.icon.innerText = 'block';
        if (this._dropIndicator) {
            this.renderer.removeClass(this._dropIndicator, this._dropIndicatorClass);
        }
        if (this.horizontalScroll) {
            this._dragLeave.next(true);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    IgxColumnMovingDropDirective.prototype.onDragDrop = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        /** @type {?} */
        var drag = event.detail.owner;
        if (!(drag instanceof IgxColumnMovingDragDirective)) {
            return;
        }
        if (this.column && (this.cms.column.grid.id !== this.column.grid.id)) {
            return;
        }
        if (this.horizontalScroll) {
            this._dragLeave.next(true);
        }
        if (this.isDropTarget) {
            /** @type {?} */
            var args = {
                source: this.cms.column,
                target: this.column
            };
            /** @type {?} */
            var nextPinnedWidth = void 0;
            if (this.column.pinned && !this.cms.column.pinned) {
                nextPinnedWidth = this.column.grid.getPinnedWidth(true) + parseFloat(this.cms.column.width);
            }
            if ((nextPinnedWidth && nextPinnedWidth > this.column.grid.calcPinnedContainerMaxWidth) ||
                this.column.level !== this.cms.column.level ||
                this.column.parent !== this.cms.column.parent ||
                this.cms.cancelDrop) {
                this.cms.cancelDrop = false;
                this.column.grid.onColumnMovingEnd.emit(args);
                return;
            }
            this.column.grid.moveColumn(this.cms.column, this.column, this._dropPos);
            this.column.grid.draggedColumn = null;
            this.column.grid.cdr.detectChanges();
        }
    };
    IgxColumnMovingDropDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxColumnMovingDrop]'
                },] }
    ];
    /** @nocollapse */
    IgxColumnMovingDropDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 },
        { type: NgZone },
        { type: IgxColumnMovingService }
    ]; };
    IgxColumnMovingDropDirective.propDecorators = {
        data: [{ type: Input, args: ['igxColumnMovingDrop',] }]
    };
    return IgxColumnMovingDropDirective;
}(IgxDropDirective));
var IgxGridBodyDirective = /** @class */ (function () {
    function IgxGridBodyDirective() {
    }
    IgxGridBodyDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxGridBody]',
                    providers: [IgxForOfSyncService]
                },] }
    ];
    return IgxGridBodyDirective;
}());
/**
 * @hidden
 */
var IgxDatePipeComponent = /** @class */ (function (_super) {
    __extends(IgxDatePipeComponent, _super);
    function IgxDatePipeComponent(locale) {
        // D.P. constructor duplication due to es6 compilation, might be obsolete in the future
        return _super.call(this, locale) || this;
    }
    /**
     * @param {?} value
     * @param {?} locale
     * @return {?}
     */
    IgxDatePipeComponent.prototype.transform = /**
     * @param {?} value
     * @param {?} locale
     * @return {?}
     */
    function (value, locale) {
        if (value && value instanceof Date) {
            if (locale) {
                return _super.prototype.transform.call(this, value, DEFAULT_DATE_FORMAT, undefined, locale);
            }
            else {
                return _super.prototype.transform.call(this, value);
            }
        }
        else {
            return value;
        }
    };
    IgxDatePipeComponent.decorators = [
        { type: Pipe, args: [{
                    name: 'igxdate'
                },] }
    ];
    /** @nocollapse */
    IgxDatePipeComponent.ctorParameters = function () { return [
        { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] }
    ]; };
    return IgxDatePipeComponent;
}(DatePipe));
/**
 * @hidden
 */
var IgxDecimalPipeComponent = /** @class */ (function (_super) {
    __extends(IgxDecimalPipeComponent, _super);
    function IgxDecimalPipeComponent(locale) {
        // D.P. constructor duplication due to es6 compilation, might be obsolete in the future
        return _super.call(this, locale) || this;
    }
    /**
     * @param {?} value
     * @param {?} locale
     * @return {?}
     */
    IgxDecimalPipeComponent.prototype.transform = /**
     * @param {?} value
     * @param {?} locale
     * @return {?}
     */
    function (value, locale) {
        if (value && typeof value === 'number') {
            if (locale) {
                return _super.prototype.transform.call(this, value, undefined, locale);
            }
            else {
                return _super.prototype.transform.call(this, value);
            }
        }
        else {
            return value;
        }
    };
    IgxDecimalPipeComponent.decorators = [
        { type: Pipe, args: [{
                    name: 'igxdecimal'
                },] }
    ];
    /** @nocollapse */
    IgxDecimalPipeComponent.ctorParameters = function () { return [
        { type: String, decorators: [{ type: Inject, args: [LOCALE_ID,] }] }
    ]; };
    return IgxDecimalPipeComponent;
}(DecimalPipe));
/**
 * @hidden
 */
var  /**
 * @hidden
 */
ContainerPositioningStrategy = /** @class */ (function (_super) {
    __extends(ContainerPositioningStrategy, _super);
    function ContainerPositioningStrategy() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isTop = false;
        _this.isTopInitialPosition = null;
        return _this;
    }
    /**
     * @param {?} contentElement
     * @param {?} size
     * @param {?=} document
     * @param {?=} initialCall
     * @return {?}
     */
    ContainerPositioningStrategy.prototype.position = /**
     * @param {?} contentElement
     * @param {?} size
     * @param {?=} document
     * @param {?=} initialCall
     * @return {?}
     */
    function (contentElement, size, document, initialCall) {
        /** @type {?} */
        var container = this.settings.container;
        // grid.tbody
        /** @type {?} */
        var target = (/** @type {?} */ (this.settings.target));
        // Position of the overlay depends on the available space in the grid.
        // If the bottom space is not enough then the the row overlay will show at the top of the row.
        // Once shown, either top or bottom, then this position stays until the overlay is closed (isTopInitialPosition property),
        // which means that when scrolling then overlay may hide, while the row is still visible (UX requirement).
        this.isTop = this.isTopInitialPosition !== null ?
            this.isTopInitialPosition :
            container.getBoundingClientRect().bottom <
                target.getBoundingClientRect().bottom + contentElement.getBoundingClientRect().height;
        // Set width of the row editing overlay to equal row width, otherwise it fits 100% of the grid.
        contentElement.style.width = target.clientWidth + 'px';
        this.settings.verticalStartPoint = this.settings.verticalDirection = this.isTop ? VerticalAlignment.Top : VerticalAlignment.Bottom;
        this.settings.openAnimation = this.isTop ? scaleInVerBottom : scaleInVerTop;
        _super.prototype.position.call(this, contentElement, { width: target.clientWidth, height: target.clientHeight }, document, initialCall);
    };
    return ContainerPositioningStrategy;
}(ConnectedPositioningStrategy));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * **Ignite UI for Angular Column** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid.html#columns-configuration)
 *
 * The Ignite UI Column is used within an `igx-grid` element to define what data the column will show. Features such as sorting,
 * filtering & editing are enabled at the column level.  You can also provide a template containing custom content inside
 * the column using `ng-template` which will be used for all cells within the column.
 */
var IgxColumnComponent = /** @class */ (function () {
    function IgxColumnComponent(gridAPI, cdr) {
        this.gridAPI = gridAPI;
        this.cdr = cdr;
        /**
         * Sets/gets the `header` value.
         * ```typescript
         * let columnHeader = this.column.header;
         * ```
         * ```html
         * <igx-column [header] = "'ID'"></igx-column>
         * ```
         *
         * \@memberof IgxColumnComponent
         */
        this.header = '';
        /**
         * Sets/gets whether the column is sortable.
         * Default value is `false`.
         * ```typescript
         * let isSortable = this.column.sortable;
         * ```
         * ```html
         * <igx-column [sortable] = "true"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.sortable = false;
        /**
         * Sets/gets whether the column is groupable.
         * Default value is `false`.
         * ```typescript
         * let isGroupable = this.column.groupable;
         * ```
         * ```html
         * <igx-column [groupable] = "true"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.groupable = false;
        /**
         * Sets/gets whether the column is editable.
         * Default value is `false`.
         * ```typescript
         * let isEditable = this.column.editable;
         * ```
         * ```html
         * <igx-column [editable] = "true"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.editable = null;
        /**
         * Sets/gets whether the column is filterable.
         * Default value is `true`.
         * ```typescript
         * let isFilterable = this.column.filterable;
         * ```
         * ```html
         * <igx-column [filterable] = "false"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.filterable = true;
        /**
         * Sets/gets whether the column is resizable.
         * Default value is `false`.
         * ```typescript
         * let isResizable = this.column.resizable;
         * ```
         * ```html
         * <igx-column [resizable] = "true"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.resizable = false;
        /**
         * Sets/gets whether the column is movable.
         * Default value is `false`.
         * ```typescript
         * let isMovable = this.column.movable;
         * ```
         * ```html
         * <igx-column [movable] = "true"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.movable = false;
        /**
         * Sets/gets the minimum `width` of the column.
         * Default value is `88`;
         * ```typescript
         * let columnMinWidth = this.column.minWidth;
         * ```
         * ```html
         * <igx-column [minWidth] = "'15%'"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.minWidth = this.defaultMinWidth;
        /**
         * Sets/gets the class selector of the column header.
         * ```typescript
         * let columnHeaderClass = this.column.headerClasses;
         * ```
         * ```html
         * <igx-column [headerClasses] = "'column-header'"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.headerClasses = '';
        /**
         * Sets/gets the class selector of the column group header.
         * ```typescript
         * let columnHeaderClass = this.column.headerGroupClasses;
         * ```
         * ```html
         * <igx-column [headerGroupClasses] = "'column-group-header'"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.headerGroupClasses = '';
        /**
         * Sets/gets whether the column filtering should be case sensitive.
         * Default value is `true`.
         * ```typescript
         * let filteringIgnoreCase = this.column.filteringIgnoreCase;
         * ```
         * ```html
         * <igx-column [filteringIgnoreCase] = "false"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.filteringIgnoreCase = true;
        /**
         * Sets/gets whether the column sorting should be case sensitive.
         * Default value is `true`.
         * ```typescript
         * let sortingIgnoreCase = this.column.sortingIgnoreCase;
         * ```
         * ```html
         * <igx-column [sortingIgnoreCase] = "false"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.sortingIgnoreCase = true;
        /**
         * Sets/gets the data type of the column values.
         * Default value is `string`.
         * ```typescript
         * let columnDataType = this.column.dataType;
         * ```
         * ```html
         * <igx-column [dataType] = "'number'"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.dataType = DataType.String;
        /**
         * Sets/gets whether the column is `searchable`.
         * Default value is `true`.
         * ```typescript
         * let isSearchable =  this.column.searchable';
         * ```
         * ```html
         *  <igx-column [searchable] = "false"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         */
        this.searchable = true;
        /**
         * Sets/gets the parent column.
         * ```typescript
         * let parentColumn = this.column.parent;
         * ```
         * ```typescript
         * this.column.parent = higherLevelColumn;
         * ```
         * \@memberof IgxColumnComponent
         */
        this.parent = null;
        /**
         * @hidden
         */
        this._pinned = false;
        /**
         * @hidden
         */
        this._summaries = null;
        /**
         * @hidden
         */
        this._filters = null;
        /**
         * @hidden
         */
        this._sortStrategy = DefaultSortingStrategy.instance();
        /**
         * @hidden
         */
        this._hidden = false;
        /**
         * @hidden
         */
        this._disableHiding = false;
        /**
         * @hidden
         */
        this._disablePinning = false;
        /**
         * @hidden
         */
        this._defaultMinWidth = '80';
        /**
         * @hidden
         */
        this._hasSummary = false;
        this._vIndex = NaN;
    }
    Object.defineProperty(IgxColumnComponent.prototype, "hasSummary", {
        /**
         * Gets a value indicating whether the summary for the column is enabled.
         * ```typescript
         * let hasSummary = this.column.hasSummary;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Gets a value indicating whether the summary for the column is enabled.
         * ```typescript
         * let hasSummary = this.column.hasSummary;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return this._hasSummary;
        },
        /**
         * Sets a value indicating whether the summary for the column is enabled.
         * Default value is `false`.
         * ```html
         * <igx-column [hasSummary] = "true"></igx-column>
         * ```
         * @memberof IgxColumnComponent
         */
        set: /**
         * Sets a value indicating whether the summary for the column is enabled.
         * Default value is `false`.
         * ```html
         * <igx-column [hasSummary] = "true"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._hasSummary = value;
            if (this.grid) {
                this.grid.summaryService.recalculateSummaries();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "hidden", {
        /**
         * Gets whether the column is hidden.
         * ```typescript
         * let isHidden = this.column.hidden;
         * ```
         *@memberof IgxColumnComponent
         */
        get: /**
         * Gets whether the column is hidden.
         * ```typescript
         * let isHidden = this.column.hidden;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return this._hidden;
        },
        /**
         * Sets the column hidden property.
         * Default value is `false`.
         * ```typescript
         * <igx-column [hidden] = "true"></igx-column>
         * ```
         * @memberof IgxColumnComponent
         */
        set: /**
         * Sets the column hidden property.
         * Default value is `false`.
         * ```typescript
         * <igx-column [hidden] = "true"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._hidden !== value) {
                this._hidden = value;
                if (this.grid) {
                    this.grid.resetCaches();
                    this.grid.endEdit(false);
                }
                // TODO: Simplify
                this.check();
                if (this.grid) {
                    this.grid.refreshSearch(true);
                    this.grid.summaryService.resetSummaryHeight();
                    this.grid.reflow();
                    this.grid.filteringService.refreshExpressions();
                }
                if (this.parent && this.parent.columnLayout && this.parent.hidden !== value) {
                    this.parent.hidden = value;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "disableHiding", {
        /**
         * Gets whether the hiding is disabled.
         * ```typescript
         * let isHidingDisabled =  this.column.disableHiding;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Gets whether the hiding is disabled.
         * ```typescript
         * let isHidingDisabled =  this.column.disableHiding;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return this._disableHiding;
        },
        /**
         * Enables/disables hiding for the column.
         * Default value is `false`.
         * ```typescript
         * <igx-column [hidden] = "true"></igx-column>
         * ```
         * @memberof IgxColumnComponent
         */
        set: /**
         * Enables/disables hiding for the column.
         * Default value is `false`.
         * ```typescript
         * <igx-column [hidden] = "true"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._disableHiding !== value) {
                this._disableHiding = value;
                this.check();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "disablePinning", {
        /**
         * Gets whether the pinning is disabled.
         * ```typescript
         * let isPinningDisabled =  this.column.disablePinning;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Gets whether the pinning is disabled.
         * ```typescript
         * let isPinningDisabled =  this.column.disablePinning;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return this._disablePinning;
        },
        /**
         * Enables/disables pinning for the column.
         * Default value is `false`.
         * ```typescript
         * <igx-column [pinned] = "true"></igx-column>
         * ```
         * @memberof IgxColumnComponent
         */
        set: /**
         * Enables/disables pinning for the column.
         * Default value is `false`.
         * ```typescript
         * <igx-column [pinned] = "true"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._disablePinning !== value) {
                this._disablePinning = value;
                this.check();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "width", {
        /**
         * Gets the `width` of the column.
         * ```typescript
         * let columnWidth = this.column.width;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Gets the `width` of the column.
         * ```typescript
         * let columnWidth = this.column.width;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return this.widthSetByUser ? this._width : this.defaultWidth;
        },
        /**
         * Sets the `width` of the column.
         * ```html
         * <igx-column [width] = "'25%'"></igx-column>
         * ```
         * @memberof IgxColumnComponent
         */
        set: /**
         * Sets the `width` of the column.
         * ```html
         * <igx-column [width] = "'25%'"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value) {
                this.widthSetByUser = true;
                this._width = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "calcWidth", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var colWidth = this.width;
            /** @type {?} */
            var isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
            if (isPercentageWidth) {
                return parseInt(colWidth, 10) / 100 * (this.grid.calcWidth - this.grid.featureColumnsWidth);
            }
            else if (!colWidth) {
                // no width
                return this.defaultWidth || this.grid.getPossibleColumnWidth();
            }
            else {
                return this.width;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "index", {
        /**
         * Gets the column index.
         * ```typescript
         * let columnIndex = this.column.index;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Gets the column index.
         * ```typescript
         * let columnIndex = this.column.index;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return this.grid.columns.indexOf(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "pinned", {
        /**
         * Gets whether the column is `pinned`.
         * ```typescript
         * let isPinned = this.column.pinned;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Gets whether the column is `pinned`.
         * ```typescript
         * let isPinned = this.column.pinned;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return this._pinned;
        },
        /**
         * Sets whether the column is pinned.
         * Default value is `false`.
         * ```html
         * <igx-column [pinned] = "true"></igx-column>
         * ```
         * @memberof IgxColumnComponent
         */
        set: /**
         * Sets whether the column is pinned.
         * Default value is `false`.
         * ```html
         * <igx-column [pinned] = "true"></igx-column>
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._pinned !== value) {
                if (this.grid && this.width && !isNaN(parseInt(this.width, 10))) {
                    value ? this.pin() : this.unpin();
                    return;
                }
                /* No grid/width available at initialization. `initPinning` in the grid
                   will re-init the group (if present)
                */
                this._pinned = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "summaries", {
        /**
         * Gets the column `summaries`.
         * ```typescript
         * let columnSummaries = this.column.summaries;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Gets the column `summaries`.
         * ```typescript
         * let columnSummaries = this.column.summaries;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return this._summaries;
        },
        /**
         * Sets the column `summaries`.
         * ```typescript
         * this.column.summaries = IgxNumberSummaryOperand;
         * ```
         * @memberof IgxColumnComponent
         */
        set: /**
         * Sets the column `summaries`.
         * ```typescript
         * this.column.summaries = IgxNumberSummaryOperand;
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} classRef
         * @return {?}
         */
        function (classRef) {
            this._summaries = new classRef();
            if (this.grid) {
                this.grid.summaryService.removeSummariesCachePerColumn(this.field);
                ((/** @type {?} */ (this.grid)))._summaryPipeTrigger++;
                this.grid.summaryService.recalculateSummaries();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "filters", {
        /**
         * Gets the column `filters`.
         * ```typescript
         * let columnFilters = this.column.filters'
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Gets the column `filters`.
         * ```typescript
         * let columnFilters = this.column.filters'
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return this._filters;
        },
        /**
         * Sets the column `filters`.
         * ```typescript
         * this.column.filters = IgxBooleanFilteringOperand.instance().
         * ```
         * @memberof IgxColumnComponent
         */
        set: /**
         * Sets the column `filters`.
         * ```typescript
         * this.column.filters = IgxBooleanFilteringOperand.instance().
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} instance
         * @return {?}
         */
        function (instance) {
            this._filters = instance;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "sortStrategy", {
        /**
         * Gets the column `sortStrategy`.
         * ```typescript
         * let sortStrategy = this.column.sortStrategy'
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Gets the column `sortStrategy`.
         * ```typescript
         * let sortStrategy = this.column.sortStrategy'
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return this._sortStrategy;
        },
        /**
         * Sets the column `sortStrategy`.
         * ```typescript
         * this.column.sortStrategy = new CustomSortingStrategy().
         *
         * class CustomSortingStrategy extends SortingStrategy {
         * ...
         * }
         * ```
         * @memberof IgxColumnComponent
         */
        set: /**
         * Sets the column `sortStrategy`.
         * ```typescript
         * this.column.sortStrategy = new CustomSortingStrategy().
         *
         * class CustomSortingStrategy extends SortingStrategy {
         * ...
         * }
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} classRef
         * @return {?}
         */
        function (classRef) {
            this._sortStrategy = classRef;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "groupingComparer", {
        /**
        * Gets the function that compares values for grouping.
        * ```typescript
        * let groupingComparer = this.column.groupingComparer'
        * ```
        * @memberof IgxColumnComponent
        */
        get: /**
         * Gets the function that compares values for grouping.
         * ```typescript
         * let groupingComparer = this.column.groupingComparer'
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return this._groupingComparer;
        },
        /**
         * Sets a custom function to compare values for grouping.
         * Subsequent values in the sorted data that the function returns 0 for are grouped.
         * ```typescript
         * this.column.groupingComparer = (a: any, b: any) => { return a === b ? 0 : -1; }
         * ```
         * @memberof IgxColumnComponent
         */
        set: /**
         * Sets a custom function to compare values for grouping.
         * Subsequent values in the sorted data that the function returns 0 for are grouped.
         * ```typescript
         * this.column.groupingComparer = (a: any, b: any) => { return a === b ? 0 : -1; }
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} funcRef
         * @return {?}
         */
        function (funcRef) {
            this._groupingComparer = funcRef;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "defaultMinWidth", {
        /**
         * Gets the default minimum `width` of the column.
         * ```typescript
         * let defaultMinWidth =  this.column.defaultMinWidth;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Gets the default minimum `width` of the column.
         * ```typescript
         * let defaultMinWidth =  this.column.defaultMinWidth;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return this._defaultMinWidth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "bodyTemplate", {
        /**
         * Returns a reference to the `bodyTemplate`.
         * ```typescript
         * let bodyTemplate = this.column.bodyTemplate;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Returns a reference to the `bodyTemplate`.
         * ```typescript
         * let bodyTemplate = this.column.bodyTemplate;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return this._bodyTemplate;
        },
        /**
         * Sets the body template.
         * ```html
         * <ng-template #bodyTemplate igxCell let-val>
         *    <div style = "background-color: yellowgreen" (click) = "changeColor(val)">
         *       <span> {{val}} </span>
         *    </div>
         * </ng-template>
         * ```
         * ```typescript
         * @ViewChild("'bodyTemplate'", {read: TemplateRef })
         * public bodyTemplate: TemplateRef<any>;
         * this.column.bodyTemplate = this.bodyTemplate;
         * ```
         * @memberof IgxColumnComponent
         */
        set: /**
         * Sets the body template.
         * ```html
         * <ng-template #bodyTemplate igxCell let-val>
         *    <div style = "background-color: yellowgreen" (click) = "changeColor(val)">
         *       <span> {{val}} </span>
         *    </div>
         * </ng-template>
         * ```
         * ```typescript
         * \@ViewChild("'bodyTemplate'", {read: TemplateRef })
         * public bodyTemplate: TemplateRef<any>;
         * this.column.bodyTemplate = this.bodyTemplate;
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} template
         * @return {?}
         */
        function (template) {
            this._bodyTemplate = template;
            if (this.grid) {
                this.grid.cdr.markForCheck();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "headerTemplate", {
        /**
         * Returns a reference to the header template.
         * ```typescript
         * let headerTemplate = this.column.headerTemplate;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Returns a reference to the header template.
         * ```typescript
         * let headerTemplate = this.column.headerTemplate;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return this._headerTemplate;
        },
        /**
         * Sets the header template.
         * ```html
         * <ng-template #headerTemplate>
         *   <div style = "background-color:black" (click) = "changeColor(val)">
         *       <span style="color:red" >{{column.field}}</span>
         *   </div>
         * </ng-template>
         * ```
         * ```typescript
         * @ViewChild("'headerTemplate'", {read: TemplateRef })
         * public headerTemplate: TemplateRef<any>;
         * this.column.headerTemplate = this.headerTemplate;
         * ```
         * @memberof IgxColumnComponent
         */
        set: /**
         * Sets the header template.
         * ```html
         * <ng-template #headerTemplate>
         *   <div style = "background-color:black" (click) = "changeColor(val)">
         *       <span style="color:red" >{{column.field}}</span>
         *   </div>
         * </ng-template>
         * ```
         * ```typescript
         * \@ViewChild("'headerTemplate'", {read: TemplateRef })
         * public headerTemplate: TemplateRef<any>;
         * this.column.headerTemplate = this.headerTemplate;
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} template
         * @return {?}
         */
        function (template) {
            this._headerTemplate = template;
            if (this.grid) {
                this.grid.cdr.markForCheck();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "inlineEditorTemplate", {
        /**
         * Returns a reference to the inline editor template.
         * ```typescript
         * let inlineEditorTemplate = this.column.inlineEditorTemplate;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Returns a reference to the inline editor template.
         * ```typescript
         * let inlineEditorTemplate = this.column.inlineEditorTemplate;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return this._inlineEditorTemplate;
        },
        /**
         * Sets the inline editor template.
         * ```html
         * <ng-template #inlineEditorTemplate igxCellEditor let-cell="cell">
         *     <input type="string" [(ngModel)]="cell.value"/>
         * </ng-template>
         * ```
         * ```typescript
         * @ViewChild("'inlineEditorTemplate'", {read: TemplateRef })
         * public inlineEditorTemplate: TemplateRef<any>;
         * this.column.inlineEditorTemplate = this.inlineEditorTemplate;
         * ```
         * @memberof IgxColumnComponent
         */
        set: /**
         * Sets the inline editor template.
         * ```html
         * <ng-template #inlineEditorTemplate igxCellEditor let-cell="cell">
         *     <input type="string" [(ngModel)]="cell.value"/>
         * </ng-template>
         * ```
         * ```typescript
         * \@ViewChild("'inlineEditorTemplate'", {read: TemplateRef })
         * public inlineEditorTemplate: TemplateRef<any>;
         * this.column.inlineEditorTemplate = this.inlineEditorTemplate;
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} template
         * @return {?}
         */
        function (template) {
            this._inlineEditorTemplate = template;
            if (this.grid) {
                this.grid.cdr.markForCheck();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "filterCellTemplate", {
        /**
         * Returns a reference to the `filterCellTemplate`.
         * ```typescript
         * let filterCellTemplate = this.column.filterCellTemplate;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Returns a reference to the `filterCellTemplate`.
         * ```typescript
         * let filterCellTemplate = this.column.filterCellTemplate;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return this._filterCellTemplate;
        },
        /**
         * Sets the quick filter template.
         * ```html
         * <ng-template #filterCellTemplate IgxFilterCellTemplate let-column="column">
         *    <input (input)="onInput()">
         * </ng-template>
         * ```
         * ```typescript
         * @ViewChild("'filterCellTemplate'", {read: TemplateRef })
         * public filterCellTemplate: TemplateRef<any>;
         * this.column.filterCellTemplate = this.filterCellTemplate;
         * ```
         * @memberof IgxColumnComponent
         */
        set: /**
         * Sets the quick filter template.
         * ```html
         * <ng-template #filterCellTemplate IgxFilterCellTemplate let-column="column">
         *    <input (input)="onInput()">
         * </ng-template>
         * ```
         * ```typescript
         * \@ViewChild("'filterCellTemplate'", {read: TemplateRef })
         * public filterCellTemplate: TemplateRef<any>;
         * this.column.filterCellTemplate = this.filterCellTemplate;
         * ```
         * \@memberof IgxColumnComponent
         * @param {?} template
         * @return {?}
         */
        function (template) {
            this._filterCellTemplate = template;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "cells", {
        /**
         * Gets the cells of the column.
         * ```typescript
         * let columnCells =  this.column.cells;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Gets the cells of the column.
         * ```typescript
         * let columnCells =  this.column.cells;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            var _this = this;
            return this.grid.rowList.filter(function (row) { return row instanceof IgxRowComponent; })
                .map(function (row) {
                if (row.cells) {
                    return row.cells.filter(function (cell) { return cell.columnIndex === _this.index; });
                }
            }).reduce(function (a, b) { return a.concat(b); }, []);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "visibleIndex", {
        /**
         * Gets the column visible index.
         * If the column is not visible, returns `-1`.
         * ```typescript
         * let visibleColumnIndex =  this.column.visibleIndex;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Gets the column visible index.
         * If the column is not visible, returns `-1`.
         * ```typescript
         * let visibleColumnIndex =  this.column.visibleIndex;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            if (!isNaN(this._vIndex)) {
                return this._vIndex;
            }
            /** @type {?} */
            var unpinnedColumns = this.grid.unpinnedColumns.filter(function (c) { return !c.columnGroup; });
            /** @type {?} */
            var pinnedColumns = this.grid.pinnedColumns.filter(function (c) { return !c.columnGroup; });
            /** @type {?} */
            var col = this;
            /** @type {?} */
            var vIndex = -1;
            if (this.columnGroup) {
                col = (/** @type {?} */ (this.allChildren.filter(function (c) { return !c.columnGroup; })[0]));
            }
            if (!this.pinned) {
                /** @type {?} */
                var indexInCollection = unpinnedColumns.indexOf(col);
                vIndex = indexInCollection === -1 ? -1 : pinnedColumns.length + indexInCollection;
            }
            else {
                vIndex = pinnedColumns.indexOf(col);
            }
            this._vIndex = vIndex;
            return vIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "columnGroup", {
        /**
         * Returns a boolean indicating if the column is a `ColumnGroup`.
         * ```typescript
         * let columnGroup =  this.column.columnGroup;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Returns a boolean indicating if the column is a `ColumnGroup`.
         * ```typescript
         * let columnGroup =  this.column.columnGroup;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "columnLayout", {
        /**
         * Returns a boolean indicating if the column is a `ColumnLayout` for multi-row layout.
         * ```typescript
         * let columnGroup =  this.column.columnGroup;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Returns a boolean indicating if the column is a `ColumnLayout` for multi-row layout.
         * ```typescript
         * let columnGroup =  this.column.columnGroup;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "allChildren", {
        /**
         * Returns the children columns collection.
         * Returns an empty array if the column does not contain children columns.
         * ```typescript
         * let childrenColumns =  this.column.allChildren;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Returns the children columns collection.
         * Returns an empty array if the column does not contain children columns.
         * ```typescript
         * let childrenColumns =  this.column.allChildren;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "level", {
        /**
         * Returns the level of the column in a column group.
         * Returns `0` if the column doesn't have a `parent`.
         * ```typescript
         * let columnLevel =  this.column.level;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Returns the level of the column in a column group.
         * Returns `0` if the column doesn't have a `parent`.
         * ```typescript
         * let columnLevel =  this.column.level;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            /** @type {?} */
            var ptr = this.parent;
            /** @type {?} */
            var lvl = 0;
            while (ptr) {
                lvl++;
                ptr = ptr.parent;
            }
            return lvl;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "isLastPinned", {
        get: /**
         * @return {?}
         */
        function () {
            return this.grid.pinnedColumns[this.grid.pinnedColumns.length - 1] === this;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "gridRowSpan", {
        get: /**
         * @return {?}
         */
        function () {
            return this.rowEnd && this.rowStart ? this.rowEnd - this.rowStart : 1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "gridColumnSpan", {
        get: /**
         * @return {?}
         */
        function () {
            return this.colEnd && this.colStart ? this.colEnd - this.colStart : 1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "filteringExpressionsTree", {
        /**
         * Returns the filteringExpressionsTree of the column.
         * ```typescript
         * let tree =  this.column.filteringExpressionsTree;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Returns the filteringExpressionsTree of the column.
         * ```typescript
         * let tree =  this.column.filteringExpressionsTree;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return (/** @type {?} */ (this.grid.filteringExpressionsTree.find(this.field)));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     * @internal
     */
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    IgxColumnComponent.prototype.resetVisibleIndex = /**
     * @hidden
     * \@internal
     * @return {?}
     */
    function () {
        this._vIndex = NaN;
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxColumnComponent.prototype.ngAfterContentInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (this.cellTemplate) {
            this._bodyTemplate = this.cellTemplate.template;
        }
        if (this.headTemplate) {
            this._headerTemplate = this.headTemplate.template;
        }
        if (this.editorTemplate) {
            this._inlineEditorTemplate = this.editorTemplate.template;
        }
        if (this.filterCellTemplateDirective) {
            this._filterCellTemplate = this.filterCellTemplateDirective.template;
        }
        if (!this.summaries) {
            switch (this.dataType) {
                case DataType.String:
                case DataType.Boolean:
                    this.summaries = IgxSummaryOperand;
                    break;
                case DataType.Number:
                    this.summaries = IgxNumberSummaryOperand;
                    break;
                case DataType.Date:
                    this.summaries = IgxDateSummaryOperand;
                    break;
                default:
                    this.summaries = IgxSummaryOperand;
                    break;
            }
        }
        if (!this.filters) {
            switch (this.dataType) {
                case DataType.Boolean:
                    this.filters = IgxBooleanFilteringOperand.instance();
                    break;
                case DataType.Number:
                    this.filters = IgxNumberFilteringOperand.instance();
                    break;
                case DataType.Date:
                    this.filters = IgxDateFilteringOperand.instance();
                    break;
                case DataType.String:
                default:
                    this.filters = IgxStringFilteringOperand.instance();
                    break;
            }
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} isRow
     * @param {?} isIE
     * @return {?}
     */
    IgxColumnComponent.prototype.getGridTemplate = /**
     * @hidden
     * @param {?} isRow
     * @param {?} isIE
     * @return {?}
     */
    function (isRow, isIE$$1) {
        /** @type {?} */
        var colSpanAccum = function (acc, val) { return Math.max(val.colStart + val.gridColumnSpan - 1, acc); };
        /** @type {?} */
        var templateItems = !isRow ?
            this.children && this.children.reduce(colSpanAccum, 1) || 1 :
            this.grid.multiRowLayoutRowSize;
        /** @type {?} */
        var generatedSizes = !isRow ? this.getColumnSizesString(this.children) : null;
        return isIE$$1 ?
            generatedSizes || "(1fr)[" + templateItems + "]" :
            generatedSizes || "repeat(" + templateItems + ",1fr)";
    };
    /**
     * @param {?} children
     * @return {?}
     */
    IgxColumnComponent.prototype.getInitialChildColumnSizes = /**
     * @param {?} children
     * @return {?}
     */
    function (children) {
        var _this = this;
        /** @type {?} */
        var columnSizes = [];
        // find the smallest col spans
        children.forEach(function (col) {
            if (!col.colStart) {
                return;
            }
            /** @type {?} */
            var newWidthSet = col.widthSetByUser && columnSizes[col.colStart - 1] && !columnSizes[col.colStart - 1].widthSetByUser;
            /** @type {?} */
            var newSpanSmaller = columnSizes[col.colStart - 1] && columnSizes[col.colStart - 1].colSpan > col.gridColumnSpan;
            /** @type {?} */
            var bothWidthsSet = col.widthSetByUser && columnSizes[col.colStart - 1] && columnSizes[col.colStart - 1].widthSetByUser;
            /** @type {?} */
            var bothWidthsNotSet = !col.widthSetByUser && columnSizes[col.colStart - 1] && !columnSizes[col.colStart - 1].widthSetByUser;
            if (columnSizes[col.colStart - 1] === undefined) {
                // If nothing is defined yet take any column at first
                // We use colEnd to know where the column actually ends, because not always it starts where we have it set in columnSizes.
                columnSizes[col.colStart - 1] = {
                    ref: col,
                    width: col.widthSetByUser || _this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                    colSpan: col.gridColumnSpan,
                    colEnd: col.colStart + col.gridColumnSpan,
                    widthSetByUser: col.widthSetByUser
                };
            }
            else if (newWidthSet || (newSpanSmaller && ((bothWidthsSet) || (bothWidthsNotSet)))) {
                // If a column is set already it should either not have width defined or have width with bigger span than the new one.
                /**
                 *  If replaced column has bigger span, we want to fill the remaining columns
                 *  that the replacing column does not fill with the old one.
                 **/
                if (bothWidthsSet && newSpanSmaller) {
                    // Start from where the new column set would end and apply the old column to the rest depending on how much it spans.
                    // We have not yet replaced it so we can use it directly from the columnSizes collection.
                    // This is where colEnd is used because the colStart of the old column is not actually i + 1.
                    for (var i = col.colStart - 1 + col.gridColumnSpan; i < columnSizes[col.colStart - 1].colEnd - 1; i++) {
                        if (!columnSizes[i] || !columnSizes[i].widthSetByUser) {
                            columnSizes[i] = columnSizes[col.colStart - 1];
                        }
                        else {
                            break;
                        }
                    }
                }
                // Replace the old column with the new one.
                columnSizes[col.colStart - 1] = {
                    ref: col,
                    width: col.widthSetByUser || _this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                    colSpan: col.gridColumnSpan,
                    colEnd: col.colStart + col.gridColumnSpan,
                    widthSetByUser: col.widthSetByUser
                };
            }
            else if (bothWidthsSet && columnSizes[col.colStart - 1].colSpan < col.gridColumnSpan) {
                // If the column already in the columnSizes has smaller span, we still need to fill any empty places with the current col.
                // Start from where the smaller column set would end and apply the bigger column to the rest depending on how much it spans.
                // Since here we do not have it in columnSizes we set it as a new column keeping the same colSpan.
                for (var i = col.colStart - 1 + columnSizes[col.colStart - 1].colSpan; i < col.colStart - 1 + col.gridColumnSpan; i++) {
                    if (!columnSizes[i] || !columnSizes[i].widthSetByUser) {
                        columnSizes[i] = {
                            ref: col,
                            width: col.widthSetByUser || _this.grid.columnWidthSetByUser ? parseInt(col.calcWidth, 10) : null,
                            colSpan: col.gridColumnSpan,
                            colEnd: col.colStart + col.gridColumnSpan,
                            widthSetByUser: col.widthSetByUser
                        };
                    }
                    else {
                        break;
                    }
                }
            }
        });
        // Flatten columnSizes so there are not columns with colSpan > 1
        for (var i = 0; i < columnSizes.length; i++) {
            if (columnSizes[i] && columnSizes[i].colSpan > 1) {
                /** @type {?} */
                var j = 1;
                // Replace all empty places depending on how much the current column spans starting from next col.
                for (; j < columnSizes[i].colSpan && i + j + 1 < columnSizes[i].colEnd; j++) {
                    if (columnSizes[i + j] &&
                        ((!columnSizes[i].width && columnSizes[i + j].width) ||
                            (!columnSizes[i].width && !columnSizes[i + j].width && columnSizes[i + j].colSpan <= columnSizes[i].colSpan) ||
                            (!!columnSizes[i + j].width && columnSizes[i + j].colSpan <= columnSizes[i].colSpan))) {
                        // If we reach an already defined column that has width and the current doesn't have or
                        // if the reached column has bigger colSpan we stop.
                        break;
                    }
                    else {
                        /** @type {?} */
                        var width = columnSizes[i].widthSetByUser ?
                            columnSizes[i].width / columnSizes[i].colSpan :
                            columnSizes[i].width;
                        columnSizes[i + j] = {
                            ref: columnSizes[i].ref,
                            width: width,
                            colSpan: 1,
                            colEnd: columnSizes[i].colEnd,
                            widthSetByUser: columnSizes[i].widthSetByUser
                        };
                    }
                }
                // Update the current column width so it is divided between all columns it spans and set it to 1.
                columnSizes[i].width = columnSizes[i].widthSetByUser ?
                    columnSizes[i].width / columnSizes[i].colSpan :
                    columnSizes[i].width;
                columnSizes[i].colSpan = 1;
                // Update the index based on how much we have replaced. Subtract 1 because we started from 1.
                i += j - 1;
            }
        }
        return columnSizes;
    };
    /**
     * @protected
     * @param {?} children
     * @return {?}
     */
    IgxColumnComponent.prototype.getFilledChildColumnSizes = /**
     * @protected
     * @param {?} children
     * @return {?}
     */
    function (children) {
        /** @type {?} */
        var columnSizes = this.getInitialChildColumnSizes(children);
        // fill the gaps if there are any
        /** @type {?} */
        var result = [];
        for (var i = 0; i < columnSizes.length; i++) {
            if (columnSizes[i] && !!columnSizes[i].width) {
                result.push(columnSizes[i].width + 'px');
            }
            else {
                result.push(parseInt(this.grid.getPossibleColumnWidth(), 10) + 'px');
            }
        }
        return result;
    };
    /**
     * @protected
     * @param {?} children
     * @return {?}
     */
    IgxColumnComponent.prototype.getColumnSizesString = /**
     * @protected
     * @param {?} children
     * @return {?}
     */
    function (children) {
        /** @type {?} */
        var res = this.getFilledChildColumnSizes(children);
        return res.join(' ');
    };
    /**
     * @return {?}
     */
    IgxColumnComponent.prototype.getResizableColUnderEnd = /**
     * @return {?}
     */
    function () {
        if (this.columnLayout || !this.parent.columnLayout || this.columnGroup) {
            return [{ target: this, spanUsed: 1 }];
        }
        /** @type {?} */
        var columnSized = this.getInitialChildColumnSizes(this.parent.children);
        /** @type {?} */
        var targets = [];
        /** @type {?} */
        var colEnd = this.colEnd ? this.colEnd : this.colStart + 1;
        for (var i = 0; i < columnSized.length; i++) {
            if (this.colStart <= i + 1 && i + 1 < colEnd) {
                targets.push({ target: columnSized[i].ref, spanUsed: 1 });
            }
        }
        /** @type {?} */
        var targetsSquashed = [];
        for (var j = 0; j < targets.length; j++) {
            if (targetsSquashed.length && targetsSquashed[targetsSquashed.length - 1].target.field === targets[j].target.field) {
                targetsSquashed[targetsSquashed.length - 1].spanUsed++;
            }
            else {
                targetsSquashed.push(targets[j]);
            }
        }
        return targetsSquashed;
    };
    /**
     * Pins the column at the provided index in the pinned area. Defaults to index `0` if not provided.
     * Returns `true` if the column is successfully pinned. Returns `false` if the column cannot be pinned.
     * Column cannot be pinned if:
     * - Is already pinned
     * - index argument is out of range
     * - The pinned area exceeds 80% of the grid width
     * ```typescript
     * let success = this.column.pin();
     * ```
     * @memberof IgxColumnComponent
     */
    /**
     * Pins the column at the provided index in the pinned area. Defaults to index `0` if not provided.
     * Returns `true` if the column is successfully pinned. Returns `false` if the column cannot be pinned.
     * Column cannot be pinned if:
     * - Is already pinned
     * - index argument is out of range
     * - The pinned area exceeds 80% of the grid width
     * ```typescript
     * let success = this.column.pin();
     * ```
     * \@memberof IgxColumnComponent
     * @param {?=} index
     * @return {?}
     */
    IgxColumnComponent.prototype.pin = /**
     * Pins the column at the provided index in the pinned area. Defaults to index `0` if not provided.
     * Returns `true` if the column is successfully pinned. Returns `false` if the column cannot be pinned.
     * Column cannot be pinned if:
     * - Is already pinned
     * - index argument is out of range
     * - The pinned area exceeds 80% of the grid width
     * ```typescript
     * let success = this.column.pin();
     * ```
     * \@memberof IgxColumnComponent
     * @param {?=} index
     * @return {?}
     */
    function (index) {
        // TODO: Probably should the return type of the old functions
        // should be moved as a event parameter.
        if (this.grid) {
            this.grid.endEdit(true);
        }
        if (this._pinned) {
            return false;
        }
        if (this.parent && !this.parent.pinned) {
            return this.topLevelParent.pin(index);
        }
        /** @type {?} */
        var grid = ((/** @type {?} */ (this.grid)));
        /** @type {?} */
        var hasIndex = index !== undefined;
        if (hasIndex && (index < 0 || index >= grid.pinnedColumns.length)) {
            return false;
        }
        /** @type {?} */
        var width = parseInt(this.width, 10);
        if (!this.parent && (grid.getUnpinnedWidth(true) - width < grid.unpinnedAreaMinWidth)) {
            return false;
        }
        this._pinned = true;
        this._unpinnedIndex = grid._unpinnedColumns.indexOf(this);
        index = index !== undefined ? index : grid._pinnedColumns.length;
        /** @type {?} */
        var targetColumn = grid._pinnedColumns[index];
        /** @type {?} */
        var args = { column: this, insertAtIndex: index, isPinned: true };
        grid.onColumnPinning.emit(args);
        if (grid._pinnedColumns.indexOf(this) === -1) {
            grid._pinnedColumns.splice(args.insertAtIndex, 0, this);
            if (grid._unpinnedColumns.indexOf(this) !== -1) {
                grid._unpinnedColumns.splice(grid._unpinnedColumns.indexOf(this), 1);
            }
        }
        if (hasIndex) {
            grid._moveColumns(this, targetColumn);
        }
        if (this.columnGroup) {
            this.allChildren.forEach(function (child) { return child.pin(); });
            grid.reinitPinStates();
        }
        grid.resetCaches();
        grid.cdr.detectChanges();
        this.grid.filteringService.refreshExpressions();
        this.grid.refreshSearch(true);
        return true;
    };
    /**
     * Unpins the column and place it at the provided index in the unpinned area. Defaults to index `0` if not provided.
     * Returns `true` if the column is successfully unpinned. Returns `false` if the column cannot be unpinned.
     * Column cannot be unpinned if:
     * - Is already unpinned
     * - index argument is out of range
     * ```typescript
     * let success = this.column.unpin();
     * ```
     * @memberof IgxColumnComponent
     */
    /**
     * Unpins the column and place it at the provided index in the unpinned area. Defaults to index `0` if not provided.
     * Returns `true` if the column is successfully unpinned. Returns `false` if the column cannot be unpinned.
     * Column cannot be unpinned if:
     * - Is already unpinned
     * - index argument is out of range
     * ```typescript
     * let success = this.column.unpin();
     * ```
     * \@memberof IgxColumnComponent
     * @param {?=} index
     * @return {?}
     */
    IgxColumnComponent.prototype.unpin = /**
     * Unpins the column and place it at the provided index in the unpinned area. Defaults to index `0` if not provided.
     * Returns `true` if the column is successfully unpinned. Returns `false` if the column cannot be unpinned.
     * Column cannot be unpinned if:
     * - Is already unpinned
     * - index argument is out of range
     * ```typescript
     * let success = this.column.unpin();
     * ```
     * \@memberof IgxColumnComponent
     * @param {?=} index
     * @return {?}
     */
    function (index) {
        if (this.grid) {
            this.grid.endEdit(true);
        }
        if (!this._pinned) {
            return false;
        }
        if (this.parent && this.parent.pinned) {
            return this.topLevelParent.unpin(index);
        }
        /** @type {?} */
        var grid = ((/** @type {?} */ (this.grid)));
        /** @type {?} */
        var hasIndex = index !== undefined;
        if (hasIndex && (index < 0 || index >= grid._unpinnedColumns.length)) {
            return false;
        }
        index = (index !== undefined ? index :
            this._unpinnedIndex !== undefined ? this._unpinnedIndex : this.index);
        this._pinned = false;
        /** @type {?} */
        var targetColumn = grid._unpinnedColumns[index];
        grid._unpinnedColumns.splice(index, 0, this);
        if (grid._pinnedColumns.indexOf(this) !== -1) {
            grid._pinnedColumns.splice(grid._pinnedColumns.indexOf(this), 1);
        }
        if (hasIndex) {
            grid._moveColumns(this, targetColumn);
        }
        if (this.columnGroup) {
            this.allChildren.forEach(function (child) { return child.unpin(); });
        }
        grid.reinitPinStates();
        grid.resetCaches();
        /** @type {?} */
        var insertAtIndex = grid._unpinnedColumns.indexOf(this);
        /** @type {?} */
        var args = { column: this, insertAtIndex: insertAtIndex, isPinned: false };
        grid.onColumnPinning.emit(args);
        grid.cdr.detectChanges();
        this.grid.filteringService.refreshExpressions();
        this.grid.refreshSearch(true);
        return true;
    };
    Object.defineProperty(IgxColumnComponent.prototype, "topLevelParent", {
        /**
         * Returns a reference to the top level parent column.
         * ```typescript
         * let topLevelParent =  this.column.topLevelParent;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Returns a reference to the top level parent column.
         * ```typescript
         * let topLevelParent =  this.column.topLevelParent;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            /** @type {?} */
            var parent = this.parent;
            while (parent && parent.parent) {
                parent = parent.parent;
            }
            return parent;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *@hidden
     */
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    IgxColumnComponent.prototype.check = /**
     * @hidden
     * @protected
     * @return {?}
     */
    function () {
        if (this.grid) {
            this.grid.markForCheck();
        }
    };
    Object.defineProperty(IgxColumnComponent.prototype, "headerCell", {
        /**
         * Returns a reference to the header of the column.
         * ```typescript
         * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
         * let headerCell = column.headerCell;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Returns a reference to the header of the column.
         * ```typescript
         * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
         * let headerCell = column.headerCell;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            var _this = this;
            return this.grid.headerCellList.find(function (header) { return header.column === _this; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "filterCell", {
        /**
        * Returns a reference to the filter cell of the column.
        * ```typescript
        * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
        * let filterell = column.filterell;
        * ```
        * @memberof IgxColumnComponent
        */
        get: /**
         * Returns a reference to the filter cell of the column.
         * ```typescript
         * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
         * let filterell = column.filterell;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            var _this = this;
            return this.grid.filterCellList.find(function (filterCell) { return filterCell.column === _this; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnComponent.prototype, "headerGroup", {
        /**
         * Returns a reference to the header group of the column.
         * @memberof IgxColumnComponent
         */
        get: /**
         * Returns a reference to the header group of the column.
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            var _this = this;
            return this.grid.headerGroupsList.find(function (headerGroup) { return headerGroup.column === _this; });
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Autosize the column to the longest currently visible cell value, including the header cell.
     * ```typescript
     * @ViewChild('grid') grid: IgxGridComponent;
     *
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * column.autosize();
     * ```
     * @memberof IgxColumnComponent
     */
    /**
     * Autosize the column to the longest currently visible cell value, including the header cell.
     * ```typescript
     * \@ViewChild('grid') grid: IgxGridComponent;
     *
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * column.autosize();
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    IgxColumnComponent.prototype.autosize = /**
     * Autosize the column to the longest currently visible cell value, including the header cell.
     * ```typescript
     * \@ViewChild('grid') grid: IgxGridComponent;
     *
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * column.autosize();
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    function () {
        if (!this.columnGroup) {
            this.width = this.getLargestCellWidth();
            this.grid.markForCheck();
            this.grid.reflow();
        }
    };
    /**
     * @hidden
     * Returns the size (in pixels) of the longest currently visible cell, including the header cell.
     * ```typescript
     * @ViewChild('grid') grid: IgxGridComponent;
     *
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * let size = column.getLargestCellWidth();
     * ```
     * @memberof IgxColumnComponent
     */
    /**
     * @hidden
     * Returns the size (in pixels) of the longest currently visible cell, including the header cell.
     * ```typescript
     * \@ViewChild('grid') grid: IgxGridComponent;
     *
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * let size = column.getLargestCellWidth();
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    IgxColumnComponent.prototype.getLargestCellWidth = /**
     * @hidden
     * Returns the size (in pixels) of the longest currently visible cell, including the header cell.
     * ```typescript
     * \@ViewChild('grid') grid: IgxGridComponent;
     *
     * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
     * let size = column.getLargestCellWidth();
     * ```
     * \@memberof IgxColumnComponent
     * @return {?}
     */
    function () {
        /** @type {?} */
        var range = this.grid.document.createRange();
        /** @type {?} */
        var largest = new Map();
        if (this.cells.length > 0) {
            /** @type {?} */
            var cellsContentWidths_1 = [];
            if (this.cells[0].nativeElement.children.length > 0) {
                this.cells.forEach(function (cell) { return cellsContentWidths_1.push(cell.calculateSizeToFit(range)); });
            }
            else {
                cellsContentWidths_1 = this.cells.map(function (cell) { return getNodeSizeViaRange(range, cell.nativeElement); });
            }
            /** @type {?} */
            var index = cellsContentWidths_1.indexOf(Math.max.apply(Math, __spread(cellsContentWidths_1)));
            /** @type {?} */
            var cellStyle = this.grid.document.defaultView.getComputedStyle(this.cells[index].nativeElement);
            /** @type {?} */
            var cellPadding = parseFloat(cellStyle.paddingLeft) + parseFloat(cellStyle.paddingRight) +
                parseFloat(cellStyle.borderRightWidth);
            largest.set(Math.max.apply(Math, __spread(cellsContentWidths_1)), cellPadding);
        }
        if (this.headerCell) {
            /** @type {?} */
            var headerCell = void 0;
            if (this.headerTemplate && this.headerCell.elementRef.nativeElement.children[0].children.length > 0) {
                headerCell = Math.max.apply(Math, __spread(Array.from(this.headerCell.elementRef.nativeElement.children[0].children)
                    .map(function (child) { return getNodeSizeViaRange(range, child); })));
            }
            else {
                headerCell = getNodeSizeViaRange(range, this.headerCell.elementRef.nativeElement.children[0]);
            }
            if (this.sortable || this.filterable) {
                headerCell += this.headerCell.elementRef.nativeElement.children[1].getBoundingClientRect().width;
            }
            /** @type {?} */
            var headerStyle = this.grid.document.defaultView.getComputedStyle(this.headerCell.elementRef.nativeElement);
            /** @type {?} */
            var headerPadding = parseFloat(headerStyle.paddingLeft) + parseFloat(headerStyle.paddingRight) +
                parseFloat(headerStyle.borderRightWidth);
            largest.set(headerCell, headerPadding);
        }
        /** @type {?} */
        var largestCell = Math.max.apply(Math, __spread(Array.from(largest.keys())));
        /** @type {?} */
        var width = Math.ceil(largestCell + largest.get(largestCell));
        if (Number.isNaN(width)) {
            return this.width;
        }
        else {
            return width + 'px';
        }
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxColumnComponent.prototype.getCellWidth = /**
     * @hidden
     * @return {?}
     */
    function () {
        /** @type {?} */
        var colWidth = this.width;
        /** @type {?} */
        var isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
        if (this.parent && this.parent.columnLayout) {
            return '';
        }
        if (colWidth && !isPercentageWidth) {
            /** @type {?} */
            var cellWidth = colWidth;
            if (typeof cellWidth !== 'string' || cellWidth.endsWith('px') === false) {
                cellWidth += 'px';
            }
            return cellWidth;
        }
        else {
            return colWidth;
        }
    };
    IgxColumnComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-column',
                    template: ""
                }] }
    ];
    /** @nocollapse */
    IgxColumnComponent.ctorParameters = function () { return [
        { type: GridBaseAPIService },
        { type: ChangeDetectorRef }
    ]; };
    IgxColumnComponent.propDecorators = {
        field: [{ type: Input }],
        header: [{ type: Input }],
        sortable: [{ type: Input }],
        groupable: [{ type: Input }],
        editable: [{ type: Input }],
        filterable: [{ type: Input }],
        resizable: [{ type: Input }],
        hasSummary: [{ type: Input }],
        hidden: [{ type: Input }],
        disableHiding: [{ type: Input }],
        disablePinning: [{ type: Input }],
        movable: [{ type: Input }],
        width: [{ type: Input }],
        maxWidth: [{ type: Input }],
        minWidth: [{ type: Input }],
        headerClasses: [{ type: Input }],
        headerGroupClasses: [{ type: Input }],
        cellClasses: [{ type: Input }],
        formatter: [{ type: Input }],
        filteringIgnoreCase: [{ type: Input }],
        sortingIgnoreCase: [{ type: Input }],
        dataType: [{ type: Input }],
        pinned: [{ type: Input }],
        summaries: [{ type: Input }],
        searchable: [{ type: Input }],
        filters: [{ type: Input }],
        sortStrategy: [{ type: Input }],
        groupingComparer: [{ type: Input }],
        bodyTemplate: [{ type: Input, args: ['cellTemplate',] }],
        headerTemplate: [{ type: Input }],
        inlineEditorTemplate: [{ type: Input, args: ['cellEditorTemplate',] }],
        filterCellTemplate: [{ type: Input, args: ['filterCellTemplate',] }],
        rowEnd: [{ type: Input }],
        colEnd: [{ type: Input }],
        rowStart: [{ type: Input }],
        colStart: [{ type: Input }],
        cellTemplate: [{ type: ContentChild, args: [IgxCellTemplateDirective, { read: IgxCellTemplateDirective },] }],
        headTemplate: [{ type: ContentChild, args: [IgxCellHeaderTemplateDirective, { read: IgxCellHeaderTemplateDirective },] }],
        editorTemplate: [{ type: ContentChild, args: [IgxCellEditorTemplateDirective, { read: IgxCellEditorTemplateDirective },] }],
        filterCellTemplateDirective: [{ type: ContentChild, args: [IgxFilterCellTemplateDirective, { read: IgxFilterCellTemplateDirective },] }]
    };
    __decorate([
        DeprecateProperty("The property is deprecated. Please, use `column.grid.id` instead."),
        __metadata("design:type", String)
    ], IgxColumnComponent.prototype, "gridID", void 0);
    return IgxColumnComponent;
}());
var IgxColumnGroupComponent = /** @class */ (function (_super) {
    __extends(IgxColumnGroupComponent, _super);
    function IgxColumnGroupComponent(gridAPI, cdr) {
        var _this = 
        // D.P. constructor duplication due to es6 compilation, might be obsolete in the future
        _super.call(this, gridAPI, cdr) || this;
        _this.gridAPI = gridAPI;
        _this.cdr = cdr;
        _this.children = new QueryList();
        /**
         * Sets/gets whether the column group is `searchable`.
         * Default value is `true`.
         * ```typescript
         * let isSearchable =  this.columnGroup.searchable;
         * ```
         * ```html
         *  <igx-column-group [searchable] = "false"></igx-column-group>
         * ```
         * \@memberof IgxColumnGroupComponent
         */
        _this.searchable = true;
        return _this;
    }
    Object.defineProperty(IgxColumnGroupComponent.prototype, "summaries", {
        /**
         * Gets the column group `summaries`.
         * ```typescript
         * let columnGroupSummaries = this.columnGroup.summaries;
         * ```
         * @memberof IgxColumnGroupComponent
         */
        get: /**
         * Gets the column group `summaries`.
         * ```typescript
         * let columnGroupSummaries = this.columnGroup.summaries;
         * ```
         * \@memberof IgxColumnGroupComponent
         * @return {?}
         */
        function () {
            return this._summaries;
        },
        /**
         * Sets the column group `summaries`.
         * ```typescript
         * this.columnGroup.summaries = IgxNumberSummaryOperand;
         * ```
         * @memberof IgxColumnGroupComponent
         */
        set: /**
         * Sets the column group `summaries`.
         * ```typescript
         * this.columnGroup.summaries = IgxNumberSummaryOperand;
         * ```
         * \@memberof IgxColumnGroupComponent
         * @param {?} classRef
         * @return {?}
         */
        function (classRef) { },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnGroupComponent.prototype, "filters", {
        /**
         * Gets the column group `filters`.
         * ```typescript
         * let columnGroupFilters = this.columnGroup.filters;
         * ```
         * @memberof IgxColumnGroupComponent
         */
        get: /**
         * Gets the column group `filters`.
         * ```typescript
         * let columnGroupFilters = this.columnGroup.filters;
         * ```
         * \@memberof IgxColumnGroupComponent
         * @return {?}
         */
        function () {
            return this._filters;
        },
        /**
         * Sets the column group `filters`.
         * ```typescript
         * this.columnGroup.filters = IgxStringFilteringOperand;
         * ```
         * @memberof IgxColumnGroupComponent
         */
        set: /**
         * Sets the column group `filters`.
         * ```typescript
         * this.columnGroup.filters = IgxStringFilteringOperand;
         * ```
         * \@memberof IgxColumnGroupComponent
         * @param {?} classRef
         * @return {?}
         */
        function (classRef) { },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnGroupComponent.prototype, "defaultMinWidth", {
        /**
         * Gets the default minimum `width` of the column group.
         * ```typescript
         * let defaultMinWidth = this.columnGroup.defaultMinWidth;
         * ```
         * @memberof IgxColumnGroupComponent
         */
        get: /**
         * Gets the default minimum `width` of the column group.
         * ```typescript
         * let defaultMinWidth = this.columnGroup.defaultMinWidth;
         * ```
         * \@memberof IgxColumnGroupComponent
         * @return {?}
         */
        function () {
            return this._defaultMinWidth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnGroupComponent.prototype, "bodyTemplate", {
        /**
         * Returns a reference to the body template.
         * ```typescript
         * let bodyTemplate = this.columnGroup.bodyTemplate;
         * ```
         * @memberof IgxColumnGroupComponent
         */
        get: /**
         * Returns a reference to the body template.
         * ```typescript
         * let bodyTemplate = this.columnGroup.bodyTemplate;
         * ```
         * \@memberof IgxColumnGroupComponent
         * @return {?}
         */
        function () {
            return this._bodyTemplate;
        },
        /**
         * @hidden
         */
        set: /**
         * @hidden
         * @param {?} template
         * @return {?}
         */
        function (template) { },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnGroupComponent.prototype, "headerTemplate", {
        /**
         * Returns a reference to the header template.
         * ```typescript
         * let headerTemplate = this.columnGroup.headerTemplate;
         * ```
         * @memberof IgxColumnGroupComponent
         */
        get: /**
         * Returns a reference to the header template.
         * ```typescript
         * let headerTemplate = this.columnGroup.headerTemplate;
         * ```
         * \@memberof IgxColumnGroupComponent
         * @return {?}
         */
        function () {
            return this._headerTemplate;
        },
        /**
         * @hidden
         * @memberof IgxColumnGroupComponent
         */
        set: /**
         * @hidden
         * \@memberof IgxColumnGroupComponent
         * @param {?} template
         * @return {?}
         */
        function (template) { },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnGroupComponent.prototype, "inlineEditorTemplate", {
        /**
         * Returns a reference to the inline editor template.
         * ```typescript
         * let inlineEditorTemplate = this.columnGroup.inlineEditorTemplate;
         * ```
         * @memberof IgxColumnGroupComponent
         */
        get: /**
         * Returns a reference to the inline editor template.
         * ```typescript
         * let inlineEditorTemplate = this.columnGroup.inlineEditorTemplate;
         * ```
         * \@memberof IgxColumnGroupComponent
         * @return {?}
         */
        function () {
            return this._inlineEditorTemplate;
        },
        /**
         * @hidden
         */
        set: /**
         * @hidden
         * @param {?} template
         * @return {?}
         */
        function (template) { },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnGroupComponent.prototype, "cells", {
        /**
         * Gets the column group cells.
         * ```typescript
         * let columnCells = this.columnGroup.cells;
         * ```
         * @memberof IgxColumnGroupComponent
         */
        get: /**
         * Gets the column group cells.
         * ```typescript
         * let columnCells = this.columnGroup.cells;
         * ```
         * \@memberof IgxColumnGroupComponent
         * @return {?}
         */
        function () {
            return [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnGroupComponent.prototype, "hidden", {
        /**
         * Gets whether the column group is hidden.
         * ```typescript
         * let isHidden = this.columnGroup.hidden;
         * ```
         * @memberof IgxColumnGroupComponent
         */
        get: /**
         * Gets whether the column group is hidden.
         * ```typescript
         * let isHidden = this.columnGroup.hidden;
         * ```
         * \@memberof IgxColumnGroupComponent
         * @return {?}
         */
        function () {
            return this.allChildren.every(function (c) { return c.hidden; });
        },
        /**
         * Sets the column group hidden property.
         * ```typescript
         * <igx-column [hidden] = "true"></igx-column>
         * ```
         * @memberof IgxColumnGroupComponent
         */
        set: /**
         * Sets the column group hidden property.
         * ```typescript
         * <igx-column [hidden] = "true"></igx-column>
         * ```
         * \@memberof IgxColumnGroupComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._hidden = value;
            this.children.forEach(function (child) { return child.hidden = value; });
        },
        enumerable: true,
        configurable: true
    });
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxColumnGroupComponent.prototype.ngAfterContentInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        /*
            @ContentChildren with descendants still returns the `parent`
            component in the query list.
        */
        this.children.reset(this.children.toArray().slice(1));
        this.children.forEach(function (child) {
            child.parent = _this;
        });
    };
    Object.defineProperty(IgxColumnGroupComponent.prototype, "allChildren", {
        /**
         * Returns the children columns collection.
         * ```typescript
         * let columns =  this.columnGroup.allChildren;
         * ```
         * @memberof IgxColumnGroupComponent
         */
        get: /**
         * Returns the children columns collection.
         * ```typescript
         * let columns =  this.columnGroup.allChildren;
         * ```
         * \@memberof IgxColumnGroupComponent
         * @return {?}
         */
        function () {
            return flatten(this.children.toArray());
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnGroupComponent.prototype, "columnGroup", {
        /**
         * Returns a boolean indicating if the column is a `ColumnGroup`.
         * ```typescript
         * let isColumnGroup =  this.columnGroup.columnGroup
         * ```
         * @memberof IgxColumnGroupComponent
         */
        get: /**
         * Returns a boolean indicating if the column is a `ColumnGroup`.
         * ```typescript
         * let isColumnGroup =  this.columnGroup.columnGroup
         * ```
         * \@memberof IgxColumnGroupComponent
         * @return {?}
         */
        function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnGroupComponent.prototype, "columnLayout", {
        /**
         * Returns a boolean indicating if the column is a `ColumnLayout` for multi-row layout.
         * ```typescript
         * let columnGroup =  this.column.columnGroup;
         * ```
         * @memberof IgxColumnComponent
         */
        get: /**
         * Returns a boolean indicating if the column is a `ColumnLayout` for multi-row layout.
         * ```typescript
         * let columnGroup =  this.column.columnGroup;
         * ```
         * \@memberof IgxColumnComponent
         * @return {?}
         */
        function () {
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnGroupComponent.prototype, "width", {
        /**
         * Gets the width of the column group.
         * ```typescript
         * let columnGroupWidth = this.columnGroup.width;
         * ```
         * @memberof IgxColumnGroupComponent
         */
        get: /**
         * Gets the width of the column group.
         * ```typescript
         * let columnGroupWidth = this.columnGroup.width;
         * ```
         * \@memberof IgxColumnGroupComponent
         * @return {?}
         */
        function () {
            /** @type {?} */
            var isChildrenWidthInPercent = false;
            /** @type {?} */
            var width;
            width = "" + this.children.reduce(function (acc, val) {
                if (val.hidden) {
                    return acc;
                }
                if (typeof val.width === 'string' && val.width.indexOf('%') !== -1) {
                    isChildrenWidthInPercent = true;
                }
                return acc + parseInt(val.width, 10);
            }, 0);
            return isChildrenWidthInPercent ? width + '%' : width;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) { },
        enumerable: true,
        configurable: true
    });
    IgxColumnGroupComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [{ provide: IgxColumnComponent, useExisting: forwardRef(function () { return IgxColumnGroupComponent; }) }],
                    selector: 'igx-column-group',
                    template: ""
                }] }
    ];
    /** @nocollapse */
    IgxColumnGroupComponent.ctorParameters = function () { return [
        { type: GridBaseAPIService },
        { type: ChangeDetectorRef }
    ]; };
    IgxColumnGroupComponent.propDecorators = {
        children: [{ type: ContentChildren, args: [IgxColumnComponent, { read: IgxColumnComponent },] }],
        summaries: [{ type: Input }],
        searchable: [{ type: Input }],
        filters: [{ type: Input }],
        hidden: [{ type: Input }]
    };
    return IgxColumnGroupComponent;
}(IgxColumnComponent));
var IgxColumnLayoutComponent = /** @class */ (function (_super) {
    __extends(IgxColumnLayoutComponent, _super);
    function IgxColumnLayoutComponent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(IgxColumnLayoutComponent.prototype, "width", {
        /**
         * Gets the width of the column layout.
         * ```typescript
         * let columnGroupWidth = this.columnGroup.width;
         * ```
         * @memberof IgxColumnGroupComponent
         */
        get: /**
         * Gets the width of the column layout.
         * ```typescript
         * let columnGroupWidth = this.columnGroup.width;
         * ```
         * \@memberof IgxColumnGroupComponent
         * @return {?}
         */
        function () {
            /** @type {?} */
            var width = this.getFilledChildColumnSizes(this.children).reduce(function (acc, val) { return acc + parseInt(val, 10); }, 0);
            return width;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) { },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnLayoutComponent.prototype, "columnLayout", {
        get: /**
         * @return {?}
         */
        function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnLayoutComponent.prototype, "hidden", {
        /**
         * Gets whether the column layout is hidden.
         * ```typescript
         * let isHidden = this.columnGroup.hidden;
         * ```
         * @memberof IgxColumnGroupComponent
         */
        get: /**
         * Gets whether the column layout is hidden.
         * ```typescript
         * let isHidden = this.columnGroup.hidden;
         * ```
         * \@memberof IgxColumnGroupComponent
         * @return {?}
         */
        function () {
            return this._hidden;
        },
        /**
         * Sets the column layout hidden property.
         * ```typescript
         * <igx-column-layout [hidden] = "true"></igx-column->
         * ```
         * @memberof IgxColumnGroupComponent
         */
        set: /**
         * Sets the column layout hidden property.
         * ```typescript
         * <igx-column-layout [hidden] = "true"></igx-column->
         * ```
         * \@memberof IgxColumnGroupComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._hidden = value;
            this.children.forEach(function (child) { return child.hidden = value; });
        },
        enumerable: true,
        configurable: true
    });
    /**
     *@hidden
    */
    /**
     * @hidden
     * @return {?}
     */
    IgxColumnLayoutComponent.prototype.ngAfterContentInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        _super.prototype.ngAfterContentInit.call(this);
        if (!this.hidden) {
            this.hidden = this.allChildren.some(function (x) { return x.hidden; });
        }
        else {
            this.children.forEach(function (child) { return child.hidden = _this.hidden; });
        }
        this.children.forEach(function (child) {
            child.disableHiding = true;
            child.disablePinning = true;
        });
    };
    Object.defineProperty(IgxColumnLayoutComponent.prototype, "hasLastPinnedChildColumn", {
        /*
         * Gets whether the group contains the last pinned child column of the column layout.
         * ```typescript
         * let columsHasLastPinned = this.columnLayout.hasLastPinnedChildColumn;
         * ```
         * @memberof IgxColumnLayoutComponent
         */
        get: /*
             * Gets whether the group contains the last pinned child column of the column layout.
             * ```typescript
             * let columsHasLastPinned = this.columnLayout.hasLastPinnedChildColumn;
             * ```
             * @memberof IgxColumnLayoutComponent
             */
        /**
         * @return {?}
         */
        function () {
            return this.children.some(function (child) { return child.isLastPinned; });
        },
        enumerable: true,
        configurable: true
    });
    IgxColumnLayoutComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    providers: [{ provide: IgxColumnComponent, useExisting: forwardRef(function () { return IgxColumnLayoutComponent; }) }],
                    selector: 'igx-column-layout',
                    template: ""
                }] }
    ];
    IgxColumnLayoutComponent.propDecorators = {
        hidden: [{ type: Input }]
    };
    return IgxColumnLayoutComponent;
}(IgxColumnGroupComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Providing reference to `IgxGridCellComponent`:
 * ```typescript
 * \@ViewChild('grid', { read: IgxGridComponent })
 *  public grid: IgxGridComponent;
 * ```
 * ```typescript
 *  let column = this.grid.columnList.first;
 * ```
 * ```typescript
 *  let cell = column.cells[0];
 * ```
 */
var IgxGridCellComponent = /** @class */ (function () {
    function IgxGridCellComponent(selectionService, crudService, gridAPI, selection, cdr, element, zone) {
        var _this = this;
        this.selectionService = selectionService;
        this.crudService = crudService;
        this.gridAPI = gridAPI;
        this.selection = selection;
        this.cdr = cdr;
        this.element = element;
        this.zone = zone;
        /**
         * Sets/gets the highlight class of the cell.
         * Default value is `"igx-highlight"`.
         * ```typescript
         * let highlightClass = this.cell.highlightClass;
         * ```
         * ```typescript
         * this.cell.highlightClass = 'igx-cell-highlight';
         * ```
         * \@memberof IgxGridCellComponent
         */
        this.highlightClass = 'igx-highlight';
        /**
         * Sets/gets the active highlight class class of the cell.
         * Default value is `"igx-highlight__active"`.
         * ```typescript
         * let activeHighlightClass = this.cell.activeHighlightClass;
         * ```
         * ```typescript
         * this.cell.activeHighlightClass = 'igx-cell-highlight_active';
         * ```
         * \@memberof IgxGridCellComponent
         */
        this.activeHighlightClass = 'igx-highlight__active';
        /**
         * Gets the visible `index` of the in which the cell is stored.
         * ```typescript
         * let visibleColumnIndex = this.cell.visibleColumnIndex;
         * ```
         * \@memberof IgxGridCellComponent
         */
        this.visibleColumnIndex = -1;
        /**
         * @hidden
         * \@internal
         */
        this.lastPinned = false;
        /**
         * Returns whether the cell is in edit mode.
         */
        this.editMode = false;
        /**
         * Sets/get the `tabindex` property of the cell.
         * Default value is `0`.
         * ```typescript
         * this.cell.tabindex = 1;
         * ```
         * ```typescript
         * let cellTabIndex = this.cell.tabindex;
         * ```
         * \@memberof IgxGridCellComponent
         */
        this.tabindex = 0;
        /**
         * Sets/get the `role` property of the cell.
         * Default value is `"gridcell"`.
         * ```typescript
         * this.cell.role = 'grid-cell';
         * ```
         * ```typescript
         * let cellRole = this.cell.role;
         * ```
         * \@memberof IgxGridCellComponent
         */
        this.role = 'gridcell';
        /**
         * Gets the width of the cell.
         * ```typescript
         * let cellWidth = this.cell.width;
         * ```
         * \@memberof IgxGridCellComponent
         */
        this.width = '';
        /**
         * @hidden
         * \@internal
         */
        this.focused = false;
        this.isInCompositionMode = false;
        /**
         *
         * @hidden
         * \@internal
         */
        this.pointerdown = function (event) {
            _this.selectionService.pointerDown(_this.selectionNode, event.shiftKey, event.ctrlKey);
        };
        /**
         *
         * @hidden
         * \@internal
         */
        this.pointerenter = function (event) {
            /** @type {?} */
            var dragMode = _this.selectionService.pointerEnter(_this.selectionNode, event.buttons === 1);
            if (dragMode) {
                _this.grid.cdr.detectChanges();
            }
        };
        /**
         * @hidden
         * \@internal
         */
        this.pointerup = function () {
            if (_this.selectionService.pointerUp(_this.selectionNode, _this.grid.onRangeSelection)) {
                _this.grid.cdr.detectChanges();
            }
        };
    }
    Object.defineProperty(IgxGridCellComponent.prototype, "context", {
        /**
         * Gets the cell template context object.
         * ```typescript
         *  let context = this.cell.context();
         * ```
         * @memberof IgxGridCellComponent
         */
        get: /**
         * Gets the cell template context object.
         * ```typescript
         *  let context = this.cell.context();
         * ```
         * \@memberof IgxGridCellComponent
         * @return {?}
         */
        function () {
            return {
                $implicit: this.value,
                cell: this
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridCellComponent.prototype, "template", {
        /**
         * Gets the cell template.
         * ```typescript
         * let template = this.cell.template;
         * ```
         * @memberof IgxGridCellComponent
         */
        get: /**
         * Gets the cell template.
         * ```typescript
         * let template = this.cell.template;
         * ```
         * \@memberof IgxGridCellComponent
         * @return {?}
         */
        function () {
            if (this.editMode) {
                /** @type {?} */
                var inlineEditorTemplate = this.column.inlineEditorTemplate;
                return inlineEditorTemplate ? inlineEditorTemplate : this.inlineEditorTemplate;
            }
            if (this.cellTemplate) {
                return this.cellTemplate;
            }
            return this.defaultCellTemplate;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridCellComponent.prototype, "gridID", {
        /**
         * Gets the `id` of the grid in which the cell is stored.
         * ```typescript
         * let gridId = this.cell.gridID;
         * ```
         * @memberof IgxGridCellComponent
         */
        get: /**
         * Gets the `id` of the grid in which the cell is stored.
         * ```typescript
         * let gridId = this.cell.gridID;
         * ```
         * \@memberof IgxGridCellComponent
         * @return {?}
         */
        function () {
            return this.row.gridID;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridCellComponent.prototype, "grid", {
        /**
         * Gets the grid of the cell.
         * ```typescript
         * let grid = this.cell.grid;
         * ```
         * @memberof IgxGridCellComponent
         */
        get: /**
         * Gets the grid of the cell.
         * ```typescript
         * let grid = this.cell.grid;
         * ```
         * \@memberof IgxGridCellComponent
         * @return {?}
         */
        function () {
            return this.gridAPI.grid;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridCellComponent.prototype, "rowIndex", {
        /**
         * Gets the `index` of the row where the cell is stored.
         * ```typescript
         * let rowIndex = this.cell.rowIndex;
         * ```
         * @memberof IgxGridCellComponent
         */
        get: /**
         * Gets the `index` of the row where the cell is stored.
         * ```typescript
         * let rowIndex = this.cell.rowIndex;
         * ```
         * \@memberof IgxGridCellComponent
         * @return {?}
         */
        function () {
            return this.row.index;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridCellComponent.prototype, "columnIndex", {
        /**
         * Gets the `index` of the cell column.
         * ```typescript
         * let columnIndex = this.cell.columnIndex;
         * ```
         * @memberof IgxGridCellComponent
         */
        get: /**
         * Gets the `index` of the cell column.
         * ```typescript
         * let columnIndex = this.cell.columnIndex;
         * ```
         * \@memberof IgxGridCellComponent
         * @return {?}
         */
        function () {
            return this.column.index;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridCellComponent.prototype, "cellID", {
        /**
         * Gets the ID of the cell.
         * ```typescript
         * let cellID = this.cell.cellID;
         * ```
         * @memberof IgxGridCellComponent
         */
        get: /**
         * Gets the ID of the cell.
         * ```typescript
         * let cellID = this.cell.cellID;
         * ```
         * \@memberof IgxGridCellComponent
         * @return {?}
         */
        function () {
            /** @type {?} */
            var primaryKey = this.grid.primaryKey;
            /** @type {?} */
            var rowID = primaryKey ? this.rowData[primaryKey] : this.rowData;
            return { rowID: rowID, columnID: this.columnIndex, rowIndex: this.rowIndex };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridCellComponent.prototype, "nativeElement", {
        /**
         * Returns a reference to the nativeElement of the cell.
         * ```typescript
         * let cellNativeElement = this.cell.nativeElement;
         * ```
         * @memberof IgxGridCellComponent
         */
        get: /**
         * Returns a reference to the nativeElement of the cell.
         * ```typescript
         * let cellNativeElement = this.cell.nativeElement;
         * ```
         * \@memberof IgxGridCellComponent
         * @return {?}
         */
        function () {
            return this.element.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridCellComponent.prototype, "inEditMode", {
        /**
         * @deprecated
         * Use `cell.editMode` as a getter and
         * `cell.setEditMode(true | false)` to start/exit edit mode.
         *
         * Gets/sets whether the cell is in edit mode.
         * ```typescript
         * let isCellInEditMode = this.cell.inEditMode;
         * ```
         * @memberof IgxGridCellComponent
         */
        get: /**
         * @deprecated
         * Use `cell.editMode` as a getter and
         * `cell.setEditMode(true | false)` to start/exit edit mode.
         *
         * Gets/sets whether the cell is in edit mode.
         * ```typescript
         * let isCellInEditMode = this.cell.inEditMode;
         * ```
         * \@memberof IgxGridCellComponent
         * @return {?}
         */
        function () {
            return this.editMode;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.setEditMode(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridCellComponent.prototype, "readonly", {
        /**
         * Gets whether the cell is editable.
         * ```typescript
         * let isCellReadonly = this.cell.readonly;
         * ```
         * @memberof IgxGridCellComponent
         */
        get: /**
         * Gets whether the cell is editable.
         * ```typescript
         * let isCellReadonly = this.cell.readonly;
         * ```
         * \@memberof IgxGridCellComponent
         * @return {?}
         */
        function () {
            return !this.column.editable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridCellComponent.prototype, "gridRowSpan", {
        get: /**
         * @return {?}
         */
        function () {
            return this.column.gridRowSpan;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridCellComponent.prototype, "gridColumnSpan", {
        get: /**
         * @return {?}
         */
        function () {
            return this.column.gridColumnSpan;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridCellComponent.prototype, "rowEnd", {
        get: /**
         * @return {?}
         */
        function () {
            return this.column.rowEnd;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridCellComponent.prototype, "colEnd", {
        get: /**
         * @return {?}
         */
        function () {
            return this.column.colEnd;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridCellComponent.prototype, "rowStart", {
        get: /**
         * @return {?}
         */
        function () {
            return this.column.rowStart;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridCellComponent.prototype, "colStart", {
        get: /**
         * @return {?}
         */
        function () {
            return this.column.colStart;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridCellComponent.prototype, "describedby", {
        /**
         * Returns a string containing the grid `id` and the column `field` concatenated by "_".
         * ```typescript
         * let describedBy = this.cell.describedBy;
         * ```
         * @memberof IgxGridCellComponent
         */
        get: /**
         * Returns a string containing the grid `id` and the column `field` concatenated by "_".
         * ```typescript
         * let describedBy = this.cell.describedBy;
         * ```
         * \@memberof IgxGridCellComponent
         * @return {?}
         */
        function () {
            return this.row.gridID + "_" + this.column.field;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridCellComponent.prototype, "selected", {
        /**
         * Gets whether the cell is selected.
         * ```typescript
         * let isSelected = this.cell.selected;
         * ```
         * @memberof IgxGridCellComponent
         */
        get: /**
         * Gets whether the cell is selected.
         * ```typescript
         * let isSelected = this.cell.selected;
         * ```
         * \@memberof IgxGridCellComponent
         * @return {?}
         */
        function () {
            return this.isCellSelected();
        },
        /**
         * Selects/deselects the cell.
         * ```typescript
         * this.cell.selected = true.
         * ```
         * @memberof IgxGridCellComponent
         */
        set: /**
         * Selects/deselects the cell.
         * ```typescript
         * this.cell.selected = true.
         * ```
         * \@memberof IgxGridCellComponent
         * @param {?} val
         * @return {?}
         */
        function (val) {
            /** @type {?} */
            var node = this.selectionNode;
            val ? this.selectionService.add(node) : this.selectionService.remove(node);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridCellComponent.prototype, "dirty", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.grid.rowEditable) {
                /** @type {?} */
                var rowCurrentState = this.grid.transactions.getAggregatedValue(this.row.rowID, false);
                if (rowCurrentState) {
                    return rowCurrentState[this.column.field] !== undefined && rowCurrentState[this.column.field] !== null;
                }
            }
            else {
                /** @type {?} */
                var rowTransaction = this.grid.transactions.getState(this.row.rowID);
                return rowTransaction && rowTransaction.value && rowTransaction.value[this.column.field];
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridCellComponent.prototype, "editValue", {
        /**
         * Gets the current edit value while a cell is in edit mode.
         * Only for cell editing mode.
         * ```typescript
         * let editValue = this.cell.editValue;
         * ```
         * @memberof IgxGridCellComponent
         */
        get: /**
         * Gets the current edit value while a cell is in edit mode.
         * Only for cell editing mode.
         * ```typescript
         * let editValue = this.cell.editValue;
         * ```
         * \@memberof IgxGridCellComponent
         * @return {?}
         */
        function () {
            if (this.crudService.inEditMode) {
                return this.crudService.cell.editValue;
            }
        },
        /**
         * Sets the current edit value while a cell is in edit mode.
         * Only for cell editing mode.
         * ```typescript
         * this.cell.editValue = value;
         * ```
         * @memberof IgxGridCellComponent
         */
        set: /**
         * Sets the current edit value while a cell is in edit mode.
         * Only for cell editing mode.
         * ```typescript
         * this.cell.editValue = value;
         * ```
         * \@memberof IgxGridCellComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this.crudService.inEditMode) {
                this.crudService.cell.editValue = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridCellComponent.prototype, "editable", {
        /**
         * Returns whether the cell is editable.
         */
        get: /**
         * Returns whether the cell is editable.
         * @return {?}
         */
        function () {
            return this.column.editable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridCellComponent.prototype, "highlight", {
        get: /**
         * @protected
         * @return {?}
         */
        function () {
            return this._highlight;
        },
        set: /**
         * @protected
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._highlight = value;
            if (this._highlight && this.grid.lastSearchInfo.searchText) {
                this._highlight.highlight(this.grid.lastSearchInfo.searchText, this.grid.lastSearchInfo.caseSensitive, this.grid.lastSearchInfo.exactMatch);
                this._highlight.activateIfNecessary();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridCellComponent.prototype, "selectionNode", {
        get: /**
         * @protected
         * @return {?}
         */
        function () {
            return { row: this.rowIndex, column: this.visibleColumnIndex };
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     * @internal
     */
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    IgxGridCellComponent.prototype.ngOnInit = /**
     * @hidden
     * \@internal
     * @return {?}
     */
    function () {
        var _this = this;
        this.zone.runOutsideAngular(function () {
            _this.nativeElement.addEventListener('pointerdown', _this.pointerdown);
            _this.nativeElement.addEventListener('pointerenter', _this.pointerenter);
            _this.nativeElement.addEventListener('pointerup', _this.pointerup);
            // IE 11 workarounds
            if (isIE()) {
                _this.compositionStartHandler = function () { return _this.isInCompositionMode = true; };
                _this.compositionEndHandler = function () { return _this.isInCompositionMode = false; };
                // Hitting Enter with IME submits and exits from edit mode instead of first closing the IME dialog
                _this.nativeElement.addEventListener('compositionstart', _this.compositionStartHandler);
                _this.nativeElement.addEventListener('compositionend', _this.compositionEndHandler);
                // https://stackoverflow.com/q/51404782
                _this.focusHandlerIE = function (e) { return _this.onFocus(e); };
                _this.focusOut = function () { return _this.onBlur(); };
                _this.nativeElement.addEventListener('focusin', _this.focusHandlerIE);
                _this.nativeElement.addEventListener('focusout', _this.focusOut);
            }
        });
    };
    /**
     * @hidden
     * @internal
     */
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    IgxGridCellComponent.prototype.ngOnDestroy = /**
     * @hidden
     * \@internal
     * @return {?}
     */
    function () {
        var _this = this;
        this.zone.runOutsideAngular(function () {
            _this.nativeElement.removeEventListener('pointerdown', _this.pointerdown);
            _this.nativeElement.removeEventListener('pointerenter', _this.pointerenter);
            _this.nativeElement.removeEventListener('pointerup', _this.pointerup);
            if (isIE()) {
                _this.nativeElement.removeEventListener('compositionstart', _this.compositionStartHandler);
                _this.nativeElement.removeEventListener('compositionend', _this.compositionEndHandler);
                _this.nativeElement.removeEventListener('focusin', _this.focusHandlerIE);
                _this.nativeElement.removeEventListener('focusout', _this.focusOut);
            }
        });
    };
    /**
     * @hidden
     * @internal
     */
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    IgxGridCellComponent.prototype._updateCRUDStatus = /**
     * @hidden
     * \@internal
     * @return {?}
     */
    function () {
        if (this.editable && this.crudService.inEditMode && !this.row.deleted) {
            this.gridAPI.update_cell(this.crudService.cell, this.crudService.cell.editValue);
            this.crudService.end();
            this.grid.cdr.markForCheck();
            this.crudService.begin(this);
        }
        else if (this.crudService.inEditMode) {
            this.grid.endEdit(true);
        }
    };
    /**
     * @hidden
     * @internal
     */
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    IgxGridCellComponent.prototype._updateCellSelectionStatus = /**
     * @hidden
     * \@internal
     * @return {?}
     */
    function () {
        if (this.editMode) {
            return;
        }
        /** @type {?} */
        var node = this.selectionNode;
        this._updateCRUDStatus();
        this.selectionService.keyboardStateOnFocus(node, this.grid.onRangeSelection);
    };
    /**
     * Gets whether the cell is selected.
     * ```typescript
     * let isCellSelected = thid.cell.isCellSelected();
     * ```
     * @memberof IgxGridCellComponent
     */
    /**
     * Gets whether the cell is selected.
     * ```typescript
     * let isCellSelected = thid.cell.isCellSelected();
     * ```
     * \@memberof IgxGridCellComponent
     * @return {?}
     */
    IgxGridCellComponent.prototype.isCellSelected = /**
     * Gets whether the cell is selected.
     * ```typescript
     * let isCellSelected = thid.cell.isCellSelected();
     * ```
     * \@memberof IgxGridCellComponent
     * @return {?}
     */
    function () {
        return this.selectionService.selected(this.selectionNode);
    };
    /**
     * @hidden
     * @internal
     */
    /**
     * @hidden
     * \@internal
     * @param {?} changes
     * @return {?}
     */
    IgxGridCellComponent.prototype.ngOnChanges = /**
     * @hidden
     * \@internal
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes.value && !changes.value.firstChange) {
            if (this.highlight) {
                this.highlight.lastSearchInfo.searchedText = this.grid.lastSearchInfo.searchText;
                this.highlight.lastSearchInfo.caseSensitive = this.grid.lastSearchInfo.caseSensitive;
                this.highlight.lastSearchInfo.exactMatch = this.grid.lastSearchInfo.exactMatch;
            }
        }
    };
    /**
     * Starts/ends edit mode for the cell.
     *
     * ```typescript
     * cell.setEditMode(true);
     * ```
     */
    /**
     * Starts/ends edit mode for the cell.
     *
     * ```typescript
     * cell.setEditMode(true);
     * ```
     * @param {?} value
     * @return {?}
     */
    IgxGridCellComponent.prototype.setEditMode = /**
     * Starts/ends edit mode for the cell.
     *
     * ```typescript
     * cell.setEditMode(true);
     * ```
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (this.row.deleted) {
            return;
        }
        if (this.editable && value) {
            this.gridAPI.submit_value();
            this.crudService.begin(this);
        }
        else {
            this.gridAPI.escape_editMode();
        }
        this.grid.cdr.markForCheck();
    };
    /**
     * Sets new value to the cell.
     * ```typescript
     * this.cell.update('New Value');
     * ```
     * @memberof IgxGridCellComponent
     */
    // TODO: Refactor
    /**
     * Sets new value to the cell.
     * ```typescript
     * this.cell.update('New Value');
     * ```
     * \@memberof IgxGridCellComponent
     * @param {?} val
     * @return {?}
     */
    // TODO: Refactor
    IgxGridCellComponent.prototype.update = /**
     * Sets new value to the cell.
     * ```typescript
     * this.cell.update('New Value');
     * ```
     * \@memberof IgxGridCellComponent
     * @param {?} val
     * @return {?}
     */
    // TODO: Refactor
    function (val) {
        if (this.row.deleted) {
            return;
        }
        /** @type {?} */
        var cell = this.crudService.createCell(this);
        /** @type {?} */
        var args = this.gridAPI.update_cell(cell, val);
        if (this.crudService.cell && this.crudService.sameCell(cell)) {
            if (args.cancel) {
                return;
            }
            this.gridAPI.escape_editMode();
        }
        this.cdr.markForCheck();
    };
    /**
     * @hidden
     * @internal
     */
    /**
     * @hidden
     * \@internal
     * @param {?} event
     * @return {?}
     */
    IgxGridCellComponent.prototype.onDoubleClick = /**
     * @hidden
     * \@internal
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.editable && !this.editMode && !this.row.deleted) {
            this.crudService.begin(this);
        }
        this.grid.onDoubleClick.emit({
            cell: this,
            event: event
        });
    };
    /**
     * @hidden
     * @internal
     */
    /**
     * @hidden
     * \@internal
     * @param {?} event
     * @return {?}
     */
    IgxGridCellComponent.prototype.onClick = /**
     * @hidden
     * \@internal
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.grid.onCellClick.emit({
            cell: this,
            event: event
        });
    };
    /**
     * @hidden
     * @internal
     */
    /**
     * @hidden
     * \@internal
     * @param {?} event
     * @return {?}
     */
    IgxGridCellComponent.prototype.onContextMenu = /**
     * @hidden
     * \@internal
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.grid.onContextMenu.emit({
            cell: this,
            event: event
        });
    };
    /**
     * @hidden
     * @internal
     */
    /**
     * @hidden
     * \@internal
     * @param {?} event
     * @return {?}
     */
    IgxGridCellComponent.prototype.onFocus = /**
     * @hidden
     * \@internal
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.focused = true;
        this.row.focused = true;
        this._updateCellSelectionStatus();
        if (!this.selectionService.isActiveNode(this.selectionNode)) {
            this.grid.onSelection.emit({ cell: this, event: event });
        }
        this.selectionService.activeElement = this.selectionNode;
    };
    /**
     * @hidden
     * @internal
     */
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    IgxGridCellComponent.prototype.onBlur = /**
     * @hidden
     * \@internal
     * @return {?}
     */
    function () {
        this.focused = false;
        this.row.focused = false;
    };
    /**
     * @protected
     * @param {?} key
     * @param {?} event
     * @return {?}
     */
    IgxGridCellComponent.prototype.handleAlt = /**
     * @protected
     * @param {?} key
     * @param {?} event
     * @return {?}
     */
    function (key, event) {
        if (this.row.nativeElement.tagName.toLowerCase() === 'igx-tree-grid-row' && this.isToggleKey(key)) {
            /** @type {?} */
            var collapse = ((/** @type {?} */ (this.row))).expanded && ROW_COLLAPSE_KEYS.has(key);
            /** @type {?} */
            var expand = !((/** @type {?} */ (this.row))).expanded && ROW_EXPAND_KEYS.has(key);
            if (collapse) {
                ((/** @type {?} */ (this.gridAPI))).trigger_row_expansion_toggle(this.row.treeRow, !this.row.expanded, event, this.visibleColumnIndex);
            }
            else if (expand) {
                ((/** @type {?} */ (this.gridAPI))).trigger_row_expansion_toggle(this.row.treeRow, !this.row.expanded, event, this.visibleColumnIndex);
            }
        }
    };
    /**
     * @protected
     * @param {?} shift
     * @return {?}
     */
    IgxGridCellComponent.prototype.handleTab = /**
     * @protected
     * @param {?} shift
     * @return {?}
     */
    function (shift) {
        if (shift) {
            this.grid.navigation.performShiftTabKey(this.row.nativeElement, this.rowIndex, this.visibleColumnIndex);
        }
        else {
            this.grid.navigation.performTab(this.row.nativeElement, this.rowIndex, this.visibleColumnIndex);
        }
    };
    /**
     * @protected
     * @param {?} ctrl
     * @return {?}
     */
    IgxGridCellComponent.prototype.handleEnd = /**
     * @protected
     * @param {?} ctrl
     * @return {?}
     */
    function (ctrl) {
        if (ctrl) {
            this.grid.navigation.goToLastCell();
        }
        else {
            this.grid.navigation.onKeydownEnd(this.rowIndex);
        }
    };
    /**
     * @protected
     * @param {?} ctrl
     * @return {?}
     */
    IgxGridCellComponent.prototype.handleHome = /**
     * @protected
     * @param {?} ctrl
     * @return {?}
     */
    function (ctrl) {
        if (ctrl) {
            this.grid.navigation.goToFirstCell();
        }
        else {
            this.grid.navigation.onKeydownHome(this.rowIndex);
        }
    };
    // TODO: Refactor
    /**
     *
     * @hidden
     * @internal
     */
    // TODO: Refactor
    /**
     *
     * @hidden
     * \@internal
     * @param {?} event
     * @return {?}
     */
    IgxGridCellComponent.prototype.dispatchEvent = 
    // TODO: Refactor
    /**
     *
     * @hidden
     * \@internal
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var key = event.key.toLowerCase();
        /** @type {?} */
        var shift = event.shiftKey;
        /** @type {?} */
        var ctrl = event.ctrlKey;
        /** @type {?} */
        var node = this.selectionNode;
        if (!SUPPORTED_KEYS.has(key)) {
            return;
        }
        event.stopPropagation();
        /** @type {?} */
        var keydownArgs = { targetType: 'dataCell', target: this, event: event, cancel: false };
        this.grid.onGridKeydown.emit(keydownArgs);
        if (keydownArgs.cancel) {
            this.selectionService.keyboardStateOnKeydown(node, shift, shift && key === 'tab');
            return;
        }
        if (event.altKey) {
            event.preventDefault();
            this.handleAlt(key, event);
            return;
        }
        this.selectionService.keyboardStateOnKeydown(node, shift, shift && key === 'tab');
        if (key === 'tab') {
            event.preventDefault();
        }
        if (this.editMode) {
            if (NAVIGATION_KEYS.has(key)) {
                if (this.column.inlineEditorTemplate) {
                    return;
                }
                if (['date', 'boolean'].indexOf(this.column.dataType) > -1) {
                    return;
                }
                return;
            }
        }
        if (NAVIGATION_KEYS.has(key)) {
            event.preventDefault();
        }
        // TODO: to be deleted when onFocusChange event is removed #4054
        /** @type {?} */
        var args = { cell: this, groupRow: null, event: event, cancel: false };
        this.grid.onFocusChange.emit(args);
        if (args.cancel) {
            return;
        }
        switch (key) {
            case 'tab':
                this.handleTab(shift);
                break;
            case 'end':
                this.handleEnd(ctrl);
                break;
            case 'home':
                this.handleHome(ctrl);
                break;
            case 'arrowleft':
            case 'left':
                if (ctrl) {
                    this.grid.navigation.onKeydownHome(node.row);
                    break;
                }
                this.grid.navigation.onKeydownArrowLeft(this.nativeElement, node.row, node.column);
                break;
            case 'arrowright':
            case 'right':
                if (ctrl) {
                    this.grid.navigation.onKeydownEnd(node.row);
                    break;
                }
                this.grid.navigation.onKeydownArrowRight(this.nativeElement, node.row, node.column);
                break;
            case 'arrowup':
            case 'up':
                if (ctrl) {
                    this.grid.navigation.navigateTop(node.column);
                    break;
                }
                this.grid.navigation.navigateUp(this.row.nativeElement, node.row, node.column);
                break;
            case 'arrowdown':
            case 'down':
                if (ctrl) {
                    this.grid.navigation.navigateBottom(node.column);
                    break;
                }
                this.grid.navigation.navigateDown(this.row.nativeElement, node.row, node.column);
                break;
            case 'enter':
            case 'f2':
                this.onKeydownEnterEditMode();
                break;
            case 'escape':
            case 'esc':
                this.onKeydownExitEditMode();
                break;
            case ' ':
            case 'spacebar':
            case 'space':
                if (this.row.rowSelectable) {
                    this.row.checkboxElement.toggle();
                }
                break;
            default:
                return;
        }
    };
    /**
     * @hidden
     * @internal
     */
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    IgxGridCellComponent.prototype.onKeydownEnterEditMode = /**
     * @hidden
     * \@internal
     * @return {?}
     */
    function () {
        if (this.isInCompositionMode) {
            return;
        }
        if (this.column.editable && !this.row.deleted) {
            if (this.editMode) {
                this.grid.endEdit(true);
                this.nativeElement.focus();
            }
            else {
                this.crudService.begin(this);
            }
        }
    };
    /**
     * @hidden
     * @internal
     */
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    IgxGridCellComponent.prototype.onKeydownExitEditMode = /**
     * @hidden
     * \@internal
     * @return {?}
     */
    function () {
        if (this.isInCompositionMode) {
            return;
        }
        if (this.editMode) {
            /** @type {?} */
            var v = this.crudService.cell;
            /** @type {?} */
            var args = (/** @type {?} */ ({
                cellID: v.id,
                rowID: v.id.rowID,
                oldValue: v.value,
                newValue: v.editValue,
                cancel: false
            }));
            this.grid.onCellEditCancel.emit(args);
            if (args.cancel) {
                return;
            }
            this.grid.endEdit(false);
            this.nativeElement.focus();
        }
    };
    /**
     * If the provided string matches the text in the cell, the text gets highlighted.
     * ```typescript
     * this.cell.highlightText('Cell Value', true);
     * ```
     * @memberof IgxGridCellComponent
     */
    /**
     * If the provided string matches the text in the cell, the text gets highlighted.
     * ```typescript
     * this.cell.highlightText('Cell Value', true);
     * ```
     * \@memberof IgxGridCellComponent
     * @param {?} text
     * @param {?=} caseSensitive
     * @param {?=} exactMatch
     * @return {?}
     */
    IgxGridCellComponent.prototype.highlightText = /**
     * If the provided string matches the text in the cell, the text gets highlighted.
     * ```typescript
     * this.cell.highlightText('Cell Value', true);
     * ```
     * \@memberof IgxGridCellComponent
     * @param {?} text
     * @param {?=} caseSensitive
     * @param {?=} exactMatch
     * @return {?}
     */
    function (text, caseSensitive, exactMatch) {
        return this.highlight && this.column.searchable ? this.highlight.highlight(text, caseSensitive, exactMatch) : 0;
    };
    /**
     * Clears the highlight of the text in the cell.
     * ```typescript
     * this.cell.clearHighLight();
     * ```
     * @memberof IgxGridCellComponent
     */
    /**
     * Clears the highlight of the text in the cell.
     * ```typescript
     * this.cell.clearHighLight();
     * ```
     * \@memberof IgxGridCellComponent
     * @return {?}
     */
    IgxGridCellComponent.prototype.clearHighlight = /**
     * Clears the highlight of the text in the cell.
     * ```typescript
     * this.cell.clearHighLight();
     * ```
     * \@memberof IgxGridCellComponent
     * @return {?}
     */
    function () {
        if (this.highlight && this.column.searchable) {
            this.highlight.clearHighlight();
        }
    };
    /**
     * @hidden
     * @internal
     */
    /**
     * @hidden
     * \@internal
     * @param {?} range
     * @return {?}
     */
    IgxGridCellComponent.prototype.calculateSizeToFit = /**
     * @hidden
     * \@internal
     * @param {?} range
     * @return {?}
     */
    function (range) {
        return Math.max.apply(Math, __spread(Array.from(this.nativeElement.children)
            .map(function (child) { return getNodeSizeViaRange(range, child); })));
    };
    /**
     * @private
     * @param {?} key
     * @return {?}
     */
    IgxGridCellComponent.prototype.isToggleKey = /**
     * @private
     * @param {?} key
     * @return {?}
     */
    function (key) {
        return ROW_COLLAPSE_KEYS.has(key) || ROW_EXPAND_KEYS.has(key);
    };
    IgxGridCellComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'igx-grid-cell',
                    template: "<ng-template #defaultCell>\n    <div igxTextHighlight [cssClass]=\"highlightClass\" [activeCssClass]=\"activeHighlightClass\" [groupName]=\"gridID\"\n        [value]=\"formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal: grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value\"\n        [row]=\"rowData\" [column]=\"this.column.field\" [containerClass]=\"'igx-grid__td-text'\"\n        class=\"igx-grid__td-text\">{{ formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal:\n        grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value }}</div>\n</ng-template>\n<ng-template #inlineEditor let-cell=\"cell\">\n    <ng-container *ngIf=\"column.dataType === 'string'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [value]=\"editValue\" (input)=\"editValue = $event.target.value\" [igxFocus]=\"focused\" />\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'number'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [value]=\"editValue\" (input)=\"editValue = $event.target.value\" [igxFocus]=\"focused\" type=\"number\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'boolean'\">\n        <igx-checkbox (change)=\"editValue = $event.checked\" [value]=\"editValue\" [checked]=\"editValue\"\n            [igxFocus]=\"focused\" [disableRipple]=\"true\"></igx-checkbox>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'date'\">\n        <igx-date-picker [style.width.%]=\"100\" [outlet]=\"grid.outletDirective\" mode=\"dropdown\" (onSelection)=\"editValue = $event\"\n            [locale]=\"grid.locale\" [value]=\"editValue\" [igxFocus]=\"focused\" [labelVisibility]=\"false\">\n        </igx-date-picker>\n    </ng-container>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"template; context: context\">\n</ng-container>\n"
                }] }
    ];
    /** @nocollapse */
    IgxGridCellComponent.ctorParameters = function () { return [
        { type: IgxGridSelectionService },
        { type: IgxGridCRUDService },
        { type: GridBaseAPIService },
        { type: IgxSelectionAPIService },
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
    IgxGridCellComponent.propDecorators = {
        column: [{ type: Input }],
        row: [{ type: Input }],
        rowData: [{ type: Input }],
        cellTemplate: [{ type: Input }],
        value: [{ type: Input }],
        formatter: [{ type: Input }],
        rowIndex: [{ type: HostBinding, args: ['attr.data-rowIndex',] }],
        visibleColumnIndex: [{ type: HostBinding, args: ['attr.data-visibleIndex',] }, { type: Input }],
        lastPinned: [{ type: Input }, { type: HostBinding, args: ['class.igx-grid__td--pinned-last',] }],
        editMode: [{ type: Input }, { type: HostBinding, args: ['class.igx-grid__td--editing',] }],
        tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
        role: [{ type: HostBinding, args: ['attr.role',] }],
        readonly: [{ type: HostBinding, args: ['attr.aria-readonly',] }],
        gridRowSpan: [{ type: HostBinding, args: ['style.-ms-grid-row-span',] }],
        gridColumnSpan: [{ type: HostBinding, args: ['style.-ms-grid-column-span',] }],
        rowEnd: [{ type: HostBinding, args: ['style.grid-row-end',] }],
        colEnd: [{ type: HostBinding, args: ['style.grid-column-end',] }],
        rowStart: [{ type: HostBinding, args: ['style.-ms-grid-row',] }, { type: HostBinding, args: ['style.grid-row-start',] }],
        colStart: [{ type: HostBinding, args: ['style.-ms-grid-column',] }, { type: HostBinding, args: ['style.grid-column-start',] }],
        describedby: [{ type: HostBinding, args: ['attr.aria-describedby',] }],
        width: [{ type: HostBinding, args: ['style.min-width',] }, { type: HostBinding, args: ['style.max-width',] }, { type: HostBinding, args: ['style.flex-basis',] }, { type: Input }],
        selected: [{ type: HostBinding, args: ['attr.aria-selected',] }, { type: HostBinding, args: ['class.igx-grid__td--selected',] }],
        dirty: [{ type: HostBinding, args: ['class.igx-grid__td--edited',] }],
        focused: [{ type: HostBinding, args: ['class.igx-grid__td--active',] }],
        defaultCellTemplate: [{ type: ViewChild, args: ['defaultCell', { read: TemplateRef },] }],
        inlineEditorTemplate: [{ type: ViewChild, args: ['inlineEditor', { read: TemplateRef },] }],
        highlight: [{ type: ViewChild, args: [IgxTextHighlightDirective, { read: IgxTextHighlightDirective },] }],
        onDoubleClick: [{ type: HostListener, args: ['dblclick', ['$event'],] }],
        onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
        onContextMenu: [{ type: HostListener, args: ['contextmenu', ['$event'],] }],
        onFocus: [{ type: HostListener, args: ['focus', ['$event'],] }],
        onBlur: [{ type: HostListener, args: ['blur',] }],
        dispatchEvent: [{ type: HostListener, args: ['keydown', ['$event'],] }]
    };
    __decorate([
        DeprecateProperty("'inEditMode' is deprecated\nUse 'editMode' to get the current state and 'setEditMode(boolean)' as a setter"),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], IgxGridCellComponent.prototype, "inEditMode", null);
    return IgxGridCellComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 * @abstract
 */
var ItemPropertyValueChanged = /** @class */ (function () {
    function ItemPropertyValueChanged(propName) {
        this.valueChanged = new EventEmitter();
        this._propName = propName;
    }
    Object.defineProperty(ItemPropertyValueChanged.prototype, "object", {
        get: /**
         * @return {?}
         */
        function () {
            return this._object;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value) {
                this._object = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ItemPropertyValueChanged.prototype, "value", {
        get: /**
         * @return {?}
         */
        function () {
            return (this.object) ? this.object[this._propName] : null;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.onValueChanged(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    ItemPropertyValueChanged.prototype.onValueChanged = /**
     * @protected
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var currentValue = this.value;
        if (value !== currentValue) {
            this.object[this._propName] = value;
            this.valueChanged.emit({ oldValue: currentValue, newValue: value });
        }
    };
    ItemPropertyValueChanged.propDecorators = {
        value: [{ type: Input }],
        valueChanged: [{ type: Output }]
    };
    return ItemPropertyValueChanged;
}());
/**
 * @hidden
 */
var ColumnChooserItemBase = /** @class */ (function (_super) {
    __extends(ColumnChooserItemBase, _super);
    function ColumnChooserItemBase(prop) {
        var _this = _super.call(this, prop) || this;
        _this.prop = prop;
        _this.indentation = 30;
        return _this;
    }
    Object.defineProperty(ColumnChooserItemBase.prototype, "column", {
        get: /**
         * @return {?}
         */
        function () {
            return this.object;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value) {
                this.object = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColumnChooserItemBase.prototype, "name", {
        get: /**
         * @return {?}
         */
        function () {
            return (this.column) ? ((this.column.header) ? this.column.header : this.column.field) : '';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColumnChooserItemBase.prototype, "level", {
        get: /**
         * @return {?}
         */
        function () {
            return this.column.level;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColumnChooserItemBase.prototype, "calcIndent", {
        get: /**
         * @return {?}
         */
        function () {
            return this.indentation * this.level;
        },
        enumerable: true,
        configurable: true
    });
    ColumnChooserItemBase.propDecorators = {
        column: [{ type: Input }],
        indentation: [{ type: Input }],
        container: [{ type: Input }]
    };
    return ColumnChooserItemBase;
}(ItemPropertyValueChanged));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxColumnHidingItemDirective = /** @class */ (function (_super) {
    __extends(IgxColumnHidingItemDirective, _super);
    function IgxColumnHidingItemDirective() {
        return _super.call(this, 'hidden') || this;
    }
    Object.defineProperty(IgxColumnHidingItemDirective.prototype, "disabled", {
        get: /**
         * @return {?}
         */
        function () {
            return this.column.disableHiding;
        },
        enumerable: true,
        configurable: true
    });
    IgxColumnHidingItemDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxColumnHidingItem]'
                },] }
    ];
    /** @nocollapse */
    IgxColumnHidingItemDirective.ctorParameters = function () { return []; };
    return IgxColumnHidingItemDirective;
}(ColumnChooserItemBase));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var ColumnDisplayOrder = {
    Alphabetical: 'Alphabetical',
    DisplayOrder: 'DisplayOrder',
};
var CustomFilteringStrategy = /** @class */ (function (_super) {
    __extends(CustomFilteringStrategy, _super);
    function CustomFilteringStrategy() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {?} data
     * @param {?} expressionsTree
     * @return {?}
     */
    CustomFilteringStrategy.prototype.filter = /**
     * @param {?} data
     * @param {?} expressionsTree
     * @return {?}
     */
    function (data, expressionsTree) {
        var _this = this;
        /** @type {?} */
        var res = [];
        data.forEach(function (item) {
            if (_this.matchRecord(item, (/** @type {?} */ (expressionsTree.filteringOperands[0])))) {
                res.push(item);
            }
            else if (item.column.columnGroup) {
                if (item.column.allChildren.findIndex(function (child) {
                    return _this.matchRecord(child, (/** @type {?} */ (expressionsTree.filteringOperands[1]))) ||
                        _this.matchRecord(child, (/** @type {?} */ (expressionsTree.filteringOperands[2])));
                }) > -1) {
                    res.push(item);
                }
            }
        });
        return res;
    };
    return CustomFilteringStrategy;
}(FilteringStrategy));
/**
 * @hidden
 * @abstract
 */
var ColumnChooserBase = /** @class */ (function () {
    function ColumnChooserBase(cdr) {
        this.cdr = cdr;
        /**
         * Hides/ shows the filtering columns input from the UI.
         */
        this.disableFilter = false;
        /**
         * Access to the columnHidingUI:
         * ```typescript
         * \@ViewChild('column-hiding-component')
         *  public columnHidingUI: IgxColumnHidingComponent;
         * ```
         * Sets/gets the max height of the column area.
         * ```typescript
         * let columnsAreaMaxHeight =  this.columnHidingUI.columnsAreaMaxHeight;
         * ```
         *
         * ```html
         * <igx-column-hiding [columnsAreaMaxHeight]="200px"></igx-column-hiding>
         * ```
         * \@memberof ColumnChooserBase
         */
        this.columnsAreaMaxHeight = '100%';
        /**
         * Sets/Gets the css class selector.
         * By default the value of the `class` attribute is `"igx-column-hiding"`.
         * ```typescript
         * let cssCLass =  this.columnHidingUI.cssClass;
         * ```
         * ```typescript
         * this.columnHidingUI.cssClass = 'column-chooser';
         * ```
         * \@memberof ColumnChooserBase
         */
        this.cssClass = 'igx-column-hiding';
        /**
         * @hidden
         */
        this._currentColumns = [];
        /**
         * @hidden
         */
        this._gridColumns = [];
        /**
         * @hidden
         */
        this._rawColumns = [];
        /**
         * @hidden
         */
        this._columnDisplayOrder = ColumnDisplayOrder.DisplayOrder;
        /**
         * @hidden
         */
        this._filterCriteria = '';
        /**
         * @hidden
         */
        this._filterColumnsPrompt = '';
        /**
         * @hidden
         */
        this._title = '';
    }
    Object.defineProperty(ColumnChooserBase.prototype, "columns", {
        /**
         * Gets the grid columns that are going to be manipulated.
         * ```typescript
         * let gridColumns = this.columnHidingUI.columns;
         * ```
         * @memberof ColumnChooserBase
         */
        get: /**
         * Gets the grid columns that are going to be manipulated.
         * ```typescript
         * let gridColumns = this.columnHidingUI.columns;
         * ```
         * \@memberof ColumnChooserBase
         * @return {?}
         */
        function () {
            return this._gridColumns;
        },
        /**
         * Sets the the grid columns that are going to be manipulated.
         * ```html
         * <igx-column-hiding [columns]="grid.columns"></igx-column-hiding>
         * ```
         * @memberof ColumnChooserBase
         */
        set: /**
         * Sets the the grid columns that are going to be manipulated.
         * ```html
         * <igx-column-hiding [columns]="grid.columns"></igx-column-hiding>
         * ```
         * \@memberof ColumnChooserBase
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value) {
                this._gridColumns = value;
                this.createColumnItems();
                if (this.filterCriteria) {
                    this.filter();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColumnChooserBase.prototype, "title", {
        /**
         * Sets/gets the title of the column chooser.
         * ```typescript
         * let title =  this.columnHidingUI.title;
         * ```
         * @memberof ColumnChooserBase
         */
        get: /**
         * Sets/gets the title of the column chooser.
         * ```typescript
         * let title =  this.columnHidingUI.title;
         * ```
         * \@memberof ColumnChooserBase
         * @return {?}
         */
        function () {
            return this._title;
        },
        /**
         * ```html
         * <igx-column-hiding [title]="'IgxColumnHidingComponent Title'"></igx-column-hiding>
         * ```
         * @memberof ColumnChooserBase
         */
        set: /**
         * ```html
         * <igx-column-hiding [title]="'IgxColumnHidingComponent Title'"></igx-column-hiding>
         * ```
         * \@memberof ColumnChooserBase
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._title = (value) ? value : '';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColumnChooserBase.prototype, "filterColumnsPrompt", {
        /**
         * Gets the prompt that is displayed in the filter input.
         * ```typescript
         * let filterColumnsPrompt =  this.columnHidingUI.filterColumnsPrompt;
         * ```
         * @memberof ColumnChooserBase
         */
        get: /**
         * Gets the prompt that is displayed in the filter input.
         * ```typescript
         * let filterColumnsPrompt =  this.columnHidingUI.filterColumnsPrompt;
         * ```
         * \@memberof ColumnChooserBase
         * @return {?}
         */
        function () {
            return this._filterColumnsPrompt;
        },
        /**
         * Sets the prompt that is going to be displayed in the filter input.
         * ```html
         * <igx-column-hiding [filterColumnsPrompt]="'Type here to search'"></igx-column-hiding>
         * ```
         * @memberof ColumnChooserBase
         */
        set: /**
         * Sets the prompt that is going to be displayed in the filter input.
         * ```html
         * <igx-column-hiding [filterColumnsPrompt]="'Type here to search'"></igx-column-hiding>
         * ```
         * \@memberof ColumnChooserBase
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._filterColumnsPrompt = (value) ? value : '';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColumnChooserBase.prototype, "columnItems", {
        /**
         * Gets the items of the selected columns.
         * ```typescript
         * let columnItems =  this.columnHidingUI.columnItems;
         * ```
         * @memberof ColumnChooserBase
         */
        get: /**
         * Gets the items of the selected columns.
         * ```typescript
         * let columnItems =  this.columnHidingUI.columnItems;
         * ```
         * \@memberof ColumnChooserBase
         * @return {?}
         */
        function () {
            return this._currentColumns;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColumnChooserBase.prototype, "filterCriteria", {
        /**
         * Gets the value which filters the columns list.
         * ```typescript
         * let filterCriteria =  this.columnHidingUI.filterCriteria;
         * ```
         * @memberof ColumnChooserBase
         */
        get: /**
         * Gets the value which filters the columns list.
         * ```typescript
         * let filterCriteria =  this.columnHidingUI.filterCriteria;
         * ```
         * \@memberof ColumnChooserBase
         * @return {?}
         */
        function () {
            return this._filterCriteria;
        },
        /**
         * Sets the value which filters the columns list.
         * ```html
         *  <igx-column-hiding [filterCriteria]="'ID'"></igx-column-hiding>
         * ```
         * @memberof ColumnChooserBase
         */
        set: /**
         * Sets the value which filters the columns list.
         * ```html
         *  <igx-column-hiding [filterCriteria]="'ID'"></igx-column-hiding>
         * ```
         * \@memberof ColumnChooserBase
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (!value || value.length === 0) {
                this.clearFiltering();
                this._filterCriteria = '';
                this.cdr.detectChanges();
                return;
            }
            else if (this._filterCriteria && this._filterCriteria.length > value.length) {
                this.clearFiltering();
            }
            this._filterCriteria = value;
            this.filter();
            this.cdr.detectChanges();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColumnChooserBase.prototype, "columnDisplayOrder", {
        /**
         * Gets the display order of the columns.
         * ```typescript
         * let columnDisplayOrder  =  this.columnHidingUI.columnDisplayOrder;
         * ```
         * @memberof ColumnChooserBase
         */
        get: /**
         * Gets the display order of the columns.
         * ```typescript
         * let columnDisplayOrder  =  this.columnHidingUI.columnDisplayOrder;
         * ```
         * \@memberof ColumnChooserBase
         * @return {?}
         */
        function () {
            return this._columnDisplayOrder;
        },
        /**
         * Sets the display order of the columns.
         * ```typescript
         * this.columnHidingUI.columnDisplayOrder = ColumnDisplayOrder.Alphabetical;
         * ```
         * @memberof ColumnChooserBase
         */
        set: /**
         * Sets the display order of the columns.
         * ```typescript
         * this.columnHidingUI.columnDisplayOrder = ColumnDisplayOrder.Alphabetical;
         * ```
         * \@memberof ColumnChooserBase
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value !== undefined) {
                this.orderColumns(value);
                if (this._filterCriteria.length > 0) {
                    this.filter();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    ColumnChooserBase.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        var e_1, _a;
        try {
            for (var _b = __values(this._currentColumns), _c = _b.next(); !_c.done; _c = _b.next()) {
                var item = _c.value;
                item.valueChanged.unsubscribe();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @private
     * @return {?}
     */
    ColumnChooserBase.prototype.createColumnItems = /**
     * @hidden
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._gridColumns.length > 0) {
            this._rawColumns = [];
            this._gridColumns.forEach(function (column) {
                /** @type {?} */
                var item = _this.createColumnItem(_this, column);
                if (item) {
                    _this._rawColumns.push(item);
                }
            });
            this._currentColumns = this._rawColumns.slice(0);
            this.orderColumns(this._columnDisplayOrder);
        }
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @private
     * @param {?} value
     * @return {?}
     */
    ColumnChooserBase.prototype.orderColumns = /**
     * @hidden
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this._columnDisplayOrder = value;
        if (value === ColumnDisplayOrder[ColumnDisplayOrder.Alphabetical] ||
            value === ColumnDisplayOrder.Alphabetical) {
            this._currentColumns = this._rawColumns.slice(0).sort(function (current, next) {
                return current.name.toLowerCase().localeCompare(next.name.toLowerCase());
            });
        }
        else {
            this._currentColumns = this._rawColumns;
        }
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    ColumnChooserBase.prototype.filter = /**
     * @hidden
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var filteringExpressionsTree = new FilteringExpressionsTree(FilteringLogic.Or);
        filteringExpressionsTree.filteringOperands.push(this.createFilteringExpression('name'));
        filteringExpressionsTree.filteringOperands.push(this.createFilteringExpression('field'));
        filteringExpressionsTree.filteringOperands.push(this.createFilteringExpression('header'));
        /** @type {?} */
        var strategy = new CustomFilteringStrategy();
        this._currentColumns = strategy.filter(this._currentColumns, filteringExpressionsTree);
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} fieldName
     * @return {?}
     */
    ColumnChooserBase.prototype.createFilteringExpression = /**
     * @hidden
     * @protected
     * @param {?} fieldName
     * @return {?}
     */
    function (fieldName) {
        return {
            condition: IgxStringFilteringOperand.instance().condition('contains'),
            fieldName: fieldName,
            ignoreCase: true,
            searchVal: this._filterCriteria
        };
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    ColumnChooserBase.prototype.clearFiltering = /**
     * @hidden
     * @protected
     * @return {?}
     */
    function () {
        this.createColumnItems();
    };
    ColumnChooserBase.propDecorators = {
        columns: [{ type: Input }],
        title: [{ type: Input }],
        filterColumnsPrompt: [{ type: Input }],
        disableFilter: [{ type: Input }],
        columnItems: [{ type: Input }],
        filterCriteria: [{ type: Input }],
        columnDisplayOrder: [{ type: Input }],
        columnsAreaMaxHeight: [{ type: Input }],
        cssClass: [{ type: HostBinding, args: ['attr.class',] }]
    };
    return ColumnChooserBase;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxColumnHidingComponent = /** @class */ (function (_super) {
    __extends(IgxColumnHidingComponent, _super);
    function IgxColumnHidingComponent(cdr) {
        var _this = _super.call(this, cdr) || this;
        _this.cdr = cdr;
        /**
         * Sets/gets the text of the button that shows all columns if they are hidden.
         * ```typescript
         * let showAllButtonText =  this.columnHiding.showAllText;
         * ```
         *
         * ```html
         * <igx-column-hiding [showAllText] = "'Show Columns'"></igx-column-hiding>
         * ```
         * \@memberof IgxColumnHidingComponent
         */
        _this.showAllText = 'Show All';
        /**
         * Sets/gets the text of the button that hides all columns if they are shown.
         * ```typescript
         * let hideAllButtonText =  this.columnHiding.hideAllText;
         * ```
         *
         * ```html
         * <igx-column-hiding [hideAllText] = "'Hide Columns'"></igx-column-hiding>
         * ```
         * \@memberof IgxColumnHidingComponent
         */
        _this.hideAllText = 'Hide All';
        /**
         * An event that is emitted after the columns visibility is changed.
         * Provides references to the `column` and the `newValue` properties as event arguments.
         * ```html
         *  <igx-column-hiding (onColumnVisibilityChanged) = "onColumnVisibilityChanged($event)"></igx-column-hiding>
         * ```
         * \@memberof IgxColumnHidingComponent
         */
        _this.onColumnVisibilityChanged = new EventEmitter();
        _this.destroy$ = new Subject();
        return _this;
    }
    Object.defineProperty(IgxColumnHidingComponent.prototype, "disableHideAll", {
        /**
         * Returns a boolean indicating whether the `HIDE ALL` button is disabled.
         * ```html
         * <igx-column-hiding #columnHidingUI
         *     [columns]="grid.columns" [title]="'Column Hiding'">
         * </igx-column-hiding>
         * ```
         * ```typescript
         * @ViewChild("'columnHidingUI'")
         * public columnHiding: IgxColumnHidingComponent;
         * let isHideAlldisabled =  this.columnHiding.disableHideAll;
         * ```
         *@memberof IgxColumnHidingComponent
         */
        get: /**
         * Returns a boolean indicating whether the `HIDE ALL` button is disabled.
         * ```html
         * <igx-column-hiding #columnHidingUI
         *     [columns]="grid.columns" [title]="'Column Hiding'">
         * </igx-column-hiding>
         * ```
         * ```typescript
         * \@ViewChild("'columnHidingUI'")
         * public columnHiding: IgxColumnHidingComponent;
         * let isHideAlldisabled =  this.columnHiding.disableHideAll;
         * ```
         * \@memberof IgxColumnHidingComponent
         * @return {?}
         */
        function () {
            if (!this.columnItems || this.columnItems.length < 1 ||
                this.hiddenColumnsCount === this.columns.length) {
                return true;
            }
            else if (this.hidableColumns.length < 1 ||
                this.hidableColumns.length === this.hidableColumns.filter(function (col) { return col.value; }).length) {
                return true;
            }
            else {
                return false;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnHidingComponent.prototype, "disableShowAll", {
        /**
         * Returns a boolean indicating whether the `SHOW ALL` button is disabled.
         * ```typescript
         * let isShowAlldisabled =  this.columnHiding.disableShowAll;
         * ```
         * @memberof IgxColumnHidingComponent
         */
        get: /**
         * Returns a boolean indicating whether the `SHOW ALL` button is disabled.
         * ```typescript
         * let isShowAlldisabled =  this.columnHiding.disableShowAll;
         * ```
         * \@memberof IgxColumnHidingComponent
         * @return {?}
         */
        function () {
            if (!this.columnItems || this.columnItems.length < 1 ||
                this.hiddenColumnsCount < 1 || this.hidableColumns.length < 1) {
                return true;
            }
            else if (this.hidableColumns.length === this.hidableColumns.filter(function (col) { return !col.value; }).length) {
                return true;
            }
            else {
                return false;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnHidingComponent.prototype, "hiddenColumnsCount", {
        /**
         * Gets the count of the hidden columns.
         * ```typescript
         * let hiddenColumnsCount =  this.columnHiding.hiddenColumnsCount;
         * ```
         * @memberof IgxColumnHidingComponent
         */
        get: /**
         * Gets the count of the hidden columns.
         * ```typescript
         * let hiddenColumnsCount =  this.columnHiding.hiddenColumnsCount;
         * ```
         * \@memberof IgxColumnHidingComponent
         * @return {?}
         */
        function () {
            return (this.columns) ? this.columns.filter(function (col) { return col.hidden; }).length : 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxColumnHidingComponent.prototype, "hidableColumns", {
        /**
         *@hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.columnItems.filter(function (col) { return !col.disabled; });
        },
        enumerable: true,
        configurable: true
    });
    /**
     *@hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} container
     * @param {?} column
     * @return {?}
     */
    IgxColumnHidingComponent.prototype.createColumnItem = /**
     * @hidden
     * @protected
     * @param {?} container
     * @param {?} column
     * @return {?}
     */
    function (container, column) {
        var _this = this;
        if (column.grid.hasColumnLayouts && !column.columnLayout) {
            return null;
        }
        /** @type {?} */
        var item = new IgxColumnHidingItemDirective();
        item.container = container;
        item.column = column;
        item.valueChanged.pipe(takeUntil(this.destroy$)).subscribe(function (args) {
            _this.onVisibilityChanged({ column: item.column, newValue: args.newValue });
        });
        return item;
    };
    /**
     * Shows all columns in the grid.
     * ```typescript
     * this.columnHiding.showAllColumns();
     * ```
     * @memberof IgxColumnHidingComponent
     */
    /**
     * Shows all columns in the grid.
     * ```typescript
     * this.columnHiding.showAllColumns();
     * ```
     * \@memberof IgxColumnHidingComponent
     * @return {?}
     */
    IgxColumnHidingComponent.prototype.showAllColumns = /**
     * Shows all columns in the grid.
     * ```typescript
     * this.columnHiding.showAllColumns();
     * ```
     * \@memberof IgxColumnHidingComponent
     * @return {?}
     */
    function () {
        var e_1, _a;
        try {
            for (var _b = __values(this.hidableColumns), _c = _b.next(); !_c.done; _c = _b.next()) {
                var col = _c.value;
                col.value = false;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * Hides all columns in the grid.
     * ```typescript
     * this.columnHiding.hideAllColumns();
     * ```
     * @memberof IgxColumnHidingComponent
     */
    /**
     * Hides all columns in the grid.
     * ```typescript
     * this.columnHiding.hideAllColumns();
     * ```
     * \@memberof IgxColumnHidingComponent
     * @return {?}
     */
    IgxColumnHidingComponent.prototype.hideAllColumns = /**
     * Hides all columns in the grid.
     * ```typescript
     * this.columnHiding.hideAllColumns();
     * ```
     * \@memberof IgxColumnHidingComponent
     * @return {?}
     */
    function () {
        var e_2, _a;
        try {
            for (var _b = __values(this.hidableColumns), _c = _b.next(); !_c.done; _c = _b.next()) {
                var col = _c.value;
                col.value = true;
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} args
     * @return {?}
     */
    IgxColumnHidingComponent.prototype.onVisibilityChanged = /**
     * @hidden
     * @param {?} args
     * @return {?}
     */
    function (args) {
        this.onColumnVisibilityChanged.emit(args);
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxColumnHidingComponent.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.destroy$.next(true);
        this.destroy$.complete();
    };
    IgxColumnHidingComponent.decorators = [
        { type: Component, args: [{
                    preserveWhitespaces: false,
                    selector: 'igx-column-hiding',
                    template: "<div class=\"igx-column-hiding__header\">\n    <h4 class=\"igx-column-hiding__header-title\" *ngIf=\"title\">{{ title }}</h4>\n\n    <igx-input-group class=\"igx-column-hiding__header-input\" *ngIf=\"!disableFilter\">\n        <input igxInput\n            type=\"text\"\n            [(ngModel)]=\"filterCriteria\"\n            [placeholder]=\"filterColumnsPrompt\"\n            autocomplete=\"off\" />\n    </igx-input-group>\n</div>\n\n<div class=\"igx-column-hiding__columns\"\n    [style.max-height]=\"columnsAreaMaxHeight\">\n    <igx-checkbox\n        *ngFor=\"let columnItem of hidableColumns\"\n        class=\"igx-column-hiding__columns-item\"\n        (onColumnVisibilityChanged)=\"onVisibilityChanged($event)\"\n        (change)=\"columnItem.value = !columnItem.value\"\n        [checked]=\"columnItem.value\"\n        [disabled]=\"columnItem.disabled\"\n        [style.margin-left.px]=\"columnItem.calcIndent\">\n        {{ columnItem.name }}\n    </igx-checkbox>\n</div>\n\n<div class=\"igx-column-hiding__buttons\">\n    <button igxButton igxRipple (click)=\"showAllColumns()\" [disabled]=\"disableShowAll\">{{ showAllText }}</button>\n    <button igxButton igxRipple (click)=\"hideAllColumns()\" [disabled]=\"disableHideAll\">{{ hideAllText }}</button>\n</div>\n"
                }] }
    ];
    /** @nocollapse */
    IgxColumnHidingComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef }
    ]; };
    IgxColumnHidingComponent.propDecorators = {
        disableHideAll: [{ type: Input }],
        disableShowAll: [{ type: Input }],
        showAllText: [{ type: Input }],
        hideAllText: [{ type: Input }],
        onColumnVisibilityChanged: [{ type: Output }]
    };
    return IgxColumnHidingComponent;
}(ColumnChooserBase));
/**
 * @hidden
 */
var IgxColumnHidingModule = /** @class */ (function () {
    function IgxColumnHidingModule() {
    }
    IgxColumnHidingModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxColumnHidingComponent, IgxColumnHidingItemDirective],
                    exports: [IgxColumnHidingComponent],
                    imports: [
                        IgxButtonModule,
                        IgxCheckboxModule,
                        IgxInputGroupModule,
                        CommonModule,
                        FormsModule,
                    ]
                },] }
    ];
    return IgxColumnHidingModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxColumnPinningItemDirective = /** @class */ (function (_super) {
    __extends(IgxColumnPinningItemDirective, _super);
    function IgxColumnPinningItemDirective() {
        return _super.call(this, 'pinned') || this;
    }
    Object.defineProperty(IgxColumnPinningItemDirective.prototype, "pinnable", {
        /**
         * Returns whether a column could be pinned.
         * It's not possible to pin a column if there is not enough space for the unpinned area.
         * ```typescript
         * const columnItem: IgxColumnPinningItemDirective;
         * this.columnItem.pinnable;
         * ```
         */
        get: /**
         * Returns whether a column could be pinned.
         * It's not possible to pin a column if there is not enough space for the unpinned area.
         * ```typescript
         * const columnItem: IgxColumnPinningItemDirective;
         * this.columnItem.pinnable;
         * ```
         * @return {?}
         */
        function () {
            if (this.column.grid.getUnpinnedWidth(true) - this.column.width < this.column.grid.unpinnedAreaMinWidth) {
                return false;
            }
            return true;
        },
        enumerable: true,
        configurable: true
    });
    IgxColumnPinningItemDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxColumnPinningItem]'
                },] }
    ];
    /** @nocollapse */
    IgxColumnPinningItemDirective.ctorParameters = function () { return []; };
    return IgxColumnPinningItemDirective;
}(ColumnChooserItemBase));
var IgxColumnPinningComponent = /** @class */ (function (_super) {
    __extends(IgxColumnPinningComponent, _super);
    function IgxColumnPinningComponent(cdr) {
        var _this = _super.call(this, cdr) || this;
        _this.cdr = cdr;
        return _this;
    }
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} container
     * @param {?} column
     * @return {?}
     */
    IgxColumnPinningComponent.prototype.createColumnItem = /**
     * @hidden
     * @param {?} container
     * @param {?} column
     * @return {?}
     */
    function (container, column) {
        if (column.level !== 0 || column.disablePinning) {
            return null;
        }
        /** @type {?} */
        var item = new IgxColumnPinningItemDirective();
        item.container = container;
        item.column = column;
        return item;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @param {?} columnItem
     * @return {?}
     */
    IgxColumnPinningComponent.prototype.checkboxValueChange = /**
     * @hidden
     * @param {?} event
     * @param {?} columnItem
     * @return {?}
     */
    function (event, columnItem) {
        if (event.checked && !columnItem.pinnable) {
            event.checkbox.checked = false;
            return false;
        }
        columnItem.value = !columnItem.value;
    };
    IgxColumnPinningComponent.decorators = [
        { type: Component, args: [{
                    preserveWhitespaces: false,
                    selector: 'igx-column-pinning',
                    template: "\n<div class=\"igx-column-hiding__header\">\n    <h4 class=\"igx-column-hiding__header-title\" *ngIf=\"title\">{{ title }}</h4>\n\n    <igx-input-group class=\"igx-column-hiding__header-input\" *ngIf=\"!disableFilter\">\n        <input igxInput\n            type=\"text\"\n            [(ngModel)]=\"filterCriteria\"\n            [placeholder]=\"filterColumnsPrompt\"\n            autocomplete=\"off\" />\n    </igx-input-group>\n</div>\n\n<div class=\"igx-column-hiding__columns\"\n    [style.max-height]=\"columnsAreaMaxHeight\">\n    <igx-checkbox igxColumnPinningItem\n        *ngFor=\"let columnItem of columnItems\"\n        class=\"igx-column-hiding__columns-item\"\n        (change)=\"checkboxValueChange($event, columnItem)\"\n        [checked]=\"columnItem.value\">\n        {{ columnItem.name }}\n    </igx-checkbox>\n</div>\n"
                }] }
    ];
    /** @nocollapse */
    IgxColumnPinningComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef }
    ]; };
    return IgxColumnPinningComponent;
}(ColumnChooserBase));
/**
 * @hidden
 */
var IgxColumnPinningModule = /** @class */ (function () {
    function IgxColumnPinningModule() {
    }
    IgxColumnPinningModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxColumnPinningComponent, IgxColumnPinningItemDirective],
                    exports: [IgxColumnPinningComponent],
                    imports: [
                        IgxCheckboxModule,
                        IgxInputGroupModule,
                        CommonModule,
                        FormsModule
                    ]
                },] }
    ];
    return IgxColumnPinningModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * This class encapsulates the Toolbar's logic and is internally used by
 * the `IgxGridComponent`, `IgxTreeGridComponent` and `IgxHierarchicalGridComponent`.
 */
var IgxGridToolbarComponent = /** @class */ (function (_super) {
    __extends(IgxGridToolbarComponent, _super);
    function IgxGridToolbarComponent(gridAPI, cdr, excelExporter, csvExporter, _displayDensityOptions) {
        var _this = _super.call(this, _displayDensityOptions) || this;
        _this.gridAPI = gridAPI;
        _this.cdr = cdr;
        _this.excelExporter = excelExporter;
        _this.csvExporter = csvExporter;
        _this._displayDensityOptions = _displayDensityOptions;
        _this._filterColumnsPrompt = 'Filter columns list ...';
        _this._positionSettings = {
            horizontalDirection: HorizontalAlignment.Left,
            horizontalStartPoint: HorizontalAlignment.Right,
            verticalDirection: VerticalAlignment.Bottom,
            verticalStartPoint: VerticalAlignment.Bottom
        };
        _this._overlaySettings = {
            positionStrategy: new ConnectedPositioningStrategy(_this._positionSettings),
            scrollStrategy: new AbsoluteScrollStrategy(),
            modal: false,
            closeOnOutsideClick: true,
            excludePositionTarget: true
        };
        return _this;
    }
    Object.defineProperty(IgxGridToolbarComponent.prototype, "filterColumnsPrompt", {
        /**
         * Gets the default text shown in the filtering box.
         * ```typescript
         * const filterPrompt = this.grid.toolbar.filterColumnsPrompt;
         * ```
         */
        get: /**
         * Gets the default text shown in the filtering box.
         * ```typescript
         * const filterPrompt = this.grid.toolbar.filterColumnsPrompt;
         * ```
         * @return {?}
         */
        function () {
            return this._filterColumnsPrompt;
        },
        /**
         * Sets the default text shown in the filtering box.
         * ```typescript
         * this.grid.toolbar.filterColumnsPrompt('Filter columns ...');
         * ```
         */
        set: /**
         * Sets the default text shown in the filtering box.
         * ```typescript
         * this.grid.toolbar.filterColumnsPrompt('Filter columns ...');
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._filterColumnsPrompt = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridToolbarComponent.prototype, "defaultDropDownsMaxHeight", {
        /**
         * Gets the height for the `IgxGridToolbarComponent`'s drop down panels.
         * ```typescript
         * const dropdownHeight = this.grid.toolbar.defaultDropDownsMaxHeight;
         * ```
         */
        get: /**
         * Gets the height for the `IgxGridToolbarComponent`'s drop down panels.
         * ```typescript
         * const dropdownHeight = this.grid.toolbar.defaultDropDownsMaxHeight;
         * ```
         * @return {?}
         */
        function () {
            /** @type {?} */
            var gridHeight = this.grid.calcHeight;
            return (gridHeight) ? gridHeight * 0.7 + 'px' : '100%';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridToolbarComponent.prototype, "grid", {
        /**
         * Returns a reference to the `IgxGridComponent` component, hosting the `IgxGridToolbarComponent`.
         * ```typescript
         * const grid = this.igxGrid1.toolbar.grid;
         * ```
         */
        get: /**
         * Returns a reference to the `IgxGridComponent` component, hosting the `IgxGridToolbarComponent`.
         * ```typescript
         * const grid = this.igxGrid1.toolbar.grid;
         * ```
         * @return {?}
         */
        function () {
            return this.gridAPI.grid;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridToolbarComponent.prototype, "shouldShowExportButton", {
        /**
         * Returns whether the `IgxGridComponent` renders an export button.
         * ```typescript
         * const exportButton = this.igxGrid1.toolbar.shouldShowExportButton;
         * ```
         */
        get: /**
         * Returns whether the `IgxGridComponent` renders an export button.
         * ```typescript
         * const exportButton = this.igxGrid1.toolbar.shouldShowExportButton;
         * ```
         * @return {?}
         */
        function () {
            return (this.grid != null && (this.grid.exportExcel || this.grid.exportCsv));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridToolbarComponent.prototype, "shouldShowExportExcelButton", {
        /**
         * Returns whether the `IgxGridComponent` renders an Excel export button.
         * ```typescript
         * const exportExcelButton = this.igxGrid1.toolbar.shouldShowExportExcelButton;
         * ```
         */
        get: /**
         * Returns whether the `IgxGridComponent` renders an Excel export button.
         * ```typescript
         * const exportExcelButton = this.igxGrid1.toolbar.shouldShowExportExcelButton;
         * ```
         * @return {?}
         */
        function () {
            return (this.grid != null && this.grid.exportExcel);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridToolbarComponent.prototype, "shouldShowExportCsvButton", {
        /**
         * Returns whether the `IgxGridComponent` renders an CSV export button.
         * ```typescript
         * const exportCSVButton = this.igxGrid1.toolbar.shouldShowExportCsvButton;
         * ```
         */
        get: /**
         * Returns whether the `IgxGridComponent` renders an CSV export button.
         * ```typescript
         * const exportCSVButton = this.igxGrid1.toolbar.shouldShowExportCsvButton;
         * ```
         * @return {?}
         */
        function () {
            return (this.grid != null && this.grid.exportCsv);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridToolbarComponent.prototype, "pinnedColumnsCount", {
        /**
         * Returns how many columns are pinned.
         * ```typescript
         * const pinnedCount = this.igxGrid1.toolbar.pinnedColumnsCount;
         * ```
         */
        get: /**
         * Returns how many columns are pinned.
         * ```typescript
         * const pinnedCount = this.igxGrid1.toolbar.pinnedColumnsCount;
         * ```
         * @return {?}
         */
        function () {
            return this.grid.pinnedColumns.filter(function (col) { return !col.columnLayout; }).length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridToolbarComponent.prototype, "hostClass", {
        /**
         * Returns the theme of the `IgxGridToolbarComponent`.
         * ```typescript
         * const toolbarTheme = this.grid.toolbar.hostClass;
         * ```
         */
        get: /**
         * Returns the theme of the `IgxGridToolbarComponent`.
         * ```typescript
         * const toolbarTheme = this.grid.toolbar.hostClass;
         * ```
         * @return {?}
         */
        function () {
            return this.getComponentDensityClass('igx-grid-toolbar');
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the title of `IgxGridToolbarComponent`.
     * ```typescript
     * const toolbarTitle = this.igxGrid1.toolbar.getTitle();
     * ```
     */
    /**
     * Returns the title of `IgxGridToolbarComponent`.
     * ```typescript
     * const toolbarTitle = this.igxGrid1.toolbar.getTitle();
     * ```
     * @return {?}
     */
    IgxGridToolbarComponent.prototype.getTitle = /**
     * Returns the title of `IgxGridToolbarComponent`.
     * ```typescript
     * const toolbarTitle = this.igxGrid1.toolbar.getTitle();
     * ```
     * @return {?}
     */
    function () {
        return this.grid != null ? this.grid.toolbarTitle : '';
    };
    /**
     * Returns the text of the export button of the `IgxGridToolbarComponent`.
     * ```typescript
     * const toolbarExportText = this.igxGrid1.toolbar.getTitle();
     * ```
     */
    /**
     * Returns the text of the export button of the `IgxGridToolbarComponent`.
     * ```typescript
     * const toolbarExportText = this.igxGrid1.toolbar.getTitle();
     * ```
     * @return {?}
     */
    IgxGridToolbarComponent.prototype.getExportText = /**
     * Returns the text of the export button of the `IgxGridToolbarComponent`.
     * ```typescript
     * const toolbarExportText = this.igxGrid1.toolbar.getTitle();
     * ```
     * @return {?}
     */
    function () {
        return this.grid != null ? this.grid.exportText : '';
    };
    /**
     * Returns the text of the Excel export button of the `IgxGridToolbarComponent`.
     * ```typescript
     * const toolbarExcelText = this.igxGrid1.toolbar.getExportExcelText();
     * ```
     */
    /**
     * Returns the text of the Excel export button of the `IgxGridToolbarComponent`.
     * ```typescript
     * const toolbarExcelText = this.igxGrid1.toolbar.getExportExcelText();
     * ```
     * @return {?}
     */
    IgxGridToolbarComponent.prototype.getExportExcelText = /**
     * Returns the text of the Excel export button of the `IgxGridToolbarComponent`.
     * ```typescript
     * const toolbarExcelText = this.igxGrid1.toolbar.getExportExcelText();
     * ```
     * @return {?}
     */
    function () {
        return this.grid != null ? this.grid.exportExcelText : '';
    };
    /**
     * Returns the text of the CSV export button of the `IgxGridToolbarComponent`.
     * ```typescript
     * const toolbarCSVText = this.igxGrid1.toolbar.getExportCsvText();
     * ```
     */
    /**
     * Returns the text of the CSV export button of the `IgxGridToolbarComponent`.
     * ```typescript
     * const toolbarCSVText = this.igxGrid1.toolbar.getExportCsvText();
     * ```
     * @return {?}
     */
    IgxGridToolbarComponent.prototype.getExportCsvText = /**
     * Returns the text of the CSV export button of the `IgxGridToolbarComponent`.
     * ```typescript
     * const toolbarCSVText = this.igxGrid1.toolbar.getExportCsvText();
     * ```
     * @return {?}
     */
    function () {
        return this.grid != null ? this.grid.exportCsvText : '';
    };
    /**
     * Toggles the export button's dropdown menu.
     * ```typescript
     * this.igxGrid1.toolbar.exportClicked();
     * ```
     */
    /**
     * Toggles the export button's dropdown menu.
     * ```typescript
     * this.igxGrid1.toolbar.exportClicked();
     * ```
     * @return {?}
     */
    IgxGridToolbarComponent.prototype.exportClicked = /**
     * Toggles the export button's dropdown menu.
     * ```typescript
     * this.igxGrid1.toolbar.exportClicked();
     * ```
     * @return {?}
     */
    function () {
        this._overlaySettings.positionStrategy.settings.target = this.exportButton.nativeElement;
        this._overlaySettings.outlet = this.grid.outletDirective;
        this.exportDropdown.toggle(this._overlaySettings);
    };
    /**
     * Exports the grid to excel.
     * ```typescript
     * this.igxGrid1.toolbar.exportToExcelClicked();
     * ```
     */
    /**
     * Exports the grid to excel.
     * ```typescript
     * this.igxGrid1.toolbar.exportToExcelClicked();
     * ```
     * @return {?}
     */
    IgxGridToolbarComponent.prototype.exportToExcelClicked = /**
     * Exports the grid to excel.
     * ```typescript
     * this.igxGrid1.toolbar.exportToExcelClicked();
     * ```
     * @return {?}
     */
    function () {
        this.performExport(this.excelExporter, 'excel');
    };
    /**
     * Exports the grid to CSV.
     * ```typescript
     * this.igxGrid1.toolbar.exportToCsvClicked();
     * ```
     */
    /**
     * Exports the grid to CSV.
     * ```typescript
     * this.igxGrid1.toolbar.exportToCsvClicked();
     * ```
     * @return {?}
     */
    IgxGridToolbarComponent.prototype.exportToCsvClicked = /**
     * Exports the grid to CSV.
     * ```typescript
     * this.igxGrid1.toolbar.exportToCsvClicked();
     * ```
     * @return {?}
     */
    function () {
        this.performExport(this.csvExporter, 'csv');
    };
    /**
     * @private
     * @param {?} exp
     * @param {?} exportType
     * @return {?}
     */
    IgxGridToolbarComponent.prototype.performExport = /**
     * @private
     * @param {?} exp
     * @param {?} exportType
     * @return {?}
     */
    function (exp, exportType) {
        this.exportClicked();
        /** @type {?} */
        var fileName = 'ExportedData';
        /** @type {?} */
        var options = exportType === 'excel' ?
            new IgxExcelExporterOptions(fileName) :
            new IgxCsvExporterOptions(fileName, CsvFileTypes.CSV);
        /** @type {?} */
        var args = { grid: this.grid, exporter: exp, options: options, cancel: false };
        this.grid.onToolbarExporting.emit(args);
        if (args.cancel) {
            return;
        }
        exp.export(this.grid, options);
    };
    /**
     * Toggles the Column Hiding UI.
     * ```typescript
     * this.grid1.toolbar.toggleColumnHidingUI();
     * ```
     */
    /**
     * Toggles the Column Hiding UI.
     * ```typescript
     * this.grid1.toolbar.toggleColumnHidingUI();
     * ```
     * @return {?}
     */
    IgxGridToolbarComponent.prototype.toggleColumnHidingUI = /**
     * Toggles the Column Hiding UI.
     * ```typescript
     * this.grid1.toolbar.toggleColumnHidingUI();
     * ```
     * @return {?}
     */
    function () {
        this._overlaySettings.positionStrategy.settings.target = this.columnHidingButton.nativeElement;
        this._overlaySettings.outlet = this.grid.outletDirective;
        this.columnHidingDropdown.toggle(this._overlaySettings);
    };
    /**
     * Toggles the Column Pinning UI.
     * ```typescript
     * this.grid1.toolbar.toggleColumnPinningUI();
     * ```
     */
    /**
     * Toggles the Column Pinning UI.
     * ```typescript
     * this.grid1.toolbar.toggleColumnPinningUI();
     * ```
     * @return {?}
     */
    IgxGridToolbarComponent.prototype.toggleColumnPinningUI = /**
     * Toggles the Column Pinning UI.
     * ```typescript
     * this.grid1.toolbar.toggleColumnPinningUI();
     * ```
     * @return {?}
     */
    function () {
        this._overlaySettings.positionStrategy.settings.target = this.columnPinningButton.nativeElement;
        this._overlaySettings.outlet = this.grid.outletDirective;
        this.columnPinningDropdown.toggle(this._overlaySettings);
    };
    Object.defineProperty(IgxGridToolbarComponent.prototype, "context", {
        /**
         * Returns the `context` object which represents the `template context` binding into the
         * `toolbar custom container` by providing references to the parent IgxGird and the toolbar itself.
         * ```typescript
         * const context =  this.igxGrid.toolbar.context;
         * ```
         */
        get: /**
         * Returns the `context` object which represents the `template context` binding into the
         * `toolbar custom container` by providing references to the parent IgxGird and the toolbar itself.
         * ```typescript
         * const context =  this.igxGrid.toolbar.context;
         * ```
         * @return {?}
         */
        function () {
            return {
                // $implicit: this
                grid: this.grid,
                toolbar: this
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridToolbarComponent.prototype, "customContentTemplate", {
        /** @hidden */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            if (this.grid != null && this.grid.toolbarCustomContentTemplate != null) {
                return this.grid.toolbarCustomContentTemplate.template;
            }
            else {
                return null;
            }
        },
        enumerable: true,
        configurable: true
    });
    IgxGridToolbarComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-grid-toolbar',
                    template: "<span class=\"igx-grid-toolbar__title\" *ngIf=\"getTitle()\">\n    {{ getTitle() }}\n</span>\n\n<div class=\"igx-grid-toolbar__custom-content\" *ngIf=\"customContentTemplate != null\">\n    <ng-container *ngTemplateOutlet=\"customContentTemplate; context: context\">\n    </ng-container>\n</div>\n\n<div class=\"igx-grid-toolbar__actions\">\n    <div *ngIf=\"grid.columnHiding\">\n        <button igxButton=\"flat\" [displayDensity]=\"grid.displayDensity\" #columnHidingButton name=\"btnColumnHiding\" igxButton igxRipple\n            (click)=\"toggleColumnHidingUI()\">\n            <div  class=\"igx-grid-toolbar__button-space\">\n                <igx-icon *ngIf=\"grid.hiddenColumnsCount > 0\">visibility_off</igx-icon>\n                <igx-icon *ngIf=\"grid.hiddenColumnsCount === 0\">visibility</igx-icon>\n                <span>{{ grid.hiddenColumnsCount }}</span>\n                <span>{{ grid.hiddenColumnsText }}</span>\n            </div>\n        </button>\n        <igx-drop-down #columnHidingDropdown>\n            <igx-column-hiding\n                [columns]=\"grid.columns\"\n                [title]=\"grid.columnHidingTitle\"\n                [filterColumnsPrompt]=\"filterColumnsPrompt\"\n                [columnsAreaMaxHeight]=\"defaultDropDownsMaxHeight\"\n                (onColumnVisibilityChanged)=\"grid.toggleColumnVisibility($event)\">\n            </igx-column-hiding>\n        </igx-drop-down>\n    </div>\n    <div *ngIf=\"grid.columnPinning\">\n        <button igxButton=\"flat\" [displayDensity]=\"grid.displayDensity\" #columnPinningButton name=\"btnColumnPinning\" igxButton igxRipple\n            (click)=\"toggleColumnPinningUI()\">\n            <div  class=\"igx-grid-toolbar__button-space\">\n                <igx-icon *ngIf=\"pinnedColumnsCount > 0\">lock</igx-icon>\n                <igx-icon *ngIf=\"pinnedColumnsCount === 0\">lock_open</igx-icon>\n                <span>{{ pinnedColumnsCount }}</span>\n                <span>{{ grid.pinnedColumnsText }}</span>\n                <span></span>\n            </div>\n        </button>\n        <igx-drop-down #columnPinningDropdown>\n            <igx-column-pinning\n                [columns]=\"grid.columns\"\n                [title]=\"grid.columnPinningTitle\"\n                [filterColumnsPrompt]=\"filterColumnsPrompt\"\n                [columnsAreaMaxHeight]=\"defaultDropDownsMaxHeight\"></igx-column-pinning>\n        </igx-drop-down>\n    </div>\n\n\n    <div class=\"igx-grid-toolbar__dropdown\" *ngIf=\"shouldShowExportButton\" id=\"btnExport\">\n        <button igxButton=\"flat\" [displayDensity]=\"grid.displayDensity\" igxRipple #btnExport\n                (click)=\"exportClicked()\">\n            <span class=\"igx-grid-toolbar__button-space\">\n                <igx-icon fontSet=\"material\">import_export</igx-icon>\n                <span>{{ getExportText() }}</span>\n                <igx-icon fontSet=\"material\">arrow_drop_down</igx-icon>\n            </span>\n        </button>\n\n        <igx-drop-down #exportDropdown>\n            <ul class=\"igx-grid-toolbar__dd-list\">\n                <li class=\"igx-grid-toolbar__dd-list-items\" igxRipple *ngIf=\"shouldShowExportExcelButton\" id=\"btnExportExcel\"\n                (click)=\"exportToExcelClicked()\">{{ getExportExcelText() }}</li>\n                <li class=\"igx-grid-toolbar__dd-list-items\" igxRipple *ngIf=\"shouldShowExportCsvButton\" id=\"btnExportCsv\"\n                (click)=\"exportToCsvClicked()\">{{ getExportCsvText() }}</li>\n            </ul>\n        </igx-drop-down>\n    </div>\n</div>\n"
                }] }
    ];
    /** @nocollapse */
    IgxGridToolbarComponent.ctorParameters = function () { return [
        { type: GridBaseAPIService },
        { type: ChangeDetectorRef },
        { type: IgxExcelExporterService, decorators: [{ type: Optional }] },
        { type: IgxCsvExporterService, decorators: [{ type: Optional }] },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
    ]; };
    IgxGridToolbarComponent.propDecorators = {
        gridID: [{ type: HostBinding, args: ['class.igx-grid-toolbar',] }, { type: Input }],
        filterColumnsPrompt: [{ type: Input }],
        defaultDropDownsMaxHeight: [{ type: Input }],
        columnHidingDropdown: [{ type: ViewChild, args: ['columnHidingDropdown', { read: IgxDropDownComponent },] }],
        columnHidingUI: [{ type: ViewChild, args: [IgxColumnHidingComponent,] }],
        columnHidingButton: [{ type: ViewChild, args: ['columnHidingButton',] }],
        exportDropdown: [{ type: ViewChild, args: ['exportDropdown', { read: IgxDropDownComponent },] }],
        exportButton: [{ type: ViewChild, args: ['btnExport',] }],
        columnPinningDropdown: [{ type: ViewChild, args: ['columnPinningDropdown', { read: IgxDropDownComponent },] }],
        columnPinningUI: [{ type: ViewChild, args: [IgxColumnPinningComponent,] }],
        columnPinningButton: [{ type: ViewChild, args: ['columnPinningButton',] }],
        hostClass: [{ type: HostBinding, args: ['attr.class',] }]
    };
    return IgxGridToolbarComponent;
}(DisplayDensityBase));
/**
 * The IgxGridToolbarCustomContentDirective directive is used to mark an 'ng-template' (with
 * the 'igxToolbarCustomContent' selector) defined in the IgxGrid which is used to provide
 * custom content for cener part of the IgxGridToolbar.
 */
var IgxGridToolbarCustomContentDirective = /** @class */ (function () {
    function IgxGridToolbarCustomContentDirective(template) {
        this.template = template;
    }
    IgxGridToolbarCustomContentDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxToolbarCustomContent]'
                },] }
    ];
    /** @nocollapse */
    IgxGridToolbarCustomContentDirective.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return IgxGridToolbarCustomContentDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxGridGroupByRowComponent = /** @class */ (function () {
    function IgxGridGroupByRowComponent(gridAPI, gridSelection, element, cdr) {
        this.gridAPI = gridAPI;
        this.gridSelection = gridSelection;
        this.element = element;
        this.cdr = cdr;
        /**
         * @hidden
         */
        this.defaultCssClass = 'igx-grid__group-row';
        /**
         * @hidden
         */
        this.paddingIndentationCssClass = 'igx-grid__group-row--padding-level';
        /**
         * @hidden
         */
        this.isFocused = false;
        /**
         * @hidden
         */
        this.tabindex = 0;
    }
    Object.defineProperty(IgxGridGroupByRowComponent.prototype, "focused", {
        /**
         * Returns whether the row is focused.
         * ```
         * let gridRowFocused = this.grid1.rowList.first.focused;
         * ```
         */
        get: /**
         * Returns whether the row is focused.
         * ```
         * let gridRowFocused = this.grid1.rowList.first.focused;
         * ```
         * @return {?}
         */
        function () {
            return this.isFocused;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridGroupByRowComponent.prototype, "expanded", {
        /**
         * Returns whether the group row is expanded.
         * ```typescript
         * const groupRowExpanded = this.grid1.rowList.first.expanded;
         * ```
         */
        get: /**
         * Returns whether the group row is expanded.
         * ```typescript
         * const groupRowExpanded = this.grid1.rowList.first.expanded;
         * ```
         * @return {?}
         */
        function () {
            return this.grid.isExpandedGroup(this.groupRow);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridGroupByRowComponent.prototype, "describedBy", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            /** @type {?} */
            var grRowExpr = this.groupRow.expression !== undefined ? this.groupRow.expression.fieldName : '';
            return this.gridID + '_' + grRowExpr;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridGroupByRowComponent.prototype, "dataRowIndex", {
        get: /**
         * @return {?}
         */
        function () {
            return this.index;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridGroupByRowComponent.prototype, "nativeElement", {
        /**
         * Returns a reference to the underlying HTML element.
         * ```typescript
         * const groupRowElement = this.nativeElement;
         * ```
         */
        get: /**
         * Returns a reference to the underlying HTML element.
         * ```typescript
         * const groupRowElement = this.nativeElement;
         * ```
         * @return {?}
         */
        function () {
            return this.element.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridGroupByRowComponent.prototype, "styleClasses", {
        /**
         * Returns the style classes applied to the group rows.
         * ```typescript
         * const groupCssStyles = this.grid1.rowList.first.styleClasses;
         * ```
         */
        get: /**
         * Returns the style classes applied to the group rows.
         * ```typescript
         * const groupCssStyles = this.grid1.rowList.first.styleClasses;
         * ```
         * @return {?}
         */
        function () {
            return this.defaultCssClass + " " + (this.paddingIndentationCssClass + "-") + this.groupRow.level +
                (this.focused ? " " + this.defaultCssClass + "--active" : '');
        },
        enumerable: true,
        configurable: true
    });
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxGridGroupByRowComponent.prototype.onFocus = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.isFocused = true;
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxGridGroupByRowComponent.prototype.onBlur = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.isFocused = false;
    };
    /**
     * Toggles the group row.
     * ```typescript
     * this.grid1.rowList.first.toggle()
     * ```
     */
    /**
     * Toggles the group row.
     * ```typescript
     * this.grid1.rowList.first.toggle()
     * ```
     * @return {?}
     */
    IgxGridGroupByRowComponent.prototype.toggle = /**
     * Toggles the group row.
     * ```typescript
     * this.grid1.rowList.first.toggle()
     * ```
     * @return {?}
     */
    function () {
        /** @type {?} */
        var isVirtualized = !this.grid.verticalScrollContainer.dc.instance.notVirtual;
        /** @type {?} */
        var groupRowIndex = this.index;
        this.grid.toggleGroup(this.groupRow);
        if (isVirtualized) {
            /** @type {?} */
            var groupRow = this.grid.nativeElement.querySelector("[data-rowIndex=\"" + groupRowIndex + "\"]");
            if (groupRow) {
                groupRow.focus();
            }
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxGridGroupByRowComponent.prototype.onKeydown = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // TODO: Refactor
        /** @type {?} */
        var key = event.key.toLowerCase();
        if (!SUPPORTED_KEYS.has(key)) {
            return;
        }
        event.stopPropagation();
        /** @type {?} */
        var keydownArgs = { targetType: 'groupRow', target: this, event: event, cancel: false };
        this.grid.onGridKeydown.emit(keydownArgs);
        if (keydownArgs.cancel) {
            return;
        }
        event.preventDefault();
        if (!this.isKeySupportedInGroupRow(key, event.shiftKey, event.altKey) || event.ctrlKey) {
            return;
        }
        if (this.isToggleKey(key, event.altKey)) {
            if ((this.expanded && ROW_COLLAPSE_KEYS.has(key)) || (!this.expanded && ROW_EXPAND_KEYS.has(key))) {
                this.toggle();
            }
            return;
        }
        // TODO: to be deleted when onFocusChange event is removed #4054
        /** @type {?} */
        var args = { cell: this, groupRow: null, event: event, cancel: false };
        this.grid.onFocusChange.emit(args);
        if (args.cancel) {
            return;
        }
        /** @type {?} */
        var selection = this.gridSelection;
        selection.keyboardState.shift = event.shiftKey && !(key === 'tab');
        /** @type {?} */
        var visibleColumnIndex = selection.activeElement && this.grid.columnList.filter(function (col) { return !col.hidden; }).map(function (c) { return c.visibleIndex; })
            .indexOf(selection.activeElement.column) !== -1 ? selection.activeElement.column : 0;
        switch (key) {
            case 'arrowdown':
            case 'down':
                this.grid.navigation.navigateDown(this.nativeElement, this.index, visibleColumnIndex);
                break;
            case 'arrowup':
            case 'up':
                this.grid.navigation.navigateUp(this.nativeElement, this.index, visibleColumnIndex);
                break;
            case 'tab':
                this.handleTabKey(event.shiftKey);
                break;
        }
    };
    Object.defineProperty(IgxGridGroupByRowComponent.prototype, "grid", {
        /**
         * Returns a reference to the `IgxGridComponent` the `IgxGridGroupByRowComponent` belongs to.
         * ```typescript
         * this.grid1.rowList.first.grid;
         * ```
         */
        get: /**
         * Returns a reference to the `IgxGridComponent` the `IgxGridGroupByRowComponent` belongs to.
         * ```typescript
         * this.grid1.rowList.first.grid;
         * ```
         * @return {?}
         */
        function () {
            return this.gridAPI.grid;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridGroupByRowComponent.prototype, "dataType", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.grid.getColumnByName(this.groupRow.expression.fieldName).dataType;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @param {?} shift
     * @return {?}
     */
    IgxGridGroupByRowComponent.prototype.handleTabKey = /**
     * @private
     * @param {?} shift
     * @return {?}
     */
    function (shift) {
        if (shift) {
            this.grid.navigation.performShiftTabKey(this.nativeElement, this.index, 0);
        }
        else {
            if (this.index === this.grid.verticalScrollContainer.igxForOf.length - 1 && this.grid.rootSummariesEnabled) {
                this.grid.navigation.onKeydownHome(0, true);
            }
            else {
                this.grid.navigation.navigateDown(this.nativeElement, this.index, 0);
            }
        }
    };
    /**
     * @private
     * @param {?} key
     * @param {?=} shift
     * @param {?=} alt
     * @return {?}
     */
    IgxGridGroupByRowComponent.prototype.isKeySupportedInGroupRow = /**
     * @private
     * @param {?} key
     * @param {?=} shift
     * @param {?=} alt
     * @return {?}
     */
    function (key, shift, alt) {
        if (shift === void 0) { shift = false; }
        if (alt === void 0) { alt = false; }
        if (shift) {
            return ['down', 'up', 'arrowdown', 'arrowup', 'tab'].indexOf(key) !== -1;
        }
        return this.isToggleKey(key, alt) ? true : ['down', 'up', 'arrowdown', 'arrowup', 'tab'].indexOf(key) !== -1;
    };
    /**
     * @private
     * @param {?} key
     * @param {?} altKey
     * @return {?}
     */
    IgxGridGroupByRowComponent.prototype.isToggleKey = /**
     * @private
     * @param {?} key
     * @param {?} altKey
     * @return {?}
     */
    function (key, altKey) {
        return altKey && ['left', 'right', 'up', 'down', 'arrowleft', 'arrowright', 'arrowup', 'arrowdown'].indexOf(key) !== -1;
    };
    IgxGridGroupByRowComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-grid-groupby-row',
                    template: "<ng-container #defaultGroupRow>\n    <div (click)=\"toggle()\" class=\"igx-grid__grouping-indicator\">\n        <igx-icon *ngIf=\"!expanded\" fontSet=\"material\">expand_more</igx-icon>\n        <igx-icon *ngIf=\"expanded\" fontSet=\"material\">expand_less</igx-icon>\n    </div>\n\n    <div class=\"igx-grid__group-content\" #groupContent>\n        <ng-container *ngTemplateOutlet=\"grid.groupRowTemplate ? grid.groupRowTemplate : defaultGroupByTemplate; context: { $implicit: groupRow }\">\n        </ng-container>\n    </div>\n\n    <ng-template #defaultGroupByTemplate>\n        <div class=\"igx-group-label\">\n            <igx-icon fontSet=\"material\" class=\"igx-group-label__icon\">group_work</igx-icon>\n            <span class=\"igx-group-label__column-name\">\n            {{ groupRow.expression ? groupRow.expression.fieldName : '' }}:\n            </span>\n\n            <ng-container *ngIf=\"dataType === 'boolean' || dataType === 'string'; else default\" >\n                <span class=\"igx-group-label__text\">{{ groupRow.value }}</span>\n            </ng-container>\n            <ng-template #default>\n                <ng-container *ngIf=\"dataType === 'number'\">\n                    <span class=\"igx-group-label__text\">{{ groupRow.value | number }}</span>\n                </ng-container>\n                <ng-container *ngIf=\"dataType === 'date'\">\n                    <span class=\"igx-group-label__text\">{{ groupRow.value | date }}</span>\n                </ng-container>\n            </ng-template>\n\n            <igx-badge [value]=\"groupRow.records ? groupRow.records.length : 0\" class='igx-group-label__count-badge'></igx-badge>\n        </div>\n    </ng-template>\n</ng-container>\n"
                }] }
    ];
    /** @nocollapse */
    IgxGridGroupByRowComponent.ctorParameters = function () { return [
        { type: GridBaseAPIService },
        { type: IgxGridSelectionService },
        { type: ElementRef },
        { type: ChangeDetectorRef }
    ]; };
    IgxGridGroupByRowComponent.propDecorators = {
        isFocused: [{ type: Input }],
        index: [{ type: Input }],
        gridID: [{ type: Input }],
        groupRow: [{ type: Input }],
        groupContent: [{ type: ViewChild, args: ['groupContent',] }],
        expanded: [{ type: HostBinding, args: ['attr.aria-expanded',] }],
        tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
        describedBy: [{ type: HostBinding, args: ['attr.aria-describedby',] }],
        dataRowIndex: [{ type: HostBinding, args: ['attr.data-rowIndex',] }],
        styleClasses: [{ type: HostBinding, args: ['class',] }],
        onFocus: [{ type: HostListener, args: ['focus',] }],
        onBlur: [{ type: HostListener, args: ['blur',] }],
        onKeydown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
    };
    return IgxGridGroupByRowComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var MoveDirection = {
    LEFT: 'left',
    RIGHT: 'right',
};
/**
 * @hidden
 */
var IgxGridNavigationService = /** @class */ (function () {
    function IgxGridNavigationService() {
    }
    Object.defineProperty(IgxGridNavigationService.prototype, "displayContainerWidth", {
        get: /**
         * @return {?}
         */
        function () {
            return parseInt(this.grid.parentVirtDir.dc.instance._viewContainer.element.nativeElement.offsetWidth, 10);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridNavigationService.prototype, "displayContainerScrollLeft", {
        get: /**
         * @return {?}
         */
        function () {
            return parseInt(this.grid.parentVirtDir.getHorizontalScroll().scrollLeft, 10);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridNavigationService.prototype, "verticalDisplayContainerElement", {
        get: /**
         * @return {?}
         */
        function () {
            return this.grid.verticalScrollContainer.dc.instance._viewContainer.element.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} rowIndex
     * @return {?}
     */
    IgxGridNavigationService.prototype.horizontalScroll = /**
     * @param {?} rowIndex
     * @return {?}
     */
    function (rowIndex) {
        /** @type {?} */
        var rowComp = this.grid.dataRowList.find(function (row) { return row.index === rowIndex; }) ?
            this.grid.dataRowList.find(function (row) { return row.index === rowIndex; }) : this.grid.dataRowList.first;
        if (!rowComp) {
            rowComp = this.grid.summariesRowList.find(function (row) { return row.index === rowIndex; });
        }
        return rowComp.virtDirRow;
    };
    /**
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    IgxGridNavigationService.prototype.getColumnUnpinnedIndex = /**
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    function (visibleColumnIndex) {
        /** @type {?} */
        var column = this.grid.unpinnedColumns.find(function (col) { return !col.columnGroup && col.visibleIndex === visibleColumnIndex; });
        return this.grid.pinnedColumns.length ? this.grid.unpinnedColumns.filter(function (c) { return !c.columnGroup; }).indexOf(column) :
            visibleColumnIndex;
    };
    /**
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    IgxGridNavigationService.prototype.isColumnFullyVisible = /**
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    function (visibleColumnIndex) {
        /** @type {?} */
        var forOfDir;
        if (this.grid.dataRowList.length > 0) {
            forOfDir = this.grid.dataRowList.first.virtDirRow;
        }
        else {
            forOfDir = this.grid.headerContainer;
        }
        /** @type {?} */
        var horizontalScroll = forOfDir.getHorizontalScroll();
        if (!horizontalScroll.clientWidth ||
            this.grid.columnList.filter(function (c) { return !c.columnGroup; }).find(function (column) { return column.visibleIndex === visibleColumnIndex; }).pinned) {
            return true;
        }
        /** @type {?} */
        var index = this.getColumnUnpinnedIndex(visibleColumnIndex);
        return this.displayContainerWidth >= forOfDir.getColumnScrollLeft(index + 1) - this.displayContainerScrollLeft;
    };
    /**
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    IgxGridNavigationService.prototype.isColumnLeftFullyVisible = /**
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    function (visibleColumnIndex) {
        /** @type {?} */
        var forOfDir;
        if (this.grid.dataRowList.length > 0) {
            forOfDir = this.grid.dataRowList.first.virtDirRow;
        }
        else {
            forOfDir = this.grid.headerContainer;
        }
        /** @type {?} */
        var horizontalScroll = forOfDir.getHorizontalScroll();
        if (!horizontalScroll.clientWidth ||
            this.grid.columnList.filter(function (c) { return !c.columnGroup; }).find(function (column) { return column.visibleIndex === visibleColumnIndex; }).pinned) {
            return true;
        }
        /** @type {?} */
        var index = this.getColumnUnpinnedIndex(visibleColumnIndex);
        return this.displayContainerScrollLeft <= forOfDir.getColumnScrollLeft(index);
    };
    Object.defineProperty(IgxGridNavigationService.prototype, "gridOrderedColumns", {
        get: /**
         * @return {?}
         */
        function () {
            return __spread(this.grid.pinnedColumns, this.grid.unpinnedColumns).filter(function (c) { return !c.columnGroup; });
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} rowIndex
     * @return {?}
     */
    IgxGridNavigationService.prototype.isRowInEditMode = /**
     * @param {?} rowIndex
     * @return {?}
     */
    function (rowIndex) {
        return this.grid.rowEditable && (this.grid.rowInEditMode && this.grid.rowInEditMode.index === rowIndex);
    };
    /**
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    IgxGridNavigationService.prototype.isColumnEditable = /**
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    function (visibleColumnIndex) {
        /** @type {?} */
        var column = this.gridOrderedColumns.find(function (c) { return c.visibleIndex === visibleColumnIndex; });
        return column ? column.editable : false;
    };
    /**
     * @param {?} direction
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    IgxGridNavigationService.prototype.findNextEditable = /**
     * @param {?} direction
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    function (direction, visibleColumnIndex) {
        /** @type {?} */
        var gridColumns = this.gridOrderedColumns;
        if (direction === MoveDirection.LEFT) {
            return gridColumns.splice(0, visibleColumnIndex + 1).reverse().findIndex(function (e) { return e.editable; });
        }
        else if (direction === MoveDirection.RIGHT) {
            return gridColumns.splice(visibleColumnIndex, gridColumns.length - 1).findIndex(function (e) { return e.editable; });
        }
    };
    /**
     * @param {?} rowIndex
     * @param {?} visibleColumnIndex
     * @param {?=} isSummary
     * @return {?}
     */
    IgxGridNavigationService.prototype.getCellElementByVisibleIndex = /**
     * @param {?} rowIndex
     * @param {?} visibleColumnIndex
     * @param {?=} isSummary
     * @return {?}
     */
    function (rowIndex, visibleColumnIndex, isSummary) {
        if (isSummary === void 0) { isSummary = false; }
        /** @type {?} */
        var cellSelector = this.getCellSelector(visibleColumnIndex, isSummary);
        return this.grid.nativeElement.querySelector(cellSelector + "[data-rowindex=\"" + rowIndex + "\"][data-visibleIndex=\"" + visibleColumnIndex + "\"]");
    };
    /**
     * @param {?} element
     * @param {?} rowIndex
     * @param {?} visibleColumnIndex
     * @param {?=} isSummary
     * @return {?}
     */
    IgxGridNavigationService.prototype.onKeydownArrowRight = /**
     * @param {?} element
     * @param {?} rowIndex
     * @param {?} visibleColumnIndex
     * @param {?=} isSummary
     * @return {?}
     */
    function (element, rowIndex, visibleColumnIndex, isSummary) {
        if (isSummary === void 0) { isSummary = false; }
        if (this.grid.unpinnedColumns[this.grid.unpinnedColumns.length - 1].visibleIndex === visibleColumnIndex) {
            return;
        }
        if (this.isColumnFullyVisible(visibleColumnIndex + 1)) { // if next column is fully visible or is pinned
            if (element.classList.contains('igx-grid__td--pinned-last') || element.classList.contains('igx-grid-summary--pinned-last')) {
                if (this.isColumnLeftFullyVisible(visibleColumnIndex + 1)) {
                    element.nextElementSibling.firstElementChild.focus({ preventScroll: true });
                }
                else {
                    this.grid.nativeElement.focus({ preventScroll: true });
                    this.grid.parentVirtDir.onChunkLoad
                        .pipe(first())
                        .subscribe(function () {
                        element.nextElementSibling.firstElementChild.focus({ preventScroll: true });
                    });
                    this.horizontalScroll(rowIndex).scrollTo(0);
                }
            }
            else {
                element.nextElementSibling.focus({ preventScroll: true });
            }
        }
        else {
            this.performHorizontalScrollToCell(rowIndex, visibleColumnIndex + 1, isSummary);
        }
    };
    /**
     * @param {?} element
     * @param {?} rowIndex
     * @param {?} visibleColumnIndex
     * @param {?=} isSummary
     * @return {?}
     */
    IgxGridNavigationService.prototype.onKeydownArrowLeft = /**
     * @param {?} element
     * @param {?} rowIndex
     * @param {?} visibleColumnIndex
     * @param {?=} isSummary
     * @return {?}
     */
    function (element, rowIndex, visibleColumnIndex, isSummary) {
        if (isSummary === void 0) { isSummary = false; }
        if (visibleColumnIndex === 0) {
            return;
        }
        /** @type {?} */
        var index = this.getColumnUnpinnedIndex(visibleColumnIndex - 1);
        if (!element.previousElementSibling && this.grid.pinnedColumns.length && index === -1) {
            element.parentNode.previousElementSibling.focus({ preventScroll: true });
        }
        else if (!this.isColumnLeftFullyVisible(visibleColumnIndex - 1)) {
            this.performHorizontalScrollToCell(rowIndex, visibleColumnIndex - 1, isSummary);
        }
        else {
            element.previousElementSibling.focus({ preventScroll: true });
        }
    };
    /**
     * @param {?} rowIndex
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    IgxGridNavigationService.prototype.movePreviousEditable = /**
     * @param {?} rowIndex
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    function (rowIndex, visibleColumnIndex) {
        /** @type {?} */
        var addedIndex = this.isColumnEditable(visibleColumnIndex - 1) ?
            0 :
            this.findNextEditable(MoveDirection.LEFT, visibleColumnIndex - 1);
        if (addedIndex === -1) {
            this.grid.rowEditTabs.last.element.nativeElement.focus();
            return;
        }
        /** @type {?} */
        var editableIndex = visibleColumnIndex - 1 - addedIndex;
        if (this.getColumnUnpinnedIndex(editableIndex) === -1 && this.grid.pinnedColumns.length) {
            // if target is NOT pinned and there are pinned columns
            // since addedIndex !== -1, there will always be a target
            this.getCellElementByVisibleIndex(rowIndex, editableIndex).focus();
        }
        else if (!this.isColumnLeftFullyVisible(editableIndex)) { // if not fully visible, perform scroll
            this.performHorizontalScrollToCell(rowIndex, editableIndex);
        }
        else {
            this.getCellElementByVisibleIndex(rowIndex, editableIndex).focus(); // if fully visible, just focus
        }
    };
    /**
     * @param {?} element
     * @param {?} rowIndex
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    IgxGridNavigationService.prototype.moveNextEditable = /**
     * @param {?} element
     * @param {?} rowIndex
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    function (element, rowIndex, visibleColumnIndex) {
        /** @type {?} */
        var addedIndex = 0;
        addedIndex = this.isColumnEditable(visibleColumnIndex + 1) ?
            0 :
            this.findNextEditable(MoveDirection.RIGHT, visibleColumnIndex + 1);
        if (addedIndex === -1 && this.grid.rowEditTabs) { // no previous edit column -> go to RE buttons
            this.grid.rowEditTabs.first.element.nativeElement.focus();
            return;
        }
        /** @type {?} */
        var editableIndex = visibleColumnIndex + 1 + addedIndex;
        if (this.isColumnFullyVisible(editableIndex)) { // If column is fully visible
            if (element.classList.contains('igx-grid__td--pinned-last')) { // If this is pinned
                if (this.isColumnLeftFullyVisible(editableIndex)) { // If next column is fully visible LEFT
                    this.getCellElementByVisibleIndex(rowIndex, editableIndex).focus(); // focus
                }
                else { // if NOT fully visible, perform scroll
                    this.performHorizontalScrollToCell(rowIndex, editableIndex);
                }
            }
            else { // cell is next cell
                this.getCellElementByVisibleIndex(rowIndex, editableIndex).focus();
            }
        }
        else {
            this.performHorizontalScrollToCell(rowIndex, editableIndex);
        }
    };
    /**
     * @param {?} rowIndex
     * @param {?=} isSummary
     * @return {?}
     */
    IgxGridNavigationService.prototype.onKeydownHome = /**
     * @param {?} rowIndex
     * @param {?=} isSummary
     * @return {?}
     */
    function (rowIndex, isSummary) {
        if (isSummary === void 0) { isSummary = false; }
        /** @type {?} */
        var rowList = isSummary ? this.grid.summariesRowList : this.grid.dataRowList;
        /** @type {?} */
        var rowElement = rowList.find(function (row) { return row.index === rowIndex; });
        /** @type {?} */
        var cellSelector = this.getCellSelector(0, isSummary);
        if (!rowElement) {
            return;
        }
        rowElement = rowElement.nativeElement;
        /** @type {?} */
        var firstCell = rowElement.querySelector(cellSelector);
        if (this.grid.pinnedColumns.length || this.displayContainerScrollLeft === 0) {
            firstCell.focus({ preventScroll: true });
        }
        else {
            this.grid.nativeElement.focus({ preventScroll: true });
            this.grid.parentVirtDir.onChunkLoad
                .pipe(first())
                .subscribe(function () {
                firstCell = rowElement.querySelector(cellSelector);
                firstCell.focus({ preventScroll: true });
            });
            this.horizontalScroll(rowIndex).scrollTo(0);
        }
    };
    /**
     * @param {?} rowIndex
     * @param {?=} isSummary
     * @return {?}
     */
    IgxGridNavigationService.prototype.onKeydownEnd = /**
     * @param {?} rowIndex
     * @param {?=} isSummary
     * @return {?}
     */
    function (rowIndex, isSummary) {
        var _this = this;
        if (isSummary === void 0) { isSummary = false; }
        /** @type {?} */
        var index = this.grid.unpinnedColumns[this.grid.unpinnedColumns.length - 1].visibleIndex;
        /** @type {?} */
        var rowList = isSummary ? this.grid.summariesRowList : this.grid.dataRowList;
        /** @type {?} */
        var rowElement = rowList.find(function (row) { return row.index === rowIndex; });
        if (!rowElement) {
            return;
        }
        rowElement = rowElement.nativeElement;
        if (this.isColumnFullyVisible(index)) {
            /** @type {?} */
            var allCells = rowElement.querySelectorAll(this.getCellSelector(-1, isSummary));
            allCells[allCells.length - 1].focus({ preventScroll: true });
        }
        else {
            this.grid.nativeElement.focus({ preventScroll: true });
            this.grid.parentVirtDir.onChunkLoad
                .pipe(first())
                .subscribe(function () {
                /** @type {?} */
                var allCells = rowElement.querySelectorAll(_this.getCellSelector(-1, isSummary));
                allCells[allCells.length - 1].focus({ preventScroll: true });
            });
            this.horizontalScroll(rowIndex).scrollTo(this.getColumnUnpinnedIndex(index));
        }
    };
    /**
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    IgxGridNavigationService.prototype.navigateTop = /**
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    function (visibleColumnIndex) {
        var _this = this;
        /** @type {?} */
        var verticalScroll = this.grid.verticalScrollContainer.getVerticalScroll();
        /** @type {?} */
        var cellSelector = this.getCellSelector(visibleColumnIndex);
        if (verticalScroll.scrollTop === 0) {
            /** @type {?} */
            var cells = this.grid.nativeElement.querySelectorAll(cellSelector + "[data-visibleIndex=\"" + visibleColumnIndex + "\"]");
            cells[0].focus();
        }
        else {
            this.grid.nativeElement.focus({ preventScroll: true });
            this.grid.verticalScrollContainer.scrollTo(0);
            this.grid.verticalScrollContainer.onChunkLoad
                .pipe(first()).subscribe(function () {
                /** @type {?} */
                var cells = _this.grid.nativeElement.querySelectorAll(cellSelector + "[data-visibleIndex=\"" + visibleColumnIndex + "\"]");
                if (cells.length > 0) {
                    cells[0].focus();
                }
            });
        }
    };
    /**
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    IgxGridNavigationService.prototype.navigateBottom = /**
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    function (visibleColumnIndex) {
        var _this = this;
        /** @type {?} */
        var verticalScroll = this.grid.verticalScrollContainer.getVerticalScroll();
        /** @type {?} */
        var cellSelector = this.getCellSelector(visibleColumnIndex);
        if (verticalScroll.scrollHeight === 0 ||
            verticalScroll.scrollTop === verticalScroll.scrollHeight - this.grid.verticalScrollContainer.igxForContainerSize) {
            /** @type {?} */
            var cells = this.grid.nativeElement.querySelectorAll(cellSelector + "[data-visibleIndex=\"" + visibleColumnIndex + "\"]");
            cells[cells.length - 1].focus();
        }
        else {
            this.grid.nativeElement.focus({ preventScroll: true });
            this.grid.verticalScrollContainer.scrollTo(this.grid.verticalScrollContainer.igxForOf.length - 1);
            this.grid.verticalScrollContainer.onChunkLoad
                .pipe(first()).subscribe(function () {
                /** @type {?} */
                var cells = _this.grid.nativeElement.querySelectorAll(cellSelector + "[data-visibleIndex=\"" + visibleColumnIndex + "\"]");
                if (cells.length > 0) {
                    cells[cells.length - 1].focus();
                }
            });
        }
    };
    /**
     * @param {?} rowElement
     * @param {?} currentRowIndex
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    IgxGridNavigationService.prototype.navigateUp = /**
     * @param {?} rowElement
     * @param {?} currentRowIndex
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    function (rowElement, currentRowIndex, visibleColumnIndex) {
        var _this = this;
        if (currentRowIndex === 0) {
            return;
        }
        /** @type {?} */
        var containerTopOffset = parseInt(this.verticalDisplayContainerElement.style.top, 10);
        if (!rowElement.previousElementSibling ||
            rowElement.previousElementSibling.offsetTop < Math.abs(containerTopOffset)) {
            this.grid.nativeElement.focus({ preventScroll: true });
            this.grid.verticalScrollContainer.scrollTo(currentRowIndex - 1);
            this.grid.verticalScrollContainer.onChunkLoad
                .pipe(first())
                .subscribe(function () {
                /** @type {?} */
                var tag = rowElement.tagName.toLowerCase();
                /** @type {?} */
                var rowSelector = _this.getRowSelector();
                if (tag === rowSelector || tag === 'igx-grid-summary-row') {
                    rowElement = _this.getRowByIndex(currentRowIndex, tag);
                }
                else {
                    rowElement = _this.grid.nativeElement.querySelector("igx-grid-groupby-row[data-rowindex=\"" + currentRowIndex + "\"]");
                }
                _this.focusPreviousElement(rowElement, visibleColumnIndex);
            });
        }
        else {
            this.focusPreviousElement(rowElement, visibleColumnIndex);
        }
    };
    /**
     * @protected
     * @param {?} currentRowEl
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    IgxGridNavigationService.prototype.focusPreviousElement = /**
     * @protected
     * @param {?} currentRowEl
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    function (currentRowEl, visibleColumnIndex) {
        this.focusElem(currentRowEl.previousElementSibling, visibleColumnIndex);
    };
    /**
     * @param {?} rowElement
     * @param {?} currentRowIndex
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    IgxGridNavigationService.prototype.navigateDown = /**
     * @param {?} rowElement
     * @param {?} currentRowIndex
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    function (rowElement, currentRowIndex, visibleColumnIndex) {
        var _this = this;
        if (currentRowIndex === this.grid.verticalScrollContainer.igxForOf.length - 1 ||
            (currentRowIndex === 0 && rowElement.tagName.toLowerCase() === 'igx-grid-summary-row')) { // check if this is rootSummary row
            return;
        }
        /** @type {?} */
        var rowHeight = this.grid.verticalScrollContainer.getSizeAt(currentRowIndex + 1);
        /** @type {?} */
        var containerHeight = this.grid.calcHeight ? Math.ceil(this.grid.calcHeight) : 0;
        /** @type {?} */
        var targetEndTopOffset = rowElement.nextElementSibling ?
            rowElement.nextElementSibling.offsetTop + rowHeight + parseInt(this.verticalDisplayContainerElement.style.top, 10) :
            containerHeight + rowHeight;
        this.grid.nativeElement.focus({ preventScroll: true });
        if (containerHeight && containerHeight < targetEndTopOffset) {
            /** @type {?} */
            var nextIndex_1 = currentRowIndex + 1;
            this.grid.verticalScrollContainer.scrollTo(nextIndex_1);
            this.grid.verticalScrollContainer.onChunkLoad
                .pipe(first())
                .subscribe(function () {
                rowElement = _this.getNextRowByIndex(nextIndex_1);
                _this.focusElem(rowElement, visibleColumnIndex);
            });
        }
        else {
            this.focusNextElement(rowElement, visibleColumnIndex);
        }
    };
    /**
     * @protected
     * @param {?} rowElement
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    IgxGridNavigationService.prototype.focusElem = /**
     * @protected
     * @param {?} rowElement
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    function (rowElement, visibleColumnIndex) {
        if (rowElement.tagName.toLowerCase() === 'igx-grid-groupby-row') {
            rowElement.focus();
        }
        else {
            /** @type {?} */
            var isSummaryRow = rowElement.tagName.toLowerCase() === 'igx-grid-summary-row';
            if (this.isColumnFullyVisible(visibleColumnIndex) && this.isColumnLeftFullyVisible(visibleColumnIndex)) {
                /** @type {?} */
                var cellSelector = this.getCellSelector(visibleColumnIndex, isSummaryRow);
                /** @type {?} */
                var cell = rowElement.querySelector(cellSelector + "[data-visibleIndex=\"" + visibleColumnIndex + "\"]");
                cell.focus();
                return cell;
            }
            this.performHorizontalScrollToCell(parseInt(rowElement.getAttribute('data-rowindex'), 10), visibleColumnIndex, isSummaryRow);
        }
    };
    /**
     * @protected
     * @param {?} rowElement
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    IgxGridNavigationService.prototype.focusNextElement = /**
     * @protected
     * @param {?} rowElement
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    function (rowElement, visibleColumnIndex) {
        return this.focusElem(rowElement.nextElementSibling, visibleColumnIndex);
    };
    /**
     * @return {?}
     */
    IgxGridNavigationService.prototype.goToFirstCell = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var verticalScroll = this.grid.verticalScrollContainer.getVerticalScroll();
        /** @type {?} */
        var horizontalScroll = this.grid.dataRowList.first.virtDirRow.getHorizontalScroll();
        if (verticalScroll.scrollTop === 0) {
            this.onKeydownHome(this.grid.dataRowList.first.index);
        }
        else {
            if (!horizontalScroll.clientWidth || parseInt(horizontalScroll.scrollLeft, 10) <= 1 || this.grid.pinnedColumns.length) {
                this.navigateTop(0);
            }
            else {
                this.grid.nativeElement.focus({ preventScroll: true });
                this.horizontalScroll(this.grid.dataRowList.first.index).scrollTo(0);
                this.grid.parentVirtDir.onChunkLoad
                    .pipe(first())
                    .subscribe(function () {
                    _this.navigateTop(0);
                });
            }
        }
    };
    /**
     * @return {?}
     */
    IgxGridNavigationService.prototype.goToLastCell = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var verticalScroll = this.grid.verticalScrollContainer.getVerticalScroll();
        if (verticalScroll.scrollHeight === 0 ||
            verticalScroll.scrollTop === verticalScroll.scrollHeight - this.grid.verticalScrollContainer.igxForContainerSize) {
            /** @type {?} */
            var rows = this.getAllRows();
            /** @type {?} */
            var rowIndex = parseInt(rows[rows.length - 1].getAttribute('data-rowIndex'), 10);
            this.onKeydownEnd(rowIndex);
        }
        else {
            this.grid.nativeElement.focus({ preventScroll: true });
            this.grid.verticalScrollContainer.scrollTo(this.grid.verticalScrollContainer.igxForOf.length - 1);
            this.grid.verticalScrollContainer.onChunkLoad
                .pipe(first()).subscribe(function () {
                /** @type {?} */
                var rows = _this.getAllRows();
                if (rows.length > 0) {
                    /** @type {?} */
                    var rowIndex = parseInt(rows[rows.length - 1].getAttribute('data-rowIndex'), 10);
                    _this.onKeydownEnd(rowIndex);
                }
            });
        }
    };
    /**
     * @return {?}
     */
    IgxGridNavigationService.prototype.goToLastBodyElement = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var verticalScroll = this.grid.verticalScrollContainer.getVerticalScroll();
        if (verticalScroll.scrollHeight === 0 ||
            verticalScroll.scrollTop === verticalScroll.scrollHeight - this.grid.verticalScrollContainer.igxForContainerSize) {
            /** @type {?} */
            var rowIndex = this.grid.verticalScrollContainer.igxForOf.length - 1;
            /** @type {?} */
            var row = this.grid.nativeElement.querySelector("[data-rowindex=\"" + rowIndex + "\"]");
            if (row && row.tagName.toLowerCase() === 'igx-grid-groupby-row') {
                row.focus();
                return;
            }
            /** @type {?} */
            var isSummary = (row && row.tagName.toLowerCase() === 'igx-grid-summary-row') ? true : false;
            this.onKeydownEnd(rowIndex, isSummary);
        }
        else {
            this.grid.verticalScrollContainer.scrollTo(this.grid.verticalScrollContainer.igxForOf.length - 1);
            this.grid.verticalScrollContainer.onChunkLoad
                .pipe(first()).subscribe(function () {
                /** @type {?} */
                var rowIndex = _this.grid.verticalScrollContainer.igxForOf.length - 1;
                /** @type {?} */
                var row = _this.grid.nativeElement.querySelector("[data-rowindex=\"" + rowIndex + "\"]");
                if (row && row.tagName.toLowerCase() === 'igx-grid-groupby-row') {
                    row.focus();
                    return;
                }
                /** @type {?} */
                var isSummary = (row && row.tagName.toLowerCase() === 'igx-grid-summary-row') ? true : false;
                _this.onKeydownEnd(rowIndex, isSummary);
            });
        }
    };
    /**
     * @param {?} currentRowEl
     * @param {?} rowIndex
     * @param {?} visibleColumnIndex
     * @param {?=} isSummaryRow
     * @return {?}
     */
    IgxGridNavigationService.prototype.performTab = /**
     * @param {?} currentRowEl
     * @param {?} rowIndex
     * @param {?} visibleColumnIndex
     * @param {?=} isSummaryRow
     * @return {?}
     */
    function (currentRowEl, rowIndex, visibleColumnIndex, isSummaryRow) {
        if (isSummaryRow === void 0) { isSummaryRow = false; }
        if (isSummaryRow && rowIndex === 0 &&
            this.grid.unpinnedColumns[this.grid.unpinnedColumns.length - 1].visibleIndex === visibleColumnIndex) {
            return;
        }
        if (this.grid.unpinnedColumns[this.grid.unpinnedColumns.length - 1].visibleIndex === visibleColumnIndex) {
            if (this.isRowInEditMode(rowIndex)) {
                this.grid.rowEditTabs.first.element.nativeElement.focus();
                return;
            }
            /** @type {?} */
            var rowEl = this.grid.rowList.find(function (row) { return row.index === rowIndex + 1; }) ?
                this.grid.rowList.find(function (row) { return row.index === rowIndex + 1; }) :
                this.grid.summariesRowList.find(function (row) { return row.index === rowIndex + 1; });
            if (rowIndex === this.grid.verticalScrollContainer.igxForOf.length - 1 && this.grid.rootSummariesEnabled) {
                this.onKeydownHome(0, true);
                return;
            }
            if (rowEl) {
                this.navigateDown(currentRowEl, rowIndex, 0);
            }
        }
        else {
            /** @type {?} */
            var cell = this.getCellElementByVisibleIndex(rowIndex, visibleColumnIndex, isSummaryRow);
            if (cell) {
                if (this.grid.rowEditable && this.isRowInEditMode(rowIndex)) {
                    this.moveNextEditable(cell, rowIndex, visibleColumnIndex);
                    return;
                }
                this.onKeydownArrowRight(cell, rowIndex, visibleColumnIndex, isSummaryRow);
            }
        }
    };
    /**
     * @param {?=} toStart
     * @return {?}
     */
    IgxGridNavigationService.prototype.moveFocusToFilterCell = /**
     * @param {?=} toStart
     * @return {?}
     */
    function (toStart) {
        if (this.grid.filteringService.isFilterRowVisible) {
            this.grid.filteringService.focusFilterRowCloseButton();
            return;
        }
        /** @type {?} */
        var columns = this.grid.filteringService.unpinnedFilterableColumns;
        /** @type {?} */
        var targetIndex = toStart ? 0 : columns.length - 1;
        /** @type {?} */
        var visibleIndex = columns[targetIndex].visibleIndex;
        /** @type {?} */
        var isVisible = toStart ? this.isColumnLeftFullyVisible(visibleIndex) : this.isColumnFullyVisible(visibleIndex);
        if (isVisible) {
            this.grid.filteringService.focusFilterCellChip(columns[targetIndex], false);
        }
        else {
            this.grid.filteringService.scrollToFilterCell(columns[targetIndex], false);
        }
    };
    /**
     * @param {?} column
     * @param {?} eventArgs
     * @return {?}
     */
    IgxGridNavigationService.prototype.navigatePrevFilterCell = /**
     * @param {?} column
     * @param {?} eventArgs
     * @return {?}
     */
    function (column, eventArgs) {
        /** @type {?} */
        var cols = this.grid.filteringService.unpinnedFilterableColumns;
        /** @type {?} */
        var prevFilterableIndex = cols.indexOf(column) - 1;
        /** @type {?} */
        var visibleIndex = column.visibleIndex;
        if (visibleIndex === 0 || prevFilterableIndex < 0) {
            // prev is not filter cell
            /** @type {?} */
            var firstFiltarableCol = this.getFirstPinnedFilterableColumn();
            if (!firstFiltarableCol || column === firstFiltarableCol) {
                eventArgs.preventDefault();
            }
            return;
        }
        /** @type {?} */
        var prevColumn = cols[prevFilterableIndex];
        /** @type {?} */
        var prevVisibleIndex = prevColumn.visibleIndex;
        if (prevFilterableIndex >= 0 && visibleIndex > 0 && !this.isColumnLeftFullyVisible(prevVisibleIndex) && !column.pinned) {
            eventArgs.preventDefault();
            this.grid.filteringService.scrollToFilterCell(prevColumn, false);
        }
    };
    /**
     * @param {?} eventArgs
     * @return {?}
     */
    IgxGridNavigationService.prototype.navigateFirstCellIfPossible = /**
     * @param {?} eventArgs
     * @return {?}
     */
    function (eventArgs) {
        if (this.grid.rowList.length > 0) {
            if (this.grid.rowList.filter(function (row) { return row instanceof IgxGridGroupByRowComponent; }).length > 0) {
                eventArgs.stopPropagation();
                return;
            }
            this.goToFirstCell();
        }
        else if (this.grid.rootSummariesEnabled) {
            this.onKeydownHome(0, true);
        }
        eventArgs.preventDefault();
    };
    /**
     * @param {?} column
     * @param {?} eventArgs
     * @return {?}
     */
    IgxGridNavigationService.prototype.navigateNextFilterCell = /**
     * @param {?} column
     * @param {?} eventArgs
     * @return {?}
     */
    function (column, eventArgs) {
        /** @type {?} */
        var cols = this.grid.filteringService.unpinnedFilterableColumns;
        /** @type {?} */
        var nextFilterableIndex = cols.indexOf(column) + 1;
        if (nextFilterableIndex >= this.grid.filteringService.unpinnedFilterableColumns.length) {
            // next is not filter cell
            this.navigateFirstCellIfPossible(eventArgs);
            return;
        }
        /** @type {?} */
        var nextColumn = cols[nextFilterableIndex];
        /** @type {?} */
        var nextVisibleIndex = nextColumn.visibleIndex;
        if (!column.pinned && !this.isColumnFullyVisible(nextVisibleIndex)) {
            eventArgs.preventDefault();
            this.grid.filteringService.scrollToFilterCell(nextColumn, true);
        }
        else if (column === this.getLastPinnedFilterableColumn() && !this.isColumnFullyVisible(nextVisibleIndex)) {
            this.grid.filteringService.scrollToFilterCell(nextColumn, false);
            eventArgs.stopPropagation();
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxGridNavigationService.prototype.getLastPinnedFilterableColumn = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var pinnedFilterableColums = this.grid.pinnedColumns.filter(function (col) { return !(col.columnGroup) && col.filterable; });
        return pinnedFilterableColums[pinnedFilterableColums.length - 1];
    };
    /**
     * @private
     * @return {?}
     */
    IgxGridNavigationService.prototype.getFirstPinnedFilterableColumn = /**
     * @private
     * @return {?}
     */
    function () {
        return this.grid.pinnedColumns.filter(function (col) { return !(col.columnGroup) && col.filterable; })[0];
    };
    /**
     * @param {?} currentRowEl
     * @param {?} rowIndex
     * @param {?} visibleColumnIndex
     * @param {?=} isSummary
     * @return {?}
     */
    IgxGridNavigationService.prototype.performShiftTabKey = /**
     * @param {?} currentRowEl
     * @param {?} rowIndex
     * @param {?} visibleColumnIndex
     * @param {?=} isSummary
     * @return {?}
     */
    function (currentRowEl, rowIndex, visibleColumnIndex, isSummary) {
        if (isSummary === void 0) { isSummary = false; }
        if (isSummary && rowIndex === 0 && visibleColumnIndex === 0 && this.grid.rowList.length) {
            this.goToLastBodyElement();
            return;
        }
        if (visibleColumnIndex === 0) {
            if (this.isRowInEditMode(rowIndex)) {
                this.grid.rowEditTabs.last.element.nativeElement.focus();
                return;
            }
            if (rowIndex === 0 && this.grid.allowFiltering && this.grid.filterMode === FilterMode.quickFilter) {
                this.moveFocusToFilterCell();
            }
            else {
                this.navigateUp(currentRowEl, rowIndex, this.grid.unpinnedColumns[this.grid.unpinnedColumns.length - 1].visibleIndex);
            }
        }
        else {
            /** @type {?} */
            var cell = this.getCellElementByVisibleIndex(rowIndex, visibleColumnIndex, isSummary);
            if (cell) {
                if (this.grid.rowEditable && this.isRowInEditMode(rowIndex)) {
                    this.movePreviousEditable(rowIndex, visibleColumnIndex);
                    return;
                }
                this.onKeydownArrowLeft(cell, rowIndex, visibleColumnIndex, isSummary);
            }
        }
    };
    /**
     * @param {?} targetRowIndex
     * @return {?}
     */
    IgxGridNavigationService.prototype.shouldPerformVerticalScroll = /**
     * @param {?} targetRowIndex
     * @return {?}
     */
    function (targetRowIndex) {
        /** @type {?} */
        var containerTopOffset = parseInt(this.verticalDisplayContainerElement.style.top, 10);
        /** @type {?} */
        var targetRow = this.grid.summariesRowList.filter(function (s) { return s.index !== 0; })
            .concat(this.grid.rowList.toArray()).find(function (r) { return r.index === targetRowIndex; });
        /** @type {?} */
        var rowHeight = this.grid.verticalScrollContainer.getSizeAt(targetRowIndex);
        /** @type {?} */
        var containerHeight = this.grid.calcHeight ? Math.ceil(this.grid.calcHeight) : 0;
        /** @type {?} */
        var targetEndTopOffset = targetRow ? targetRow.nativeElement.offsetTop + rowHeight + containerTopOffset :
            containerHeight + rowHeight;
        if (!targetRow || targetRow.nativeElement.offsetTop < Math.abs(containerTopOffset)
            || containerHeight && containerHeight < targetEndTopOffset) {
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * @private
     * @param {?} rowIndex
     * @param {?} visibleColumnIndex
     * @param {?=} isSummary
     * @return {?}
     */
    IgxGridNavigationService.prototype.performHorizontalScrollToCell = /**
     * @private
     * @param {?} rowIndex
     * @param {?} visibleColumnIndex
     * @param {?=} isSummary
     * @return {?}
     */
    function (rowIndex, visibleColumnIndex, isSummary) {
        var _this = this;
        if (isSummary === void 0) { isSummary = false; }
        /** @type {?} */
        var unpinnedIndex = this.getColumnUnpinnedIndex(visibleColumnIndex);
        this.grid.nativeElement.focus({ preventScroll: true });
        this.grid.parentVirtDir.onChunkLoad
            .pipe(first())
            .subscribe(function () {
            _this.getCellElementByVisibleIndex(rowIndex, visibleColumnIndex, isSummary).focus({ preventScroll: true });
        });
        this.horizontalScroll(rowIndex).scrollTo(unpinnedIndex);
    };
    /**
     * @protected
     * @param {?} index
     * @param {?=} selector
     * @return {?}
     */
    IgxGridNavigationService.prototype.getRowByIndex = /**
     * @protected
     * @param {?} index
     * @param {?=} selector
     * @return {?}
     */
    function (index, selector) {
        if (selector === void 0) { selector = this.getRowSelector(); }
        return this.grid.nativeElement.querySelector(selector + "[data-rowindex=\"" + index + "\"]");
    };
    /**
     * @protected
     * @param {?} nextIndex
     * @return {?}
     */
    IgxGridNavigationService.prototype.getNextRowByIndex = /**
     * @protected
     * @param {?} nextIndex
     * @return {?}
     */
    function (nextIndex) {
        return this.grid.tbody.nativeElement.querySelector("[data-rowindex=\"" + nextIndex + "\"]");
    };
    /**
     * @private
     * @return {?}
     */
    IgxGridNavigationService.prototype.getAllRows = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var selector = this.getRowSelector();
        return this.grid.nativeElement.querySelectorAll(selector);
    };
    /**
     * @protected
     * @param {?=} visibleIndex
     * @param {?=} isSummary
     * @return {?}
     */
    IgxGridNavigationService.prototype.getCellSelector = /**
     * @protected
     * @param {?=} visibleIndex
     * @param {?=} isSummary
     * @return {?}
     */
    function (visibleIndex, isSummary) {
        if (isSummary === void 0) { isSummary = false; }
        return isSummary ? 'igx-grid-summary-cell' : 'igx-grid-cell';
    };
    /**
     * @protected
     * @return {?}
     */
    IgxGridNavigationService.prototype.getRowSelector = /**
     * @protected
     * @return {?}
     */
    function () {
        return 'igx-grid-row';
    };
    IgxGridNavigationService.decorators = [
        { type: Injectable }
    ];
    return IgxGridNavigationService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxRowEditTemplateDirective = /** @class */ (function () {
    function IgxRowEditTemplateDirective() {
    }
    IgxRowEditTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxRowEdit]'
                },] }
    ];
    return IgxRowEditTemplateDirective;
}());
/**
 * @hidden
 */
var IgxRowEditTextDirective = /** @class */ (function () {
    function IgxRowEditTextDirective() {
    }
    IgxRowEditTextDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxRowEditText]'
                },] }
    ];
    return IgxRowEditTextDirective;
}());
/**
 * @hidden
 */
var IgxRowEditActionsDirective = /** @class */ (function () {
    function IgxRowEditActionsDirective() {
    }
    IgxRowEditActionsDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxRowEditActions]'
                },] }
    ];
    return IgxRowEditActionsDirective;
}());
// TODO: Refactor circular ref, deps and logic
/**
 * @hidden
 */
var IgxRowEditTabStopDirective = /** @class */ (function () {
    function IgxRowEditTabStopDirective(grid, element, navigationService) {
        this.element = element;
        this.grid = grid;
        this.navigationService = navigationService;
        this.navigationService.grid = grid;
    }
    Object.defineProperty(IgxRowEditTabStopDirective.prototype, "allTabs", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return this.grid.rowEditTabs;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} event
     * @return {?}
     */
    IgxRowEditTabStopDirective.prototype.handleTab = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.stopPropagation();
        if (this.allTabs.length > 1) {
            if ((this.allTabs.last === this && !event.shiftKey) ||
                (this.allTabs.first === this && event.shiftKey)) {
                this.move(event);
            }
        }
        else {
            this.move(event);
        }
    };
    /**
     * @private
     * @param {?} rowIndex
     * @param {?} cellIndex
     * @return {?}
     */
    IgxRowEditTabStopDirective.prototype.focusNextCell = /**
     * @private
     * @param {?} rowIndex
     * @param {?} cellIndex
     * @return {?}
     */
    function (rowIndex, cellIndex) {
        /** @type {?} */
        var grid = (/** @type {?} */ (this.grid));
        grid.parentVirtDir.onChunkLoad.pipe(first(), tap(function () { return grid.markForCheck(); })).subscribe(function () {
            grid.rowInEditMode.cells.find(function (c) { return c.visibleColumnIndex === cellIndex; }).element.nativeElement.focus();
        });
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    IgxRowEditTabStopDirective.prototype.move = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        /** @type {?} */
        var horizontalScroll = this.grid.parentVirtDir.getHorizontalScroll();
        /** @type {?} */
        var targetIndex = event.shiftKey ? this.grid.lastEditableColumnIndex : this.grid.firstEditableColumnIndex;
        /** @type {?} */
        var targetCell = this.grid.rowInEditMode.cells.find(function (e) { return e.visibleColumnIndex === targetIndex; });
        if (!targetCell ||
            !this.navigationService.isColumnFullyVisible(targetIndex)
            || !this.navigationService.isColumnLeftFullyVisible(targetIndex)) {
            this.focusNextCell(this.grid.rowInEditMode.index, targetIndex);
            horizontalScroll.scrollLeft =
                this.grid.rowInEditMode.virtDirRow.getColumnScrollLeft(this.navigationService.getColumnUnpinnedIndex(targetIndex));
        }
        else {
            targetCell.nativeElement.focus();
        }
    };
    IgxRowEditTabStopDirective.decorators = [
        { type: Directive, args: [{
                    selector: "[igxRowEditTabStop]"
                },] }
    ];
    /** @nocollapse */
    IgxRowEditTabStopDirective.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [forwardRef(function () { return IgxGridBaseComponent; }),] }] },
        { type: ElementRef },
        { type: undefined, decorators: [{ type: Inject, args: [forwardRef(function () { return IgxGridNavigationService; }),] }] }
    ]; };
    IgxRowEditTabStopDirective.propDecorators = {
        handleTab: [{ type: HostListener, args: ['keydown.Tab', ["$event"],] }, { type: HostListener, args: ['keydown.Shift.Tab', ["$event"],] }]
    };
    return IgxRowEditTabStopDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/* tslint:disable */
var icons = [
    {
        name: 'add_filter',
        value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M19 15v-3h-2v3h-3v2h3v3h2v-3h3v-2h-3zM5 10h10v2H5zM2 5h16v2H2zM8 15h4v2H8z\"/>\n      </svg>"
    },
    {
        name: 'contains',
        value: "<svg xmlns=\"http://www.w3.org/2000/svg\" id=\"Layer_1\" data-name=\"Layer 1\" viewBox=\"0 0 24 24\">\n        <path d=\"M3 3v18h18V3zm16 16H5V5h14z\"/>\n        <path d=\"M12 11.3a4.39 4.39 0 0 0-2.54.63 2.07 2.07 0 0 0-.9 1.78 2.29 2.29 0 0 0 .66 1.74 2.63 2.63 0 0 0 1.89.63 2.39 2.39 0 0 0 1.32-.37 3.05 3.05 0 0 0 1-.93 3.72 3.72 0 0 0 .08.57c0 .19.1.38.16.58h1.79a4.51 4.51 0 0 1-.21-.88 5.57 5.57 0 0 1-.07-.93v-3.5a2.44 2.44 0 0 0-.84-2 3.34 3.34 0 0 0-2.22-.7 3.54 3.54 0 0 0-2.3.72A1.93 1.93 0 0 0 9 10.29h1.71a.93.93 0 0 1 .29-.71 1.5 1.5 0 0 1 1-.29 1.45 1.45 0 0 1 1 .35 1.3 1.3 0 0 1 .37 1v.69zm1.4 1.08v1.17a1.61 1.61 0 0 1-.71.77 2.27 2.27 0 0 1-1.21.34 1.18 1.18 0 0 1-.84-.27.92.92 0 0 1-.3-.72 1.16 1.16 0 0 1 .44-.9 1.76 1.76 0 0 1 1.22-.39z\"/>\n      </svg>"
    },
    {
        name: 'does_not_contain',
        value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M21,19.74V3H4.26L2.89,1.63,1.63,2.92,3,4.29V21H19.73l1.37,1.37,1.27-1.26ZM5,19V6.28l5.28,5.27a3.19,3.19,0,0,0-.81.38,2.07,2.07,0,0,0-.9,1.78,2.29,2.29,0,0,0,.66,1.74,2.63,2.63,0,0,0,1.89.63,2.39,2.39,0,0,0,1.32-.37,3.05,3.05,0,0,0,1-.93,3.72,3.72,0,0,0,.08.57c0,.19.1.38.16.58h1L17.73,19Zm5.79-6.23a1.31,1.31,0,0,1,.45-.25l1.37,1.36.28.29a1.57,1.57,0,0,1-.19.15,2.27,2.27,0,0,1-1.21.34,1.18,1.18,0,0,1-.84-.27.92.92,0,0,1-.3-.72A1.16,1.16,0,0,1,10.79,12.77Zm2.6-1.47h-.83L10.94,9.68l.08-.1a1.5,1.5,0,0,1,1-.29,1.45,1.45,0,0,1,1,.35,1.3,1.3,0,0,1,.37,1ZM19,17.74l-3.85-3.85V10.62a2.44,2.44,0,0,0-.84-2,3.34,3.34,0,0,0-2.22-.7,3.64,3.64,0,0,0-2.24.67L6.26,5H19Z\"/>\n    </svg>"
    },
    {
        name: 'all',
        value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M2 14h8v2H2zM2 6h12v2H2zM16 17l-3-3-1.5 1.5L16 20l7-7-1.5-1.5L16 17zM2 10h12v2H2z\"/>\n      </svg>\n      "
    },
    {
        name: 'empty',
        value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M5 17h2v2H5zM13 17h2v2h-2zM5 13h2v2H5zM17 17h2v2h-2zM13 5h2v2h-2zM9 17h2v2H9zM17 9h2v2h-2zM17 13h2v2h-2zM17 5h2v2h-2zM5 9h2v2H5zM5 5h2v2H5zM9 5h2v2H9z\"/>\n      </svg>"
    },
    {
        name: 'end_expression',
        value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M13.14 6.76L17.49 12l-4.35 5.24 1.54 1.28L20.09 12l-5.41-6.52-1.54 1.28z\"/>\n        <path d=\"M11.91 11h2v2h-2zM7.91 11h2v2h-2zM3.91 11h2v2h-2z\"/>\n      </svg>"
    },
    {
        name: 'ends_with',
        value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M3 14.5h2v2H3zM11 14.5h2v2h-2zM7 14.5h2v2H7zM20.8 14.8v-3A2.1 2.1 0 0 0 20 10a3 3 0 0 0-2-.6 3 3 0 0 0-2 .6 1.7 1.7 0 0 0-.7 1.5h1.5a.8.8 0 0 1 .3-.7 1.3 1.3 0 0 1 .9-.3 1.3 1.3 0 0 1 .9.4 1.1 1.1 0 0 1 .3.8v.6H18a3.8 3.8 0 0 0-2.2.6 1.8 1.8 0 0 0-.8 1.5 2 2 0 0 0 .6 1.6 2.3 2.3 0 0 0 1.6.6 2.1 2.1 0 0 0 1.2-.4 2.8 2.8 0 0 0 .8-.8 4.3 4.3 0 0 0 .1.5l.1.5H21a4.1 4.1 0 0 1-.2-.7 5.4 5.4 0 0 1 0-1zm-1.6-.5a1.5 1.5 0 0 1-.6.7 2 2 0 0 1-1 .2 1.1 1.1 0 0 1-.8-.2.8.8 0 0 1-.2-.6 1 1 0 0 1 .3-.8 1.5 1.5 0 0 1 1.1-.3h1.2z\"/>\n      </svg>"
    },
    {
        name: 'equals',
        value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M5 13.5h14v2H5zM5 8.5h14v2H5z\"/>\n      </svg>"
    },
    {
        name: 'greater_than_or_equal',
        value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M5.99 19h12.02v2H5.99zM18 9.47L6 3v2.11L15.09 10 6 14.9v2.11l12-6.47V9.47z\"/>\n      </svg>"
    },
    {
        name: 'greater_than',
        value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M6 7.11L15.09 12 6 16.89V19l12-6.46v-1.08L6 5v2.11z\"/>\n      </svg>\n      "
    },
    {
        name: 'is_after',
        value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M15 7h4v10h-4v2h6V5h-6v2zM11 3h2v18h-2zM7 5h2v2H7zM3 5h2v2H3zM3 17h2v2H3zM3 13h2v2H3zM3 9h2v2H3zM7 17h2v2H7z\"/>\n      </svg>"
    },
    {
        name: 'is_before',
        value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M3 19h6v-2H5V7h4V5H3v14zM11 3h2v18h-2zM15 5h2v2h-2zM19 5h2v2h-2zM19 13h2v2h-2zM15 17h2v2h-2zM19 17h2v2h-2zM19 9h2v2h-2z\"/>\n      </svg>"
    },
    {
        name: 'is_false',
        value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M8 5a7 7 0 1 0 7 7 7 7 0 0 0-7-7zm4.31 9.79l-1.52 1.52L8 13.52l-2.79 2.79-1.52-1.52L6.48 12 3.69 9.21l1.52-1.52L8 10.48l2.79-2.79 1.52 1.52L9.52 12zM18 7a5 5 0 0 0-3 1.06 7.48 7.48 0 0 1 .49 1 3.89 3.89 0 1 1 0 5.82 8.08 8.08 0 0 1-.49 1A5 5 0 1 0 18 7z\"/>\n        <path d=\"M17.52 13.85l2.91-2.92-.78-.78-2.13 2.12-1.17-1.15-.38.37-.41.41.42.42L17 13.34l.52.51z\"/>\n      </svg>"
    },
    {
        name: 'is_not_null',
        value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M16.58 6.07l.79-1.36-1.74-1-.78 1.35a7.5 7.5 0 0 0-7.43 12.87l-.79 1.36 1.74 1 .78-1.35a7.5 7.5 0 0 0 7.43-12.87zM6.5 12A5.5 5.5 0 0 1 12 6.5a5.65 5.65 0 0 1 1.84.32l-5.41 9.36A5.49 5.49 0 0 1 6.5 12zm5.5 5.5a5.65 5.65 0 0 1-1.84-.32l5.41-9.36A5.5 5.5 0 0 1 12 17.5z\"/>\n      </svg>"
    },
    {
        name: 'is_null',
        value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M12 4.5a7.5 7.5 0 1 0 7.5 7.5A7.5 7.5 0 0 0 12 4.5zm0 13a5.5 5.5 0 1 1 5.5-5.5 5.5 5.5 0 0 1-5.5 5.5z\"/>\n      </svg>"
    },
    {
        name: 'is_true',
        value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M19.44 14.22zM16.56 14.22zM16.56 14.22L18 12.79l1.44 1.43.78-.78L18.79 12l1.43-1.44-.78-.78L18 11.21l-1.44-1.43-.78.78L17.21 12l-1.43 1.44.78.78z\"/>\n        <path d=\"M18 7a5 5 0 0 0-3 1.06 7.48 7.48 0 0 1 .49 1 3.89 3.89 0 1 1 0 5.82 8.08 8.08 0 0 1-.49 1A5 5 0 1 0 18 7zM8 5a7 7 0 1 0 7 7 7 7 0 0 0-7-7zm-.93 10.18l-3.38-3.37 1.13-1.12 2.25 2.25 4.11-4.12 1.13 1.12z\"/>\n      </svg>"
    },
    {
        name: 'last_month',
        value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M17.5 14a4.48 4.48 0 1 0 4.5 4.5 4.47 4.47 0 0 0-4.5-4.5zm3.5 5.5h-4v2l-3-3 3-3v2h4zM5 9h2v2H5zM5 13h2v2H5zM10 13h2v2h-2zM5 17h2v2H5zM10 17h2v2h-2zM10 9h2v2h-2zM15 9h2v2h-2z\"/>\n        <path d=\"M4 8h14v4h2V5a2 2 0 0 0-2-2h-1V1h-2v2H7V1H5v2H4a2 2 0 0 0-2 2v15a2 2 0 0 0 2 2h7v-2H4z\"/>\n      </svg>"
    },
    {
        name: 'last_year',
        value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M21 10v11H7v2h14a2 2 0 0 0 2-2V10z\"/>\n        <path d=\"M19 17V5a2 2 0 0 0-2-2h-1V1h-2v2H6V1H4v2H3a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2zM3 17V7h14v10H3z\"/>\n        <path d=\"M8.87 9l-2.99 3 2.99 3v-2.25h5.26v-1.5H8.87V9z\"/>\n      </svg>"
    },
    {
        name: 'less_than_or_equal',
        value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M5.99 19h12.02v2H5.99zM18 14.9L8.91 10 18 5.11V3L6 9.47v1.07l12 6.47V14.9z\"/>\n      </svg>"
    },
    {
        name: 'less_than',
        value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M6 12.54L18 19v-2.11L8.91 12 18 7.11V5L6 11.46v1.08z\"/>\n      </svg>"
    },
    {
        name: 'next_month',
        value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M20 14.76a4.5 4.5 0 1 0 2 3.74 4.47 4.47 0 0 0-2-3.74zm-2 6.74v-2h-4v-2h4v-2l3 3zM5 9h2v2H5zM5 13h2v2H5zM10 13h2v2h-2zM5 17h2v2H5zM10 17h2v2h-2zM10 9h2v2h-2zM15 9h2v2h-2z\"/>\n        <path d=\"M4 8h14v4h2V5a2 2 0 0 0-2-2h-1V1h-2v2H7V1H5v2H4a2 2 0 0 0-2 2v15a2 2 0 0 0 2 2h7v-2H4z\"/>\n      </svg>"
    },
    {
        name: 'next_year',
        value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M21 21H7v2h14a2 2 0 0 0 2-2V10h-2z\"/>\n        <path d=\"M19 17V5a2 2 0 0 0-2-2h-1V1h-2v2H6V1H4v2H3a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2zM3 17V7h14v10H3z\"/>\n        <path d=\"M11.13 11.25H5.88v1.5h5.25V15l3-3-3-3v2.25z\"/>\n      </svg>"
    },
    {
        name: 'not_empty',
        value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M5 9h2v2H5zM9 17h2v2H9zM13 17h2v2h-2zM17 9h2v2h-2zM17 5h2v2h-2zM5 17h2v2H5zM13 5h2v2h-2zM5 13h2v2H5zM19 15v-2h-2v.47L18.53 15H19zM11 7V5H9v.46L10.54 7H11zM2.76 1.76L1.5 3.06 20.97 22.5l1.26-1.26-8.89-8.89L2.76 1.76z\"/>\n      </svg>"
    },
    {
        name: 'not_equal',
        value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M17.37 4.71l-1.74-1-2.76 4.79H5v2h6.71l-1.73 3H5v2h3.82l-2.19 3.79 1.74 1 2.76-4.79H19v-2h-6.71l1.73-3H19v-2h-3.82l2.19-3.79z\"/>\n      </svg>"
    },
    {
        name: 'start_expression',
        value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M18.1 11h2v2h-2zM10.1 11h2v2h-2z\"/>\n        <path d=\"M10.9 6.8L9.3 5.5 4 12l5.4 6.5 1.6-1.3L6.5 12 11 6.8zM14.1 11h2v2h-2z\"/>\n      </svg>"
    },
    {
        name: 'starts_with',
        value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path fill=\"none\" d=\"M4.97 13.23h3.06L6.5 9.12l-1.53 4.11z\"/>\n        <path d=\"M5.89 7.5L2 16.5h1.72l.73-1.8h4.1l.73 1.8H11l-3.89-9zM5 13.23l1.5-4.11L8 13.23zM12 14.5h2v2h-2zM20 14.5h2v2h-2zM16 14.5h2v2h-2z\"/>\n      </svg>"
    },
    {
        name: 'this_month',
        value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M6 9h2v2H6zM6 13h2v2H6zM11 13h2v2h-2zM6 17h2v2H6zM11 17h2v2h-2zM11 9h2v2h-2zM16 9h2v2h-2zM21 14.76a4.5 4.5 0 1 0 2 3.74 4.47 4.47 0 0 0-2-3.74zm-2.94 5.41l-1.75-1.76.69-.71 1.05 1L20 16.83l.71.71z\"/>\n        <path d=\"M5 8h14v4h2V5a2 2 0 0 0-2-2h-1V1h-2v2H8V1H6v2H5a2 2 0 0 0-2 2v15a2 2 0 0 0 2 2h7v-2H5z\"/>\n      </svg>"
    },
    {
        name: 'this_year',
        value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M21 21H7v2h14a2 2 0 0 0 2-2V10h-2z\"/>\n        <path d=\"M19 17V5a2 2 0 0 0-2-2h-1V1h-2v2H6V1H4v2H3a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2zM3 17V7h14v10H3z\"/>\n        <path d=\"M8.85 13.15l-1.77-1.77-.88.89 2.65 2.65 4.95-4.96-.88-.88-4.07 4.07z\"/>\n      </svg>"
    },
    {
        name: 'today',
        value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M19 4h-1V2h-2v2H8V2H6v2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2zm0 16H5V9h14z\"/>\n        <path d=\"M16.53 12.06L15.47 11l-4.88 4.88-2.12-2.12-1.06 1.06L10.59 18l5.94-5.94z\"/>\n      </svg>"
    },
    {
        name: 'ungroup',
        value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M15 15h5v5h-5zM6 13h5v5H6zM13 6h5v5h-5zM6 6h5v5H6z\"/>\n        <path d=\"M20 2H4a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h9v-2H4V4h16v9h2V4a2 2 0 0 0-2-2z\"/>\n      </svg>"
    },
    {
        name: 'yesterday',
        value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M10.68 15.38h6.13v-1.75h-6.13V11l-3.49 3.5 3.49 3.5v-2.62z\"/>\n        <path d=\"M19 4h-1V2h-2v2H8V2H6v2H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2zm0 16H5V9h14z\"/>\n      </svg>"
    },
    {
        name: 'pin',
        value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path d=\"M15.18 2.25l7.07 7.07-2.83-.01-3.54 3.55.01 4.24-3.53-3.54-5.66 5.66H5.28V17.8l5.66-5.66L7.4 8.61l4.24.01 3.55-3.54-.01-2.83z\"/>\n      </svg>"
    },
    {
        name: 'unpin',
        value: "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n        <path fill=\"none\" d=\"M0 0h24v25H0V0z\"/>\n        <path d=\"M11.84 14.08L6.7 19.22H5.28V17.8l5.14-5.14L2 4.26 3.29 3l18 18L20 22.21zm4-.49l-5-5h.73l3.55-3.54v-2.8l7.07 7.07h-2.77l-3.54 3.54z\" />\n      </svg>"
    }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxGridSortingPipe = /** @class */ (function () {
    function IgxGridSortingPipe(gridAPI) {
        this.gridAPI = (/** @type {?} */ (gridAPI));
    }
    /**
     * @param {?} collection
     * @param {?} expressions
     * @param {?} id
     * @param {?} pipeTrigger
     * @return {?}
     */
    IgxGridSortingPipe.prototype.transform = /**
     * @param {?} collection
     * @param {?} expressions
     * @param {?} id
     * @param {?} pipeTrigger
     * @return {?}
     */
    function (collection, expressions, id, pipeTrigger) {
        /** @type {?} */
        var grid = this.gridAPI.grid;
        /** @type {?} */
        var result;
        if (!expressions.length) {
            result = collection;
        }
        else {
            result = DataUtil.sort(cloneArray(collection), expressions);
        }
        grid.filteredSortedData = result;
        return result;
    };
    IgxGridSortingPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'gridSort',
                    pure: true
                },] }
    ];
    /** @nocollapse */
    IgxGridSortingPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };
    return IgxGridSortingPipe;
}());
/**
 * @hidden
 */
var IgxGridPreGroupingPipe = /** @class */ (function () {
    function IgxGridPreGroupingPipe(gridAPI) {
        this.gridAPI = (/** @type {?} */ (gridAPI));
    }
    /**
     * @param {?} collection
     * @param {?} expression
     * @param {?} expansion
     * @param {?} defaultExpanded
     * @param {?} id
     * @param {?} groupsRecords
     * @param {?} pipeTrigger
     * @return {?}
     */
    IgxGridPreGroupingPipe.prototype.transform = /**
     * @param {?} collection
     * @param {?} expression
     * @param {?} expansion
     * @param {?} defaultExpanded
     * @param {?} id
     * @param {?} groupsRecords
     * @param {?} pipeTrigger
     * @return {?}
     */
    function (collection, expression, expansion, defaultExpanded, id, groupsRecords, pipeTrigger) {
        /** @type {?} */
        var state$$1 = { expressions: [], expansion: [], defaultExpanded: defaultExpanded };
        /** @type {?} */
        var grid = this.gridAPI.grid;
        state$$1.expressions = grid.groupingExpressions;
        if (!state$$1.expressions.length) {
            // empty the array without changing reference
            groupsRecords.splice(0, groupsRecords.length);
            return {
                data: collection,
                metadata: collection
            };
        }
        state$$1.expansion = grid.groupingExpansionState;
        state$$1.defaultExpanded = grid.groupsExpanded;
        return DataUtil.group(cloneArray(collection), state$$1, grid, groupsRecords);
    };
    IgxGridPreGroupingPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'gridPreGroupBy',
                    pure: true
                },] }
    ];
    /** @nocollapse */
    IgxGridPreGroupingPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };
    return IgxGridPreGroupingPipe;
}());
/**
 * @hidden
 */
var IgxGridPostGroupingPipe = /** @class */ (function () {
    function IgxGridPostGroupingPipe(gridAPI) {
        this.gridAPI = (/** @type {?} */ (gridAPI));
    }
    /**
     * @param {?} collection
     * @param {?} expression
     * @param {?} expansion
     * @param {?} defaultExpanded
     * @param {?} id
     * @param {?} pipeTrigger
     * @return {?}
     */
    IgxGridPostGroupingPipe.prototype.transform = /**
     * @param {?} collection
     * @param {?} expression
     * @param {?} expansion
     * @param {?} defaultExpanded
     * @param {?} id
     * @param {?} pipeTrigger
     * @return {?}
     */
    function (collection, expression, expansion, defaultExpanded, id, pipeTrigger) {
        /** @type {?} */
        var state$$1 = { expressions: [], expansion: [], defaultExpanded: defaultExpanded };
        /** @type {?} */
        var grid = this.gridAPI.grid;
        state$$1.expressions = grid.groupingExpressions;
        if (!state$$1.expressions.length) {
            return collection.data;
        }
        state$$1.expansion = grid.groupingExpansionState;
        state$$1.defaultExpanded = grid.groupsExpanded;
        return DataUtil.restoreGroups({
            data: cloneArray(collection.data),
            metadata: cloneArray(collection.metadata)
        }, state$$1);
    };
    IgxGridPostGroupingPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'gridPostGroupBy',
                    pure: true
                },] }
    ];
    /** @nocollapse */
    IgxGridPostGroupingPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };
    return IgxGridPostGroupingPipe;
}());
/**
 * @hidden
 */
var IgxGridPagingPipe = /** @class */ (function () {
    function IgxGridPagingPipe(gridAPI) {
        this.gridAPI = gridAPI;
    }
    /**
     * @param {?} collection
     * @param {?=} page
     * @param {?=} perPage
     * @param {?=} id
     * @param {?=} pipeTrigger
     * @return {?}
     */
    IgxGridPagingPipe.prototype.transform = /**
     * @param {?} collection
     * @param {?=} page
     * @param {?=} perPage
     * @param {?=} id
     * @param {?=} pipeTrigger
     * @return {?}
     */
    function (collection, page, perPage, id, pipeTrigger) {
        if (page === void 0) { page = 0; }
        if (perPage === void 0) { perPage = 15; }
        if (!this.gridAPI.grid.paging) {
            return collection;
        }
        /** @type {?} */
        var state$$1 = {
            index: page,
            recordsPerPage: perPage
        };
        /** @type {?} */
        var result = {
            data: DataUtil.page(cloneArray(collection.data), state$$1),
            metadata: DataUtil.page(cloneArray(collection.metadata), state$$1)
        };
        this.gridAPI.grid.pagingState = state$$1;
        return result;
    };
    IgxGridPagingPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'gridPaging',
                    pure: true
                },] }
    ];
    /** @nocollapse */
    IgxGridPagingPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };
    return IgxGridPagingPipe;
}());
/**
 * @hidden
 */
var IgxGridFilteringPipe = /** @class */ (function () {
    function IgxGridFilteringPipe(gridAPI) {
        this.gridAPI = gridAPI;
    }
    /**
     * @param {?} collection
     * @param {?} expressionsTree
     * @param {?} id
     * @param {?} pipeTrigger
     * @return {?}
     */
    IgxGridFilteringPipe.prototype.transform = /**
     * @param {?} collection
     * @param {?} expressionsTree
     * @param {?} id
     * @param {?} pipeTrigger
     * @return {?}
     */
    function (collection, expressionsTree, id, pipeTrigger) {
        /** @type {?} */
        var grid = this.gridAPI.grid;
        /** @type {?} */
        var state$$1 = { expressionsTree: expressionsTree };
        if (!state$$1.expressionsTree ||
            !state$$1.expressionsTree.filteringOperands ||
            state$$1.expressionsTree.filteringOperands.length === 0) {
            return collection;
        }
        /** @type {?} */
        var result = DataUtil.filter(cloneArray(collection), state$$1);
        grid.filteredData = result;
        return result;
    };
    IgxGridFilteringPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'gridFiltering',
                    pure: true
                },] }
    ];
    /** @nocollapse */
    IgxGridFilteringPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };
    return IgxGridFilteringPipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var FILTERING_ICONS_FONT_SET = 'filtering-icons';
/**
 * @hidden
 */
var /**
 * @hidden
 */
ExpressionUI = /** @class */ (function () {
    function ExpressionUI() {
        this.isSelected = false;
        this.isVisible = true;
    }
    return ExpressionUI;
}());
/**
 * @hidden
 */
var IgxFilteringService = /** @class */ (function () {
    function IgxFilteringService(gridAPI, iconService) {
        this.gridAPI = gridAPI;
        this.iconService = iconService;
        this.columnsWithComplexFilter = new Set();
        this.areEventsSubscribed = false;
        this.destroy$ = new Subject();
        this.isFiltering = false;
        this.columnToExpressionsMap = new Map();
        this.columnStartIndex = -1;
        this.isFilterRowVisible = false;
        this.filteredColumn = null;
        this.selectedExpression = null;
        this.columnToFocus = null;
        this.shouldFocusNext = false;
        this.columnToMoreIconHidden = new Map();
    }
    /**
     * @return {?}
     */
    IgxFilteringService.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.destroy$.next(true);
        this.destroy$.complete();
    };
    Object.defineProperty(IgxFilteringService.prototype, "displayContainerWidth", {
        get: /**
         * @return {?}
         */
        function () {
            return parseInt(this.grid.parentVirtDir.dc.instance._viewContainer.element.nativeElement.offsetWidth, 10);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxFilteringService.prototype, "displayContainerScrollLeft", {
        get: /**
         * @return {?}
         */
        function () {
            return parseInt(this.grid.parentVirtDir.getHorizontalScroll().scrollLeft, 10);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxFilteringService.prototype, "areAllColumnsInView", {
        get: /**
         * @return {?}
         */
        function () {
            return parseInt(this.grid.parentVirtDir.dc.instance._viewContainer.element.nativeElement.offsetWidth, 10) === 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxFilteringService.prototype, "unpinnedFilterableColumns", {
        get: /**
         * @return {?}
         */
        function () {
            return this.grid.unpinnedColumns.filter(function (col) { return !col.columnGroup && col.filterable; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxFilteringService.prototype, "unpinnedColumns", {
        get: /**
         * @return {?}
         */
        function () {
            return this.grid.unpinnedColumns.filter(function (col) { return !col.columnGroup; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxFilteringService.prototype, "datePipe", {
        get: /**
         * @return {?}
         */
        function () {
            if (!this._datePipe) {
                this._datePipe = new IgxDatePipeComponent(this.grid.locale);
            }
            return this._datePipe;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Subscribe to grid's events.
     */
    /**
     * Subscribe to grid's events.
     * @return {?}
     */
    IgxFilteringService.prototype.subscribeToEvents = /**
     * Subscribe to grid's events.
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.areEventsSubscribed) {
            this.areEventsSubscribed = true;
            this.grid.onColumnResized.pipe(takeUntil(this.destroy$)).subscribe(function (eventArgs) {
                _this.updateFilteringCell(eventArgs.column);
            });
            this.grid.parentVirtDir.onChunkLoad.pipe(takeUntil(this.destroy$)).subscribe(function (eventArgs) {
                if (eventArgs.startIndex !== _this.columnStartIndex) {
                    _this.columnStartIndex = eventArgs.startIndex;
                    _this.grid.filterCellList.forEach(function (filterCell) {
                        filterCell.updateFilterCellArea();
                    });
                }
                if (_this.columnToFocus) {
                    _this.focusFilterCellChip(_this.columnToFocus, false);
                    _this.columnToFocus = null;
                }
            });
            this.grid.onColumnMovingEnd.pipe(takeUntil(this.destroy$)).subscribe(function () {
                _this.grid.filterCellList.forEach(function (filterCell) {
                    filterCell.updateFilterCellArea();
                });
            });
        }
    };
    /**
     * Internal method to create expressionsTree and filter grid used in both filter modes.
     */
    /**
     * Internal method to create expressionsTree and filter grid used in both filter modes.
     * @param {?} field
     * @param {?=} expressions
     * @return {?}
     */
    IgxFilteringService.prototype.filterInternal = /**
     * Internal method to create expressionsTree and filter grid used in both filter modes.
     * @param {?} field
     * @param {?=} expressions
     * @return {?}
     */
    function (field, expressions) {
        if (expressions === void 0) { expressions = null; }
        this.isFiltering = true;
        /** @type {?} */
        var expressionsTree;
        if (expressions instanceof FilteringExpressionsTree) {
            expressionsTree = expressions;
        }
        else {
            expressionsTree = this.createSimpleFilteringTree(field, expressions);
        }
        if (expressionsTree.filteringOperands.length === 0) {
            this.clearFilter(field);
        }
        else {
            this.filter(field, null, expressionsTree);
        }
        this.isFiltering = false;
    };
    /**
     * Execute filtering on the grid.
     */
    /**
     * Execute filtering on the grid.
     * @param {?} field
     * @param {?} value
     * @param {?=} conditionOrExpressionTree
     * @param {?=} ignoreCase
     * @return {?}
     */
    IgxFilteringService.prototype.filter = /**
     * Execute filtering on the grid.
     * @param {?} field
     * @param {?} value
     * @param {?=} conditionOrExpressionTree
     * @param {?=} ignoreCase
     * @return {?}
     */
    function (field, value, conditionOrExpressionTree, ignoreCase) {
        var _this = this;
        /** @type {?} */
        var col = this.gridAPI.get_column_by_name(field);
        /** @type {?} */
        var filteringIgnoreCase = ignoreCase || (col ? col.filteringIgnoreCase : false);
        if (conditionOrExpressionTree) {
            this.gridAPI.filter(field, value, conditionOrExpressionTree, filteringIgnoreCase);
        }
        else {
            /** @type {?} */
            var expressionsTreeForColumn = this.grid.filteringExpressionsTree.find(field);
            if (expressionsTreeForColumn instanceof FilteringExpressionsTree) {
                this.gridAPI.filter(field, value, expressionsTreeForColumn, filteringIgnoreCase);
            }
            else {
                /** @type {?} */
                var expressionForColumn = (/** @type {?} */ (expressionsTreeForColumn));
                this.gridAPI.filter(field, value, expressionForColumn.condition, filteringIgnoreCase);
            }
        }
        // Wait for the change detection to update filtered data through the pipes and then emit the event.
        requestAnimationFrame(function () { return _this.grid.onFilteringDone.emit(col.filteringExpressionsTree); });
    };
    /**
     * Clear the filter of a given column.
     */
    /**
     * Clear the filter of a given column.
     * @param {?} field
     * @return {?}
     */
    IgxFilteringService.prototype.clearFilter = /**
     * Clear the filter of a given column.
     * @param {?} field
     * @return {?}
     */
    function (field) {
        var _this = this;
        if (field) {
            /** @type {?} */
            var column = this.gridAPI.get_column_by_name(field);
            if (!column) {
                return;
            }
        }
        this.isFiltering = true;
        this.gridAPI.clear_filter(field);
        // Wait for the change detection to update filtered data through the pipes and then emit the event.
        requestAnimationFrame(function () { return _this.grid.onFilteringDone.emit(null); });
        if (field) {
            /** @type {?} */
            var expressions = this.getExpressions(field);
            expressions.length = 0;
        }
        this.isFiltering = false;
    };
    /**
     * Filters all the `IgxColumnComponent` in the `IgxGridComponent` with the same condition.
     */
    /**
     * Filters all the `IgxColumnComponent` in the `IgxGridComponent` with the same condition.
     * @param {?} value
     * @param {?=} condition
     * @param {?=} ignoreCase
     * @return {?}
     */
    IgxFilteringService.prototype.filterGlobal = /**
     * Filters all the `IgxColumnComponent` in the `IgxGridComponent` with the same condition.
     * @param {?} value
     * @param {?=} condition
     * @param {?=} ignoreCase
     * @return {?}
     */
    function (value, condition, ignoreCase) {
        var _this = this;
        this.gridAPI.filter_global(value, condition, ignoreCase);
        // Wait for the change detection to update filtered data through the pipes and then emit the event.
        requestAnimationFrame(function () { return _this.grid.onFilteringDone.emit(_this.grid.filteringExpressionsTree); });
    };
    /**
     * Register filtering SVG icons in the icon service.
     */
    /**
     * Register filtering SVG icons in the icon service.
     * @return {?}
     */
    IgxFilteringService.prototype.registerSVGIcons = /**
     * Register filtering SVG icons in the icon service.
     * @return {?}
     */
    function () {
        var e_1, _a;
        try {
            for (var icons_1 = __values(icons), icons_1_1 = icons_1.next(); !icons_1_1.done; icons_1_1 = icons_1.next()) {
                var icon = icons_1_1.value;
                if (!this.iconService.isSvgIconCached(icon.name, FILTERING_ICONS_FONT_SET)) {
                    this.iconService.addSvgIconFromText(icon.name, icon.value, FILTERING_ICONS_FONT_SET);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (icons_1_1 && !icons_1_1.done && (_a = icons_1.return)) _a.call(icons_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * Returns the ExpressionUI array for a given column.
     */
    /**
     * Returns the ExpressionUI array for a given column.
     * @param {?} columnId
     * @return {?}
     */
    IgxFilteringService.prototype.getExpressions = /**
     * Returns the ExpressionUI array for a given column.
     * @param {?} columnId
     * @return {?}
     */
    function (columnId) {
        if (!this.columnToExpressionsMap.has(columnId)) {
            /** @type {?} */
            var column = this.grid.columns.find(function (col) { return col.field === columnId; });
            /** @type {?} */
            var expressionUIs = new Array();
            this.generateExpressionsList(column.filteringExpressionsTree, this.grid.filteringExpressionsTree.operator, expressionUIs);
            this.columnToExpressionsMap.set(columnId, expressionUIs);
            return expressionUIs;
        }
        return this.columnToExpressionsMap.get(columnId);
    };
    /**
     * Recreates all ExpressionUIs for all columns. Executed after filtering to refresh the cache.
     */
    /**
     * Recreates all ExpressionUIs for all columns. Executed after filtering to refresh the cache.
     * @return {?}
     */
    IgxFilteringService.prototype.refreshExpressions = /**
     * Recreates all ExpressionUIs for all columns. Executed after filtering to refresh the cache.
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.isFiltering) {
            this.columnsWithComplexFilter.clear();
            this.columnToExpressionsMap.forEach(function (value, key) {
                /** @type {?} */
                var column = _this.grid.columns.find(function (col) { return col.field === key; });
                if (column) {
                    value.length = 0;
                    _this.generateExpressionsList(column.filteringExpressionsTree, _this.grid.filteringExpressionsTree.operator, value);
                    /** @type {?} */
                    var isComplex = _this.isFilteringTreeComplex(column.filteringExpressionsTree);
                    if (isComplex) {
                        _this.columnsWithComplexFilter.add(key);
                    }
                    _this.updateFilteringCell(column);
                }
                else {
                    _this.columnToExpressionsMap.delete(key);
                }
            });
        }
    };
    /**
     * Remove an ExpressionUI for a given column.
     */
    /**
     * Remove an ExpressionUI for a given column.
     * @param {?} columnId
     * @param {?} indexToRemove
     * @return {?}
     */
    IgxFilteringService.prototype.removeExpression = /**
     * Remove an ExpressionUI for a given column.
     * @param {?} columnId
     * @param {?} indexToRemove
     * @return {?}
     */
    function (columnId, indexToRemove) {
        /** @type {?} */
        var expressionsList = this.getExpressions(columnId);
        if (indexToRemove === 0 && expressionsList.length > 1) {
            expressionsList[1].beforeOperator = null;
        }
        else if (indexToRemove === expressionsList.length - 1) {
            expressionsList[indexToRemove - 1].afterOperator = null;
        }
        else {
            expressionsList[indexToRemove - 1].afterOperator = expressionsList[indexToRemove + 1].beforeOperator;
            expressionsList[0].beforeOperator = null;
            expressionsList[expressionsList.length - 1].afterOperator = null;
        }
        expressionsList.splice(indexToRemove, 1);
    };
    /**
     * Generate filtering tree for a given column from existing ExpressionUIs.
     */
    /**
     * Generate filtering tree for a given column from existing ExpressionUIs.
     * @param {?} columnId
     * @param {?=} expressionUIList
     * @return {?}
     */
    IgxFilteringService.prototype.createSimpleFilteringTree = /**
     * Generate filtering tree for a given column from existing ExpressionUIs.
     * @param {?} columnId
     * @param {?=} expressionUIList
     * @return {?}
     */
    function (columnId, expressionUIList) {
        if (expressionUIList === void 0) { expressionUIList = null; }
        /** @type {?} */
        var expressionsList = expressionUIList ? expressionUIList : this.getExpressions(columnId);
        /** @type {?} */
        var expressionsTree = new FilteringExpressionsTree(FilteringLogic.Or, columnId);
        /** @type {?} */
        var currAndBranch;
        /** @type {?} */
        var currExpressionUI;
        for (var i = 0; i < expressionsList.length; i++) {
            currExpressionUI = expressionsList[i];
            if (!currExpressionUI.expression.condition.isUnary && currExpressionUI.expression.searchVal === null) {
                if (currExpressionUI.afterOperator === FilteringLogic.And && !currAndBranch) {
                    currAndBranch = new FilteringExpressionsTree(FilteringLogic.And, columnId);
                    expressionsTree.filteringOperands.push(currAndBranch);
                }
                continue;
            }
            if ((currExpressionUI.beforeOperator === undefined || currExpressionUI.beforeOperator === null ||
                currExpressionUI.beforeOperator === FilteringLogic.Or) &&
                currExpressionUI.afterOperator === FilteringLogic.And) {
                currAndBranch = new FilteringExpressionsTree(FilteringLogic.And, columnId);
                expressionsTree.filteringOperands.push(currAndBranch);
                currAndBranch.filteringOperands.push(currExpressionUI.expression);
            }
            else if (currExpressionUI.beforeOperator === FilteringLogic.And) {
                currAndBranch.filteringOperands.push(currExpressionUI.expression);
            }
            else {
                expressionsTree.filteringOperands.push(currExpressionUI.expression);
                currAndBranch = null;
            }
        }
        return expressionsTree;
    };
    /**
     * Returns whether a complex filter is applied to a given column.
     */
    /**
     * Returns whether a complex filter is applied to a given column.
     * @param {?} columnId
     * @return {?}
     */
    IgxFilteringService.prototype.isFilterComplex = /**
     * Returns whether a complex filter is applied to a given column.
     * @param {?} columnId
     * @return {?}
     */
    function (columnId) {
        if (this.columnsWithComplexFilter.has(columnId)) {
            return true;
        }
        /** @type {?} */
        var column = this.grid.columns.find(function (col) { return col.field === columnId; });
        /** @type {?} */
        var isComplex = this.isFilteringTreeComplex(column.filteringExpressionsTree);
        if (isComplex) {
            this.columnsWithComplexFilter.add(columnId);
        }
        return isComplex;
    };
    /**
     * Returns the string representation of the FilteringLogic operator.
     */
    /**
     * Returns the string representation of the FilteringLogic operator.
     * @param {?} operator
     * @return {?}
     */
    IgxFilteringService.prototype.getOperatorAsString = /**
     * Returns the string representation of the FilteringLogic operator.
     * @param {?} operator
     * @return {?}
     */
    function (operator) {
        if (operator === 0) {
            return this.grid.resourceStrings.igx_grid_filter_operator_and;
        }
        else {
            return this.grid.resourceStrings.igx_grid_filter_operator_or;
        }
    };
    /**
     * Generate the label of a chip from a given filtering expression.
     */
    /**
     * Generate the label of a chip from a given filtering expression.
     * @param {?} expression
     * @return {?}
     */
    IgxFilteringService.prototype.getChipLabel = /**
     * Generate the label of a chip from a given filtering expression.
     * @param {?} expression
     * @return {?}
     */
    function (expression) {
        if (expression.condition.isUnary) {
            return this.grid.resourceStrings["igx_grid_filter_" + expression.condition.name] || expression.condition.name;
        }
        else if (expression.searchVal instanceof Date) {
            return this.datePipe.transform(expression.searchVal, this.grid.locale);
        }
        else {
            return expression.searchVal;
        }
    };
    /**
     * Updates the content of a filterCell.
     */
    /**
     * Updates the content of a filterCell.
     * @param {?} column
     * @return {?}
     */
    IgxFilteringService.prototype.updateFilteringCell = /**
     * Updates the content of a filterCell.
     * @param {?} column
     * @return {?}
     */
    function (column) {
        /** @type {?} */
        var filterCell = column.filterCell;
        if (filterCell) {
            filterCell.updateFilterCellArea();
        }
    };
    /**
     * Focus a chip in a filterCell.
     */
    /**
     * Focus a chip in a filterCell.
     * @param {?} column
     * @param {?} focusFirst
     * @return {?}
     */
    IgxFilteringService.prototype.focusFilterCellChip = /**
     * Focus a chip in a filterCell.
     * @param {?} column
     * @param {?} focusFirst
     * @return {?}
     */
    function (column, focusFirst) {
        /** @type {?} */
        var filterCell = column.filterCell;
        if (filterCell) {
            filterCell.focusChip(focusFirst);
        }
    };
    /**
     * Focus the close button in the filtering row.
     */
    /**
     * Focus the close button in the filtering row.
     * @return {?}
     */
    IgxFilteringService.prototype.focusFilterRowCloseButton = /**
     * Focus the close button in the filtering row.
     * @return {?}
     */
    function () {
        this.grid.filteringRow.closeButton.nativeElement.focus();
    };
    Object.defineProperty(IgxFilteringService.prototype, "filteredData", {
        get: /**
         * @return {?}
         */
        function () {
            return this.grid.filteredData;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxFilteringService.prototype, "sortedData", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var sortData = new IgxGridSortingPipe(((/** @type {?} */ (this.grid))).gridAPI)
                .transform(this.grid.data, this.grid.sortingExpressions, this.gridId, 0);
            return sortData;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Scrolls to a filterCell.
     */
    /**
     * Scrolls to a filterCell.
     * @param {?} column
     * @param {?} shouldFocusNext
     * @return {?}
     */
    IgxFilteringService.prototype.scrollToFilterCell = /**
     * Scrolls to a filterCell.
     * @param {?} column
     * @param {?} shouldFocusNext
     * @return {?}
     */
    function (column, shouldFocusNext) {
        this.grid.nativeElement.focus({ preventScroll: true });
        this.columnToFocus = column;
        this.shouldFocusNext = shouldFocusNext;
        /** @type {?} */
        var currentColumnRight = 0;
        /** @type {?} */
        var currentColumnLeft = 0;
        for (var index = 0; index < this.unpinnedColumns.length; index++) {
            currentColumnRight += parseInt(this.unpinnedColumns[index].width, 10);
            if (this.unpinnedColumns[index] === column) {
                currentColumnLeft = currentColumnRight - parseInt(this.unpinnedColumns[index].width, 10);
                break;
            }
        }
        /** @type {?} */
        var forOfDir = this.grid.headerContainer;
        /** @type {?} */
        var width = this.displayContainerWidth + this.displayContainerScrollLeft;
        if (shouldFocusNext) {
            forOfDir.getHorizontalScroll().scrollLeft += currentColumnRight - width;
        }
        else {
            forOfDir.getHorizontalScroll().scrollLeft = currentColumnLeft;
        }
    };
    /**
     * @private
     * @param {?} expressions
     * @return {?}
     */
    IgxFilteringService.prototype.isFilteringTreeComplex = /**
     * @private
     * @param {?} expressions
     * @return {?}
     */
    function (expressions) {
        if (!expressions) {
            return false;
        }
        if (expressions instanceof FilteringExpressionsTree) {
            /** @type {?} */
            var expressionsTree = (/** @type {?} */ (expressions));
            if (expressionsTree.operator === FilteringLogic.Or) {
                /** @type {?} */
                var andOperatorsCount = this.getChildAndOperatorsCount(expressionsTree);
                // having more that 'And' and operator in the sub-tree means that the filter could not be represented without parentheses.
                return andOperatorsCount > 1;
            }
            /** @type {?} */
            var isComplex = false;
            for (var i = 0; i < expressionsTree.filteringOperands.length; i++) {
                isComplex = isComplex || this.isFilteringTreeComplex(expressionsTree.filteringOperands[i]);
            }
            return isComplex;
        }
        return false;
    };
    /**
     * @private
     * @param {?} expressions
     * @return {?}
     */
    IgxFilteringService.prototype.getChildAndOperatorsCount = /**
     * @private
     * @param {?} expressions
     * @return {?}
     */
    function (expressions) {
        /** @type {?} */
        var count = 0;
        /** @type {?} */
        var operand;
        for (var i = 0; i < expressions.filteringOperands.length; i++) {
            operand = expressions[i];
            if (operand instanceof FilteringExpressionsTree) {
                if (operand.operator === FilteringLogic.And) {
                    count++;
                }
                count = count + this.getChildAndOperatorsCount(operand);
            }
        }
        return count;
    };
    /**
     * @param {?} expressions
     * @param {?} operator
     * @param {?} expressionsUIs
     * @return {?}
     */
    IgxFilteringService.prototype.generateExpressionsList = /**
     * @param {?} expressions
     * @param {?} operator
     * @param {?} expressionsUIs
     * @return {?}
     */
    function (expressions, operator, expressionsUIs) {
        this.generateExpressionsListRecursive(expressions, operator, expressionsUIs);
        // The beforeOperator of the first expression and the afterOperator of the last expression should be null
        if (expressionsUIs.length) {
            expressionsUIs[expressionsUIs.length - 1].afterOperator = null;
        }
    };
    /**
     * @private
     * @param {?} expressions
     * @param {?} operator
     * @param {?} expressionsUIs
     * @return {?}
     */
    IgxFilteringService.prototype.generateExpressionsListRecursive = /**
     * @private
     * @param {?} expressions
     * @param {?} operator
     * @param {?} expressionsUIs
     * @return {?}
     */
    function (expressions, operator, expressionsUIs) {
        if (!expressions) {
            return;
        }
        if (expressions instanceof FilteringExpressionsTree) {
            /** @type {?} */
            var expressionsTree = (/** @type {?} */ (expressions));
            for (var i = 0; i < expressionsTree.filteringOperands.length; i++) {
                this.generateExpressionsListRecursive(expressionsTree.filteringOperands[i], expressionsTree.operator, expressionsUIs);
            }
            if (expressionsUIs.length) {
                expressionsUIs[expressionsUIs.length - 1].afterOperator = operator;
            }
        }
        else {
            /** @type {?} */
            var exprUI = new ExpressionUI();
            exprUI.expression = (/** @type {?} */ (expressions));
            exprUI.afterOperator = operator;
            /** @type {?} */
            var prevExprUI = expressionsUIs[expressionsUIs.length - 1];
            if (prevExprUI) {
                exprUI.beforeOperator = prevExprUI.afterOperator;
            }
            expressionsUIs.push(exprUI);
        }
    };
    /**
     * @return {?}
     */
    IgxFilteringService.prototype.isFilteringExpressionsTreeEmpty = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var expressionTree = this.grid.filteringExpressionsTree;
        if (!expressionTree.filteringOperands || !expressionTree.filteringOperands.length) {
            return true;
        }
        /** @type {?} */
        var expr;
        for (var i = 0; i < expressionTree.filteringOperands.length; i++) {
            expr = expressionTree.filteringOperands[i];
            if ((expr instanceof FilteringExpressionsTree)) {
                /** @type {?} */
                var exprTree = (/** @type {?} */ (expr));
                if (exprTree.filteringOperands && exprTree.filteringOperands.length) {
                    return false;
                }
            }
            else {
                return false;
            }
        }
        return true;
    };
    IgxFilteringService.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    IgxFilteringService.ctorParameters = function () { return [
        { type: GridBaseAPIService },
        { type: IgxIconService }
    ]; };
    return IgxFilteringService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 * @return {?}
 */
function WatchChanges() {
    return function (target, key, propDesc) {
        /** @type {?} */
        var privateKey = '_' + key.toString();
        propDesc = propDesc || {
            configurable: true,
            enumerable: true,
        };
        propDesc.get = propDesc.get || (function () { return this[privateKey]; });
        /** @type {?} */
        var originalSetter = propDesc.set || (function (val) { this[privateKey] = val; });
        propDesc.set = function (val) {
            var _a;
            /** @type {?} */
            var oldValue = this[key];
            if (val !== oldValue || (typeof val === 'object' && val === oldValue)) {
                originalSetter.call(this, val);
                if (this.ngOnChanges) {
                    // in case wacthed prop changes trigger ngOnChanges manually
                    /** @type {?} */
                    var changes = (_a = {},
                        _a[key] = new SimpleChange(oldValue, val, false),
                        _a);
                    this.ngOnChanges(changes);
                }
            }
        };
        return propDesc;
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxExcelStyleSearchComponent = /** @class */ (function () {
    function IgxExcelStyleSearchComponent() {
    }
    /**
     * @return {?}
     */
    IgxExcelStyleSearchComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        requestAnimationFrame(function () {
            _this.virtDir.recalcUpdateSizes();
        });
    };
    /**
     * @return {?}
     */
    IgxExcelStyleSearchComponent.prototype.clearInput = /**
     * @return {?}
     */
    function () {
        this.searchValue = null;
    };
    /**
     * @param {?} eventArgs
     * @return {?}
     */
    IgxExcelStyleSearchComponent.prototype.onCheckboxChange = /**
     * @param {?} eventArgs
     * @return {?}
     */
    function (eventArgs) {
        var _this = this;
        /** @type {?} */
        var selectedIndex = this.data.indexOf(eventArgs.checkbox.value);
        if (selectedIndex === 0) {
            this.data.forEach(function (element) {
                element.isSelected = eventArgs.checked;
                _this.data[0].indeterminate = false;
            });
        }
        else {
            eventArgs.checkbox.value.isSelected = eventArgs.checked;
            if (!this.data.slice(1, this.data.length).find(function (el) { return el.isSelected === false; })) {
                this.data[0].indeterminate = false;
                this.data[0].isSelected = true;
            }
            else if (!this.data.slice(1, this.data.length).find(function (el) { return el.isSelected === true; })) {
                this.data[0].indeterminate = false;
                this.data[0].isSelected = false;
            }
            else {
                this.data[0].indeterminate = true;
            }
        }
        eventArgs.checkbox.nativeCheckbox.nativeElement.blur();
    };
    Object.defineProperty(IgxExcelStyleSearchComponent.prototype, "itemSize", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var itemSize = '48px';
            switch (this.displayDensity) {
                case DisplayDensity.cosy:
                    itemSize = '32px';
                    break;
                case DisplayDensity.compact:
                    itemSize = '28px';
                    break;
                default: break;
            }
            return itemSize;
        },
        enumerable: true,
        configurable: true
    });
    IgxExcelStyleSearchComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-excel-style-search',
                    template: "<igx-input-group\n            type=\"box\"\n            [displayDensity]=\"displayDensity\"\n            [supressInputAutofocus]=\"true\">\n    <igx-icon igxPrefix>search</igx-icon>\n    <input\n        #input\n        igxInput\n        tabindex=\"0\"\n        [(ngModel)]=\"searchValue\"\n        [placeholder]=\"column.grid.resourceStrings.igx_grid_excel_search_placeholder\"\n        autocomplete=\"off\"/>\n    <igx-icon\n        igxSuffix\n        *ngIf=\"searchValue || searchValue === 0\"\n        (click)=\"clearInput()\"\n        tabindex=\"0\">\n        clear\n    </igx-icon>\n</igx-input-group>\n\n        <igx-list [displayDensity]=\"displayDensity\" [style.height.px]=\"250\">\n            <div [style.overflow]=\"'hidden'\" [style.position]=\"'relative'\">\n                <igx-list-item\n                    *igxFor=\"let item of data | excelStyleSearchFilter: searchValue; scrollOrientation : 'vertical'; containerSize: '250px'; itemSize: itemSize\">\n                    <igx-checkbox\n                    [value]=\"item\"\n                    tabindex=\"-1\"\n                    [checked]=\"item.isSelected\"\n                    [disableRipple]=\"true\"\n                    [indeterminate]=\"item.indeterminate\"\n                    [disableTransitions]=\"true\"\n                    (change)=\"onCheckboxChange($event)\">\n                        {{ column.formatter && !item.isSpecial ? column.formatter(item.label) : column.dataType === 'number' ? (item.label | igxdecimal:\n                            column.grid.locale) : column.dataType === 'date' ? (item.label | igxdate: column.grid.locale) : item.label }}\n                    </igx-checkbox>\n                </igx-list-item>\n            </div>\n        </igx-list>\n"
                }] }
    ];
    /** @nocollapse */
    IgxExcelStyleSearchComponent.ctorParameters = function () { return []; };
    IgxExcelStyleSearchComponent.propDecorators = {
        data: [{ type: Input }],
        column: [{ type: Input }],
        searchInput: [{ type: ViewChild, args: ['input', { read: IgxInputDirective },] }],
        displayDensity: [{ type: Input }],
        virtDir: [{ type: ViewChild, args: [IgxForOfDirective,] }]
    };
    return IgxExcelStyleSearchComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxExcelStyleDefaultExpressionComponent = /** @class */ (function () {
    function IgxExcelStyleDefaultExpressionComponent(cdr) {
        this.cdr = cdr;
        this._dropDownOverlaySettings = {
            closeOnOutsideClick: true,
            modal: false,
            positionStrategy: new ConnectedPositioningStrategy(),
            scrollStrategy: new CloseScrollStrategy()
        };
        this.onExpressionRemoved = new EventEmitter();
        this.onLogicOperatorChanged = new EventEmitter();
    }
    Object.defineProperty(IgxExcelStyleDefaultExpressionComponent.prototype, "inputValuesElement", {
        get: /**
         * @protected
         * @return {?}
         */
        function () {
            return this.inputValuesDirective;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxExcelStyleDefaultExpressionComponent.prototype, "isLast", {
        get: /**
         * @return {?}
         */
        function () {
            return this.expressionsList[this.expressionsList.length - 1] === this.expressionUI;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxExcelStyleDefaultExpressionComponent.prototype, "isSingle", {
        get: /**
         * @return {?}
         */
        function () {
            return this.expressionsList.length === 1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxExcelStyleDefaultExpressionComponent.prototype, "inputConditionsPlaceholder", {
        get: /**
         * @return {?}
         */
        function () {
            return this.grid.resourceStrings['igx_grid_filter_condition_placeholder'];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxExcelStyleDefaultExpressionComponent.prototype, "inputValuePlaceholder", {
        get: /**
         * @return {?}
         */
        function () {
            return this.grid.resourceStrings['igx_grid_filter_row_placeholder'];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxExcelStyleDefaultExpressionComponent.prototype, "type", {
        get: /**
         * @return {?}
         */
        function () {
            switch (this.column.dataType) {
                case DataType.Number:
                    return 'number';
                default:
                    return 'text';
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    IgxExcelStyleDefaultExpressionComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this._dropDownOverlaySettings.outlet = this.column.grid.outletDirective;
        this._dropDownOverlaySettings.positionStrategy.settings.target = this.inputGroupConditions.element.nativeElement;
    };
    /**
     * @return {?}
     */
    IgxExcelStyleDefaultExpressionComponent.prototype.focus = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // use requestAnimationFrame to focus the values input because when initializing the component
        // datepicker's input group is not yet fully initialized
        requestAnimationFrame(function () { return _this.inputValuesElement.focus(); });
    };
    /**
     * @param {?} conditionName
     * @return {?}
     */
    IgxExcelStyleDefaultExpressionComponent.prototype.isConditionSelected = /**
     * @param {?} conditionName
     * @return {?}
     */
    function (conditionName) {
        return this.expressionUI.expression.condition && this.expressionUI.expression.condition.name === conditionName;
    };
    /**
     * @param {?} condition
     * @return {?}
     */
    IgxExcelStyleDefaultExpressionComponent.prototype.getConditionName = /**
     * @param {?} condition
     * @return {?}
     */
    function (condition) {
        return condition ? this.translateCondition(condition.name) : null;
    };
    /**
     * @return {?}
     */
    IgxExcelStyleDefaultExpressionComponent.prototype.getInputWidth = /**
     * @return {?}
     */
    function () {
        return this.inputGroupConditions.element.nativeElement.offsetWidth + 'px';
    };
    Object.defineProperty(IgxExcelStyleDefaultExpressionComponent.prototype, "conditions", {
        get: /**
         * @return {?}
         */
        function () {
            return this.column.filters.conditionList();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} value
     * @return {?}
     */
    IgxExcelStyleDefaultExpressionComponent.prototype.translateCondition = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return this.grid.resourceStrings["igx_grid_filter_" + this.getCondition(value).name] || value;
    };
    /**
     * @return {?}
     */
    IgxExcelStyleDefaultExpressionComponent.prototype.getIconName = /**
     * @return {?}
     */
    function () {
        if (this.column.dataType === DataType.Boolean && this.expressionUI.expression.condition === null) {
            return this.getCondition(this.conditions[0]).iconName;
        }
        else if (!this.expressionUI.expression.condition) {
            return 'filter_list';
        }
        else {
            return this.expressionUI.expression.condition.iconName;
        }
    };
    /**
     * @return {?}
     */
    IgxExcelStyleDefaultExpressionComponent.prototype.toggleCustomDialogDropDown = /**
     * @return {?}
     */
    function () {
        this.dropdownConditions.toggle(this._dropDownOverlaySettings);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    IgxExcelStyleDefaultExpressionComponent.prototype.getCondition = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return this.column.filters.condition(value);
    };
    /**
     * @param {?} eventArgs
     * @return {?}
     */
    IgxExcelStyleDefaultExpressionComponent.prototype.onConditionsChanged = /**
     * @param {?} eventArgs
     * @return {?}
     */
    function (eventArgs) {
        /** @type {?} */
        var value = ((/** @type {?} */ (eventArgs.newSelection))).value;
        this.expressionUI.expression.condition = this.getCondition(value);
        this.focus();
    };
    /**
     * @param {?} value
     * @return {?}
     */
    IgxExcelStyleDefaultExpressionComponent.prototype.isValueSelected = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (this.expressionUI.expression.searchVal) {
            return this.expressionUI.expression.searchVal === value;
        }
        else {
            return false;
        }
    };
    /**
     * @param {?} eventArgs
     * @return {?}
     */
    IgxExcelStyleDefaultExpressionComponent.prototype.onValuesInput = /**
     * @param {?} eventArgs
     * @return {?}
     */
    function (eventArgs) {
        this.expressionUI.expression.searchVal = this.transformValue(eventArgs.target.value);
    };
    /**
     * @param {?} eventArgs
     * @param {?} buttonIndex
     * @return {?}
     */
    IgxExcelStyleDefaultExpressionComponent.prototype.onLogicOperatorButtonClicked = /**
     * @param {?} eventArgs
     * @param {?} buttonIndex
     * @return {?}
     */
    function (eventArgs, buttonIndex) {
        if (this.logicOperatorButtonGroup.selectedButtons.length === 0) {
            eventArgs.stopPropagation();
            this.logicOperatorButtonGroup.selectButton(buttonIndex);
        }
        else {
            this.onLogicOperatorChanged.emit({
                target: this.expressionUI,
                newValue: (/** @type {?} */ (buttonIndex))
            });
        }
    };
    /**
     * @param {?} eventArgs
     * @param {?} buttonIndex
     * @return {?}
     */
    IgxExcelStyleDefaultExpressionComponent.prototype.onLogicOperatorKeyDown = /**
     * @param {?} eventArgs
     * @param {?} buttonIndex
     * @return {?}
     */
    function (eventArgs, buttonIndex) {
        if (eventArgs.key === "Enter" /* ENTER */) {
            this.logicOperatorButtonGroup.selectButton(buttonIndex);
            this.onLogicOperatorChanged.emit({
                target: this.expressionUI,
                newValue: (/** @type {?} */ (buttonIndex))
            });
        }
    };
    /**
     * @return {?}
     */
    IgxExcelStyleDefaultExpressionComponent.prototype.onRemoveButtonClick = /**
     * @return {?}
     */
    function () {
        this.onExpressionRemoved.emit(this.expressionUI);
    };
    /**
     * @param {?} eventArgs
     * @return {?}
     */
    IgxExcelStyleDefaultExpressionComponent.prototype.onInputConditionsKeyDown = /**
     * @param {?} eventArgs
     * @return {?}
     */
    function (eventArgs) {
        if (eventArgs.altKey && (eventArgs.key === "ArrowDown" /* DOWN_ARROW */ || eventArgs.key === "Down" /* DOWN_ARROW_IE */)) {
            this.toggleCustomDialogDropDown();
        }
        if (eventArgs.key === "Tab" /* TAB */ && eventArgs.shiftKey && this.expressionsList[0] === this.expressionUI) {
            eventArgs.preventDefault();
        }
        event.stopPropagation();
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    IgxExcelStyleDefaultExpressionComponent.prototype.transformValue = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (this.column.dataType === DataType.Number) {
            value = parseFloat(value);
        }
        else if (this.column.dataType === DataType.Boolean) {
            value = Boolean(value);
        }
        return value;
    };
    IgxExcelStyleDefaultExpressionComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-excel-style-default-expression',
                    template: "<igx-drop-down\n    #dropdownConditions\n    [maxHeight]=\"'200px'\"\n    [width]=\"getInputWidth()\"\n    (onSelection)=\"onConditionsChanged($event)\">\n    <igx-drop-down-item *ngFor=\"let condition of conditions\" [value]=\"condition\" [selected]=\"isConditionSelected(condition)\">\n        <igx-icon fontSet=\"filtering-icons\" [name]=\"getCondition(condition).iconName\"></igx-icon>\n        <span>{{ translateCondition(condition) }}</span>\n    </igx-drop-down-item>\n</igx-drop-down>\n\n<igx-input-group\n    #inputGroupConditions\n    (click)=\"toggleCustomDialogDropDown()\"\n    type=\"box\"\n    [displayDensity]=\"displayDensity\"\n    [supressInputAutofocus]=\"true\">\n\n    <igx-prefix>\n        <igx-icon *ngIf=\"expressionUI.expression.condition\" fontSet=\"filtering-icons\" [name]=\"getIconName()\"></igx-icon>\n        <igx-icon *ngIf=\"!expressionUI.expression.condition\">filter_list</igx-icon>\n    </igx-prefix>\n\n    <input\n        igxInput\n        (keydown)=\"onInputConditionsKeyDown($event)\"\n        [igxDropDownItemNavigation]=\"dropdownConditions\"\n        tabindex=\"0\"\n        [placeholder]=\"inputConditionsPlaceholder\"\n        autocomplete=\"off\"\n        [value]=\"getConditionName(expressionUI.expression.condition)\"\n        [readonly]=\"true\"\n    />\n</igx-input-group>\n\n<igx-input-group #inputGroupValues type=\"box\" [displayDensity]=\"displayDensity\" [supressInputAutofocus]=\"true\">\n    <input\n        #inputValues\n        igxInput\n        [type]=\"type\"\n        tabindex=\"0\"\n        [placeholder]=\"inputValuePlaceholder\"\n        [disabled]=\"expressionUI.expression.condition && expressionUI.expression.condition.isUnary\"\n        autocomplete=\"off\"\n        [value]=\"expressionUI.expression.searchVal\"\n        (input)=\"onValuesInput($event)\"\n    />\n</igx-input-group>\n\n<button (click)=\"onRemoveButtonClick()\" igxButton=\"icon\" [displayDensity]=\"displayDensity\" *ngIf=\"!isSingle\">\n    <igx-icon>cancel</igx-icon>\n</button>\n\n<igx-buttongroup #logicOperatorButtonGroup\n    *ngIf=\"!isLast\"\n    [multiSelection]=\"false\">\n    <span igxButton [displayDensity]=\"displayDensity\"\n        tabindex=\"0\"\n        #andButton\n        (keydown)=\"onLogicOperatorKeyDown($event, 0)\"\n        [selected]=\"expressionUI.afterOperator === 0\"\n        type=\"button\"\n        (click)=\"onLogicOperatorButtonClicked($event, 0)\">\n        {{ grid.resourceStrings.igx_grid_filter_operator_and }}\n    </span>\n\n    <span igxButton [displayDensity]=\"displayDensity\"\n        tabindex=\"0\"\n        #orButton\n        (keydown)=\"onLogicOperatorKeyDown($event, 1)\"\n        [selected]=\"expressionUI.afterOperator === 1\"\n        type=\"button\"\n        (click)=\"onLogicOperatorButtonClicked($event, 1)\">\n        {{ grid.resourceStrings.igx_grid_filter_operator_or }}\n    </span>\n</igx-buttongroup>\n"
                }] }
    ];
    /** @nocollapse */
    IgxExcelStyleDefaultExpressionComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef }
    ]; };
    IgxExcelStyleDefaultExpressionComponent.propDecorators = {
        column: [{ type: Input }],
        expressionUI: [{ type: Input }],
        expressionsList: [{ type: Input }],
        grid: [{ type: Input }],
        displayDensity: [{ type: Input }],
        onExpressionRemoved: [{ type: Output }],
        onLogicOperatorChanged: [{ type: Output }],
        inputGroupConditions: [{ type: ViewChild, args: ['inputGroupConditions', { read: IgxInputGroupComponent },] }],
        inputValuesDirective: [{ type: ViewChild, args: ['inputValues', { read: IgxInputDirective },] }],
        dropdownConditions: [{ type: ViewChild, args: ['dropdownConditions', { read: IgxDropDownComponent },] }],
        logicOperatorButtonGroup: [{ type: ViewChild, args: ['logicOperatorButtonGroup', { read: IgxButtonGroupComponent },] }]
    };
    return IgxExcelStyleDefaultExpressionComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxExcelStyleDateExpressionComponent = /** @class */ (function (_super) {
    __extends(IgxExcelStyleDateExpressionComponent, _super);
    function IgxExcelStyleDateExpressionComponent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(IgxExcelStyleDateExpressionComponent.prototype, "inputValuesElement", {
        get: /**
         * @protected
         * @return {?}
         */
        function () {
            return this.datePicker.getEditElement();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxExcelStyleDateExpressionComponent.prototype, "inputDatePlaceholder", {
        get: /**
         * @return {?}
         */
        function () {
            return this.grid.resourceStrings['igx_grid_filter_row_date_placeholder'];
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} openDialog
     * @return {?}
     */
    IgxExcelStyleDateExpressionComponent.prototype.openDatePicker = /**
     * @param {?} openDialog
     * @return {?}
     */
    function (openDialog) {
        openDialog();
    };
    IgxExcelStyleDateExpressionComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-excel-style-date-expression',
                    template: "<igx-drop-down\n    #dropdownConditions\n    [maxHeight]=\"'200px'\"\n    [width]=\"getInputWidth()\"\n    (onSelection)=\"onConditionsChanged($event)\">\n    <igx-drop-down-item *ngFor=\"let condition of conditions\" [value]=\"condition\" [selected]=\"isConditionSelected(condition)\">\n        <igx-icon fontSet=\"filtering-icons\" [name]=\"getCondition(condition).iconName\"></igx-icon>\n        <span>{{ translateCondition(condition) }}</span>\n    </igx-drop-down-item>\n</igx-drop-down>\n\n<igx-input-group\n    #inputGroupConditions\n    (click)=\"toggleCustomDialogDropDown()\"\n    type=\"box\"\n    [displayDensity]=\"displayDensity\"\n    [supressInputAutofocus]=\"true\">\n\n    <igx-prefix>\n        <igx-icon *ngIf=\"expressionUI.expression.condition\" fontSet=\"filtering-icons\" [name]=\"getIconName()\"></igx-icon>\n        <igx-icon *ngIf=\"!expressionUI.expression.condition\">filter_list</igx-icon>\n    </igx-prefix>\n\n    <input\n        igxInput\n        (keydown)=\"onInputConditionsKeyDown($event)\"\n        tabindex=\"0\"\n        [igxDropDownItemNavigation]=\"dropdownConditions\"\n        [placeholder]=\"inputConditionsPlaceholder\"\n        autocomplete=\"off\"\n        [value]=\"getConditionName(expressionUI.expression.condition)\"\n        [readonly]=\"true\"\n    />\n</igx-input-group>\n\n<igx-date-picker #datePicker mode=\"dropdown\" [(ngModel)]=\"expressionUI.expression.searchVal\" [locale]=\"grid.locale\">\n    <ng-template igxDatePickerTemplate let-openDialog=\"openDialog\" let-value=\"value\">\n        <igx-input-group #dropDownTarget type=\"box\" [displayDensity]=\"displayDensity\" [supressInputAutofocus]=\"true\">\n            <input #input\n                    igxInput\n                    tabindex=\"0\"\n                    (click)=\"openDatePicker(openDialog)\"\n                    [placeholder]=\"inputDatePlaceholder\"\n                    autocomplete=\"off\"\n                    [value]=\"value | igxdate: grid.locale\"\n                    [readonly]=\"true\"\n                    [disabled]=\"expressionUI.expression.condition && expressionUI.expression.condition.isUnary\"/>\n        </igx-input-group>\n    </ng-template>\n</igx-date-picker>\n\n<button (click)=\"onRemoveButtonClick()\" igxButton=\"icon\" [displayDensity]=\"displayDensity\" *ngIf=\"!isSingle\" >\n    <igx-icon>cancel</igx-icon>\n</button>\n\n<igx-buttongroup #logicOperatorButtonGroup\n    *ngIf=\"!isLast\"\n    [multiSelection]=\"false\">\n    <span igxButton [displayDensity]=\"displayDensity\"\n        #andButton\n        (keydown)=\"onLogicOperatorKeyDown($event, 0)\"\n        tabindex=\"0\"\n        [selected]=\"expressionUI.afterOperator === 0\"\n        type=\"button\"\n        (click)=\"onLogicOperatorButtonClicked($event, 0)\">\n        {{ grid.resourceStrings.igx_grid_filter_operator_and }}\n    </span>\n\n    <span igxButton [displayDensity]=\"displayDensity\"\n        #orButton\n        tabindex=\"0\"\n        (keydown)=\"onLogicOperatorKeyDown($event, 1)\"\n        [selected]=\"expressionUI.afterOperator === 1\"\n        type=\"button\"\n        (click)=\"onLogicOperatorButtonClicked($event, 1)\">\n        {{ grid.resourceStrings.igx_grid_filter_operator_or }}\n    </span>\n</igx-buttongroup>\n"
                }] }
    ];
    IgxExcelStyleDateExpressionComponent.propDecorators = {
        datePicker: [{ type: ViewChild, args: ['datePicker', { read: IgxDatePickerComponent },] }],
        displayDensity: [{ type: Input }]
    };
    return IgxExcelStyleDateExpressionComponent;
}(IgxExcelStyleDefaultExpressionComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxExcelStyleCustomDialogComponent = /** @class */ (function () {
    function IgxExcelStyleCustomDialogComponent(cdr) {
        this.cdr = cdr;
        this.expressionsList = new Array();
        this._customDialogPositionSettings = {
            verticalDirection: VerticalAlignment.Middle,
            horizontalDirection: HorizontalAlignment.Center,
            horizontalStartPoint: HorizontalAlignment.Center,
            verticalStartPoint: VerticalAlignment.Middle
        };
        this._customDialogOverlaySettings = {
            closeOnOutsideClick: true,
            modal: false,
            positionStrategy: new ConnectedPositioningStrategy(this._customDialogPositionSettings),
            scrollStrategy: new AbsoluteScrollStrategy()
        };
    }
    /**
     * @return {?}
     */
    IgxExcelStyleCustomDialogComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this._customDialogOverlaySettings.outlet = this.grid.outlet;
    };
    Object.defineProperty(IgxExcelStyleCustomDialogComponent.prototype, "template", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.column.dataType === DataType.Date) {
                return this.dateExpressionTemplate;
            }
            return this.defaultExpressionTemplate;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxExcelStyleCustomDialogComponent.prototype, "grid", {
        get: /**
         * @return {?}
         */
        function () {
            return this.filteringService.grid;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    IgxExcelStyleCustomDialogComponent.prototype.onCustomDialogOpening = /**
     * @return {?}
     */
    function () {
        if (this.selectedOperator) {
            this.createInitialExpressionUIElement();
        }
    };
    /**
     * @return {?}
     */
    IgxExcelStyleCustomDialogComponent.prototype.onCustomDialogOpened = /**
     * @return {?}
     */
    function () {
        if (this.expressionComponents.first) {
            this.expressionComponents.first.focus();
        }
    };
    /**
     * @return {?}
     */
    IgxExcelStyleCustomDialogComponent.prototype.open = /**
     * @return {?}
     */
    function () {
        this._customDialogOverlaySettings.positionStrategy.settings.target =
            this.grid.rootGrid ? this.grid.rootGrid.nativeElement : this.grid.nativeElement;
        this.toggle.open(this._customDialogOverlaySettings);
    };
    /**
     * @return {?}
     */
    IgxExcelStyleCustomDialogComponent.prototype.onClearButtonClick = /**
     * @return {?}
     */
    function () {
        this.filteringService.clearFilter(this.column.field);
        this.createInitialExpressionUIElement();
        this.cdr.detectChanges();
    };
    /**
     * @return {?}
     */
    IgxExcelStyleCustomDialogComponent.prototype.closeDialog = /**
     * @return {?}
     */
    function () {
        if (this.overlayComponentId) {
            this.overlayService.hide(this.overlayComponentId);
        }
    };
    /**
     * @return {?}
     */
    IgxExcelStyleCustomDialogComponent.prototype.onApplyButtonClick = /**
     * @return {?}
     */
    function () {
        this.expressionsList = this.expressionsList.filter(function (element) { return element.expression.condition &&
            (element.expression.searchVal || element.expression.searchVal === 0 || element.expression.condition.isUnary); });
        if (this.expressionsList.length > 0) {
            this.expressionsList[0].beforeOperator = null;
            this.expressionsList[this.expressionsList.length - 1].afterOperator = null;
        }
        this.filteringService.filterInternal(this.column.field, this.expressionsList);
        this.closeDialog();
    };
    /**
     * @return {?}
     */
    IgxExcelStyleCustomDialogComponent.prototype.onAddButtonClick = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var exprUI = new ExpressionUI();
        exprUI.expression = {
            condition: null,
            fieldName: this.column.field,
            ignoreCase: this.column.filteringIgnoreCase,
            searchVal: null
        };
        this.expressionsList[this.expressionsList.length - 1].afterOperator = FilteringLogic.And;
        exprUI.beforeOperator = this.expressionsList[this.expressionsList.length - 1].afterOperator;
        this.expressionsList.push(exprUI);
        this.markChildrenForCheck();
        this.scrollToBottom();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    IgxExcelStyleCustomDialogComponent.prototype.onExpressionRemoved = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var indexToRemove = this.expressionsList.indexOf(event);
        if (indexToRemove === 0 && this.expressionsList.length > 1) {
            this.expressionsList[1].beforeOperator = null;
        }
        else if (indexToRemove === this.expressionsList.length - 1) {
            this.expressionsList[indexToRemove - 1].afterOperator = null;
        }
        else {
            this.expressionsList[indexToRemove - 1].afterOperator = this.expressionsList[indexToRemove + 1].beforeOperator;
            this.expressionsList[0].beforeOperator = null;
            this.expressionsList[this.expressionsList.length - 1].afterOperator = null;
        }
        this.expressionsList.splice(indexToRemove, 1);
        this.cdr.detectChanges();
        this.markChildrenForCheck();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    IgxExcelStyleCustomDialogComponent.prototype.onLogicOperatorChanged = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var index = this.expressionsList.indexOf(event.target);
        event.target.afterOperator = event.newValue;
        if (index + 1 < this.expressionsList.length) {
            this.expressionsList[index + 1].beforeOperator = event.newValue;
        }
    };
    /**
     * @param {?} eventArgs
     * @return {?}
     */
    IgxExcelStyleCustomDialogComponent.prototype.onKeyDown = /**
     * @param {?} eventArgs
     * @return {?}
     */
    function (eventArgs) {
        eventArgs.stopPropagation();
    };
    /**
     * @param {?} eventArgs
     * @return {?}
     */
    IgxExcelStyleCustomDialogComponent.prototype.onApplyButtonKeyDown = /**
     * @param {?} eventArgs
     * @return {?}
     */
    function (eventArgs) {
        if (eventArgs.key === "Tab" /* TAB */ && !eventArgs.shiftKey) {
            eventArgs.stopPropagation();
            eventArgs.preventDefault();
        }
    };
    /**
     * @private
     * @param {?} conditionName
     * @return {?}
     */
    IgxExcelStyleCustomDialogComponent.prototype.createCondition = /**
     * @private
     * @param {?} conditionName
     * @return {?}
     */
    function (conditionName) {
        switch (this.column.dataType) {
            case DataType.Boolean:
                return IgxBooleanFilteringOperand.instance().condition(conditionName);
            case DataType.Number:
                return IgxNumberFilteringOperand.instance().condition(conditionName);
            case DataType.Date:
                return IgxDateFilteringOperand.instance().condition(conditionName);
            default:
                return IgxStringFilteringOperand.instance().condition(conditionName);
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxExcelStyleCustomDialogComponent.prototype.markChildrenForCheck = /**
     * @private
     * @return {?}
     */
    function () {
        this.expressionComponents.forEach(function (x) { return x.cdr.markForCheck(); });
        this.expressionDateComponents.forEach(function (x) { return x.cdr.markForCheck(); });
    };
    /**
     * @private
     * @return {?}
     */
    IgxExcelStyleCustomDialogComponent.prototype.createInitialExpressionUIElement = /**
     * @private
     * @return {?}
     */
    function () {
        this.expressionsList = [];
        /** @type {?} */
        var firstExprUI = new ExpressionUI();
        firstExprUI.expression = {
            condition: this.createCondition(this.selectedOperator),
            fieldName: this.column.field,
            ignoreCase: this.column.filteringIgnoreCase,
            searchVal: null
        };
        firstExprUI.afterOperator = FilteringLogic.And;
        this.expressionsList.push(firstExprUI);
        /** @type {?} */
        var secondExprUI = new ExpressionUI();
        secondExprUI.expression = {
            condition: null,
            fieldName: this.column.field,
            ignoreCase: this.column.filteringIgnoreCase,
            searchVal: null
        };
        secondExprUI.beforeOperator = FilteringLogic.And;
        this.expressionsList.push(secondExprUI);
    };
    /**
     * @private
     * @return {?}
     */
    IgxExcelStyleCustomDialogComponent.prototype.scrollToBottom = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        requestAnimationFrame(function () {
            _this.expressionsContainer.nativeElement.scrollTop = _this.expressionsContainer.nativeElement.scrollHeight;
        });
    };
    IgxExcelStyleCustomDialogComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-excel-style-custom-dialog',
                    template: "<article #toggle igxToggle\n    class=\"igx-excel-filter__secondary\"\n    (keydown)=\"onKeyDown($event)\"\n    (onOpening)=\"onCustomDialogOpening()\"\n    (onOpened)=\"onCustomDialogOpened()\">\n    <header class=\"igx-excel-filter__secondary-header\">\n        <h4 class=\"igx-typography__h6\">\n            {{ grid.resourceStrings.igx_grid_excel_custom_dialog_header }}{{ column.header || column.field }}\n        </h4>\n    </header>\n\n    <article #expressionsContainer class=\"igx-excel-filter__secondary-main\">\n        <ng-container *ngIf=\"column.dataType === 'date'\">\n            <igx-excel-style-date-expression *ngFor=\"let expression of expressionsList;\"\n                class=\"igx-excel-filter__condition\"\n                [expressionUI]=\"expression\"\n                [column]=\"column\"\n                [grid]=\"grid\"\n                [displayDensity]=\"displayDensity\"\n                [expressionsList]=\"expressionsList\"\n                (onExpressionRemoved)=\"onExpressionRemoved($event)\"\n                (onLogicOperatorChanged)=\"onLogicOperatorChanged($event)\">\n            </igx-excel-style-date-expression>\n        </ng-container>\n\n        <ng-container *ngIf=\"column.dataType !== 'date'\">\n            <igx-excel-style-default-expression *ngFor=\"let expression of expressionsList;\"\n                class=\"igx-excel-filter__condition\"\n                [expressionUI]=\"expression\"\n                [column]=\"column\"\n                [grid]=\"grid\"\n                [displayDensity]=\"displayDensity\"\n                [expressionsList]=\"expressionsList\"\n                (onExpressionRemoved)=\"onExpressionRemoved($event)\"\n                (onLogicOperatorChanged)=\"onLogicOperatorChanged($event)\">\n            </igx-excel-style-default-expression>\n        </ng-container>\n\n        <button igxButton [displayDensity]=\"displayDensity\"\n            class=\"igx-excel-filter__add-filter\"\n            (click)=\"onAddButtonClick()\">\n            <igx-icon>add</igx-icon>\n            <span>{{ grid.resourceStrings.igx_grid_excel_custom_dialog_add }}</span>\n        </button>\n    </article>\n\n    <footer class=\"igx-excel-filter__secondary-footer\">\n        <button igxButton [displayDensity]=\"displayDensity\" (click)=\"onClearButtonClick()\">{{ grid.resourceStrings.igx_grid_excel_custom_dialog_clear }}</button>\n\n        <div>\n            <button igxButton [displayDensity]=\"displayDensity\" (click)=\"closeDialog()\">{{ grid.resourceStrings.igx_grid_excel_cancel }}</button>\n            <button igxButton=\"raised\" [displayDensity]=\"displayDensity\" (click)=\"onApplyButtonClick()\" (keydown)=\"onApplyButtonKeyDown($event)\">\n                {{ grid.resourceStrings.igx_grid_excel_apply }}\n            </button>\n        </div>\n    </footer>\n</article>\n"
                }] }
    ];
    /** @nocollapse */
    IgxExcelStyleCustomDialogComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef }
    ]; };
    IgxExcelStyleCustomDialogComponent.propDecorators = {
        expressionsList: [{ type: Input }],
        column: [{ type: Input }],
        selectedOperator: [{ type: Input }],
        filteringService: [{ type: Input }],
        overlayComponentId: [{ type: Input }],
        overlayService: [{ type: Input }],
        displayDensity: [{ type: Input }],
        expressionComponents: [{ type: ViewChildren, args: [IgxExcelStyleDefaultExpressionComponent,] }],
        expressionDateComponents: [{ type: ViewChildren, args: [IgxExcelStyleDateExpressionComponent,] }],
        toggle: [{ type: ViewChild, args: ['toggle', { read: IgxToggleDirective },] }],
        defaultExpressionTemplate: [{ type: ViewChild, args: ['defaultExpressionTemplate', { read: TemplateRef },] }],
        dateExpressionTemplate: [{ type: ViewChild, args: ['dateExpressionTemplate', { read: TemplateRef },] }],
        expressionsContainer: [{ type: ViewChild, args: ['expressionsContainer',] }]
    };
    return IgxExcelStyleCustomDialogComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxExcelStyleSortingComponent = /** @class */ (function () {
    function IgxExcelStyleSortingComponent() {
    }
    /**
     * @param {?} sortDirection
     * @return {?}
     */
    IgxExcelStyleSortingComponent.prototype.onSortButtonClicked = /**
     * @param {?} sortDirection
     * @return {?}
     */
    function (sortDirection) {
        if (this.sortButtonGroup.selectedIndexes.length === 0) {
            if (this.grid.isColumnGrouped(this.column.field)) {
                this.selectButton(sortDirection);
            }
            else {
                this.grid.clearSort(this.column.field);
            }
        }
        else {
            this.grid.sort({ fieldName: this.column.field, dir: sortDirection, ignoreCase: true });
        }
    };
    /**
     * @param {?} sortDirection
     * @return {?}
     */
    IgxExcelStyleSortingComponent.prototype.selectButton = /**
     * @param {?} sortDirection
     * @return {?}
     */
    function (sortDirection) {
        if (sortDirection === 1) {
            this.sortButtonGroup.selectButton(0);
        }
        else {
            this.sortButtonGroup.selectButton(1);
        }
    };
    IgxExcelStyleSortingComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-excel-style-sorting',
                    template: "<header>\n    {{ grid.resourceStrings.igx_grid_excel_filter_sorting_header }}\n</header>\n<igx-buttongroup #sortButtonGroup [multiSelection]=\"false\">\n    <span tabindex=\"0\" igxButton type=\"button\" [displayDensity]=\"displayDensity\" [attr.data-togglable]=\"true\" (click)=\"onSortButtonClicked(1)\">\n        <igx-icon>arrow_upwards</igx-icon>\n        <span>\n            {{ displayDensity==='compact'?\n            grid.resourceStrings.igx_grid_excel_filter_sorting_asc_short:\n            grid.resourceStrings.igx_grid_excel_filter_sorting_asc  }}\n        </span>\n    </span>\n\n    <span tabindex=\"0\" igxButton type=\"button\" [displayDensity]=\"displayDensity\" [attr.data-togglable]=\"true\" (click)=\"onSortButtonClicked(2)\">\n        <igx-icon>arrow_downwards</igx-icon>\n        <span>\n            {{ displayDensity==='compact'?\n            grid.resourceStrings.igx_grid_excel_filter_sorting_desc_short:\n            grid.resourceStrings.igx_grid_excel_filter_sorting_desc\n         }}\n        </span>\n    </span>\n</igx-buttongroup>\n"
                }] }
    ];
    /** @nocollapse */
    IgxExcelStyleSortingComponent.ctorParameters = function () { return []; };
    IgxExcelStyleSortingComponent.propDecorators = {
        column: [{ type: Input }],
        grid: [{ type: Input }],
        displayDensity: [{ type: Input }],
        sortButtonGroup: [{ type: ViewChild, args: ['sortButtonGroup', { read: IgxButtonGroupComponent },] }]
    };
    return IgxExcelStyleSortingComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var /**
 * @hidden
 */
FilterListItem = /** @class */ (function () {
    function FilterListItem() {
        this.isSpecial = false;
    }
    return FilterListItem;
}());
var IgxExcelStyleSortingTemplateDirective = /** @class */ (function () {
    function IgxExcelStyleSortingTemplateDirective(template) {
        this.template = template;
    }
    IgxExcelStyleSortingTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxExcelStyleSortingTemplate]'
                },] }
    ];
    /** @nocollapse */
    IgxExcelStyleSortingTemplateDirective.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return IgxExcelStyleSortingTemplateDirective;
}());
var IgxExcelStyleMovingTemplateDirective = /** @class */ (function () {
    function IgxExcelStyleMovingTemplateDirective(template) {
        this.template = template;
    }
    IgxExcelStyleMovingTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxExcelStyleMovingTemplate]'
                },] }
    ];
    /** @nocollapse */
    IgxExcelStyleMovingTemplateDirective.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return IgxExcelStyleMovingTemplateDirective;
}());
var IgxExcelStyleHidingTemplateDirective = /** @class */ (function () {
    function IgxExcelStyleHidingTemplateDirective(template) {
        this.template = template;
    }
    IgxExcelStyleHidingTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxExcelStyleHidingTemplate]'
                },] }
    ];
    /** @nocollapse */
    IgxExcelStyleHidingTemplateDirective.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return IgxExcelStyleHidingTemplateDirective;
}());
var IgxExcelStylePinningTemplateDirective = /** @class */ (function () {
    function IgxExcelStylePinningTemplateDirective(template) {
        this.template = template;
    }
    IgxExcelStylePinningTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxExcelStylePinningTemplate]'
                },] }
    ];
    /** @nocollapse */
    IgxExcelStylePinningTemplateDirective.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return IgxExcelStylePinningTemplateDirective;
}());
/**
 * @hidden
 */
var IgxGridExcelStyleFilteringComponent = /** @class */ (function () {
    function IgxGridExcelStyleFilteringComponent(cdr) {
        this.cdr = cdr;
        this.shouldOpenSubMenu = true;
        this.expressionsList = new Array();
        this.destroy$ = new Subject();
        this.containsNullOrEmpty = false;
        this.selectAllSelected = true;
        this.selectAllIndeterminate = false;
        this.filterValues = new Set();
        this.columnMoving = new Subscription();
        this.listData = new Array();
        this.uniqueValues = [];
        this._subMenuPositionSettings = {
            verticalStartPoint: VerticalAlignment.Top
        };
        this._subMenuOverlaySettings = {
            closeOnOutsideClick: true,
            modal: false,
            positionStrategy: new ConnectedPositioningStrategy(this._subMenuPositionSettings),
            scrollStrategy: new AbsoluteScrollStrategy()
        };
        this.className = 'igx-excel-filter';
    }
    Object.defineProperty(IgxGridExcelStyleFilteringComponent.prototype, "grid", {
        get: /**
         * @return {?}
         */
        function () {
            return this.filteringService.grid;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridExcelStyleFilteringComponent.prototype, "conditions", {
        get: /**
         * @return {?}
         */
        function () {
            return this.column.filters.conditionList();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridExcelStyleFilteringComponent.prototype, "subMenuText", {
        get: /**
         * @return {?}
         */
        function () {
            switch (this.column.dataType) {
                case DataType.Boolean:
                    return this.grid.resourceStrings.igx_grid_excel_boolean_filter;
                case DataType.Number:
                    return this.grid.resourceStrings.igx_grid_excel_number_filter;
                case DataType.Date:
                    return this.grid.resourceStrings.igx_grid_excel_date_filter;
                default:
                    return this.grid.resourceStrings.igx_grid_excel_text_filter;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    IgxGridExcelStyleFilteringComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.destroy$.next(true);
        this.destroy$.complete();
    };
    /**
     * @return {?}
     */
    IgxGridExcelStyleFilteringComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.expressionsList = new Array();
        this.filteringService.generateExpressionsList(this.column.filteringExpressionsTree, this.grid.filteringLogic, this.expressionsList);
        if (this.expressionsList && this.expressionsList.length &&
            this.expressionsList[0].expression.condition.name !== 'in') {
            this.customDialog.expressionsList = this.expressionsList;
        }
        this.populateColumnData();
        if (this.excelStyleSorting) {
            /** @type {?} */
            var se = this.grid.sortingExpressions.find(function (expr) { return expr.fieldName === _this.column.field; });
            if (se) {
                this.excelStyleSorting.selectButton(se.dir);
            }
        }
        requestAnimationFrame(function () {
            _this.excelStyleSearch.searchInput.nativeElement.focus();
        });
    };
    /**
     * @return {?}
     */
    IgxGridExcelStyleFilteringComponent.prototype.clearFilterClass = /**
     * @return {?}
     */
    function () {
        if (this.column.filteringExpressionsTree) {
            return 'igx-excel-filter__actions-clear';
        }
        return 'igx-excel-filter__actions-clear--disabled';
    };
    /**
     * @param {?} column
     * @param {?} filteringService
     * @param {?} overlayService
     * @param {?} overlayComponentId
     * @return {?}
     */
    IgxGridExcelStyleFilteringComponent.prototype.initialize = /**
     * @param {?} column
     * @param {?} filteringService
     * @param {?} overlayService
     * @param {?} overlayComponentId
     * @return {?}
     */
    function (column, filteringService, overlayService, overlayComponentId) {
        var _this = this;
        this.column = column;
        this.filteringService = filteringService;
        this.overlayService = overlayService;
        this.overlayComponentId = overlayComponentId;
        this._subMenuOverlaySettings.outlet = this.grid.outlet;
        this.columnMoving = this.grid.onColumnMoving.pipe(takeUntil(this.destroy$)).subscribe(function () {
            _this.closeDropdown();
        });
    };
    /**
     * Returns the filtering operation condition for a given value.
     */
    /**
     * Returns the filtering operation condition for a given value.
     * @param {?} value
     * @return {?}
     */
    IgxGridExcelStyleFilteringComponent.prototype.getCondition = /**
     * Returns the filtering operation condition for a given value.
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return this.column.filters.condition(value);
    };
    /**
     * Returns the translated condition name for a given value.
     */
    /**
     * Returns the translated condition name for a given value.
     * @param {?} value
     * @return {?}
     */
    IgxGridExcelStyleFilteringComponent.prototype.translateCondition = /**
     * Returns the translated condition name for a given value.
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return this.grid.resourceStrings["igx_grid_filter_" + this.getCondition(value).name] || value;
    };
    /**
     * @return {?}
     */
    IgxGridExcelStyleFilteringComponent.prototype.onPin = /**
     * @return {?}
     */
    function () {
        this.column.pinned = !this.column.pinned;
        this.closeDropdown();
    };
    /**
     * @return {?}
     */
    IgxGridExcelStyleFilteringComponent.prototype.onHide = /**
     * @return {?}
     */
    function () {
        this.column.hidden = true;
        this.grid.onColumnVisibilityChanged.emit({ column: this.column, newValue: true });
        this.closeDropdown();
    };
    /**
     * @param {?} eventArgs
     * @return {?}
     */
    IgxGridExcelStyleFilteringComponent.prototype.onTextFilterClick = /**
     * @param {?} eventArgs
     * @return {?}
     */
    function (eventArgs) {
        if (this.shouldOpenSubMenu) {
            this._subMenuOverlaySettings.positionStrategy.settings.target = eventArgs.currentTarget;
            /** @type {?} */
            var gridRect = this.grid.nativeElement.getBoundingClientRect();
            /** @type {?} */
            var dropdownRect = this.mainDropdown.nativeElement.getBoundingClientRect();
            /** @type {?} */
            var x = dropdownRect.left + dropdownRect.width;
            /** @type {?} */
            var x1 = gridRect.left + gridRect.width;
            x += window.pageXOffset;
            x1 += window.pageXOffset;
            if (Math.abs(x - x1) < 200) {
                this._subMenuOverlaySettings.positionStrategy.settings.horizontalDirection = HorizontalAlignment.Left;
                this._subMenuOverlaySettings.positionStrategy.settings.horizontalStartPoint = HorizontalAlignment.Left;
            }
            else {
                this._subMenuOverlaySettings.positionStrategy.settings.horizontalDirection = HorizontalAlignment.Right;
                this._subMenuOverlaySettings.positionStrategy.settings.horizontalStartPoint = HorizontalAlignment.Right;
            }
            this.subMenu.open(this._subMenuOverlaySettings);
            this.shouldOpenSubMenu = false;
        }
    };
    /**
     * @param {?} eventArgs
     * @return {?}
     */
    IgxGridExcelStyleFilteringComponent.prototype.onTextFilterKeyDown = /**
     * @param {?} eventArgs
     * @return {?}
     */
    function (eventArgs) {
        if (eventArgs.key === "Enter" /* ENTER */) {
            this.onTextFilterClick(eventArgs);
        }
    };
    /**
     * @return {?}
     */
    IgxGridExcelStyleFilteringComponent.prototype.onSubMenuClosed = /**
     * @return {?}
     */
    function () {
        var _this = this;
        requestAnimationFrame(function () {
            _this.shouldOpenSubMenu = true;
        });
    };
    /**
     * @param {?} eventArgs
     * @return {?}
     */
    IgxGridExcelStyleFilteringComponent.prototype.onSubMenuSelection = /**
     * @param {?} eventArgs
     * @return {?}
     */
    function (eventArgs) {
        this.customDialog.selectedOperator = eventArgs.newSelection.value;
        eventArgs.cancel = true;
        this.mainDropdown.nativeElement.style.display = 'none';
        this.subMenu.close();
        this.customDialog.open();
    };
    /**
     * @private
     * @return {?}
     */
    IgxGridExcelStyleFilteringComponent.prototype.areExpressionsSelectable = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.expressionsList.length === 1 &&
            (this.expressionsList[0].expression.condition.name === 'equals' ||
                this.expressionsList[0].expression.condition.name === 'true' ||
                this.expressionsList[0].expression.condition.name === 'false' ||
                this.expressionsList[0].expression.condition.name === 'empty' ||
                this.expressionsList[0].expression.condition.name === 'in')) {
            return true;
        }
        /** @type {?} */
        var selectableExpressionsCount = this.expressionsList.filter(function (exp) {
            return (exp.beforeOperator === 1 || exp.afterOperator === 1) &&
                (exp.expression.condition.name === 'equals' ||
                    exp.expression.condition.name === 'true' ||
                    exp.expression.condition.name === 'false' ||
                    exp.expression.condition.name === 'empty' ||
                    exp.expression.condition.name === 'in');
        }).length;
        return selectableExpressionsCount === this.expressionsList.length;
    };
    /**
     * @private
     * @return {?}
     */
    IgxGridExcelStyleFilteringComponent.prototype.areExpressionsValuesInTheList = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.column.dataType === DataType.Boolean) {
            return true;
        }
        if (this.filterValues.size === 1) {
            /** @type {?} */
            var firstValue = this.filterValues.values().next().value;
            if (!firstValue && firstValue !== 0) {
                return true;
            }
        }
        for (var index = 0; index < this.uniqueValues.length; index++) {
            if (this.filterValues.has(this.uniqueValues[index])) {
                return true;
            }
        }
        return false;
    };
    /**
     * @return {?}
     */
    IgxGridExcelStyleFilteringComponent.prototype.populateColumnData = /**
     * @return {?}
     */
    function () {
        var _this = this;
        var e_1, _a;
        /** @type {?} */
        var data = this.column.gridAPI.get_all_data(this.grid.id);
        /** @type {?} */
        var gridExpressionsTree = this.grid.filteringExpressionsTree;
        /** @type {?} */
        var expressionsTree = new FilteringExpressionsTree(gridExpressionsTree.operator, gridExpressionsTree.fieldName);
        try {
            for (var _b = __values(gridExpressionsTree.filteringOperands), _c = _b.next(); !_c.done; _c = _b.next()) {
                var operand = _c.value;
                if (operand instanceof FilteringExpressionsTree) {
                    /** @type {?} */
                    var columnExprTree = (/** @type {?} */ (operand));
                    if (columnExprTree.fieldName === this.column.field) {
                        break;
                    }
                }
                expressionsTree.filteringOperands.push(operand);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (expressionsTree.filteringOperands.length) {
            /** @type {?} */
            var state$$1 = { expressionsTree: expressionsTree };
            data = DataUtil.filter(cloneArray(data), state$$1);
        }
        if (this.column.dataType === DataType.Date) {
            this.uniqueValues = Array.from(new Set(data.map(function (record) {
                return record[_this.column.field] ? record[_this.column.field].toDateString() : record[_this.column.field];
            })));
            this.filterValues = new Set(this.expressionsList.reduce(function (arr, e) {
                if (e.expression.condition.name === 'in') {
                    return __spread(arr, Array.from(((/** @type {?} */ (e.expression.searchVal))).values()).map(function (v) {
                        return new Date(v).toDateString();
                    }));
                }
                return __spread(arr, [e.expression.searchVal ? e.expression.searchVal.toDateString() : e.expression.searchVal]);
            }, []));
        }
        else {
            this.uniqueValues = Array.from(new Set(data.map(function (record) { return record[_this.column.field]; })));
            this.filterValues = new Set(this.expressionsList.reduce(function (arr, e) {
                if (e.expression.condition.name === 'in') {
                    return __spread(arr, Array.from(((/** @type {?} */ (e.expression.searchVal))).values()));
                }
                return __spread(arr, [e.expression.searchVal]);
            }, []));
        }
        this.listData = new Array();
        /** @type {?} */
        var shouldUpdateSelection = this.areExpressionsSelectable() && this.areExpressionsValuesInTheList();
        if (this.column.dataType === DataType.Boolean) {
            this.addBooleanItems();
        }
        else {
            this.addItems(shouldUpdateSelection);
        }
        this.listData.sort(function (a, b) { return _this.sortData(a, b); });
        if (this.column.dataType === DataType.Date) {
            this.uniqueValues = this.uniqueValues.map(function (value) { return new Date(value); });
        }
        if (this.containsNullOrEmpty) {
            this.addBlanksItem(shouldUpdateSelection);
        }
        this.addSelectAllItem();
        this.cdr.detectChanges();
    };
    /**
     * @private
     * @return {?}
     */
    IgxGridExcelStyleFilteringComponent.prototype.addBooleanItems = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.selectAllSelected = true;
        this.selectAllIndeterminate = false;
        this.uniqueValues.forEach(function (element) {
            /** @type {?} */
            var filterListItem = new FilterListItem();
            if (element !== undefined && element !== null && element !== '') {
                if (_this.column.filteringExpressionsTree) {
                    if (element === true && _this.expressionsList.find(function (exp) { return exp.expression.condition.name === 'true'; })) {
                        filterListItem.isSelected = true;
                        _this.selectAllIndeterminate = true;
                    }
                    else if (element === false && _this.expressionsList.find(function (exp) { return exp.expression.condition.name === 'false'; })) {
                        filterListItem.isSelected = true;
                        _this.selectAllIndeterminate = true;
                    }
                    else {
                        filterListItem.isSelected = false;
                    }
                }
                else {
                    filterListItem.isSelected = true;
                }
                filterListItem.value = element;
                filterListItem.label = element;
                filterListItem.indeterminate = false;
                _this.listData.push(filterListItem);
            }
            else {
                _this.containsNullOrEmpty = true;
            }
        });
    };
    /**
     * @private
     * @param {?} shouldUpdateSelection
     * @return {?}
     */
    IgxGridExcelStyleFilteringComponent.prototype.addItems = /**
     * @private
     * @param {?} shouldUpdateSelection
     * @return {?}
     */
    function (shouldUpdateSelection) {
        var _this = this;
        this.selectAllSelected = true;
        this.selectAllIndeterminate = false;
        this.uniqueValues.forEach(function (element) {
            if (element !== undefined && element !== null && element !== '') {
                /** @type {?} */
                var filterListItem = new FilterListItem();
                if (_this.column.filteringExpressionsTree) {
                    if (shouldUpdateSelection) {
                        if (_this.filterValues.has(element)) {
                            filterListItem.isSelected = true;
                        }
                        else {
                            filterListItem.isSelected = false;
                        }
                        _this.selectAllIndeterminate = true;
                    }
                    else {
                        filterListItem.isSelected = false;
                        _this.selectAllSelected = false;
                    }
                }
                else {
                    filterListItem.isSelected = true;
                }
                if (_this.column.dataType === DataType.Date) {
                    filterListItem.value = new Date(element);
                    filterListItem.label = new Date(element);
                }
                else {
                    filterListItem.value = element;
                    filterListItem.label = element;
                }
                filterListItem.indeterminate = false;
                _this.listData.push(filterListItem);
            }
            else {
                _this.containsNullOrEmpty = true;
            }
        });
    };
    /**
     * @private
     * @return {?}
     */
    IgxGridExcelStyleFilteringComponent.prototype.addSelectAllItem = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var selectAll = new FilterListItem();
        selectAll.isSelected = this.selectAllSelected;
        selectAll.value = this.grid.resourceStrings.igx_grid_excel_select_all;
        selectAll.label = this.grid.resourceStrings.igx_grid_excel_select_all;
        selectAll.indeterminate = this.selectAllIndeterminate;
        selectAll.isSpecial = true;
        this.listData.unshift(selectAll);
    };
    /**
     * @private
     * @param {?} shouldUpdateSelection
     * @return {?}
     */
    IgxGridExcelStyleFilteringComponent.prototype.addBlanksItem = /**
     * @private
     * @param {?} shouldUpdateSelection
     * @return {?}
     */
    function (shouldUpdateSelection) {
        /** @type {?} */
        var blanks = new FilterListItem();
        if (this.column.filteringExpressionsTree) {
            if (shouldUpdateSelection) {
                if (this.filterValues.has(null)) {
                    blanks.isSelected = true;
                }
                else {
                    blanks.isSelected = false;
                }
            }
        }
        else {
            blanks.isSelected = true;
        }
        blanks.value = null;
        blanks.label = this.grid.resourceStrings.igx_grid_excel_blanks;
        blanks.indeterminate = false;
        blanks.isSpecial = true;
        this.listData.unshift(blanks);
    };
    /**
     * @private
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    IgxGridExcelStyleFilteringComponent.prototype.sortData = /**
     * @private
     * @param {?} a
     * @param {?} b
     * @return {?}
     */
    function (a, b) {
        /** @type {?} */
        var valueA = a.value;
        /** @type {?} */
        var valueB = b.value;
        if (typeof (a) === DataType.String) {
            valueA = a.value.toUpperCase();
            valueB = b.value.toUpperCase();
        }
        if (valueA < valueB) {
            return -1;
        }
        else if (valueA > valueB) {
            return 1;
        }
        else {
            return 0;
        }
    };
    Object.defineProperty(IgxGridExcelStyleFilteringComponent.prototype, "sortingTemplate", {
        // TODO: sort members by access modifier
        get: 
        // TODO: sort members by access modifier
        /**
         * @return {?}
         */
        function () {
            if (this.grid.excelStyleSortingTemplateDirective) {
                return this.grid.excelStyleSortingTemplateDirective.template;
            }
            else {
                return this.defaultExcelStyleSortingTemplate;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridExcelStyleFilteringComponent.prototype, "movingTemplate", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.grid.excelStyleMovingTemplateDirective) {
                return this.grid.excelStyleMovingTemplateDirective.template;
            }
            else {
                return this.defaultExcelStyleMovingTemplate;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridExcelStyleFilteringComponent.prototype, "pinningTemplate", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.grid.excelStylePinningTemplateDirective) {
                return this.grid.excelStylePinningTemplateDirective.template;
            }
            else {
                return this.defaultExcelStylePinningTemplate;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridExcelStyleFilteringComponent.prototype, "hidingTemplate", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.grid.excelStyleHidingTemplateDirective) {
                return this.grid.excelStyleHidingTemplateDirective.template;
            }
            else {
                return this.defaultExcelStyleHidingTemplate;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridExcelStyleFilteringComponent.prototype, "applyButtonDisabled", {
        get: /**
         * @return {?}
         */
        function () {
            return this.listData[0] && !this.listData[0].isSelected && !this.listData[0].indeterminate;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    IgxGridExcelStyleFilteringComponent.prototype.applyFilter = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var filterTree = new FilteringExpressionsTree(FilteringLogic.Or, this.column.field);
        /** @type {?} */
        var selectedItems = this.listData.slice(1, this.listData.length).filter(function (el) { return el.isSelected === true; });
        /** @type {?} */
        var unselectedItem = this.listData.slice(1, this.listData.length).find(function (el) { return el.isSelected === false; });
        if (unselectedItem) {
            if (selectedItems.length <= IgxGridExcelStyleFilteringComponent.filterOptimizationThreshold) {
                selectedItems.forEach(function (element) {
                    /** @type {?} */
                    var condition = null;
                    if (element.value !== null && element.value !== undefined) {
                        if (_this.column.dataType === DataType.Boolean) {
                            condition = _this.createCondition(element.value.toString());
                        }
                        else {
                            condition = _this.createCondition('equals');
                        }
                    }
                    else {
                        condition = _this.createCondition('empty');
                    }
                    filterTree.filteringOperands.push({
                        condition: condition,
                        fieldName: _this.column.field,
                        ignoreCase: _this.column.filteringIgnoreCase,
                        searchVal: element.value
                    });
                });
            }
            else {
                /** @type {?} */
                var blanksItemIndex = selectedItems.findIndex(function (e) { return e.value === null || e.value === undefined; });
                /** @type {?} */
                var blanksItem = void 0;
                if (blanksItemIndex >= 0) {
                    blanksItem = selectedItems[blanksItemIndex];
                    selectedItems.splice(blanksItemIndex, 1);
                }
                if (this.column.dataType === DataType.Date) {
                    filterTree.filteringOperands.push({
                        condition: new InDateFilteringOperation(),
                        fieldName: this.column.field,
                        ignoreCase: this.column.filteringIgnoreCase,
                        searchVal: new Set(selectedItems.map(function (d) {
                            return new Date(d.value.getFullYear(), d.value.getMonth(), d.value.getDate()).toISOString();
                        }))
                    });
                }
                else {
                    filterTree.filteringOperands.push({
                        condition: new InFilteringOperation(),
                        fieldName: this.column.field,
                        ignoreCase: this.column.filteringIgnoreCase,
                        searchVal: new Set(selectedItems.map(function (e) { return e.value; }))
                    });
                }
                if (blanksItem) {
                    filterTree.filteringOperands.push({
                        condition: this.createCondition('empty'),
                        fieldName: this.column.field,
                        ignoreCase: this.column.filteringIgnoreCase,
                        searchVal: blanksItem.value
                    });
                }
            }
            this.expressionsList = new Array();
            this.filteringService.filterInternal(this.column.field, filterTree);
        }
        else {
            this.filteringService.clearFilter(this.column.field);
        }
        this.closeDropdown();
    };
    /**
     * @return {?}
     */
    IgxGridExcelStyleFilteringComponent.prototype.closeDropdown = /**
     * @return {?}
     */
    function () {
        if (this.overlayComponentId) {
            this.overlayService.hide(this.overlayComponentId);
            this.overlayComponentId = null;
        }
    };
    /**
     * @param {?} eventArgs
     * @return {?}
     */
    IgxGridExcelStyleFilteringComponent.prototype.onKeyDown = /**
     * @param {?} eventArgs
     * @return {?}
     */
    function (eventArgs) {
        if (eventArgs.key === "Escape" /* ESCAPE */ || eventArgs.key === "Esc" /* ESCAPE_IE */) {
            this.closeDropdown();
        }
        eventArgs.stopPropagation();
    };
    /**
     * @return {?}
     */
    IgxGridExcelStyleFilteringComponent.prototype.clearFilter = /**
     * @return {?}
     */
    function () {
        this.filteringService.clearFilter(this.column.field);
        this.populateColumnData();
    };
    /**
     * @param {?} eventArgs
     * @return {?}
     */
    IgxGridExcelStyleFilteringComponent.prototype.onClearFilterKeyDown = /**
     * @param {?} eventArgs
     * @return {?}
     */
    function (eventArgs) {
        if (eventArgs.key === "Enter" /* ENTER */) {
            this.clearFilter();
        }
    };
    /**
     * @return {?}
     */
    IgxGridExcelStyleFilteringComponent.prototype.showCustomFilterItem = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var exprTree = this.column.filteringExpressionsTree;
        return exprTree && exprTree.filteringOperands && exprTree.filteringOperands.length &&
            !(((/** @type {?} */ (exprTree.filteringOperands[0]))).condition &&
                ((/** @type {?} */ (exprTree.filteringOperands[0]))).condition.name === 'in');
    };
    /**
     * @private
     * @param {?} conditionName
     * @return {?}
     */
    IgxGridExcelStyleFilteringComponent.prototype.createCondition = /**
     * @private
     * @param {?} conditionName
     * @return {?}
     */
    function (conditionName) {
        switch (this.column.dataType) {
            case DataType.Boolean:
                return IgxBooleanFilteringOperand.instance().condition(conditionName);
            case DataType.Number:
                return IgxNumberFilteringOperand.instance().condition(conditionName);
            case DataType.Date:
                return IgxDateFilteringOperand.instance().condition(conditionName);
            default:
                return IgxStringFilteringOperand.instance().condition(conditionName);
        }
    };
    IgxGridExcelStyleFilteringComponent.filterOptimizationThreshold = 2;
    IgxGridExcelStyleFilteringComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-grid-excel-style-filtering',
                    template: "<article #dropdown\n    class=\"igx-excel-filter__menu\"\n    [id]=\"overlayComponentId\"\n    (keydown)=\"onKeyDown($event)\">\n\n    <header class=\"igx-excel-filter__menu-header\">\n        <h4 class=\"igx-typography__h6\">{{ column.header || column.field }}</h4>\n        <div *ngIf=\"grid.displayDensity!=='comfortable'\" class=\"igx-excel-filter__menu-header-actions\">\n            <button *ngIf=\"!column.disablePinning && !column.pinned\"\n                igxButton=\"icon\"\n                [displayDensity]=\"grid.displayDensity\"\n                (click)=\"onPin()\"\n                tabindex=\"0\">\n                <igx-icon fontSet=\"filtering-icons\" name=\"pin\"></igx-icon>\n            </button>\n            <button *ngIf=\"!column.disablePinning && column.pinned\"\n                igxButton=\"icon\"\n                [displayDensity]=\"grid.displayDensity\"\n                (click)=\"onPin()\"\n                tabindex=\"0\">\n                <igx-icon fontSet=\"filtering-icons\" name=\"unpin\"></igx-icon>\n            </button>\n            <button *ngIf=\"!column.disableHiding\"\n                igxButton=\"icon\"\n                [displayDensity]=\"grid.displayDensity\"\n                tabindex=\"0\"\n                (click)=\"onHide()\">\n                <igx-icon>visibility_off</igx-icon>\n            </button>\n        </div>\n    </header>\n\n    <ng-template #defaultExcelStyleSortingTemplate>\n        <igx-excel-style-sorting\n            #excelStyleSorting\n            [ngClass]=\"(grid.displayDensity==='compact')? 'igx-excel-filter__sort--compact': 'igx-excel-filter__sort'\"\n            [column]=\"column\"\n            [grid]=\"grid\"\n            [displayDensity]=\"grid.displayDensity\">\n        </igx-excel-style-sorting>\n    </ng-template>\n\n    <div *ngIf=\"column.sortable\">\n        <ng-container *ngTemplateOutlet=\"sortingTemplate\"></ng-container>\n    </div>\n\n    <section class=\"igx-excel-filter__actions\">\n\n        <ng-template #defaultExcelStyleMovingTemplate>\n            <igx-excel-style-column-moving\n                [ngClass]=\"(grid.displayDensity==='compact')? 'igx-excel-filter__move--compact': 'igx-excel-filter__move'\"\n                [column]=\"column\"\n                [grid]=\"grid\"\n                [displayDensity]=\"grid.displayDensity\">\n            </igx-excel-style-column-moving>\n        </ng-template>\n\n        <div *ngIf=\"column.movable\">\n            <ng-container *ngTemplateOutlet=\"movingTemplate\"></ng-container>\n        </div>\n\n        <ng-template #defaultExcelStylePinningTemplate>\n            <div class=\"igx-excel-filter__actions-pin\"\n                (click)=\"onPin()\"\n                tabindex=\"0\"\n                *ngIf=\"!column.pinned\">\n                <span>{{ grid.resourceStrings.igx_grid_excel_pin }}</span>\n                <igx-icon fontSet=\"filtering-icons\" name=\"pin\"></igx-icon>\n            </div>\n\n            <div class=\"igx-excel-filter__actions-unpin\"\n                (click)=\"onPin()\"\n                tabindex=\"0\"\n                *ngIf=\"column.pinned\">\n                <span>{{ grid.resourceStrings.igx_grid_excel_unpin }}</span>\n                <igx-icon fontSet=\"filtering-icons\" name=\"unpin\"></igx-icon>\n            </div>\n        </ng-template>\n\n        <div *ngIf=\"!column.disablePinning && grid.displayDensity==='comfortable'\">\n            <ng-container *ngTemplateOutlet=\"pinningTemplate\"></ng-container>\n        </div>\n\n        <ng-template #defaultExcelStyleHidingTemplate>\n            <div class=\"igx-excel-filter__actions-hide\"\n                tabindex=\"0\"\n                (click)=\"onHide()\">\n                <span>{{ grid.resourceStrings.igx_grid_excel_hide }}</span>\n                <igx-icon>visibility_off</igx-icon>\n            </div>\n        </ng-template>\n\n        <div *ngIf=\"!column.disableHiding && grid.displayDensity==='comfortable'\">\n            <ng-container *ngTemplateOutlet=\"hidingTemplate\"></ng-container>\n        </div>\n\n        <div\n            tabindex=\"0\"\n            [ngClass]=\"clearFilterClass()\"\n            (keydown)=\"onClearFilterKeyDown($event)\"\n            (click)=\"clearFilter()\">\n            <span>{{ grid.resourceStrings.igx_grid_excel_custom_dialog_clear }}</span>\n            <igx-icon>clear</igx-icon>\n        </div>\n\n        <div\n            tabindex=\"0\"\n            class=\"igx-excel-filter__actions-filter\"\n            (keydown)=\"onTextFilterKeyDown($event)\"\n            (click)=\"onTextFilterClick($event)\"\n            [igxDropDownItemNavigation]=\"subMenu\" >\n            <span>{{ subMenuText }}</span>\n            <igx-icon>keyboard_arrow_right</igx-icon>\n        </div>\n    </section>\n\n    <igx-excel-style-search\n        class=\"igx-excel-filter__menu-main\"\n        #excelStyleSearch\n        [column]=\"column\"\n        [data]=\"listData\"\n        [displayDensity]=\"grid.displayDensity\">\n    </igx-excel-style-search>\n\n    <footer class=\"igx-excel-filter__menu-footer\">\n        <button igxButton [displayDensity]=\"grid.displayDensity\" (click)=\"closeDropdown()\">{{ grid.resourceStrings.igx_grid_excel_cancel }}</button>\n        <button igxButton=\"raised\" [displayDensity]=\"grid.displayDensity\" [disabled]=\"applyButtonDisabled\" (click)=\"applyFilter()\">{{ grid.resourceStrings.igx_grid_excel_apply }}</button>\n    </footer>\n</article>\n\n<igx-drop-down [maxHeight]=\"'397px'\" #subMenu (onSelection)=\"onSubMenuSelection($event)\" (onClosed)=\"onSubMenuClosed()\">\n    <div>\n        <igx-drop-down-item\n            *ngFor=\"let condition of conditions\"\n            [value]=\"condition\">\n            <igx-icon fontSet=\"filtering-icons\" [name]=\"getCondition(condition).iconName\"></igx-icon>\n            <span style=\"margin-left: 16px\">{{ translateCondition(condition) }}</span>\n        </igx-drop-down-item>\n        <igx-drop-down-item *ngIf=\"showCustomFilterItem()\">\n            <igx-icon>filter_list</igx-icon>\n            <span style=\"margin-left: 16px\">{{ grid.resourceStrings.igx_grid_excel_custom_filter }}</span>\n        </igx-drop-down-item>\n    </div>\n</igx-drop-down>\n\n<igx-excel-style-custom-dialog\n    #customDialog\n    [column]=\"column\"\n    [filteringService]=\"filteringService\"\n    [overlayComponentId]=\"overlayComponentId\"\n    [overlayService]=\"overlayService\"\n    [displayDensity]=\"grid.displayDensity\">\n</igx-excel-style-custom-dialog>\n"
                }] }
    ];
    /** @nocollapse */
    IgxGridExcelStyleFilteringComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef }
    ]; };
    IgxGridExcelStyleFilteringComponent.propDecorators = {
        className: [{ type: HostBinding, args: ['class.igx-excel-filter',] }],
        mainDropdown: [{ type: ViewChild, args: ['dropdown', { read: ElementRef },] }],
        subMenu: [{ type: ViewChild, args: ['subMenu', { read: IgxDropDownComponent },] }],
        customDialog: [{ type: ViewChild, args: ['customDialog', { read: IgxExcelStyleCustomDialogComponent },] }],
        excelStyleSearch: [{ type: ViewChild, args: ['excelStyleSearch', { read: IgxExcelStyleSearchComponent },] }],
        excelStyleSorting: [{ type: ViewChild, args: ['excelStyleSorting', { read: IgxExcelStyleSortingComponent },] }],
        defaultExcelStyleSortingTemplate: [{ type: ViewChild, args: ['defaultExcelStyleSortingTemplate', { read: TemplateRef },] }],
        defaultExcelStyleHidingTemplate: [{ type: ViewChild, args: ['defaultExcelStyleHidingTemplate', { read: TemplateRef },] }],
        defaultExcelStyleMovingTemplate: [{ type: ViewChild, args: ['defaultExcelStyleMovingTemplate', { read: TemplateRef },] }],
        defaultExcelStylePinningTemplate: [{ type: ViewChild, args: ['defaultExcelStylePinningTemplate', { read: TemplateRef },] }]
    };
    return IgxGridExcelStyleFilteringComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxGridHeaderComponent = /** @class */ (function () {
    function IgxGridHeaderComponent(gridAPI, colResizingService, cdr, elementRef, zone, _filteringService, _moduleRef, _overlayService) {
        this.gridAPI = gridAPI;
        this.colResizingService = colResizingService;
        this.cdr = cdr;
        this.elementRef = elementRef;
        this.zone = zone;
        this._filteringService = _filteringService;
        this._moduleRef = _moduleRef;
        this._overlayService = _overlayService;
        this._destroy$ = new Subject();
        this.hostRole = 'columnheader';
        this.tabindex = -1;
        this.sortDirection = SortingDirection.None;
    }
    Object.defineProperty(IgxGridHeaderComponent.prototype, "styleClasses", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var defaultClasses = [
                'igx-grid__th--fw',
                this.column.headerClasses
            ];
            /** @type {?} */
            var classList = {
                'igx-grid__th': !this.column.columnGroup,
                'asc': this.ascending,
                'desc': this.descending,
                'igx-grid__th--number': this.column.dataType === DataType.Number,
                'igx-grid__th--sortable': this.column.sortable,
                'igx-grid__th--filtrable': this.column.filterable && this.grid.filteringService.isFilterRowVisible,
                'igx-grid__th--sorted': this.sorted
            };
            Object.entries(classList).forEach(function (_a) {
                var _b = __read(_a, 2), klass = _b[0], value = _b[1];
                if (value) {
                    defaultClasses.push(klass);
                }
            });
            return defaultClasses.join(' ');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridHeaderComponent.prototype, "height", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.grid.hasColumnGroups) {
                return (this.grid.maxLevelHeaderDepth + 1 - this.column.level) * this.grid.defaultRowHeight;
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridHeaderComponent.prototype, "ascending", {
        get: /**
         * @return {?}
         */
        function () {
            return this.sortDirection === SortingDirection.Asc;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridHeaderComponent.prototype, "descending", {
        get: /**
         * @return {?}
         */
        function () {
            return this.sortDirection === SortingDirection.Desc;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridHeaderComponent.prototype, "sortingIcon", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.sortDirection !== SortingDirection.None) {
                // arrow_downward and arrow_upward
                // are material icons ligature strings
                return this.sortDirection === SortingDirection.Asc ? 'arrow_upward' : 'arrow_downward';
            }
            return 'arrow_upward';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridHeaderComponent.prototype, "sorted", {
        get: /**
         * @return {?}
         */
        function () {
            return this.sortDirection !== SortingDirection.None;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridHeaderComponent.prototype, "filterIconClassName", {
        get: /**
         * @return {?}
         */
        function () {
            return this.column.filteringExpressionsTree ? 'igx-excel-filter__icon--filtered' : 'igx-excel-filter__icon';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridHeaderComponent.prototype, "headerID", {
        get: /**
         * @return {?}
         */
        function () {
            return this.gridID + "_" + this.column.field;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    IgxGridHeaderComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.initFilteringSettings();
    };
    /**
     * @return {?}
     */
    IgxGridHeaderComponent.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
        this.getSortDirection();
        this.cdr.markForCheck();
    };
    /**
     * @return {?}
     */
    IgxGridHeaderComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this._destroy$.next(true);
        this._destroy$.complete();
        if (this._componentOverlayId) {
            this._overlayService.hide(this._componentOverlayId);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    IgxGridHeaderComponent.prototype.onClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this.colResizingService.isColumnResizing) {
            event.stopPropagation();
            if (this.grid.filteringService.isFilterRowVisible) {
                if (this.column.filterable && !this.column.columnGroup &&
                    !this.grid.filteringService.isFilterComplex(this.column.field)) {
                    this.grid.filteringService.filteredColumn = this.column;
                }
            }
            else if (this.column.sortable) {
                this.triggerSort();
            }
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    IgxGridHeaderComponent.prototype.onFilteringIconClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.stopPropagation();
        this.toggleFilterDropdown();
    };
    Object.defineProperty(IgxGridHeaderComponent.prototype, "grid", {
        get: /**
         * @return {?}
         */
        function () {
            return this.gridAPI.grid;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @protected
     * @return {?}
     */
    IgxGridHeaderComponent.prototype.getSortDirection = /**
     * @protected
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var expr = this.gridAPI.grid.sortingExpressions.find(function (x) { return x.fieldName === _this.column.field; });
        this.sortDirection = expr ? expr.dir : SortingDirection.None;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    IgxGridHeaderComponent.prototype.onSortingIconClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.grid.filteringService.isFilterRowVisible) {
            event.stopPropagation();
            this.triggerSort();
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxGridHeaderComponent.prototype.triggerSort = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var groupingExpr = this.grid.groupingExpressions ?
            this.grid.groupingExpressions.find(function (expr) { return expr.fieldName === _this.column.field; }) : null;
        /** @type {?} */
        var sortDir = groupingExpr ?
            this.sortDirection + 1 > SortingDirection.Desc ? SortingDirection.Asc : SortingDirection.Desc
            : this.sortDirection + 1 > SortingDirection.Desc ? SortingDirection.None : this.sortDirection + 1;
        this.sortDirection = sortDir;
        this.grid.sort({ fieldName: this.column.field, dir: this.sortDirection, ignoreCase: this.column.sortingIgnoreCase,
            strategy: this.column.sortStrategy });
    };
    /**
     * @private
     * @return {?}
     */
    IgxGridHeaderComponent.prototype.toggleFilterDropdown = /**
     * @private
     * @return {?}
     */
    function () {
        if (!this._componentOverlayId) {
            /** @type {?} */
            var headerTarget = this.elementRef.nativeElement;
            /** @type {?} */
            var filterIconTarget = headerTarget.querySelector('.' + this.filterIconClassName);
            this._filterMenuOverlaySettings.positionStrategy.settings.target = filterIconTarget;
            this._filterMenuOverlaySettings.outlet = this.grid.outlet;
            this._componentOverlayId =
                this._overlayService.attach(IgxGridExcelStyleFilteringComponent, this._filterMenuOverlaySettings, this._moduleRef);
            this._overlayService.show(this._componentOverlayId, this._filterMenuOverlaySettings);
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxGridHeaderComponent.prototype.initFilteringSettings = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this._filterMenuPositionSettings = {
            verticalStartPoint: VerticalAlignment.Bottom,
            openAnimation: useAnimation(fadeIn, {
                params: {
                    duration: '250ms'
                }
            }),
            closeAnimation: useAnimation(fadeOut, {
                params: {
                    duration: '200ms'
                }
            })
        };
        this._filterMenuOverlaySettings = {
            closeOnOutsideClick: true,
            modal: false,
            positionStrategy: new AutoPositionStrategy(this._filterMenuPositionSettings),
            scrollStrategy: new AbsoluteScrollStrategy()
        };
        this._overlayService.onOpening.pipe(filter(function (overlay) { return overlay.id === _this._componentOverlayId; }), takeUntil(this._destroy$)).subscribe(function (eventArgs) {
            _this.onOverlayOpening(eventArgs);
        });
        this._overlayService.onClosed.pipe(filter(function (overlay) { return overlay.id === _this._componentOverlayId; }), takeUntil(this._destroy$)).subscribe(function () {
            _this.onOverlayClosed();
        });
    };
    /**
     * @private
     * @param {?} eventArgs
     * @return {?}
     */
    IgxGridHeaderComponent.prototype.onOverlayOpening = /**
     * @private
     * @param {?} eventArgs
     * @return {?}
     */
    function (eventArgs) {
        /** @type {?} */
        var instance = (/** @type {?} */ (eventArgs.componentRef.instance));
        if (instance) {
            instance.initialize(this.column, this._filteringService, this._overlayService, eventArgs.id);
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxGridHeaderComponent.prototype.onOverlayClosed = /**
     * @private
     * @return {?}
     */
    function () {
        this._componentOverlayId = null;
    };
    IgxGridHeaderComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-grid-header',
                    template: "<ng-template #defaultColumn>\n    {{ column.header || column.field }}\n</ng-template>\n\n<span class=\"igx-grid__th-title\">\n    <ng-container *ngTemplateOutlet=\"column.headerTemplate ? column.headerTemplate : defaultColumn; context: { $implicit: column, column: column}\">\n    </ng-container>\n</span>\n<div class=\"igx-grid__th-icons\" *ngIf=\"!column.columnGroup\">\n    <igx-icon [attr.draggable]=\"false\"\n        class=\"sort-icon\"\n        *ngIf=\"column.sortable\"\n        (click)=\"onSortingIconClick($event)\">\n        {{sortingIcon}}\n    </igx-icon>\n\n    <igx-icon [ngClass]=\"filterIconClassName\" [attr.draggable]=\"false\" (click)=\"onFilteringIconClick($event)\"\n        *ngIf=\"grid.allowFiltering == true && column.filterable && grid.filterMode == 'excelStyleFilter'\">\n        filter_list\n    </igx-icon>\n</div>\n"
                }] }
    ];
    /** @nocollapse */
    IgxGridHeaderComponent.ctorParameters = function () { return [
        { type: GridBaseAPIService },
        { type: IgxColumnResizingService },
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone },
        { type: IgxFilteringService },
        { type: NgModuleRef },
        { type: IgxOverlayService, decorators: [{ type: Inject, args: [IgxOverlayService,] }] }
    ]; };
    IgxGridHeaderComponent.propDecorators = {
        column: [{ type: Input }],
        gridID: [{ type: Input }],
        styleClasses: [{ type: HostBinding, args: ['class',] }],
        height: [{ type: HostBinding, args: ['style.height.px',] }],
        hostRole: [{ type: HostBinding, args: ['attr.role',] }],
        tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
        headerID: [{ type: HostBinding, args: ['attr.id',] }],
        onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
    };
    return IgxGridHeaderComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxGridFilteringCellComponent = /** @class */ (function () {
    function IgxGridFilteringCellComponent(cdr, filteringService, navService) {
        this.cdr = cdr;
        this.filteringService = filteringService;
        this.navService = navService;
        this.baseClass = 'igx-grid__filtering-cell-indicator';
        this.currentTemplate = null;
        this.moreFiltersCount = 0;
        this.cssClass = 'igx-grid__filtering-cell';
        this.filteringService.subscribeToEvents();
    }
    /**
     * @return {?}
     */
    IgxGridFilteringCellComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.filteringService.columnToMoreIconHidden.set(this.column.field, true);
    };
    /**
     * @return {?}
     */
    IgxGridFilteringCellComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.updateFilterCellArea();
    };
    /**
     * @return {?}
     */
    IgxGridFilteringCellComponent.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
        this.updateFilterCellArea();
    };
    /**
     * @param {?} eventArgs
     * @return {?}
     */
    IgxGridFilteringCellComponent.prototype.onTabKeyDown = /**
     * @param {?} eventArgs
     * @return {?}
     */
    function (eventArgs) {
        if (this.isLastElementFocused()) {
            this.filteringService.grid.navigation.navigateNextFilterCell(this.column, eventArgs);
        }
        eventArgs.stopPropagation();
    };
    /**
     * @param {?} eventArgs
     * @return {?}
     */
    IgxGridFilteringCellComponent.prototype.onShiftTabKeyDown = /**
     * @param {?} eventArgs
     * @return {?}
     */
    function (eventArgs) {
        if (this.isFirstElementFocused()) {
            this.filteringService.grid.navigation.navigatePrevFilterCell(this.column, eventArgs);
        }
        eventArgs.stopPropagation();
    };
    /**
     * Returns whether a chip with a given index is visible or not.
     */
    /**
     * Returns whether a chip with a given index is visible or not.
     * @param {?} index
     * @return {?}
     */
    IgxGridFilteringCellComponent.prototype.isChipVisible = /**
     * Returns whether a chip with a given index is visible or not.
     * @param {?} index
     * @return {?}
     */
    function (index) {
        /** @type {?} */
        var expression = this.expressionsList[index];
        return !!(expression && expression.isVisible);
    };
    /**
     * Updates the filtering cell area.
     */
    /**
     * Updates the filtering cell area.
     * @return {?}
     */
    IgxGridFilteringCellComponent.prototype.updateFilterCellArea = /**
     * Updates the filtering cell area.
     * @return {?}
     */
    function () {
        this.expressionsList = this.filteringService.getExpressions(this.column.field);
        this.updateVisibleFilters();
    };
    Object.defineProperty(IgxGridFilteringCellComponent.prototype, "template", {
        get: /**
         * @return {?}
         */
        function () {
            if (!this.column.filterable) {
                this.currentTemplate = null;
                return null;
            }
            if (this.column.filterCellTemplate) {
                this.currentTemplate = this.column.filterCellTemplate;
                return this.column.filterCellTemplate;
            }
            /** @type {?} */
            var expressionTree = this.column.filteringExpressionsTree;
            if (!expressionTree || expressionTree.filteringOperands.length === 0) {
                this.currentTemplate = this.emptyFilter;
                return this.emptyFilter;
            }
            if (this.filteringService.isFilterComplex(this.column.field)) {
                this.currentTemplate = this.complexFilter;
                return this.complexFilter;
            }
            this.currentTemplate = this.defaultFilter;
            return this.defaultFilter;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridFilteringCellComponent.prototype, "context", {
        /**
         * Gets the context passed to the filter template.
         * @memberof IgxGridFilteringCellComponent
         */
        get: /**
         * Gets the context passed to the filter template.
         * \@memberof IgxGridFilteringCellComponent
         * @return {?}
         */
        function () {
            return {
                column: this.column
            };
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Chip clicked event handler.
     */
    /**
     * Chip clicked event handler.
     * @param {?=} expression
     * @return {?}
     */
    IgxGridFilteringCellComponent.prototype.onChipClicked = /**
     * Chip clicked event handler.
     * @param {?=} expression
     * @return {?}
     */
    function (expression) {
        if (expression) {
            this.expressionsList.forEach(function (item) {
                item.isSelected = (item.expression === expression);
            });
        }
        else if (this.expressionsList.length > 0) {
            this.expressionsList.forEach(function (item) {
                item.isSelected = false;
            });
            this.expressionsList[0].isSelected = true;
        }
        /** @type {?} */
        var index = this.filteringService.unpinnedFilterableColumns.indexOf(this.column);
        if (index >= 0 && !this.isColumnRightVisible(index)) {
            this.filteringService.scrollToFilterCell(this.filteringService.unpinnedFilterableColumns[index], true);
        }
        else if (index >= 0 && !this.isColumnLeftVisible(index)) {
            this.filteringService.scrollToFilterCell(this.filteringService.unpinnedFilterableColumns[index], false);
        }
        this.filteringService.filteredColumn = this.column;
        this.filteringService.isFilterRowVisible = true;
        this.filteringService.selectedExpression = expression;
    };
    /**
     * Chip removed event handler.
     */
    /**
     * Chip removed event handler.
     * @param {?} eventArgs
     * @param {?} item
     * @return {?}
     */
    IgxGridFilteringCellComponent.prototype.onChipRemoved = /**
     * Chip removed event handler.
     * @param {?} eventArgs
     * @param {?} item
     * @return {?}
     */
    function (eventArgs, item) {
        /** @type {?} */
        var indexToRemove = this.expressionsList.indexOf(item);
        this.removeExpression(indexToRemove);
        this.focusChip();
    };
    /**
     * Clears the filtering.
     */
    /**
     * Clears the filtering.
     * @return {?}
     */
    IgxGridFilteringCellComponent.prototype.clearFiltering = /**
     * Clears the filtering.
     * @return {?}
     */
    function () {
        this.filteringService.clearFilter(this.column.field);
        this.cdr.detectChanges();
    };
    /**
     * Chip keydown event handler.
     */
    /**
     * Chip keydown event handler.
     * @param {?} eventArgs
     * @param {?=} expression
     * @return {?}
     */
    IgxGridFilteringCellComponent.prototype.onChipKeyDown = /**
     * Chip keydown event handler.
     * @param {?} eventArgs
     * @param {?=} expression
     * @return {?}
     */
    function (eventArgs, expression) {
        if (eventArgs.key === "Enter" /* ENTER */) {
            eventArgs.preventDefault();
            this.onChipClicked(expression);
        }
    };
    /**
     * Returns the filtering indicator class.
     */
    /**
     * Returns the filtering indicator class.
     * @return {?}
     */
    IgxGridFilteringCellComponent.prototype.filteringIndicatorClass = /**
     * Returns the filtering indicator class.
     * @return {?}
     */
    function () {
        var _a;
        return _a = {},
            _a[this.baseClass] = !this.isMoreIconHidden(),
            _a[this.baseClass + "--hidden"] = this.isMoreIconHidden(),
            _a;
    };
    /**
     * Focus a chip depending on the current visible template.
     */
    /**
     * Focus a chip depending on the current visible template.
     * @param {?=} focusFirst
     * @return {?}
     */
    IgxGridFilteringCellComponent.prototype.focusChip = /**
     * Focus a chip depending on the current visible template.
     * @param {?=} focusFirst
     * @return {?}
     */
    function (focusFirst) {
        if (focusFirst === void 0) { focusFirst = false; }
        if (this.currentTemplate === this.defaultFilter) {
            if (focusFirst) {
                this.focusFirstElement();
            }
            else {
                this.focusElement();
            }
        }
        else if (this.currentTemplate === this.emptyFilter) {
            this.ghostChip.elementRef.nativeElement.querySelector(".igx-chip__item").focus();
        }
        else if (this.currentTemplate === this.complexFilter) {
            this.complexChip.elementRef.nativeElement.querySelector(".igx-chip__item").focus();
        }
    };
    /**
     * @private
     * @param {?} indexToRemove
     * @return {?}
     */
    IgxGridFilteringCellComponent.prototype.removeExpression = /**
     * @private
     * @param {?} indexToRemove
     * @return {?}
     */
    function (indexToRemove) {
        if (indexToRemove === 0 && this.expressionsList.length === 1) {
            this.clearFiltering();
            return;
        }
        this.filteringService.removeExpression(this.column.field, indexToRemove);
        this.updateVisibleFilters();
        this.filteringService.filterInternal(this.column.field);
    };
    /**
     * @private
     * @return {?}
     */
    IgxGridFilteringCellComponent.prototype.isMoreIconHidden = /**
     * @private
     * @return {?}
     */
    function () {
        return this.filteringService.columnToMoreIconHidden.get(this.column.field);
    };
    /**
     * @private
     * @return {?}
     */
    IgxGridFilteringCellComponent.prototype.updateVisibleFilters = /**
     * @private
     * @return {?}
     */
    function () {
        this.expressionsList.forEach(function (ex) { return ex.isVisible = true; });
        if (this.moreIcon) {
            this.filteringService.columnToMoreIconHidden.set(this.column.field, true);
        }
        this.cdr.detectChanges();
        if (this.chipsArea && this.expressionsList.length > 1) {
            /** @type {?} */
            var areaWidth = this.chipsArea.element.nativeElement.offsetWidth;
            /** @type {?} */
            var viewWidth = 0;
            /** @type {?} */
            var chipsAreaElements = this.chipsArea.element.nativeElement.children;
            /** @type {?} */
            var visibleChipsCount = 0;
            /** @type {?} */
            var moreIconWidth = this.moreIcon.nativeElement.offsetWidth -
                parseInt(document.defaultView.getComputedStyle(this.moreIcon.nativeElement)['margin-left'], 10);
            for (var index = 0; index < chipsAreaElements.length - 1; index++) {
                if (viewWidth + chipsAreaElements[index].offsetWidth < areaWidth) {
                    viewWidth += chipsAreaElements[index].offsetWidth;
                    if (index % 2 === 0) {
                        visibleChipsCount++;
                    }
                    else {
                        viewWidth += parseInt(document.defaultView.getComputedStyle(chipsAreaElements[index])['margin-left'], 10);
                        viewWidth += parseInt(document.defaultView.getComputedStyle(chipsAreaElements[index])['margin-right'], 10);
                    }
                }
                else {
                    if (index % 2 !== 0 && viewWidth + moreIconWidth > areaWidth) {
                        visibleChipsCount--;
                    }
                    else if (visibleChipsCount > 0 && viewWidth - chipsAreaElements[index - 1].offsetWidth + moreIconWidth > areaWidth) {
                        visibleChipsCount--;
                    }
                    this.moreFiltersCount = this.expressionsList.length - visibleChipsCount;
                    this.filteringService.columnToMoreIconHidden.set(this.column.field, false);
                    break;
                }
            }
            for (var i = visibleChipsCount; i < this.expressionsList.length; i++) {
                this.expressionsList[i].isVisible = false;
            }
            this.cdr.detectChanges();
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxGridFilteringCellComponent.prototype.isFirstElementFocused = /**
     * @private
     * @return {?}
     */
    function () {
        return !(this.chipsArea && this.chipsArea.chipsList.length > 0 &&
            this.chipsArea.chipsList.first.elementRef.nativeElement.querySelector(".igx-chip__item") !== document.activeElement);
    };
    /**
     * @private
     * @return {?}
     */
    IgxGridFilteringCellComponent.prototype.isLastElementFocused = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.chipsArea) {
            if (this.isMoreIconHidden() && this.chipsArea.chipsList.last.elementRef.nativeElement.querySelector(".igx-chip__remove") !==
                document.activeElement) {
                return false;
            }
            else if (!this.isMoreIconHidden() && this.moreIcon.nativeElement !== document.activeElement) {
                return false;
            }
        }
        return true;
    };
    /**
     * @private
     * @return {?}
     */
    IgxGridFilteringCellComponent.prototype.focusFirstElement = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.chipsArea.chipsList.length > 0) {
            this.chipsArea.chipsList.first.elementRef.nativeElement.querySelector(".igx-chip__item").focus();
        }
        else {
            this.moreIcon.nativeElement.focus();
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxGridFilteringCellComponent.prototype.focusElement = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.filteringService.shouldFocusNext) {
            if (!this.isMoreIconHidden() && this.chipsArea.chipsList.length === 0) {
                this.moreIcon.nativeElement.focus();
            }
            else {
                this.chipsArea.chipsList.first.elementRef.nativeElement.querySelector(".igx-chip__item").focus();
            }
        }
        else {
            if (!this.isMoreIconHidden()) {
                this.moreIcon.nativeElement.focus();
            }
            else {
                this.chipsArea.chipsList.last.elementRef.nativeElement.querySelector(".igx-chip__remove").focus();
            }
        }
    };
    /**
     * @private
     * @param {?} columnIndex
     * @return {?}
     */
    IgxGridFilteringCellComponent.prototype.isColumnRightVisible = /**
     * @private
     * @param {?} columnIndex
     * @return {?}
     */
    function (columnIndex) {
        if (this.filteringService.areAllColumnsInView) {
            return true;
        }
        /** @type {?} */
        var currentColumnRight = 0;
        for (var index = 0; index < this.filteringService.unpinnedColumns.length; index++) {
            currentColumnRight += parseInt(this.filteringService.unpinnedColumns[index].width, 10);
            if (this.filteringService.unpinnedColumns[index] === this.filteringService.unpinnedFilterableColumns[columnIndex]) {
                break;
            }
        }
        /** @type {?} */
        var width = this.filteringService.displayContainerWidth + this.filteringService.displayContainerScrollLeft;
        return currentColumnRight <= width;
    };
    /**
     * @private
     * @param {?} columnIndex
     * @return {?}
     */
    IgxGridFilteringCellComponent.prototype.isColumnLeftVisible = /**
     * @private
     * @param {?} columnIndex
     * @return {?}
     */
    function (columnIndex) {
        if (this.filteringService.areAllColumnsInView) {
            return true;
        }
        /** @type {?} */
        var currentColumnLeft = 0;
        for (var index = 0; index < this.filteringService.unpinnedColumns.length; index++) {
            if (this.filteringService.unpinnedColumns[index] === this.filteringService.unpinnedFilterableColumns[columnIndex]) {
                break;
            }
            currentColumnLeft += parseInt(this.filteringService.unpinnedColumns[index].width, 10);
        }
        return currentColumnLeft >= this.filteringService.displayContainerScrollLeft;
    };
    IgxGridFilteringCellComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-grid-filtering-cell',
                    template: "<ng-template #emptyFilter>\n        <igx-chips-area [attr.draggable]=\"false\" class=\"igx-filtering-chips\">\n            <igx-chip #ghostChip [attr.draggable]=\"false\" (click)=\"onChipClicked()\" (keydown)=\"onChipKeyDown($event)\" [displayDensity]=\"'cosy'\">\n                <igx-icon [attr.draggable]=\"false\" igxPrefix>filter_list</igx-icon>\n                <span [attr.draggable]=\"false\">{{filteringService.grid.resourceStrings.igx_grid_filter}}</span>\n            </igx-chip>\n        </igx-chips-area>\n</ng-template>\n\n<ng-template #defaultFilter>\n    <igx-chips-area #chipsArea class=\"igx-filtering-chips\">\n        <ng-container *ngFor=\"let item of expressionsList; let last = last; let index = index;\" >\n            <igx-chip\n                *ngIf=\"isChipVisible(index)\"\n                [removable]=\"true\"\n                [displayDensity]=\"'cosy'\"\n                (click)=\"onChipClicked(item.expression)\"\n                (keydown)=\"onChipKeyDown($event, item.expression)\"\n                (onRemove)=\"onChipRemoved($event, item)\">\n                <igx-icon igxPrefix\n                    fontSet=\"filtering-icons\"\n                    [name]=\"item.expression.condition.iconName\">\n                </igx-icon>\n                <span #label>\n                    {{filteringService.getChipLabel(item.expression)}}\n                </span>\n            </igx-chip>\n            <span class=\"igx-filtering-chips__connector\" *ngIf=\"!last && isChipVisible(index + 1)\">{{filteringService.getOperatorAsString(item.afterOperator)}}</span>\n        </ng-container>\n        <div #moreIcon [ngClass]=\"filteringIndicatorClass()\" (click)=\"onChipClicked()\" (keydown)=\"onChipKeyDown($event)\" tabindex=\"0\">\n            <igx-icon>filter_list</igx-icon>\n            <igx-badge [value]=\"moreFiltersCount\"></igx-badge>\n        </div>\n    </igx-chips-area>\n</ng-template>\n\n<ng-template #complexFilter>\n    <igx-chip #complexChip [removable]=\"true\" [displayDensity]=\"'cosy'\" (onRemove)=\"clearFiltering()\">\n        <igx-icon igxPrefix>filter_list</igx-icon>\n        <span>{{filteringService.grid.resourceStrings.igx_grid_complex_filter}}</span>\n    </igx-chip>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template; context: context\"></ng-container>\n"
                }] }
    ];
    /** @nocollapse */
    IgxGridFilteringCellComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: IgxFilteringService },
        { type: IgxGridNavigationService }
    ]; };
    IgxGridFilteringCellComponent.propDecorators = {
        column: [{ type: Input }],
        emptyFilter: [{ type: ViewChild, args: ['emptyFilter', { read: TemplateRef },] }],
        defaultFilter: [{ type: ViewChild, args: ['defaultFilter', { read: TemplateRef },] }],
        complexFilter: [{ type: ViewChild, args: ['complexFilter', { read: TemplateRef },] }],
        chipsArea: [{ type: ViewChild, args: ['chipsArea', { read: IgxChipsAreaComponent },] }],
        moreIcon: [{ type: ViewChild, args: ['moreIcon', { read: ElementRef },] }],
        ghostChip: [{ type: ViewChild, args: ['ghostChip', { read: IgxChipComponent },] }],
        complexChip: [{ type: ViewChild, args: ['complexChip', { read: IgxChipComponent },] }],
        cssClass: [{ type: HostBinding, args: ['class.igx-grid__filtering-cell',] }],
        onTabKeyDown: [{ type: HostListener, args: ['keydown.tab', ['$event'],] }],
        onShiftTabKeyDown: [{ type: HostListener, args: ['keydown.shift.tab', ['$event'],] }]
    };
    return IgxGridFilteringCellComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var Z_INDEX = 9999;
/**
 * @hidden
 */
var IgxGridHeaderGroupComponent = /** @class */ (function () {
    function IgxGridHeaderGroupComponent(cdr, gridAPI, element, colResizingService, filteringService) {
        this.cdr = cdr;
        this.gridAPI = gridAPI;
        this.element = element;
        this.colResizingService = colResizingService;
        this.filteringService = filteringService;
    }
    Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "gridRowSpan", {
        get: /**
         * @return {?}
         */
        function () {
            return this.column.gridRowSpan;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "gridColumnSpan", {
        get: /**
         * @return {?}
         */
        function () {
            return this.column.gridColumnSpan;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "rowEnd", {
        get: /**
         * @return {?}
         */
        function () {
            return this.column.rowEnd;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "colEnd", {
        get: /**
         * @return {?}
         */
        function () {
            return this.column.colEnd;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "rowStart", {
        get: /**
         * @return {?}
         */
        function () {
            return this.column.rowStart;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "colStart", {
        get: /**
         * @return {?}
         */
        function () {
            return this.column.colStart;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "width", {
        /**
         * Gets the width of the header group.
         * @memberof IgxGridHeaderGroupComponent
         */
        get: /**
         * Gets the width of the header group.
         * \@memberof IgxGridHeaderGroupComponent
         * @return {?}
         */
        function () {
            return this.grid.getHeaderGroupWidth(this.column);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "styleClasses", {
        /**
         * Gets the style classes of the header group.
         * @memberof IgxGridHeaderGroupComponent
         */
        get: /**
         * Gets the style classes of the header group.
         * \@memberof IgxGridHeaderGroupComponent
         * @return {?}
         */
        function () {
            /** @type {?} */
            var defaultClasses = [
                'igx-grid__thead-item',
                this.column.headerGroupClasses
            ];
            /** @type {?} */
            var classList = {
                'igx-grid__th--pinned': this.isPinned,
                'igx-grid__th--pinned-last': this.isLastPinned,
                'igx-grid__drag-col-header': this.isHeaderDragged,
                'igx-grid__th--filtering': this.isFiltered
            };
            Object.entries(classList).forEach(function (_a) {
                var _b = __read(_a, 2), className = _b[0], value = _b[1];
                if (value) {
                    defaultClasses.push(className);
                }
            });
            return defaultClasses.join(' ');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "zIndex", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            if (!this.column.pinned) {
                return null;
            }
            return Z_INDEX - this.grid.pinnedColumns.indexOf(this.column);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "grid", {
        /**
         * Gets the grid of the header group.
         * @memberof IgxGridHeaderGroupComponent
         */
        get: /**
         * Gets the grid of the header group.
         * \@memberof IgxGridHeaderGroupComponent
         * @return {?}
         */
        function () {
            return this.gridAPI.grid;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "isFiltered", {
        /**
         * Gets whether the header group belongs to a column that is filtered.
         * @memberof IgxGridHeaderGroupComponent
         */
        get: /**
         * Gets whether the header group belongs to a column that is filtered.
         * \@memberof IgxGridHeaderGroupComponent
         * @return {?}
         */
        function () {
            return this.filteringService.filteredColumn === this.column;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "isLastPinned", {
        /**
         * Gets whether the header group is stored in the last column in the pinned area.
         * @memberof IgxGridHeaderGroupComponent
         */
        get: /**
         * Gets whether the header group is stored in the last column in the pinned area.
         * \@memberof IgxGridHeaderGroupComponent
         * @return {?}
         */
        function () {
            return !this.grid.hasColumnLayouts ? this.column.isLastPinned : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "groupDisplayStyle", {
        get: /**
         * @return {?}
         */
        function () {
            return this.grid.hasColumnLayouts && this.column.children && !isIE() ? 'flex' : '';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "isPinned", {
        /**
         * Gets whether the header group is stored in a pinned column.
         * @memberof IgxGridHeaderGroupComponent
         */
        get: /**
         * Gets whether the header group is stored in a pinned column.
         * \@memberof IgxGridHeaderGroupComponent
         * @return {?}
         */
        function () {
            return this.column.pinned;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "isHeaderDragged", {
        /**
         * Gets whether the header group belongs to a column that is moved.
         * @memberof IgxGridHeaderGroupComponent
         */
        get: /**
         * Gets whether the header group belongs to a column that is moved.
         * \@memberof IgxGridHeaderGroupComponent
         * @return {?}
         */
        function () {
            return this.grid.draggedColumn === this.column;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "hasLastPinnedChildColumn", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.column.allChildren.some(function (child) { return child.isLastPinned; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridHeaderGroupComponent.prototype, "height", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.element.nativeElement.getBoundingClientRect().height;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxGridHeaderGroupComponent.prototype.onMouseDown = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // hack for preventing text selection in IE and Edge while dragging the resizer
        event.preventDefault();
    };
    /**
     * @return {?}
     */
    IgxGridHeaderGroupComponent.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
        this.cdr.markForCheck();
    };
    IgxGridHeaderGroupComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-grid-header-group',
                    template: "<ng-container *ngIf=\"grid.hasColumnLayouts && column.columnGroup\">\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-left\"></span>\n    <div class=\"igx-grid__thead-group igx-grid__mrl-block\"\n     [ngClass]=\"{'igx-grid__th--pinned-last': hasLastPinnedChildColumn}\"\n     [ngStyle]=\"{'grid-template-rows':column.getGridTemplate(true, false),\n     'grid-template-columns':column.getGridTemplate(false, false),\n     '-ms-grid-rows':column.getGridTemplate(true, true),\n     '-ms-grid-columns':column.getGridTemplate(false, true)}\">\n        <ng-container *ngFor=\"let child of column.children\" >\n            <igx-grid-header-group *ngIf=\"!child.hidden\" class=\"igx-grid__thead-subgroup\"\n                [column]=\"child\"\n                [gridID]=\"child.gridID\"\n                [igxColumnMovingDrag]=\"child\"\n                [dragGhostHost]=\"grid.outletDirective.nativeElement\"\n                [attr.droppable]=\"true\"\n                [igxColumnMovingDrop]=\"child\">\n            </igx-grid-header-group>\n        </ng-container>\n    </div>\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-right\"></span>\n</ng-container>\n\n<ng-container *ngIf=\"!grid.hasColumnLayouts && column.columnGroup\">\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-left\"></span>\n    <div class=\"igx-grid__thead-title\"\n        [ngClass]=\"{'igx-grid__th--pinned-last': hasLastPinnedChildColumn}\"\n        [igxColumnMovingDrag]=\"column\"\n        [dragGhostHost]=\"grid.outletDirective.nativeElement\"\n        [attr.droppable]=\"true\"\n        [igxColumnMovingDrop]=\"column\">{{ column.header }}</div>\n    <div class=\"igx-grid__thead-group\">\n        <ng-container *ngFor=\"let child of column.children\">\n            <igx-grid-header-group *ngIf=\"!child.hidden\" class=\"igx-grid__thead-subgroup\"\n                                [column]=\"child\"\n                                [gridID]=\"child.grid.id\"\n                                [style.min-width.px]=\"grid.getHeaderGroupWidth(child)\"\n                                [style.flex-basis.px]=\"grid.getHeaderGroupWidth(child)\">\n            </igx-grid-header-group>\n        </ng-container>\n    </div>\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-right\"></span>\n</ng-container>\n\n<ng-container *ngIf=\"!column.columnGroup\">\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-left\"></span>\n    <igx-grid-header [igxColumnMovingDrag]=\"column\" [dragGhostHost]=\"grid.igxFilteringOverlayOutlet\" [attr.droppable]=\"true\" [igxColumnMovingDrop]=\"column\" [gridID]=\"column.grid.id\" [column]=\"column\"></igx-grid-header>\n    <igx-grid-filtering-cell *ngIf=\"grid.allowFiltering && grid.filterMode == 'quickFilter'\" [column]=\"column\" [attr.draggable]=\"false\"></igx-grid-filtering-cell>\n    <span *ngIf=\"!column.columnGroup && column.resizable\" class=\"igx-grid__th-resize-handle\"\n          [igxResizeHandle]=\"column\"\n          [attr.draggable]=\"false\"\n          [style.cursor]=\"colResizingService.resizeCursor\">\n    </span>\n    <span *ngIf=\"grid.hasMovableColumns\" class=\"igx-grid__th-drop-indicator-right\"></span>\n</ng-container>\n"
                }] }
    ];
    /** @nocollapse */
    IgxGridHeaderGroupComponent.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: GridBaseAPIService },
        { type: ElementRef },
        { type: IgxColumnResizingService },
        { type: IgxFilteringService }
    ]; };
    IgxGridHeaderGroupComponent.propDecorators = {
        gridRowSpan: [{ type: HostBinding, args: ['style.-ms-grid-row-span',] }],
        gridColumnSpan: [{ type: HostBinding, args: ['style.-ms-grid-column-span',] }],
        rowEnd: [{ type: HostBinding, args: ['style.grid-row-end',] }],
        colEnd: [{ type: HostBinding, args: ['style.grid-column-end',] }],
        rowStart: [{ type: HostBinding, args: ['style.-ms-grid-row',] }, { type: HostBinding, args: ['style.grid-row-start',] }],
        colStart: [{ type: HostBinding, args: ['style.-ms-grid-column',] }, { type: HostBinding, args: ['style.grid-column-start',] }],
        column: [{ type: Input }],
        gridID: [{ type: Input }],
        headerCell: [{ type: ViewChild, args: [IgxGridHeaderComponent,] }],
        filterCell: [{ type: ViewChild, args: [IgxGridFilteringCellComponent,] }],
        children: [{ type: ViewChildren, args: [forwardRef(function () { return IgxGridHeaderGroupComponent; }), { read: IgxGridHeaderGroupComponent },] }],
        width: [{ type: HostBinding, args: ['style.min-width',] }, { type: HostBinding, args: ['style.flex-basis',] }],
        styleClasses: [{ type: HostBinding, args: ['class',] }],
        zIndex: [{ type: HostBinding, args: ['style.z-index',] }],
        groupDisplayStyle: [{ type: HostBinding, args: ['style.display',] }],
        onMouseDown: [{ type: HostListener, args: ['mousedown', ['$event'],] }]
    };
    return IgxGridHeaderGroupComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var GridResourceStringsEN = {
    igx_grid_groupByArea_message: 'Drag a column header and drop it here to group by that column.',
    igx_grid_emptyFilteredGrid_message: 'No records found.',
    igx_grid_emptyGrid_message: 'Grid has no data.',
    igx_grid_filter: 'Filter',
    igx_grid_filter_row_close: 'Close',
    igx_grid_filter_row_reset: 'Reset',
    igx_grid_filter_row_placeholder: 'Add filter value',
    igx_grid_filter_row_boolean_placeholder: 'All',
    igx_grid_filter_row_date_placeholder: 'Pick up date',
    igx_grid_filter_operator_and: 'And',
    igx_grid_filter_operator_or: 'Or',
    igx_grid_complex_filter: 'Complex Filter',
    igx_grid_filter_contains: 'Contains',
    igx_grid_filter_doesNotContain: 'Does Not Contain',
    igx_grid_filter_startsWith: 'Starts With',
    igx_grid_filter_endsWith: 'Ends With',
    igx_grid_filter_equals: 'Equals',
    igx_grid_filter_doesNotEqual: 'Does Not Equal',
    igx_grid_filter_empty: 'Empty',
    igx_grid_filter_notEmpty: 'Not Empty',
    igx_grid_filter_null: 'Null',
    igx_grid_filter_notNull: 'Not Null',
    igx_grid_filter_before: 'Before',
    igx_grid_filter_after: 'After',
    igx_grid_filter_today: 'Today',
    igx_grid_filter_yesterday: 'Yesterday',
    igx_grid_filter_thisMonth: 'This Month',
    igx_grid_filter_lastMonth: 'Last Month',
    igx_grid_filter_nextMonth: 'Next Month',
    igx_grid_filter_thisYear: 'This Year',
    igx_grid_filter_lastYear: 'Last Year',
    igx_grid_filter_nextYear: 'Next Year',
    igx_grid_filter_greaterThan: 'Greater Than',
    igx_grid_filter_lessThan: 'Less Than',
    igx_grid_filter_greaterThanOrEqualTo: 'Greater Than Or Equal To',
    igx_grid_filter_lessThanOrEqualTo: 'Less Than Or Equal To',
    igx_grid_filter_true: 'True',
    igx_grid_filter_false: 'False',
    igx_grid_filter_all: 'All',
    igx_grid_filter_condition_placeholder: 'Select filter',
    igx_grid_summary_count: 'Count',
    igx_grid_summary_min: 'Min',
    igx_grid_summary_max: 'Max',
    igx_grid_summary_sum: 'Sum',
    igx_grid_summary_average: 'Avg',
    igx_grid_summary_earliest: 'Earliest',
    igx_grid_summary_latest: 'Latest',
    igx_grid_excel_filter_moving_left: 'move left',
    igx_grid_excel_filter_moving_left_short: 'left',
    igx_grid_excel_filter_moving_right: 'move right',
    igx_grid_excel_filter_moving_right_short: 'right',
    igx_grid_excel_filter_moving_header: 'move',
    igx_grid_excel_filter_sorting_asc: 'ascending',
    igx_grid_excel_filter_sorting_asc_short: 'asc',
    igx_grid_excel_filter_sorting_desc: 'descending',
    igx_grid_excel_filter_sorting_desc_short: 'desc',
    igx_grid_excel_filter_sorting_header: 'sort',
    igx_grid_excel_custom_dialog_add: 'add filter',
    igx_grid_excel_custom_dialog_clear: 'Clear filter',
    igx_grid_excel_custom_dialog_header: 'Custom auto-filter on column: ',
    igx_grid_excel_cancel: 'cancel',
    igx_grid_excel_apply: 'apply',
    igx_grid_excel_search_placeholder: 'Search',
    igx_grid_excel_select_all: 'Select All',
    igx_grid_excel_blanks: '(Blanks)',
    igx_grid_excel_hide: 'Hide column',
    igx_grid_excel_pin: 'Pin column',
    igx_grid_excel_unpin: 'Unpin column',
    igx_grid_excel_text_filter: 'Text filter',
    igx_grid_excel_number_filter: 'Number filter',
    igx_grid_excel_date_filter: 'Date filter',
    igx_grid_excel_boolean_filter: 'Boolean filter',
    igx_grid_excel_custom_filter: 'Custom filter...'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var TimePickerResourceStringsEN = {
    igx_time_picker_ok: 'OK',
    igx_time_picker_cancel: 'Cancel'
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 * @type {?}
 */
var CurrentResourceStrings = {
    GridResStrings: cloneValue(GridResourceStringsEN),
    TimePickerResStrings: cloneValue(TimePickerResourceStringsEN)
};
/**
 * @param {?} currentStrings
 * @param {?} newStrings
 * @return {?}
 */
function updateResourceStrings(currentStrings, newStrings) {
    var e_1, _a;
    try {
        for (var _b = __values(Object.keys(newStrings)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var key = _c.value;
            if (key in currentStrings) {
                currentStrings[key] = newStrings[key];
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
}
/**
 * Changes the resource strings for all components in the application
 * ```
 * @param {?} resourceStrings to be applied
 * @return {?}
 */
function changei18n(resourceStrings) {
    var e_2, _a;
    try {
        for (var _b = __values(Object.keys(CurrentResourceStrings)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var key = _c.value;
            updateResourceStrings(CurrentResourceStrings[key], resourceStrings);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_2) throw e_2.error; }
    }
}
/**
 * Returns current resource strings for all components
 * @return {?}
 */
function getCurrentResourceStrings() {
    return __assign({}, CurrentResourceStrings.GridResStrings, CurrentResourceStrings.TimePickerResStrings);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxGridSummaryService = /** @class */ (function () {
    function IgxGridSummaryService() {
        this.summaryCacheMap = new Map();
        this.rootSummaryID = 'igxGridRootSummary';
        this.summaryHeight = 0;
        this.maxSummariesLenght = 0;
        this.groupingExpressions = [];
        this.retriggerRootPipe = 0;
        this.deleteOperation = false;
    }
    /**
     * @return {?}
     */
    IgxGridSummaryService.prototype.recalculateSummaries = /**
     * @return {?}
     */
    function () {
        this.resetSummaryHeight();
        this.grid.calculateGridHeight();
        this.grid.cdr.detectChanges();
    };
    /**
     * @param {?=} args
     * @return {?}
     */
    IgxGridSummaryService.prototype.clearSummaryCache = /**
     * @param {?=} args
     * @return {?}
     */
    function (args) {
        if (!this.summaryCacheMap.size) {
            return;
        }
        if (!args) {
            this.summaryCacheMap.clear();
            if (this.grid && this.grid.rootSummariesEnabled) {
                this.retriggerRootPipe++;
            }
            return;
        }
        if (args.data) {
            /** @type {?} */
            var rowID = args.rowID;
            if (!args.rowID) {
                rowID = this.grid.primaryKey ? args.data[this.grid.primaryKey] : args.data;
            }
            this.removeSummaries(rowID);
        }
        if (args.rowID !== undefined && args.rowID !== null) {
            /** @type {?} */
            var columnName = args.cellID ? this.grid.columnList.find(function (col) { return col.index === args.cellID.columnID; }).field : undefined;
            /** @type {?} */
            var isGroupedColumn = this.grid.groupingExpressions &&
                this.grid.groupingExpressions.map(function (expr) { return expr.fieldName; }).indexOf(columnName) !== -1;
            if (columnName && isGroupedColumn) {
                this.removeSummaries(args.rowID);
                return;
            }
            this.removeSummaries(args.rowID, columnName);
        }
    };
    /**
     * @param {?} rowID
     * @param {?=} columnName
     * @return {?}
     */
    IgxGridSummaryService.prototype.removeSummaries = /**
     * @param {?} rowID
     * @param {?=} columnName
     * @return {?}
     */
    function (rowID, columnName) {
        var _this = this;
        if (this.summaryCacheMap.size === 0) {
            return;
        }
        this.deleteSummaryCache(this.rootSummaryID, columnName);
        if (this.summaryCacheMap.size === 1 && this.summaryCacheMap.has(this.rootSummaryID)) {
            return;
        }
        if (this.isTreeGrid) {
            if (this.grid.transactions.enabled && this.deleteOperation) {
                this.deleteOperation = false;
                // TODO: this.removeChildRowSummaries(rowID, columnName);
                this.summaryCacheMap.clear();
                return;
            }
            this.removeAllTreeGridSummaries(rowID, columnName);
        }
        else if (this.isHierarchicalGrid) {
            if (this.grid.transactions.enabled && this.deleteOperation) {
                this.deleteOperation = false;
                this.summaryCacheMap.clear();
                return;
            }
        }
        else {
            /** @type {?} */
            var summaryIds = this.getSummaryID(rowID, this.grid.groupingExpressions);
            summaryIds.forEach(function (id) {
                _this.deleteSummaryCache(id, columnName);
            });
        }
    };
    /**
     * @param {?} columnName
     * @return {?}
     */
    IgxGridSummaryService.prototype.removeSummariesCachePerColumn = /**
     * @param {?} columnName
     * @return {?}
     */
    function (columnName) {
        this.summaryCacheMap.forEach(function (cache) {
            if (cache.get(columnName)) {
                cache.delete(columnName);
            }
        });
        if (this.grid.rootSummariesEnabled) {
            this.retriggerRootPipe++;
        }
    };
    /**
     * @return {?}
     */
    IgxGridSummaryService.prototype.calcMaxSummaryHeight = /**
     * @return {?}
     */
    function () {
        if (this.summaryHeight) {
            return this.summaryHeight;
        }
        if (!this.grid.data) {
            return this.summaryHeight = 0;
        }
        /** @type {?} */
        var maxSummaryLength = 0;
        this.grid.columnList.filter(function (col) { return col.hasSummary && !col.hidden; }).forEach(function (column) {
            /** @type {?} */
            var getCurrentSummaryColumn = column.summaries.operate([]).length;
            if (getCurrentSummaryColumn) {
                if (maxSummaryLength < getCurrentSummaryColumn) {
                    maxSummaryLength = getCurrentSummaryColumn;
                }
            }
        });
        this.maxSummariesLenght = maxSummaryLength;
        this.summaryHeight = maxSummaryLength * this.grid.defaultSummaryHeight;
        return this.summaryHeight;
    };
    /**
     * @param {?} rowID
     * @param {?} data
     * @return {?}
     */
    IgxGridSummaryService.prototype.calculateSummaries = /**
     * @param {?} rowID
     * @param {?} data
     * @return {?}
     */
    function (rowID, data) {
        /** @type {?} */
        var rowSummaries = this.summaryCacheMap.get(rowID);
        if (!rowSummaries) {
            rowSummaries = new Map();
            this.summaryCacheMap.set(rowID, rowSummaries);
        }
        if (!this.hasSummarizedColumns || !data) {
            return rowSummaries;
        }
        this.grid.columnList.filter(function (col) { return col.hasSummary; }).forEach(function (column) {
            if (!rowSummaries.get(column.field)) {
                /** @type {?} */
                var columnValues = data.map(function (record) { return record[column.field]; });
                rowSummaries.set(column.field, column.summaries.operate(columnValues));
            }
        });
        return rowSummaries;
    };
    /**
     * @return {?}
     */
    IgxGridSummaryService.prototype.resetSummaryHeight = /**
     * @return {?}
     */
    function () {
        this.summaryHeight = 0;
        ((/** @type {?} */ (this.grid)))._summaryPipeTrigger++;
        if (this.grid.rootSummariesEnabled) {
            this.retriggerRootPipe++;
        }
    };
    /**
     * @param {?} groupingArgs
     * @return {?}
     */
    IgxGridSummaryService.prototype.updateSummaryCache = /**
     * @param {?} groupingArgs
     * @return {?}
     */
    function (groupingArgs) {
        if (this.summaryCacheMap.size === 0 || !this.hasSummarizedColumns) {
            return;
        }
        if (this.groupingExpressions.length === 0) {
            this.groupingExpressions = groupingArgs.expressions.map(function (record) { return record.fieldName; });
            return;
        }
        if (groupingArgs.length === 0) {
            this.groupingExpressions = [];
            this.clearSummaryCache();
            return;
        }
        this.compareGroupingExpressions(this.groupingExpressions, groupingArgs);
        this.groupingExpressions = groupingArgs.expressions.map(function (record) { return record.fieldName; });
    };
    Object.defineProperty(IgxGridSummaryService.prototype, "hasSummarizedColumns", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var summarizedColumns = this.grid.columnList.filter(function (col) { return col.hasSummary && !col.hidden; });
            return summarizedColumns.length > 0;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @param {?} id
     * @param {?} columnName
     * @return {?}
     */
    IgxGridSummaryService.prototype.deleteSummaryCache = /**
     * @private
     * @param {?} id
     * @param {?} columnName
     * @return {?}
     */
    function (id, columnName) {
        if (this.summaryCacheMap.get(id)) {
            /** @type {?} */
            var filteringApplied = columnName && this.grid.filteringExpressionsTree &&
                this.grid.filteringExpressionsTree.filteringOperands.map(function (expr) { return expr.fieldName; }).indexOf(columnName) !== -1;
            if (columnName && this.summaryCacheMap.get(id).get(columnName) && !filteringApplied) {
                this.summaryCacheMap.get(id).delete(columnName);
            }
            else {
                this.summaryCacheMap.delete(id);
            }
            if (id === this.rootSummaryID && this.grid.rootSummariesEnabled) {
                this.retriggerRootPipe++;
            }
        }
    };
    /**
     * @private
     * @param {?} rowID
     * @param {?} groupingExpressions
     * @return {?}
     */
    IgxGridSummaryService.prototype.getSummaryID = /**
     * @private
     * @param {?} rowID
     * @param {?} groupingExpressions
     * @return {?}
     */
    function (rowID, groupingExpressions) {
        var _this = this;
        if (groupingExpressions.length === 0) {
            return [];
        }
        /** @type {?} */
        var summaryIDs = [];
        /** @type {?} */
        var data = this.grid.data;
        if (this.grid.transactions.enabled) {
            data = DataUtil.mergeTransactions(cloneArray(this.grid.data), this.grid.transactions.getAggregatedChanges(true), this.grid.primaryKey);
        }
        /** @type {?} */
        var rowData = this.grid.primaryKey ? data.find(function (rec) { return rec[_this.grid.primaryKey] === rowID; }) : rowID;
        /** @type {?} */
        var id = '{ ';
        groupingExpressions.forEach(function (expr) {
            id += "'" + expr.fieldName + "': '" + rowData[expr.fieldName] + "'";
            summaryIDs.push(id.concat(' }'));
            id += ', ';
        });
        return summaryIDs;
    };
    /**
     * @private
     * @param {?} rowID
     * @param {?=} columnName
     * @return {?}
     */
    IgxGridSummaryService.prototype.removeAllTreeGridSummaries = /**
     * @private
     * @param {?} rowID
     * @param {?=} columnName
     * @return {?}
     */
    function (rowID, columnName) {
        /** @type {?} */
        var row = this.grid.records.get(rowID);
        if (!row) {
            return;
        }
        row = row.children ? row : row.parent;
        while (row) {
            rowID = row.rowID;
            this.deleteSummaryCache(rowID, columnName);
            row = row.parent;
        }
    };
    // TODO: remove only deleted rows
    // TODO: remove only deleted rows
    /**
     * @private
     * @param {?} rowID
     * @param {?=} columnName
     * @return {?}
     */
    IgxGridSummaryService.prototype.removeChildRowSummaries = 
    // TODO: remove only deleted rows
    /**
     * @private
     * @param {?} rowID
     * @param {?=} columnName
     * @return {?}
     */
    function (rowID, columnName) {
    };
    /**
     * @private
     * @param {?} current
     * @param {?} groupingArgs
     * @return {?}
     */
    IgxGridSummaryService.prototype.compareGroupingExpressions = /**
     * @private
     * @param {?} current
     * @param {?} groupingArgs
     * @return {?}
     */
    function (current, groupingArgs) {
        var _this = this;
        /** @type {?} */
        var newExpressions = groupingArgs.expressions.map(function (record) { return record.fieldName; });
        /** @type {?} */
        var removedCols = groupingArgs.ungroupedColumns;
        if (current.length <= newExpressions.length) {
            /** @type {?} */
            var newExpr = newExpressions.slice(0, current.length).toString();
            if (current.toString() !== newExpr) {
                this.clearSummaryCache();
            }
        }
        else {
            /** @type {?} */
            var currExpr = current.slice(0, newExpressions.length).toString();
            if (currExpr !== newExpressions.toString()) {
                this.clearSummaryCache();
                return;
            }
            removedCols.map(function (col) { return col.field; }).forEach(function (colName) {
                _this.summaryCacheMap.forEach(function (cache, id) {
                    if (id.indexOf(colName) !== -1) {
                        _this.summaryCacheMap.delete(id);
                    }
                });
            });
        }
    };
    Object.defineProperty(IgxGridSummaryService.prototype, "isTreeGrid", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return this.grid.nativeElement.tagName.toLowerCase() === 'igx-tree-grid';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridSummaryService.prototype, "isHierarchicalGrid", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return this.grid.nativeElement.tagName.toLowerCase() === 'igx-hierarchical-grid';
        },
        enumerable: true,
        configurable: true
    });
    IgxGridSummaryService.decorators = [
        { type: Injectable }
    ];
    return IgxGridSummaryService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxSummaryCellComponent = /** @class */ (function () {
    function IgxSummaryCellComponent(element, selectionService) {
        this.element = element;
        this.selectionService = selectionService;
        this.firstCellIndentation = 0;
        this.hasSummary = false;
        this.tabindex = 0;
    }
    Object.defineProperty(IgxSummaryCellComponent.prototype, "visibleColumnIndex", {
        get: /**
         * @return {?}
         */
        function () {
            return this.column.visibleIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSummaryCellComponent.prototype, "describeby", {
        get: /**
         * @return {?}
         */
        function () {
            return "Summary_" + this.column.field;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    IgxSummaryCellComponent.prototype.onFocus = /**
     * @return {?}
     */
    function () {
        this.focused = true;
    };
    /**
     * @return {?}
     */
    IgxSummaryCellComponent.prototype.onBlur = /**
     * @return {?}
     */
    function () {
        this.focused = false;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    IgxSummaryCellComponent.prototype.dispatchEvent = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        // TODO: Refactor
        /** @type {?} */
        var key = event.key.toLowerCase();
        /** @type {?} */
        var ctrl = event.ctrlKey;
        /** @type {?} */
        var shift = event.shiftKey;
        if (!SUPPORTED_KEYS.has(key)) {
            return;
        }
        event.stopPropagation();
        /** @type {?} */
        var args = { targetType: 'summaryCell', target: this, event: event, cancel: false };
        this.grid.onGridKeydown.emit(args);
        if (args.cancel) {
            return;
        }
        event.preventDefault();
        if (!this.isKeySupportedInCell(key, ctrl)) {
            return;
        }
        this.selectionService.keyboardState.shift = shift && !(key === 'tab');
        /** @type {?} */
        var row = this.getRowElementByIndex(this.rowIndex);
        switch (key) {
            case 'tab':
                if (shift) {
                    this.grid.navigation.performShiftTabKey(row, this.rowIndex, this.visibleColumnIndex, true);
                    break;
                }
                this.grid.navigation.performTab(row, this.rowIndex, this.visibleColumnIndex, true);
                break;
            case 'arrowleft':
            case 'home':
            case 'left':
                if (ctrl || key === 'home') {
                    this.grid.navigation.onKeydownHome(this.rowIndex, true);
                    break;
                }
                this.grid.navigation.onKeydownArrowLeft(this.nativeElement, this.rowIndex, this.visibleColumnIndex, true);
                break;
            case 'end':
            case 'arrowright':
            case 'right':
                if (ctrl || key === 'end') {
                    this.grid.navigation.onKeydownEnd(this.rowIndex, true);
                    break;
                }
                this.grid.navigation.onKeydownArrowRight(this.nativeElement, this.rowIndex, this.visibleColumnIndex, true);
                break;
            case 'arrowup':
            case 'up':
                this.grid.navigation.navigateUp(row, this.rowIndex, this.visibleColumnIndex);
                break;
            case 'arrowdown':
            case 'down':
                this.grid.navigation.navigateDown(row, this.rowIndex, this.visibleColumnIndex);
                break;
        }
    };
    Object.defineProperty(IgxSummaryCellComponent.prototype, "width", {
        get: /**
         * @return {?}
         */
        function () {
            return this.column.getCellWidth();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSummaryCellComponent.prototype, "nativeElement", {
        get: /**
         * @return {?}
         */
        function () {
            return this.element.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSummaryCellComponent.prototype, "columnDatatype", {
        get: /**
         * @return {?}
         */
        function () {
            return this.column.dataType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSummaryCellComponent.prototype, "itemHeight", {
        get: /**
         * @return {?}
         */
        function () {
            return this.column.grid.defaultSummaryHeight;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSummaryCellComponent.prototype, "grid", {
        /**
        * @hidden
        */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return ((/** @type {?} */ (this.column.grid)));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @param {?} rowIndex
     * @return {?}
     */
    IgxSummaryCellComponent.prototype.getRowElementByIndex = /**
     * @private
     * @param {?} rowIndex
     * @return {?}
     */
    function (rowIndex) {
        /** @type {?} */
        var summaryRows = this.grid.summariesRowList.toArray();
        return summaryRows.find(function (sr) { return sr.dataRowIndex === rowIndex; }).nativeElement;
    };
    /**
     * @private
     * @param {?} key
     * @param {?} ctrl
     * @return {?}
     */
    IgxSummaryCellComponent.prototype.isKeySupportedInCell = /**
     * @private
     * @param {?} key
     * @param {?} ctrl
     * @return {?}
     */
    function (key, ctrl) {
        if (ctrl) {
            return ['arrowup', 'arrowdown', 'up', 'down', 'end', 'home'].indexOf(key) === -1;
        }
        return ['down', 'up', 'left', 'right', 'arrowdown', 'arrowup', 'arrowleft', 'arrowright', 'home', 'end', 'tab'].indexOf(key) !== -1;
    };
    /**
     * @param {?} summary
     * @return {?}
     */
    IgxSummaryCellComponent.prototype.translateSummary = /**
     * @param {?} summary
     * @return {?}
     */
    function (summary) {
        return this.grid.resourceStrings["igx_grid_summary_" + summary.key] || summary.label;
    };
    IgxSummaryCellComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-grid-summary-cell',
                    template: "<ng-container *ngIf=\"hasSummary\">\n    <ng-container *ngFor=\"let summary of summaryResults\">\n            <div class=\"igx-grid-summary__item\" [style.height.px]=\"itemHeight\">\n\n                <ng-container *ngIf=\"visibleColumnIndex === 0 && firstCellIndentation >= 0\">\n                    <div class=\"igx-grid__tree-cell--padding-level-{{firstCellIndentation}}\"></div>\n\n                    <div #indicator class=\"igx-grid__tree-grouping-indicator\" style=\"visibility: hidden\">\n                        <igx-icon fontSet=\"material\">chevron_right</igx-icon>\n                    </div>\n                </ng-container>\n\n                <span class=\"igx-grid-summary__label\" title=\"{{ summary.label }}\">{{ translateSummary(summary) }}</span>\n                <span class=\"igx-grid-summary__result\" title=\"{{ summary.summaryResult }}\">\n                    {{ columnDatatype === 'number' ? (summary.summaryResult | igxdecimal: grid.locale) : columnDatatype === 'date' ? (summary.summaryResult | igxdate: grid.locale) : (summary.summaryResult) }}\n                </span>\n            </div>\n    </ng-container>\n</ng-container>\n"
                }] }
    ];
    /** @nocollapse */
    IgxSummaryCellComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: IgxGridSelectionService }
    ]; };
    IgxSummaryCellComponent.propDecorators = {
        summaryResults: [{ type: Input }],
        column: [{ type: Input }],
        firstCellIndentation: [{ type: Input }],
        hasSummary: [{ type: Input }],
        density: [{ type: Input }],
        rowIndex: [{ type: Input }, { type: HostBinding, args: ['attr.data-rowIndex',] }],
        visibleColumnIndex: [{ type: HostBinding, args: ['attr.data-visibleIndex',] }],
        tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
        describeby: [{ type: HostBinding, args: ['attr.aria-describedby',] }],
        focused: [{ type: HostBinding, args: ['class.igx-grid-summary--active',] }],
        onFocus: [{ type: HostListener, args: ['focus',] }],
        onBlur: [{ type: HostListener, args: ['blur',] }],
        dispatchEvent: [{ type: HostListener, args: ['keydown', ['$event'],] }],
        width: [{ type: HostBinding, args: ['style.min-width',] }, { type: HostBinding, args: ['style.max-width',] }, { type: HostBinding, args: ['style.flex-basis',] }]
    };
    return IgxSummaryCellComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxSummaryRowComponent = /** @class */ (function () {
    function IgxSummaryRowComponent(gridAPI, element, cdr) {
        this.gridAPI = gridAPI;
        this.element = element;
        this.cdr = cdr;
        this.indentation = 0;
        this.firstCellIndentation = -1;
    }
    Object.defineProperty(IgxSummaryRowComponent.prototype, "dataRowIndex", {
        get: /**
         * @return {?}
         */
        function () {
            return this.index;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSummaryRowComponent.prototype, "minHeight", {
        get: /**
         * @return {?}
         */
        function () {
            return this.grid.summaryService.calcMaxSummaryHeight() - 1;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    IgxSummaryRowComponent.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
        this.cdr.markForCheck();
    };
    Object.defineProperty(IgxSummaryRowComponent.prototype, "grid", {
        get: /**
         * @return {?}
         */
        function () {
            return this.gridAPI.grid;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSummaryRowComponent.prototype, "nativeElement", {
        get: /**
         * @return {?}
         */
        function () {
            return this.element.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} columnName
     * @return {?}
     */
    IgxSummaryRowComponent.prototype.getColumnSummaries = /**
     * @param {?} columnName
     * @return {?}
     */
    function (columnName) {
        if (!this.summaries.get(columnName)) {
            return [];
        }
        return this.summaries.get(columnName);
    };
    Object.defineProperty(IgxSummaryRowComponent.prototype, "pinnedColumns", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.grid.pinnedColumns;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSummaryRowComponent.prototype, "unpinnedColumns", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.grid.unpinnedColumns;
        },
        enumerable: true,
        configurable: true
    });
    IgxSummaryRowComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-grid-summary-row',
                    template: "<ng-container *ngIf=\"summaries.size\">\n    <ng-container *ngIf=\"indentation\">\n        <div class=\"igx-grid__row-indentation igx-grid__row-indentation--level-{{indentation}}\"></div>\n    </ng-container>\n    <ng-container *ngIf=\"grid.summariesMargin\">\n        <div\n        class=\"igx-grid__summaries-patch\"\n        [style.min-width.px]=\"grid.summariesMargin\"\n        [style.flex-basis.px]=\"grid.summariesMargin\"\n        ></div>\n    </ng-container>\n    <ng-container *ngIf=\"pinnedColumns.length > 0\">\n        <igx-grid-summary-cell *ngFor=\"let col of pinnedColumns | igxNotGrouped\"\n            class=\"igx-grid-summary igx-grid-summary--fw igx-grid-summary--pinned\"\n            [class.igx-grid-summary--cosy]=\"grid.displayDensity === 'cosy'\"\n            [class.igx-grid-summary--compact]=\"grid.displayDensity === 'compact'\"\n            [class.igx-grid-summary--empty]=\"!col.hasSummary\"\n            [class.igx-grid-summary--pinned-last]=\"col.isLastPinned\"\n            [column]=\"col\"\n            [firstCellIndentation]=\"firstCellIndentation\"\n            [rowIndex]=\"index\"\n            [summaryResults]=\"getColumnSummaries(col.field)\"\n            [hasSummary]=\"col.hasSummary\"\n            [density]=\"grid.displayDensity\"\n            [style.max-height.px]=\"minHeight\"\n            [style.min-height.px]=\"minHeight\">\n        </igx-grid-summary-cell>\n    </ng-container>\n    <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\" [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]=\"grid.unpinnedWidth\" [igxForTrackBy]=\"grid.trackColumnChanges\" [igxForSizePropName]='\"calcWidth\"' #igxDirRef>\n        <igx-grid-summary-cell\n            class=\"igx-grid-summary igx-grid-summary--fw\"\n            [class.igx-grid-summary--cosy]=\"grid.displayDensity === 'cosy'\"\n            [class.igx-grid-summary--compact]=\"grid.displayDensity === 'compact'\"\n            [class.igx-grid-summary--empty]=\"!col.hasSummary\"\n            [column]=\"col\"\n            [rowIndex]=\"index\"\n            [firstCellIndentation]=\"firstCellIndentation\"\n            [summaryResults]=\"getColumnSummaries(col.field)\"\n            [hasSummary]=\"col.hasSummary\"\n            [density]=\"grid.displayDensity\"\n            [style.max-height.px]=\"minHeight\"\n            [style.min-height.px]=\"minHeight\">\n        </igx-grid-summary-cell>\n    </ng-template>\n</ng-container>\n",
                    providers: [IgxForOfSyncService]
                }] }
    ];
    /** @nocollapse */
    IgxSummaryRowComponent.ctorParameters = function () { return [
        { type: GridBaseAPIService },
        { type: ElementRef },
        { type: ChangeDetectorRef }
    ]; };
    IgxSummaryRowComponent.propDecorators = {
        summaries: [{ type: Input }],
        gridID: [{ type: Input }],
        index: [{ type: Input }],
        indentation: [{ type: Input }],
        firstCellIndentation: [{ type: Input }],
        dataRowIndex: [{ type: HostBinding, args: ['attr.data-rowIndex',] }],
        summaryCells: [{ type: ViewChildren, args: [IgxSummaryCellComponent, { read: IgxSummaryCellComponent },] }],
        virtDirRow: [{ type: ViewChild, args: ['igxDirRef', { read: IgxGridForOfDirective },] }]
    };
    return IgxSummaryRowComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
var DragScrollDirection = {
    NONE: 0,
    LEFT: 1,
    TOP: 2,
    RIGHT: 3,
    BOTTOM: 4,
    TOPLEFT: 5,
    TOPRIGHT: 6,
    BOTTOMLEFT: 7,
    BOTTOMRIGHT: 8,
};
DragScrollDirection[DragScrollDirection.NONE] = 'NONE';
DragScrollDirection[DragScrollDirection.LEFT] = 'LEFT';
DragScrollDirection[DragScrollDirection.TOP] = 'TOP';
DragScrollDirection[DragScrollDirection.RIGHT] = 'RIGHT';
DragScrollDirection[DragScrollDirection.BOTTOM] = 'BOTTOM';
DragScrollDirection[DragScrollDirection.TOPLEFT] = 'TOPLEFT';
DragScrollDirection[DragScrollDirection.TOPRIGHT] = 'TOPRIGHT';
DragScrollDirection[DragScrollDirection.BOTTOMLEFT] = 'BOTTOMLEFT';
DragScrollDirection[DragScrollDirection.BOTTOMRIGHT] = 'BOTTOMRIGHT';
var IgxGridDragSelectDirective = /** @class */ (function () {
    function IgxGridDragSelectDirective(ref, zone) {
        var _this = this;
        this.ref = ref;
        this.zone = zone;
        this.onDragStop = new EventEmitter();
        this.onDragScroll = new EventEmitter();
        this.end$ = new Subject();
        this.lastDirection = DragScrollDirection.NONE;
        this.startDragSelection = function (ev) {
            if (!_this.activeDrag) {
                return;
            }
            /** @type {?} */
            var x = ev.clientX;
            /** @type {?} */
            var y = ev.clientY;
            /** @type {?} */
            var direction = _this._measureDimensions(x, y);
            if (direction === _this.lastDirection) {
                return;
            }
            _this.unsubscribe();
            _this._sub = _this._interval$.subscribe(function () { return _this.onDragScroll.emit(direction); });
            _this.lastDirection = direction;
        };
        this.stopDragSelection = function () {
            if (!_this.activeDrag) {
                return;
            }
            _this.onDragStop.emit(false);
            _this.unsubscribe();
            _this.lastDirection = DragScrollDirection.NONE;
        };
        this._interval$ = interval(100).pipe(takeUntil(this.end$), filter(function () { return _this.activeDrag; }));
    }
    Object.defineProperty(IgxGridDragSelectDirective.prototype, "activeDrag", {
        get: /**
         * @return {?}
         */
        function () {
            return this._activeDrag;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            if (val !== this._activeDrag) {
                this.unsubscribe();
                this._activeDrag = val;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridDragSelectDirective.prototype, "nativeElement", {
        get: /**
         * @return {?}
         */
        function () {
            return this.ref.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridDragSelectDirective.prototype, "clientRect", {
        get: /**
         * @return {?}
         */
        function () {
            return this.nativeElement.getBoundingClientRect();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    IgxGridDragSelectDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.zone.runOutsideAngular(function () {
            _this.nativeElement.addEventListener('pointerover', _this.startDragSelection);
            _this.nativeElement.addEventListener('pointerleave', _this.stopDragSelection);
        });
    };
    /**
     * @return {?}
     */
    IgxGridDragSelectDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.zone.runOutsideAngular(function () {
            _this.nativeElement.removeEventListener('pointerover', _this.startDragSelection);
            _this.nativeElement.removeEventListener('pointerleave', _this.stopDragSelection);
        });
        this.unsubscribe();
        this.end$.complete();
    };
    /**
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    IgxGridDragSelectDirective.prototype._measureDimensions = /**
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    function (x, y) {
        /** @type {?} */
        var direction;
        /** @type {?} */
        var rect = this.clientRect;
        /** @type {?} */
        var RATIO = 0.15;
        /** @type {?} */
        var offsetX = Math.trunc(x - rect.left);
        /** @type {?} */
        var offsetY = Math.trunc(y - rect.top);
        /** @type {?} */
        var left = offsetX <= rect.width * RATIO;
        /** @type {?} */
        var right = offsetX >= rect.width * (1 - RATIO);
        /** @type {?} */
        var top = offsetY <= rect.height * RATIO;
        /** @type {?} */
        var bottom = offsetY >= rect.height * (1 - RATIO);
        if (top && left) {
            direction = DragScrollDirection.TOPLEFT;
        }
        else if (top && right) {
            direction = DragScrollDirection.TOPRIGHT;
        }
        else if (bottom && left) {
            direction = DragScrollDirection.BOTTOMLEFT;
        }
        else if (bottom && right) {
            direction = DragScrollDirection.BOTTOMRIGHT;
        }
        else if (top) {
            direction = DragScrollDirection.TOP;
        }
        else if (bottom) {
            direction = DragScrollDirection.BOTTOM;
        }
        else if (left) {
            direction = DragScrollDirection.LEFT;
        }
        else if (right) {
            direction = DragScrollDirection.RIGHT;
        }
        else {
            direction = DragScrollDirection.NONE;
        }
        return direction;
    };
    /**
     * @protected
     * @return {?}
     */
    IgxGridDragSelectDirective.prototype.unsubscribe = /**
     * @protected
     * @return {?}
     */
    function () {
        if (this._sub) {
            this._sub.unsubscribe();
        }
    };
    IgxGridDragSelectDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxGridDragSelect]'
                },] }
    ];
    /** @nocollapse */
    IgxGridDragSelectDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: NgZone }
    ]; };
    IgxGridDragSelectDirective.propDecorators = {
        activeDrag: [{ type: Input, args: ['igxGridDragSelect',] }],
        onDragStop: [{ type: Output }],
        onDragScroll: [{ type: Output }]
    };
    return IgxGridDragSelectDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxGridColumnResizerComponent = /** @class */ (function () {
    function IgxGridColumnResizerComponent(colResizingService) {
        this.colResizingService = colResizingService;
    }
    IgxGridColumnResizerComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-grid-column-resizer',
                    template: "<div class=\"igx-grid__th-resize-line\"\n    [style.left.px]=\"-99999\" igxResizer\n    [style.height.px]=\"colResizingService.resizerHeight\"\n    [restrictHResizeMax]=\"colResizingService.restrictResizeMax\"\n    [restrictHResizeMin]=\"colResizingService.restrictResizeMin\"\n    (resizeEnd)=\"colResizingService.resizeColumn($event)\">\n</div>"
                }] }
    ];
    /** @nocollapse */
    IgxGridColumnResizerComponent.ctorParameters = function () { return [
        { type: IgxColumnResizingService }
    ]; };
    IgxGridColumnResizerComponent.propDecorators = {
        resizer: [{ type: ViewChild, args: [IgxColumnResizerDirective,] }]
    };
    return IgxGridColumnResizerComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxGridFilteringRowComponent = /** @class */ (function () {
    function IgxGridFilteringRowComponent(filteringService, element, cdr) {
        this.filteringService = filteringService;
        this.element = element;
        this.cdr = cdr;
        this._positionSettings = {
            horizontalStartPoint: HorizontalAlignment.Left,
            verticalStartPoint: VerticalAlignment.Bottom
        };
        this._conditionsOverlaySettings = {
            excludePositionTarget: true,
            closeOnOutsideClick: true,
            modal: false,
            scrollStrategy: new AbsoluteScrollStrategy(),
            positionStrategy: new ConnectedPositioningStrategy(this._positionSettings)
        };
        this._operatorsOverlaySettings = {
            excludePositionTarget: true,
            closeOnOutsideClick: true,
            modal: false,
            scrollStrategy: new AbsoluteScrollStrategy(),
            positionStrategy: new ConnectedPositioningStrategy(this._positionSettings)
        };
        this.chipAreaScrollOffset = 0;
        this._column = null;
        this.isKeyPressed = false;
        this.isComposing = false;
        this.cssClass = 'igx-grid__filtering-row';
    }
    Object.defineProperty(IgxGridFilteringRowComponent.prototype, "column", {
        get: /**
         * @return {?}
         */
        function () {
            return this._column;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            if (val) {
                this._column = val;
                this.expressionsList = this.filteringService.getExpressions(this._column.field);
                this.resetExpression();
                this.chipAreaScrollOffset = 0;
                this.transform(this.chipAreaScrollOffset);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridFilteringRowComponent.prototype, "value", {
        get: /**
         * @return {?}
         */
        function () {
            return this.expression ? this.expression.searchVal : null;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            var _this = this;
            if (!val && val !== 0) {
                this.expression.searchVal = null;
                this.showHideArrowButtons();
            }
            else {
                this.expression.searchVal = this.transformValue(val);
                if (this.expressionsList.find(function (item) { return item.expression === _this.expression; }) === undefined) {
                    this.addExpression(true);
                }
            }
            this.filter();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this._conditionsOverlaySettings.outlet = this.column.grid.outletDirective;
        this._operatorsOverlaySettings.outlet = this.column.grid.outletDirective;
        this.input.nativeElement.focus();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.onTabKeydown = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.stopPropagation();
        if (document.activeElement === this.closeButton.nativeElement && !event.shiftKey) {
            this.filteringService.grid.navigation.navigateFirstCellIfPossible(event);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.onEscKeydown = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        event.stopPropagation();
        this.close();
    };
    Object.defineProperty(IgxGridFilteringRowComponent.prototype, "disabled", {
        get: /**
         * @return {?}
         */
        function () {
            return !(this.column.filteringExpressionsTree && this.column.filteringExpressionsTree.filteringOperands.length > 0);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridFilteringRowComponent.prototype, "template", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.column.dataType === DataType.Date) {
                return this.defaultDateUI;
            }
            return this.defaultFilterUI;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridFilteringRowComponent.prototype, "type", {
        get: /**
         * @return {?}
         */
        function () {
            switch (this.column.dataType) {
                case DataType.String:
                case DataType.Boolean:
                    return 'text';
                case DataType.Number:
                    return 'number';
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridFilteringRowComponent.prototype, "conditions", {
        get: /**
         * @return {?}
         */
        function () {
            return this.column.filters.conditionList();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridFilteringRowComponent.prototype, "isUnaryCondition", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.expression.condition) {
                return this.expression.condition.isUnary;
            }
            else {
                return true;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridFilteringRowComponent.prototype, "placeholder", {
        get: /**
         * @return {?}
         */
        function () {
            if (this.expression.condition && this.expression.condition.isUnary) {
                return this.filteringService.getChipLabel(this.expression);
            }
            else if (this.column.dataType === DataType.Date) {
                return this.filteringService.grid.resourceStrings.igx_grid_filter_row_date_placeholder;
            }
            else if (this.column.dataType === DataType.Boolean) {
                return this.filteringService.grid.resourceStrings.igx_grid_filter_row_boolean_placeholder;
            }
            else {
                return this.filteringService.grid.resourceStrings.igx_grid_filter_row_placeholder;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Event handler for keydown on the input group's prefix.
     */
    /**
     * Event handler for keydown on the input group's prefix.
     * @param {?} event
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.onPrefixKeyDown = /**
     * Event handler for keydown on the input group's prefix.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if ((event.key === "Enter" /* ENTER */ || event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */) && this.dropDownConditions.collapsed) {
            this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
            event.stopImmediatePropagation();
        }
        else if (event.key === "Tab" /* TAB */) {
            if (event.shiftKey) {
                event.preventDefault();
                event.stopPropagation();
            }
            else if (!this.dropDownConditions.collapsed) {
                this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
            }
        }
    };
    /**
     * Event handler for keydown on the input.
     */
    /**
     * Event handler for keydown on the input.
     * @param {?} event
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.onInputKeyDown = /**
     * Event handler for keydown on the input.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.isKeyPressed = true;
        if (this.column.dataType === DataType.Boolean) {
            if (event.key === "Enter" /* ENTER */ || event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */) {
                this.inputGroupPrefix.nativeElement.focus();
                this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
                event.stopPropagation();
                return;
            }
        }
        if (event.key === "Enter" /* ENTER */) {
            if (this.isComposing) {
                return;
            }
            this.commitInput();
        }
        else if (event.altKey && (event.key === "ArrowDown" /* DOWN_ARROW */ || event.key === "Down" /* DOWN_ARROW_IE */)) {
            this.inputGroupPrefix.nativeElement.focus();
            this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
        }
        else if (event.key === "Escape" /* ESCAPE */ || event.key === "Esc" /* ESCAPE_IE */) {
            event.preventDefault();
            this.close();
        }
        event.stopPropagation();
    };
    /**
     * Event handler for keyup on the input.
     */
    /**
     * Event handler for keyup on the input.
     * @param {?} eventArgs
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.onInputKeyUp = /**
     * Event handler for keyup on the input.
     * @param {?} eventArgs
     * @return {?}
     */
    function (eventArgs) {
        this.isKeyPressed = false;
    };
    /**
     * Event handler for input on the input.
     */
    /**
     * Event handler for input on the input.
     * @param {?} eventArgs
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.onInput = /**
     * Event handler for input on the input.
     * @param {?} eventArgs
     * @return {?}
     */
    function (eventArgs) {
        // The 'iskeyPressed' flag is needed for a case in IE, because the input event is fired on focus and for some reason,
        // when you have a japanese character as a placeholder, on init the value here is empty string .
        if (isEdge() || this.isKeyPressed || eventArgs.target.value) {
            this.value = eventArgs.target.value;
        }
    };
    /**
     * Event handler for compositionstart on the input.
     */
    /**
     * Event handler for compositionstart on the input.
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.onCompositionStart = /**
     * Event handler for compositionstart on the input.
     * @return {?}
     */
    function () {
        this.isComposing = true;
    };
    /**
     * Event handler for compositionend on the input.
     */
    /**
     * Event handler for compositionend on the input.
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.onCompositionEnd = /**
     * Event handler for compositionend on the input.
     * @return {?}
     */
    function () {
        this.isComposing = false;
    };
    /**
     * Event handler for input click event.
     */
    /**
     * Event handler for input click event.
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.onInputClick = /**
     * Event handler for input click event.
     * @return {?}
     */
    function () {
        if (this.column.dataType === DataType.Boolean && this.dropDownConditions.collapsed) {
            this.inputGroupPrefix.nativeElement.focus();
            this.toggleConditionsDropDown(this.inputGroupPrefix.nativeElement);
        }
    };
    /**
     * Event handler for datepicker's close.
     */
    /**
     * Event handler for datepicker's close.
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.datePickerClose = /**
     * Event handler for datepicker's close.
     * @return {?}
     */
    function () {
        this.input.nativeElement.focus();
    };
    /**
     * Returns the filtering operation condition for a given value.
     */
    /**
     * Returns the filtering operation condition for a given value.
     * @param {?} value
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.getCondition = /**
     * Returns the filtering operation condition for a given value.
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return this.column.filters.condition(value);
    };
    /**
     * Returns the translated condition name for a given value.
     */
    /**
     * Returns the translated condition name for a given value.
     * @param {?} value
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.translateCondition = /**
     * Returns the translated condition name for a given value.
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return this.filteringService.grid.resourceStrings["igx_grid_filter_" + this.getCondition(value).name] || value;
    };
    /**
     * Returns the icon name of the current condition.
     */
    /**
     * Returns the icon name of the current condition.
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.getIconName = /**
     * Returns the icon name of the current condition.
     * @return {?}
     */
    function () {
        if (this.column.dataType === DataType.Boolean && this.expression.condition === null) {
            return this.getCondition(this.conditions[0]).iconName;
        }
        else {
            return this.expression.condition.iconName;
        }
    };
    /**
     * Returns whether a given condition is selected in dropdown.
     */
    /**
     * Returns whether a given condition is selected in dropdown.
     * @param {?} conditionName
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.isConditionSelected = /**
     * Returns whether a given condition is selected in dropdown.
     * @param {?} conditionName
     * @return {?}
     */
    function (conditionName) {
        if (this.expression.condition) {
            return this.expression.condition.name === conditionName;
        }
        else {
            return false;
        }
    };
    /**
     * Clears the current filtering.
     */
    /**
     * Clears the current filtering.
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.clearFiltering = /**
     * Clears the current filtering.
     * @return {?}
     */
    function () {
        this.filteringService.clearFilter(this.column.field);
        this.resetExpression();
        if (this.input) {
            this.input.nativeElement.focus();
        }
        this.cdr.detectChanges();
        this.chipAreaScrollOffset = 0;
        this.transform(this.chipAreaScrollOffset);
    };
    /**
     * Commits the value of the input.
     */
    /**
     * Commits the value of the input.
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.commitInput = /**
     * Commits the value of the input.
     * @return {?}
     */
    function () {
        this.chipsArea.chipsList.filter(function (chip) { return chip.selected = false; });
        /** @type {?} */
        var indexToDeselect = -1;
        for (var index = 0; index < this.expressionsList.length; index++) {
            /** @type {?} */
            var expression = this.expressionsList[index].expression;
            if (expression.searchVal === null && !expression.condition.isUnary) {
                indexToDeselect = index;
            }
        }
        if (indexToDeselect !== -1) {
            this.removeExpression(indexToDeselect, this.expression);
        }
        this.resetExpression();
        this.scrollChipsWhenAddingExpression();
    };
    /**
     * Clears the value of the input.
     */
    /**
     * Clears the value of the input.
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.clearInput = /**
     * Clears the value of the input.
     * @return {?}
     */
    function () {
        this.value = null;
    };
    /**
     * Event handler for keydown on clear button.
     */
    /**
     * Event handler for keydown on clear button.
     * @param {?} eventArgs
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.onClearKeyDown = /**
     * Event handler for keydown on clear button.
     * @param {?} eventArgs
     * @return {?}
     */
    function (eventArgs) {
        if (eventArgs.key === "Enter" /* ENTER */ || eventArgs.key === " " /* SPACE */ || eventArgs.key === "Spacebar" /* SPACE_IE */) {
            eventArgs.preventDefault();
            this.clearInput();
            this.input.nativeElement.focus();
        }
    };
    /**
     * Event handler for click on clear button.
     */
    /**
     * Event handler for click on clear button.
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.onClearClick = /**
     * Event handler for click on clear button.
     * @return {?}
     */
    function () {
        this.clearInput();
        this.input.nativeElement.focus();
    };
    /**
     * Event handler for keydown on commit button.
     */
    /**
     * Event handler for keydown on commit button.
     * @param {?} eventArgs
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.onCommitKeyDown = /**
     * Event handler for keydown on commit button.
     * @param {?} eventArgs
     * @return {?}
     */
    function (eventArgs) {
        if (eventArgs.key === "Enter" /* ENTER */ || eventArgs.key === " " /* SPACE */ || eventArgs.key === "Spacebar" /* SPACE_IE */) {
            eventArgs.preventDefault();
            this.commitInput();
            this.input.nativeElement.focus();
        }
    };
    /**
     * Event handler for click on commit button.
     */
    /**
     * Event handler for click on commit button.
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.onCommitClick = /**
     * Event handler for click on commit button.
     * @return {?}
     */
    function () {
        this.commitInput();
        this.input.nativeElement.focus();
    };
    /**
     * Event handler for focusout on the input group.
     */
    /**
     * Event handler for focusout on the input group.
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.onInputGroupFocusout = /**
     * Event handler for focusout on the input group.
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.value && this.value !== 0) {
            return;
        }
        requestAnimationFrame(function () {
            /** @type {?} */
            var focusedElement = document.activeElement;
            if (!(focusedElement && _this.inputGroup.nativeElement.contains(focusedElement)) &&
                _this.dropDownConditions.collapsed) {
                _this.commitInput();
            }
        });
    };
    /**
     * Closes the filtering edit row.
     */
    /**
     * Closes the filtering edit row.
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.close = /**
     * Closes the filtering edit row.
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.expressionsList.length === 1 &&
            this.expressionsList[0].expression.searchVal === null &&
            this.expressionsList[0].expression.condition.isUnary === false) {
            this.filteringService.getExpressions(this.column.field).pop();
        }
        else {
            this.expressionsList.forEach(function (item) {
                if (item.expression.searchVal === null && !item.expression.condition.isUnary) {
                    _this.filteringService.removeExpression(_this.column.field, _this.expressionsList.indexOf(item));
                }
            });
        }
        this.filteringService.isFilterRowVisible = false;
        this.filteringService.updateFilteringCell(this.column);
        this.filteringService.focusFilterCellChip(this.column, true);
        this.filteringService.filteredColumn = null;
        this.filteringService.selectedExpression = null;
        this.cdr.detectChanges();
        this.chipAreaScrollOffset = 0;
        this.transform(this.chipAreaScrollOffset);
    };
    /*
    * Opens date-picker if condition is not unary
    */
    /*
        * Opens date-picker if condition is not unary
        */
    /**
     * @param {?} openDialog
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.openDatePicker = /*
        * Opens date-picker if condition is not unary
        */
    /**
     * @param {?} openDialog
     * @return {?}
     */
    function (openDialog) {
        if (!this.expression.condition.isUnary) {
            openDialog();
        }
    };
    /**
     *  Event handler for date picker's selection.
     */
    /**
     *  Event handler for date picker's selection.
     * @param {?} value
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.onDateSelected = /**
     *  Event handler for date picker's selection.
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.value = value;
        this.commitInput();
    };
    /**
     * Opens the conditions dropdown.
     */
    /**
     * Opens the conditions dropdown.
     * @param {?} target
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.toggleConditionsDropDown = /**
     * Opens the conditions dropdown.
     * @param {?} target
     * @return {?}
     */
    function (target) {
        this._conditionsOverlaySettings.positionStrategy.settings.target = target;
        this.dropDownConditions.toggle(this._conditionsOverlaySettings);
    };
    /**
     * Opens the logic operators dropdown.
     */
    /**
     * Opens the logic operators dropdown.
     * @param {?} eventArgs
     * @param {?} index
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.toggleOperatorsDropDown = /**
     * Opens the logic operators dropdown.
     * @param {?} eventArgs
     * @param {?} index
     * @return {?}
     */
    function (eventArgs, index) {
        this._operatorsOverlaySettings.positionStrategy.settings.target = eventArgs.target.parentElement;
        this.dropDownOperators.toArray()[index].toggle(this._operatorsOverlaySettings);
    };
    /**
     * Event handler for change event in conditions dropdown.
     */
    /**
     * Event handler for change event in conditions dropdown.
     * @param {?} eventArgs
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.onConditionsChanged = /**
     * Event handler for change event in conditions dropdown.
     * @param {?} eventArgs
     * @return {?}
     */
    function (eventArgs) {
        var _this = this;
        /** @type {?} */
        var value = ((/** @type {?} */ (eventArgs.newSelection))).value;
        this.expression.condition = this.getCondition(value);
        if (this.expression.condition.isUnary) {
            // update grid's filtering on the next cycle to ensure the drop-down is closed
            // if the drop-down is not closed this event handler will be invoked multiple times
            requestAnimationFrame(function () { return _this.unaryConditionChangedCallback(); });
        }
        else {
            requestAnimationFrame(function () { return _this.conditionChangedCallback(); });
        }
        if (this.input) {
            // Add requestAnimationFrame becasue of an issue in IE, where you are still able to write in the input,
            // if it has been focused and then set to readonly.
            requestAnimationFrame(function () { return _this.input.nativeElement.focus(); });
        }
    };
    /**
     *  Event handler for chip selected event.
     */
    /**
     *  Event handler for chip selected event.
     * @param {?} eventArgs
     * @param {?} expression
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.onChipSelected = /**
     *  Event handler for chip selected event.
     * @param {?} eventArgs
     * @param {?} expression
     * @return {?}
     */
    function (eventArgs, expression) {
        if (eventArgs.selected) {
            if (this.chipsArea.chipsList) {
                this.chipsArea.chipsList.forEach(function (chip) {
                    if (chip !== eventArgs.owner) {
                        chip.selected = false;
                    }
                });
            }
            this.expression = expression;
            if (this.input) {
                this.input.nativeElement.focus();
            }
        }
        else if (this.expression === expression) {
            this.resetExpression();
        }
    };
    /**
     * Event handler for chip keydown event.
     */
    /**
     * Event handler for chip keydown event.
     * @param {?} eventArgs
     * @param {?} chip
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.onChipKeyDown = /**
     * Event handler for chip keydown event.
     * @param {?} eventArgs
     * @param {?} chip
     * @return {?}
     */
    function (eventArgs, chip) {
        if (eventArgs.key === "Enter" /* ENTER */) {
            eventArgs.preventDefault();
            chip.selected = !chip.selected;
        }
    };
    /**
     * Scrolls the first chip into view if the tab key is pressed on the left arrow.
     */
    /**
     * Scrolls the first chip into view if the tab key is pressed on the left arrow.
     * @param {?} event
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.onLeftArrowKeyDown = /**
     * Scrolls the first chip into view if the tab key is pressed on the left arrow.
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.key === "Tab" /* TAB */) {
            this.chipAreaScrollOffset = 0;
            this.transform(this.chipAreaScrollOffset);
        }
    };
    /**
     * Event handler for chip removed event.
     */
    /**
     * Event handler for chip removed event.
     * @param {?} eventArgs
     * @param {?} item
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.onChipRemoved = /**
     * Event handler for chip removed event.
     * @param {?} eventArgs
     * @param {?} item
     * @return {?}
     */
    function (eventArgs, item) {
        /** @type {?} */
        var indexToRemove = this.expressionsList.indexOf(item);
        this.removeExpression(indexToRemove, item.expression);
        this.scrollChipsOnRemove();
    };
    /**
     * Event handler for logic operator changed event.
     */
    /**
     * Event handler for logic operator changed event.
     * @param {?} eventArgs
     * @param {?} expression
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.onLogicOperatorChanged = /**
     * Event handler for logic operator changed event.
     * @param {?} eventArgs
     * @param {?} expression
     * @return {?}
     */
    function (eventArgs, expression) {
        var _this = this;
        if (eventArgs.oldSelection) {
            expression.afterOperator = ((/** @type {?} */ (eventArgs.newSelection))).value;
            this.expressionsList[this.expressionsList.indexOf(expression) + 1].beforeOperator = expression.afterOperator;
            // update grid's filtering on the next cycle to ensure the drop-down is closed
            // if the drop-down is not closed this event handler will be invoked multiple times
            requestAnimationFrame(function () { return _this.filter(); });
        }
    };
    /**
     * Scrolls the chips into the chip area when left or right arrows are pressed.
     */
    /**
     * Scrolls the chips into the chip area when left or right arrows are pressed.
     * @param {?} arrowPosition
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.scrollChipsOnArrowPress = /**
     * Scrolls the chips into the chip area when left or right arrows are pressed.
     * @param {?} arrowPosition
     * @return {?}
     */
    function (arrowPosition) {
        /** @type {?} */
        var count = 0;
        /** @type {?} */
        var chipAraeChildren = this.chipsArea.element.nativeElement.children;
        /** @type {?} */
        var containerRect = this.container.nativeElement.getBoundingClientRect();
        if (arrowPosition === 'right') {
            for (var index = 0; index < chipAraeChildren.length; index++) {
                if (Math.ceil(chipAraeChildren[index].getBoundingClientRect().right) < Math.ceil(containerRect.right)) {
                    count++;
                }
            }
            if (count < chipAraeChildren.length) {
                this.chipAreaScrollOffset -= Math.ceil(chipAraeChildren[count].getBoundingClientRect().right) -
                    Math.ceil(containerRect.right) + 1;
                this.transform(this.chipAreaScrollOffset);
            }
        }
        if (arrowPosition === 'left') {
            for (var index = 0; index < chipAraeChildren.length; index++) {
                if (Math.ceil(chipAraeChildren[index].getBoundingClientRect().left) < Math.ceil(containerRect.left)) {
                    count++;
                }
            }
            if (count > 0) {
                this.chipAreaScrollOffset += Math.ceil(containerRect.left) -
                    Math.ceil(chipAraeChildren[count - 1].getBoundingClientRect().left) + 1;
                this.transform(this.chipAreaScrollOffset);
            }
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.showHideArrowButtons = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        requestAnimationFrame(function () {
            if (_this.filteringService.isFilterRowVisible) {
                /** @type {?} */
                var containerWidth = _this.container.nativeElement.getBoundingClientRect().width;
                _this.chipsAreaWidth = _this.chipsArea.element.nativeElement.getBoundingClientRect().width;
                _this.showArrows = _this.chipsAreaWidth >= containerWidth && _this.isColumnFiltered;
                // TODO: revise the cdr.detectChanges() usage here
                _this.cdr.detectChanges();
            }
        });
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.transformValue = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (this.column.dataType === DataType.Number) {
            value = parseFloat(value);
        }
        else if (this.column.dataType === DataType.Boolean) {
            value = Boolean(value);
        }
        return value;
    };
    /**
     * @private
     * @param {?} isSelected
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.addExpression = /**
     * @private
     * @param {?} isSelected
     * @return {?}
     */
    function (isSelected) {
        /** @type {?} */
        var exprUI = new ExpressionUI();
        exprUI.expression = this.expression;
        exprUI.beforeOperator = this.expressionsList.length > 0 ? FilteringLogic.And : null;
        exprUI.isSelected = isSelected;
        this.expressionsList.push(exprUI);
        /** @type {?} */
        var length = this.expressionsList.length;
        if (this.expressionsList[length - 2]) {
            this.expressionsList[length - 2].afterOperator = this.expressionsList[length - 1].beforeOperator;
        }
        this.showHideArrowButtons();
    };
    /**
     * @private
     * @param {?} indexToRemove
     * @param {?} expression
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.removeExpression = /**
     * @private
     * @param {?} indexToRemove
     * @param {?} expression
     * @return {?}
     */
    function (indexToRemove, expression) {
        if (indexToRemove === 0 && this.expressionsList.length === 1) {
            this.clearFiltering();
            return;
        }
        this.filteringService.removeExpression(this.column.field, indexToRemove);
        this.filter();
        if (this.expression === expression) {
            this.resetExpression();
        }
        this.showHideArrowButtons();
    };
    /**
     * @private
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.resetExpression = /**
     * @private
     * @return {?}
     */
    function () {
        this.expression = {
            fieldName: this.column.field,
            condition: null,
            searchVal: null,
            ignoreCase: this.column.filteringIgnoreCase
        };
        if (this.column.dataType !== DataType.Boolean) {
            this.expression.condition = this.getCondition(this.conditions[0]);
        }
        if (this.column.dataType === DataType.Date && this.input) {
            this.input.nativeElement.value = null;
        }
        this.showHideArrowButtons();
    };
    /**
     * @private
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.scrollChipsWhenAddingExpression = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var chipAraeChildren = this.chipsArea.element.nativeElement.children;
        if (!chipAraeChildren || chipAraeChildren.length === 0) {
            return;
        }
        /** @type {?} */
        var containerRectRight = Math.ceil(this.container.nativeElement.getBoundingClientRect().right);
        /** @type {?} */
        var lastChipRectRight = Math.ceil(chipAraeChildren[chipAraeChildren.length - 1].getBoundingClientRect().right);
        if (lastChipRectRight >= containerRectRight) {
            this.chipAreaScrollOffset -= lastChipRectRight - containerRectRight;
            this.transform(this.chipAreaScrollOffset);
        }
    };
    /**
     * @private
     * @param {?} offset
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.transform = /**
     * @private
     * @param {?} offset
     * @return {?}
     */
    function (offset) {
        var _this = this;
        requestAnimationFrame(function () {
            _this.chipsArea.element.nativeElement.style.transform = "translate(" + offset + "px)";
        });
    };
    /**
     * @private
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.scrollChipsOnRemove = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var count = 0;
        /** @type {?} */
        var chipAraeChildren = this.chipsArea.element.nativeElement.children;
        /** @type {?} */
        var containerRect = this.container.nativeElement.getBoundingClientRect();
        for (var index = 0; index < chipAraeChildren.length; index++) {
            if (Math.ceil(chipAraeChildren[index].getBoundingClientRect().left) < Math.ceil(containerRect.left)) {
                count++;
            }
        }
        if (count <= 2) {
            this.chipAreaScrollOffset = 0;
        }
        else {
            /** @type {?} */
            var dif = chipAraeChildren[count].id === 'chip' ? count - 2 : count - 1;
            this.chipAreaScrollOffset += Math.ceil(containerRect.left) - Math.ceil(chipAraeChildren[dif].getBoundingClientRect().left) + 1;
        }
        this.transform(this.chipAreaScrollOffset);
    };
    /**
     * @private
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.conditionChangedCallback = /**
     * @private
     * @return {?}
     */
    function () {
        if (!!this.expression.searchVal || this.expression.searchVal === 0) {
            this.filter();
        }
        else if (this.value) {
            this.value = null;
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.unaryConditionChangedCallback = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.value) {
            this.value = null;
        }
        if (this.expressionsList.find(function (item) { return item.expression === _this.expression; }) === undefined) {
            this.addExpression(true);
        }
        this.filter();
    };
    /**
     * @private
     * @return {?}
     */
    IgxGridFilteringRowComponent.prototype.filter = /**
     * @private
     * @return {?}
     */
    function () {
        this.filteringService.filterInternal(this.column.field);
    };
    Object.defineProperty(IgxGridFilteringRowComponent.prototype, "isColumnFiltered", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return this.column.filteringExpressionsTree && this.column.filteringExpressionsTree.filteringOperands.length > 0;
        },
        enumerable: true,
        configurable: true
    });
    IgxGridFilteringRowComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-grid-filtering-row',
                    template: "<!-- Have to apply styles inline because of the overlay outlet ... -->\n<igx-drop-down #inputGroupConditions [height]=\"'200px'\" (onSelection)=\"onConditionsChanged($event)\">\n    <igx-drop-down-item\n        *ngFor=\"let condition of conditions\"\n        [value]=\"condition\"\n        [selected]=\"isConditionSelected(condition)\">\n        <igx-icon fontSet=\"filtering-icons\" [name]=\"getCondition(condition).iconName\"></igx-icon>\n        <span style=\"margin-left: 16px\">{{ translateCondition(condition) }}</span>\n    </igx-drop-down-item>\n</igx-drop-down>\n\n<ng-template #defaultFilterUI>\n    <igx-input-group #inputGroup type=\"box\" [displayDensity]=\"'compact'\" [supressInputAutofocus]=\"true\" (focusout)=\"onInputGroupFocusout()\">\n        <igx-prefix #inputGroupPrefix\n                    (click)=\"toggleConditionsDropDown(inputGroupPrefix)\"\n                    (keydown)=\"onPrefixKeyDown($event)\"\n                    tabindex=\"0\"\n                    [igxDropDownItemNavigation]=\"inputGroupConditions\">\n            <igx-icon fontSet=\"filtering-icons\" [name]=\"getIconName()\"></igx-icon>\n        </igx-prefix>\n        <input\n            #input\n            igxInput\n            tabindex=\"0\"\n            [placeholder]=\"placeholder\"\n            autocomplete=\"off\"\n            [value]=\"value\"\n            (input)=\"onInput($event)\"\n            [type]=\"type\"\n            [readonly]=\"isUnaryCondition\"\n            (click)=\"onInputClick()\"\n            (compositionstart)=\"onCompositionStart()\"\n            (compositionend)=\"onCompositionEnd()\"\n            (keydown)=\"onInputKeyDown($event)\"\n            (keyup)=\"onInputKeyUp($event)\"/>\n            <igx-suffix *ngIf=\"value || value === 0\" >\n                <igx-icon (keydown)=\"onCommitKeyDown($event)\" (click)=\"onCommitClick()\" tabindex=\"0\">done</igx-icon>\n                <igx-icon (keydown)=\"onClearKeyDown($event)\" (click)=\"onClearClick()\" tabindex=\"0\">clear</igx-icon>\n            </igx-suffix>\n    </igx-input-group>\n</ng-template>\n\n<ng-template #defaultDateUI>\n    <igx-date-picker\n        tabindex=\"0\"\n        mode=\"dropdown\"\n        [value]=\"value\"\n        [outlet]=\"filteringService.grid.outletDirective\"\n        [locale]=\"filteringService.grid.locale\"\n        (onSelection)=\"onDateSelected($event)\"\n        (onClose)=\"datePickerClose()\">\n        <ng-template igxDatePickerTemplate let-openDialog=\"openDialog\">\n            <igx-input-group #dropDownTarget type=\"box\" [displayDensity]=\"'compact'\" [supressInputAutofocus]=\"true\">\n                <igx-prefix #inputGroupPrefix\n                            tabindex=\"0\"\n                            (click)=\"toggleConditionsDropDown(inputGroupPrefix)\"\n                            (keydown)=\"onPrefixKeyDown($event)\"\n                            [igxDropDownItemNavigation]=\"inputGroupConditions\">\n                    <igx-icon fontSet=\"filtering-icons\" [name]=\"expression.condition.iconName\"></igx-icon>\n                </igx-prefix>\n                <input #input\n                       igxInput\n                       tabindex=\"0\"\n                       (click)=\"openDatePicker(openDialog)\"\n                       [placeholder]=\"placeholder\"\n                       autocomplete=\"off\"\n                       [value]=\"value | igxdate: filteringService.grid.locale\"\n                       [readonly]=\"true\"\n                       (keydown)=\"onInputKeyDown($event)\"/>\n                <igx-suffix *ngIf=\"value\" (keydown)=\"onClearKeyDown($event)\" (click)=\"clearInput()\" tabindex=\"0\">\n                    <igx-icon>clear</igx-icon>\n                </igx-suffix>\n            </igx-input-group>\n            </ng-template>\n    </igx-date-picker>\n</ng-template>\n\n<ng-container *ngTemplateOutlet=\"template; context: { $implicit: this }\"></ng-container>\n\n<button igxButton=\"icon\" class=\"igx-grid__filtering-row-scroll-start\" *ngIf=\"showArrows\" (keydown)=\"onLeftArrowKeyDown($event)\" (click)=\"scrollChipsOnArrowPress('left')\">\n    <igx-icon>navigate_before</igx-icon>\n</button>\n\n<div #container class=\"igx-grid__filtering-row-main\">\n    <div>\n         <igx-chips-area #chipsArea>\n            <ng-container *ngFor=\"let item of expressionsList; index as i; let last = last;\" tabindex=\"0\">\n                <igx-chip #chip id='chip'\n                    (onSelection)=\"onChipSelected($event, item.expression)\"\n                    (keydown)=\"onChipKeyDown($event, chip)\"\n                    (onRemove)=\"onChipRemoved($event, item)\"\n                    [selectable]=\"true\"\n                    [selected]=\"item.isSelected\"\n                    [displayDensity]=\"'cosy'\"\n                    [removable]=\"true\">\n                    <igx-icon\n                        igxPrefix\n                        fontSet=\"filtering-icons\"\n                        [name]=\"item.expression.condition.iconName\">\n                    </igx-icon>\n                    <span>{{filteringService.getChipLabel(item.expression)}}</span>\n                </igx-chip>\n\n                <span id='operand' *ngIf=\"!last\">\n                    <button igxButton (click)=\"toggleOperatorsDropDown($event, i)\" [igxDropDownItemNavigation]=\"operators\">\n                        <igx-icon>expand_more</igx-icon>\n                        <span>{{filteringService.getOperatorAsString(item.afterOperator)}}</span>\n                    </button>\n                    <igx-drop-down #operators (onSelection)=\"onLogicOperatorChanged($event, item)\">\n                            <igx-drop-down-item [value]=\"0\" [selected]=\"item.afterOperator === 0\">{{filteringService.grid.resourceStrings.igx_grid_filter_operator_and}}</igx-drop-down-item>\n                            <igx-drop-down-item [value]=\"1\" [selected]=\"item.afterOperator === 1\">{{filteringService.grid.resourceStrings.igx_grid_filter_operator_or}}</igx-drop-down-item>\n                    </igx-drop-down>\n                </span>\n            </ng-container>\n        </igx-chips-area>\n    </div>\n</div>\n\n<button igxButton=\"icon\" class=\"igx-grid__filtering-row-scroll-end\" *ngIf=\"showArrows\" (click)=\"scrollChipsOnArrowPress('right')\">\n    <igx-icon>navigate_next</igx-icon>\n</button>\n\n<div #buttonsContainer class=\"igx-grid__filtering-row-editing-buttons\">\n    <button igxButton igxRipple (click)=\"clearFiltering()\" [disabled]=\"disabled\" [tabindex]=\"disabled\">{{filteringService.grid.resourceStrings.igx_grid_filter_row_reset}}</button>\n    <button #closeButton igxButton igxRipple (click)=\"close()\">{{filteringService.grid.resourceStrings.igx_grid_filter_row_close}}</button>\n</div>\n"
                }] }
    ];
    /** @nocollapse */
    IgxGridFilteringRowComponent.ctorParameters = function () { return [
        { type: IgxFilteringService },
        { type: ElementRef },
        { type: ChangeDetectorRef }
    ]; };
    IgxGridFilteringRowComponent.propDecorators = {
        column: [{ type: Input }],
        value: [{ type: Input }],
        defaultFilterUI: [{ type: ViewChild, args: ['defaultFilterUI', { read: TemplateRef },] }],
        defaultDateUI: [{ type: ViewChild, args: ['defaultDateUI', { read: TemplateRef },] }],
        input: [{ type: ViewChild, args: ['input', { read: ElementRef },] }],
        dropDownConditions: [{ type: ViewChild, args: ['inputGroupConditions', { read: IgxDropDownComponent },] }],
        chipsArea: [{ type: ViewChild, args: ['chipsArea', { read: IgxChipsAreaComponent },] }],
        dropDownOperators: [{ type: ViewChildren, args: ['operators', { read: IgxDropDownComponent },] }],
        inputGroup: [{ type: ViewChild, args: ['inputGroup', { read: ElementRef },] }],
        inputGroupPrefix: [{ type: ViewChild, args: ['inputGroupPrefix', { read: ElementRef },] }],
        container: [{ type: ViewChild, args: ['container',] }],
        operand: [{ type: ViewChild, args: ['operand',] }],
        closeButton: [{ type: ViewChild, args: ['closeButton',] }],
        cssClass: [{ type: HostBinding, args: ['class.igx-grid__filtering-row',] }],
        onTabKeydown: [{ type: HostListener, args: ['keydown.shift.tab', ['$event'],] }, { type: HostListener, args: ['keydown.tab', ['$event'],] }],
        onEscKeydown: [{ type: HostListener, args: ['keydown.esc', ['$event'],] }]
    };
    return IgxGridFilteringRowComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var MINIMUM_COLUMN_WIDTH = 136;
/** @type {?} */
var FILTER_ROW_HEIGHT = 50;
// By default row editing overlay outlet is inside grid body so that overlay is hidden below grid header when scrolling.
// In cases when grid has 1-2 rows there isn't enough space in grid body and row editing overlay should be shown above header.
// Default row editing overlay height is higher then row height that is why the case is valid also for row with 2 rows.
// More accurate calculation is not possible, cause row editing overlay is still not shown and we don't know its height,
// but in the same time we need to set row editing overlay outlet before opening the overlay itself.
/** @type {?} */
var MIN_ROW_EDITING_COUNT_THRESHOLD = 2;
/** @type {?} */
var IgxGridTransaction = new InjectionToken('IgxGridTransaction');
/** @enum {string} */
var GridSummaryPosition = {
    top: 'top',
    bottom: 'bottom',
};
/** @enum {string} */
var GridSummaryCalculationMode = {
    rootLevelOnly: 'rootLevelOnly',
    childLevelsOnly: 'childLevelsOnly',
    rootAndChildLevels: 'rootAndChildLevels',
};
/** @enum {string} */
var FilterMode = {
    quickFilter: 'quickFilter',
    excelStyleFilter: 'excelStyleFilter',
};
/** @enum {string} */
var GridKeydownTargetType = {
    dataCell: 'dataCell',
    summaryCell: 'summaryCell',
    groupRow: 'groupRow',
    hierarchicalRow: 'hierarchicalRow',
};
/**
 * @abstract
 */
var IgxGridBaseComponent = /** @class */ (function (_super) {
    __extends(IgxGridBaseComponent, _super);
    function IgxGridBaseComponent(selectionService, crudService, gridAPI, selection, _transactions, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions) {
        var _this = _super.call(this, _displayDensityOptions) || this;
        _this.selectionService = selectionService;
        _this.crudService = crudService;
        _this.gridAPI = gridAPI;
        _this.selection = selection;
        _this._transactions = _transactions;
        _this.elementRef = elementRef;
        _this.zone = zone;
        _this.document = document;
        _this.cdr = cdr;
        _this.resolver = resolver;
        _this.differs = differs;
        _this.viewRef = viewRef;
        _this.navigation = navigation;
        _this.filteringService = filteringService;
        _this.overlayService = overlayService;
        _this.summaryService = summaryService;
        _this._displayDensityOptions = _displayDensityOptions;
        _this._resourceStrings = CurrentResourceStrings.GridResStrings;
        _this._emptyGridMessage = null;
        _this._emptyFilteredGridMessage = null;
        _this._isLoading = false;
        _this._locale = null;
        _this._destroyed = false;
        _this.overlayIDs = [];
        /**
         * An \@Input property that autogenerates the `IgxGridComponent` columns.
         * The default value is false.
         * ```html
         * <igx-grid [data]="Data" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */
        _this.autoGenerate = false;
        /**
         * @hidden
         * \@internal
         */
        _this.rowDragging = false;
        /**
         * An \@Input property that adds styling classes applied to all even `IgxGridRowComponent`s in the grid.
         * ```html
         * <igx-grid #grid [data]="Data" [evenRowCSS]="'igx-grid--my-even-class'" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */
        _this.evenRowCSS = 'igx-grid__tr--even';
        /**
         * An \@Input property that adds styling classes applied to all odd `IgxGridRowComponent`s in the grid.
         * ```html
         * <igx-grid #grid [data]="Data" [evenRowCSS]="'igx-grid--my-odd-class'" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */
        _this.oddRowCSS = 'igx-grid__tr--odd';
        /**
         * An \@Input property that sets the title to be displayed in the built-in column hiding UI.
         * ```html
         * <igx-grid [showToolbar]="true" [columnHiding]="true" columnHidingTitle="Column Hiding"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */
        _this.columnHidingTitle = '';
        /**
         * An \@Input property that sets the title to be displayed in the UI of the column pinning.
         * ```html
         * <igx-grid #grid [data]="localData" [columnPinning]="'true" [columnPinningTitle]="'Column Hiding'" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */
        _this.columnPinningTitle = '';
        /**
         * Emitted when `IgxGridCellComponent` is clicked. Returns the `IgxGridCellComponent`.
         * ```html
         * <igx-grid #grid (onCellClick)="onCellClick($event)" [data]="localData" [height]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         * ```typescript
         * public onCellClick(e){
         *     alert("The cell has been clicked!");
         * }
         * ```
         * \@memberof IgxGridBaseComponent
         */
        _this.onCellClick = new EventEmitter();
        /**
         * Emitted when `IgxGridCellComponent` is selected. Returns the `IgxGridCellComponent`.
         * ```html
         * <igx-grid #grid (onSelection)="onCellSelect($event)" [data]="localData" [height]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         * ```typescript
         * public onCellSelect(e){
         *     alert("The cell has been selected!");
         * }
         * ```
         * \@memberof IgxGridBaseComponent
         */
        _this.onSelection = new EventEmitter();
        /**
         *  Emitted when `IgxGridRowComponent` is selected.
         * ```html
         * <igx-grid #grid (onRowSelectionChange)="onRowClickChange($event)" [data]="localData" [autoGenerate]="true"></igx-grid>
         * ```
         * ```typescript
         * public onCellClickChange(e){
         *     alert("The selected row has been changed!");
         * }
         * ```
         * \@memberof IgxGridBaseComponent
         */
        _this.onRowSelectionChange = new EventEmitter();
        /**
         * Emitted when `IgxColumnComponent` is pinned.
         * The index that the column is inserted at may be changed through the `insertAtIndex` property.
         * ```typescript
         * public columnPinning(event) {
         *     if (event.column.field === "Name") {
         *       event.insertAtIndex = 0;
         *     }
         * }
         * ```
         * \@memberof IgxGridBaseComponent
         */
        _this.onColumnPinning = new EventEmitter();
        /**
         * An \@Output property emitting an event when `IgxGridCellComponent`
         * editing has been performed in the grid and the values have **not** been submitted (e.g. `Esc` key was pressed).
         * This event is cancelable.
         *
         * args: IGridEditEventArgs = {
         *      cancel: bool,
         *      cellID: {
         *          columnID: int,
         *          rowID: int,
         *          rowIndex: int
         *      }
         *      newValue: object,
         *      oldValue: object,
         *      rowID: int
         *  }
         *
         * ```typescript
         * editCancel(event: IGridEditEventArgs){
         *    const rowID: IgxColumnComponent = event.rowID;
         * }
         * ```
         * ```html
         * <igx-grid #grid3 (onCellEditCancel)="editCancel($event)" [data]="remote | async" (onSortingDone)="process($event)"
         *          [primaryKey]="'ProductID'" [rowSelectable]="true">
         *          <igx-column [sortable]="true" [field]="'ProductID'"></igx-column>
         *          <igx-column [editable]="true" [field]="'ProductName'"></igx-column>
         *          <igx-column [sortable]="true" [field]="'UnitsInStock'" [header]="'Units in Stock'"></igx-column>
         * </igx-grid>
         * ```
         * \@memberof IgxGridComponent
         */
        _this.onCellEditCancel = new EventEmitter();
        /**
         * An \@Output property emitting an event when `IgxGridCellComponent` enters edit mode.
         * This event is cancelable.
         *
         * args: IGridEditEventArgs = {
         *      cancel: bool,
         *      cellID: {
         *          columnID: int,
         *          rowID: int,
         *          rowIndex: int
         *      }
         *      oldValue: object,
         *      rowID: int
         *  }
         *
         * ```typescript
         * editStart(event: IGridEditEventArgs){
         *    const value: IgxColumnComponent = event.newValue;
         * }
         * ```
         * ```html
         * <igx-grid #grid3 (onCellEditEnter)="editStart($event)" [data]="remote | async" (onSortingDone)="process($event)"
         *          [primaryKey]="'ProductID'" [rowSelectable]="true">
         *          <igx-column [sortable]="true" [field]="'ProductID'"></igx-column>
         *          <igx-column [editable]="true" [field]="'ProductName'"></igx-column>
         *          <igx-column [sortable]="true" [field]="'UnitsInStock'" [header]="'Units in Stock'"></igx-column>
         * </igx-grid>
         * ```
         * \@memberof IgxGridComponent
         */
        _this.onCellEditEnter = new EventEmitter();
        /**
         * An \@Output property emitting an event when `IgxGridCellComponent` editing has been performed in the grid.
         * Event is fired after editing is completed, when the cell is exiting edit mode.
         * This event is cancelable.
         *
         * args: IGridEditEventArgs = {
         *      cancel: bool,
         *      cellID: {
         *          columnID: int,
         *          rowID: int,
         *          rowIndex: int
         *      }
         *      newValue: object,
         *      oldValue: object,
         *      rowID: int
         *  }
         *
         * ```typescript
         * editDone(event: IGridEditEventArgs){
         *    const value: IgxColumnComponent = event.newValue;
         * }
         * ```
         * ```html
         * <igx-grid #grid3 (onCellEdit)="editDone($event)" [data]="remote | async" (onSortingDone)="process($event)"
         *          [primaryKey]="'ProductID'" [rowSelectable]="true">
         *          <igx-column [sortable]="true" [field]="'ProductID'"></igx-column>
         *          <igx-column [editable]="true" [field]="'ProductName'"></igx-column>
         *          <igx-column [sortable]="true" [field]="'UnitsInStock'" [header]="'Units in Stock'"></igx-column>
         * </igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */
        _this.onCellEdit = new EventEmitter();
        /**
         * An \@Output property emitting an event when [rowEditable]="true" a row enters edit mode.
         * This event is cancelable.
         *
         * args: IGridEditEventArgs = {
         *      cancel: bool,
         *      oldValue: <rowObj>,
         *      rowID: int
         *  }
         *
         * Bind to the event in markup as follows:
         * ```html
         * <igx-grid #grid3 (onRowEditEnter)="editStart($event)" [data]="remote | async" (onSortingDone)="process($event)"
         *          [primaryKey]="'ProductID'" [rowSelectable]="true" [rowEditable]="true">
         *          <igx-column [sortable]="true" [field]="'ProductID'"></igx-column>
         *          <igx-column [editable]="true" [field]="'ProductName'"></igx-column>
         *          <igx-column [sortable]="true" [field]="'UnitsInStock'" [header]="'Units in Stock'"></igx-column>
         * </igx-grid>
         * ```
         * ```typescript
         *      editStart(event: IGridEditEventArgs) {
         *          const editedRowObj = event.oldValue;
         *          const cancelValue = event.cancel;
         *          const rowID = event.rowID;
         *      }
         * ```
         * \@memberof IgxGridComponent
         */
        _this.onRowEditEnter = new EventEmitter();
        /**
         * An \@Output property emitting an event when [rowEditable]="true" & `endEdit(true)` is called.
         * Emitted when changing rows during edit mode, selecting an un-editable cell in the edited row,
         * performing paging operation, column resizing, pinning, moving or hitting  `Done`
         * button inside of the rowEditingOverlay, or hitting the `Enter` key while editing a cell.
         * This event is cancelable.
         *
         * args: IGridEditEventArgs = {
         *      cancel: bool,
         *      newValue: <rowObj>,
         *      oldValue: <rowObj>,
         *      rowID: int
         *  }
         *
         * Bind to the event in markup as follows:
         * ```html
         * <igx-grid #grid3 (onRowEdit)="editDone($event)" [data]="remote | async" (onSortingDone)="process($event)"
         *          [primaryKey]="'ProductID'" [rowSelectable]="true" [rowEditable]="true">
         *          <igx-column [sortable]="true" [field]="'ProductID'"></igx-column>
         *          <igx-column [editable]="true" [field]="'ProductName'"></igx-column>
         *          <igx-column [sortable]="true" [field]="'UnitsInStock'" [header]="'Units in Stock'"></igx-column>
         * </igx-grid>
         * ```
         *
         * ```typescript
         *      editDone(event: IGridEditEventArgs) {
         *          const originalRowObj = event.oldValue;
         *          const updatedRowObj = event.newValue;
         *          const cancelValue = event.cancel;
         *          const rowID = event.rowID;
         *      }
         * ```
         * \@memberof IgxGridBaseComponent
         */
        _this.onRowEdit = new EventEmitter();
        /**
         * An \@Output property emitting an event when [rowEditable]="true" & `endEdit(false)` is called.
         * Emitted when changing hitting `Esc` key during cell editing and when click on the `Cancel` button
         * in the row editing overlay.
         * This event is cancelable.
         *
         * args: IGridEditEventArgs = {
         *      cancel: bool,
         *      newValue: <rowObj>,
         *      oldValue: <rowObj>,
         *      rowID: int
         *  }
         *
         * Bind to the event in markup as follows:
         * ```html
         * <igx-grid #grid3 (onRowEditCancel)="editCancel($event)" [data]="remote | async" (onSortingDone)="process($event)"
         *          [primaryKey]="'ProductID'" [rowSelectable]="true" [rowEditable]="true">
         *          <igx-column [sortable]="true" [field]="'ProductID'"></igx-column>
         *          <igx-column [editable]="true" [field]="'ProductName'"></igx-column>
         *          <igx-column [sortable]="true" [field]="'UnitsInStock'" [header]="'Units in Stock'"></igx-column>
         * </igx-grid>
         * ```
         * ```typescript
         *      editCancel(emitted: { row: IgxGridRowComponent, newValue: any, oldValue: any }): void {
         *          const originalRowObj = event.oldValue;
         *          const updatedRowObj = event.newValue;
         *          const cancelValue = event.cancel;
         *          const rowID = event.rowID;
         *      }
         * ```
         * \@memberof IgxGridBaseComponent
         */
        _this.onRowEditCancel = new EventEmitter();
        /**
         * Emitted when a grid column is initialized. Returns the column object.
         * ```html
         * <igx-grid #grid [data]="localData" [onColumnInit]="initColumns($event)" [autoGenerate]="true"></igx-grid>
         * ```
         * ```typescript
         * initColumns(event: IgxColumnComponent) {
         * const column: IgxColumnComponent = event;
         *       column.filterable = true;
         *       column.sortable = true;
         *       column.editable = true;
         * }
         * ```
         * \@memberof IgxGridBaseComponent
         */
        _this.onColumnInit = new EventEmitter();
        /**
         * Emitted when sorting is performed through the UI. Returns the sorting expression.
         * ```html
         * <igx-grid #grid [data]="localData" [autoGenerate]="true" (onSortingDone)="sortingDone($event)"></igx-grid>
         * ```
         * ```typescript
         * sortingDone(event: SortingDirection){
         *     const sortingDirection = event;
         * }
         * ```
         * \@memberof IgxGridBaseComponent
         */
        _this.onSortingDone = new EventEmitter();
        /**
         * Emitted when filtering is performed through the UI.
         * Returns the filtering expressions tree of the column for which filtering was performed.
         * ```typescript
         * filteringDone(event: IFilteringExpressionsTree){
         *     const filteringTree = event;
         * }
         * ```
         * ```html
         * <igx-grid #grid [data]="localData" [height]="'305px'" [autoGenerate]="true" (onFilteringDone)="filteringDone($event)"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */
        _this.onFilteringDone = new EventEmitter();
        /**
         * Emitted when paging is performed. Returns an object consisting of the previous and next pages.
         * ```typescript
         * pagingDone(event: IPageEventArgs){
         *     const paging = event;
         * }
         * ```
         * ```html
         * <igx-grid #grid [data]="localData" [height]="'305px'" [autoGenerate]="true" (onPagingDone)="pagingDone($event)"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */
        _this.onPagingDone = new EventEmitter();
        /**
         * Emitted when a `IgxGridRowComponent` is being added to the `IgxGridComponent` through the API.
         * Returns the data for the new `IgxGridRowComponent` object.
         * ```typescript
         * rowAdded(event: IRowDataEventArgs){
         *    const rowInfo = event;
         * }
         * ```
         * ```html
         * <igx-grid #grid [data]="localData" (onRowAdded)="rowAdded($event)" [height]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */
        _this.onRowAdded = new EventEmitter();
        /**
         * Emitted when a `IgxGridRowComponent` is deleted through the `IgxGridComponent` API.
         * Returns an `IRowDataEventArgs` object.
         * ```typescript
         * rowDeleted(event: IRowDataEventArgs){
         *    const rowInfo = event;
         * }
         * ```
         * ```html
         * <igx-grid #grid [data]="localData" (onRowDeleted)="rowDeleted($event)" [height]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */
        _this.onRowDeleted = new EventEmitter();
        /**
         * Emitted when a new chunk of data is loaded from virtualization.
         * ```typescript
         *  <igx-grid #grid [data]="localData" [autoGenerate]="true" (onDataPreLoad)='handleDataPreloadEvent()'></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */
        _this.onDataPreLoad = new EventEmitter();
        /**
         * Emitted when `IgxColumnComponent` is resized.
         * Returns the `IgxColumnComponent` object's old and new width.
         * ```typescript
         * resizing(event: IColumnResizeEventArgs){
         *     const grouping = event;
         * }
         * ```
         * ```html
         * <igx-grid #grid [data]="localData" (onColumnResized)="resizing($event)" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */
        _this.onColumnResized = new EventEmitter();
        /**
         * Emitted when a `IgxGridCellComponent` is right clicked. Returns the `IgxGridCellComponent` object.
         * ```typescript
         * contextMenu(event: IGridCellEventArgs){
         *     const resizing = event;
         *     console.log(resizing);
         * }
         * ```
         * ```html
         * <igx-grid #grid [data]="localData" (onContextMenu)="contextMenu($event)" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */
        _this.onContextMenu = new EventEmitter();
        /**
         * Emitted when a `IgxGridCellComponent` is double clicked. Returns the `IgxGridCellComponent` object.
         * ```typescript
         * dblClick(event: IGridCellEventArgs){
         *     const dblClick = event;
         *     console.log(dblClick);
         * }
         * ```
         * ```html
         * <igx-grid #grid [data]="localData" (onDoubleClick)="dblClick($event)" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */
        _this.onDoubleClick = new EventEmitter();
        /**
         * Emitted when `IgxColumnComponent` visibility is changed. Args: { column: any, newValue: boolean }
         * ```typescript
         * visibilityChanged(event: IColumnVisibilityChangedEventArgs){
         *    const visiblity = event;
         * }
         * ```
         * ```html
         * <igx-grid [columnHiding]="true" [showToolbar]="true" (onColumnVisibilityChanged)="visibilityChanged($event)"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */
        _this.onColumnVisibilityChanged = new EventEmitter();
        /**
         * Emitted when `IgxColumnComponent` moving starts. Returns the moved `IgxColumnComponent` object.
         * ```typescript
         * movingStart(event: IColumnMovingStartEventArgs){
         *     const movingStarts = event;
         * }
         * ```
         * ```html
         * <igx-grid [columnHiding]="true" [showToolbar]="true" (onColumnMovingStart)="movingStart($event)"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */
        _this.onColumnMovingStart = new EventEmitter();
        /**
         * Emitted throughout the `IgxColumnComponent` moving operation.
         * Returns the source and target `IgxColumnComponent` objects. This event is cancelable.
         * ```typescript
         * moving(event: IColumnMovingEventArgs){
         *     const moving = event;
         * }
         * ```
         * ```html
         * <igx-grid [columnHiding]="true" [showToolbar]="true" (onColumnMoving)="moving($event)"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */
        _this.onColumnMoving = new EventEmitter();
        /**
         * Emitted when `IgxColumnComponent` moving ends.
         * Returns the source and target `IgxColumnComponent` objects.
         * ```typescript
         * movingEnds(event: IColumnMovingEndEventArgs){
         *     const movingEnds = event;
         * }
         * ```
         * ```html
         * <igx-grid [columnHiding]="true" [showToolbar]="true" (onColumnMovingEnd)="movingEnds($event)"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         */
        _this.onColumnMovingEnd = new EventEmitter();
        /**
         * @deprecated you should use onGridKeydown event
         */
        _this.onFocusChange = new EventEmitter();
        /**
         * Emitted when keydown is triggered over element inside grid's body.
         * This event is fired only if the key combination is supported in the grid.
         * Return the target type, target object and the original event. This event is cancelable.
         * ```typescript
         * customKeydown(args: IGridKeydownEventArgs) {
         *  const keydownEvent = args.event;
         * }
         * ```
         * ```html
         *  <igx-grid (onGridKeydown)="customKeydown($event)"></igx-grid>
         * ```
         */
        _this.onGridKeydown = new EventEmitter();
        /**
         * Emitted when start dragging a row.
         * Return the dragged row.
         */
        _this.onRowDragStart = new EventEmitter();
        /**
         * Emitted when dropping a row.
         * Return the dropped row.
         */
        _this.onRowDragEnd = new EventEmitter();
        /**
         * @hidden
         */
        _this.tabindex = 0;
        /**
         * @hidden
         */
        _this.hostRole = 'grid';
        /**
         * @hidden
         */
        _this.columnsWithNoSetWidths = null;
        /* Toolbar related definitions */
        _this._showToolbar = false;
        _this._exportExcel = false;
        _this._exportCsv = false;
        _this._toolbarTitle = null;
        _this._exportText = null;
        _this._exportExcelText = null;
        _this._exportCsvText = null;
        _this._rowEditable = false;
        _this._filteredSortedData = null;
        /**
         * Provides access to the `IgxToolbarComponent`.
         * ```typescript
         * const gridToolbar = this.grid.toolbar;
         * ```
         * \@memberof IgxGridBaseComponent
         */
        _this.toolbar = null;
        _this.toolbarHtml = null;
        /**
         * Emitted when an export process is initiated by the user.
         * ```typescript
         * toolbarExporting(event: IGridToolbarExportEventArgs){
         *     const toolbarExporting = event;
         * }
         * ```
         * \@memberof IgxGridBaseComponent
         */
        _this.onToolbarExporting = new EventEmitter();
        /* End of toolbar related definitions */
        // TODO: Document
        _this.onRangeSelection = new EventEmitter();
        /**
         * @hidden
         */
        _this.calcHeight = 0;
        /**
         * @hidden
         */
        _this.chipsGoupingExpressions = [];
        /**
         * @hidden
         */
        _this.allRowsSelected = false;
        /**
         * @hidden
         */
        _this.disableTransitions = false;
        /**
         * @hidden
         */
        _this.lastSearchInfo = {
            searchText: '',
            caseSensitive: false,
            exactMatch: false,
            activeMatchIndex: 0,
            matchInfoCache: []
        };
        /**
         * @hidden
         */
        _this.columnWidthSetByUser = false;
        // abstract dataLength;
        /**
         * @hidden
         */
        _this.destroy$ = new Subject();
        /**
         * @hidden
         */
        _this._perPage = 15;
        /**
         * @hidden
         */
        _this._page = 0;
        /**
         * @hidden
         */
        _this._paging = false;
        /**
         * @hidden
         */
        _this._rowSelection = false;
        /**
         * @hidden
         */
        _this._rowDrag = false;
        /**
         * @hidden
         */
        _this._pipeTrigger = 0;
        /**
         * @hidden
         */
        _this._summaryPipeTrigger = 0;
        /**
         * @hidden
         */
        _this._columns = [];
        /**
         * @hidden
         */
        _this._pinnedColumns = [];
        /**
         * @hidden
         */
        _this._unpinnedColumns = [];
        /**
         * @hidden
         */
        _this._filteringExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And);
        /**
         * @hidden
         */
        _this._sortingExpressions = [];
        /**
         * @hidden
         */
        _this._maxLevelHeaderDepth = null;
        /**
         * @hidden
         */
        _this._columnHiding = false;
        /**
         * @hidden
         */
        _this._columnPinning = false;
        /**
         * @hidden
         */
        _this._keydownListener = null;
        /**
         * @hidden
         */
        _this._vScrollListener = null;
        /**
         * @hidden
         */
        _this._hScrollListener = null;
        /**
         * @hidden
         */
        _this._wheelListener = null;
        _this._allowFiltering = false;
        _this._filterMode = FilterMode.quickFilter;
        _this._hiddenColumnsText = '';
        _this._pinnedColumnsText = '';
        _this._height = '100%';
        _this._width = '100%';
        _this._ngAfterViewInitPassed = false;
        _this._multiRowLayoutRowSize = 1;
        // Caches
        _this._totalWidth = NaN;
        _this._pinnedVisible = [];
        _this._unpinnedVisible = [];
        _this._pinnedWidth = NaN;
        _this._unpinnedWidth = NaN;
        _this._visibleColumns = [];
        _this._columnGroups = false;
        _this._defaultTargetRecordNumber = 10;
        _this._summaryPosition = GridSummaryPosition.bottom;
        _this._summaryCalculationMode = GridSummaryCalculationMode.rootAndChildLevels;
        _this.rowEditPositioningStrategy = new ContainerPositioningStrategy({
            horizontalDirection: HorizontalAlignment.Right,
            verticalDirection: VerticalAlignment.Bottom,
            horizontalStartPoint: HorizontalAlignment.Left,
            verticalStartPoint: VerticalAlignment.Bottom,
            closeAnimation: null
        });
        _this.rowEditSettings = {
            scrollStrategy: new AbsoluteScrollStrategy(),
            modal: false,
            closeOnOutsideClick: false,
            outlet: _this.rowOutletDirective,
            positionStrategy: _this.rowEditPositioningStrategy
        };
        _this.resizeHandler = function () {
            _this.zone.run(function () { return _this.calculateGridSizes(); });
        };
        return _this;
    }
    Object.defineProperty(IgxGridBaseComponent.prototype, "scrollWidth", {
        get: /**
         * @return {?}
         */
        function () {
            return this._scrollWidth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "resourceStrings", {
        /**
         * An accessor that returns the resource strings.
        */
        get: /**
         * An accessor that returns the resource strings.
         * @return {?}
         */
        function () {
            return this._resourceStrings;
        },
        /**
         * An accessor that sets the resource strings.
         * By default it uses EN resources.
        */
        set: /**
         * An accessor that sets the resource strings.
         * By default it uses EN resources.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._resourceStrings = Object.assign({}, this._resourceStrings, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "filteringLogic", {
        get: /**
         * @return {?}
         */
        function () {
            return this._filteringExpressionsTree.operator;
        },
        /**
         * Sets the filtering logic of the `IgxGridComponent`.
         * The default is AND.
         * ```html
         * <igx-grid [data]="Data" [autoGenerate]="true" [filteringLogic]="filtering"></igx-grid>
         * ```
         * @memberof IgxGridBaseComponent
         */
        set: /**
         * Sets the filtering logic of the `IgxGridComponent`.
         * The default is AND.
         * ```html
         * <igx-grid [data]="Data" [autoGenerate]="true" [filteringLogic]="filtering"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._filteringExpressionsTree.operator = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "filteringExpressionsTree", {
        /**
         * Returns the filtering state of `IgxGridComponent`.
         * ```typescript
         * let filteringExpressionsTree = this.grid.filteringExpressionsTree;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns the filtering state of `IgxGridComponent`.
         * ```typescript
         * let filteringExpressionsTree = this.grid.filteringExpressionsTree;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this._filteringExpressionsTree;
        },
        /**
         * Sets the filtering state of the `IgxGridComponent`.
         * ```typescript
         * const logic = new FilteringExpressionsTree(FilteringLogic.And, "ID");
         * logic.filteringOperands = [
         *     {
         *          condition: IgxNumberFilteringOperand.instance().condition('greaterThan'),
         *          fieldName: 'ID',
         *          searchVal: 1
         *     }
         * ];
         * this.grid.filteringExpressionsTree = (logic);
         * ```
         * @memberof IgxGridBaseComponent
         */
        set: /**
         * Sets the filtering state of the `IgxGridComponent`.
         * ```typescript
         * const logic = new FilteringExpressionsTree(FilteringLogic.And, "ID");
         * logic.filteringOperands = [
         *     {
         *          condition: IgxNumberFilteringOperand.instance().condition('greaterThan'),
         *          fieldName: 'ID',
         *          searchVal: 1
         *     }
         * ];
         * this.grid.filteringExpressionsTree = (logic);
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value && value instanceof FilteringExpressionsTree) {
                /** @type {?} */
                var val = ((/** @type {?} */ (value)));
                for (var index = 0; index < val.filteringOperands.length; index++) {
                    if (!(val.filteringOperands[index] instanceof FilteringExpressionsTree)) {
                        /** @type {?} */
                        var newExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And, val.filteringOperands[index].fieldName);
                        newExpressionsTree.filteringOperands.push((/** @type {?} */ (val.filteringOperands[index])));
                        val.filteringOperands[index] = newExpressionsTree;
                    }
                }
                // clone the filtering expression tree in order to trigger the filtering pipe
                /** @type {?} */
                var filteringExpressionTreeClone = new FilteringExpressionsTree(value.operator, value.fieldName);
                filteringExpressionTreeClone.filteringOperands = value.filteringOperands;
                this._filteringExpressionsTree = filteringExpressionTreeClone;
                if (this.filteringService.isFilteringExpressionsTreeEmpty()) {
                    this.filteredData = null;
                }
                this.filteringService.refreshExpressions();
                this.summaryService.clearSummaryCache();
                this.markForCheck();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "locale", {
        /**
         * Returns the locale of the grid.
         * If not set, returns browser's language.
         */
        get: /**
         * Returns the locale of the grid.
         * If not set, returns browser's language.
         * @return {?}
         */
        function () {
            if (this._locale) {
                return this._locale;
            }
            else {
                return 'en';
            }
        },
        /**
         * Sets the locale of the grid.
         */
        set: /**
         * Sets the locale of the grid.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._locale = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "paging", {
        /**
         * Returns whether the paging feature is enabled/disabled.
         * The default state is disabled (false).
         * ```
         * const paging = this.grid.paging;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns whether the paging feature is enabled/disabled.
         * The default state is disabled (false).
         * ```
         * const paging = this.grid.paging;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this._paging;
        },
        /**
         * Enables/Disables the paging feature.
         * ```html
         * <igx-grid #grid [data]="Data" [autoGenerate]="true" [paging]="true"></igx-grid>
         * ```
         * @memberof IgxGridBaseComponent
         */
        set: /**
         * Enables/Disables the paging feature.
         * ```html
         * <igx-grid #grid [data]="Data" [autoGenerate]="true" [paging]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._paging = value;
            this._pipeTrigger++;
            if (this._ngAfterViewInitPassed) {
                this.cdr.detectChanges();
                this.calculateGridHeight();
                this.cdr.detectChanges();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "page", {
        /**
         * Returns the current page index.
         * ```html
         * let gridPage = this.grid.page;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns the current page index.
         * ```html
         * let gridPage = this.grid.page;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this._page;
        },
        /**
         * Sets the current page index.
         * <igx-grid #grid [data]="Data" [paging]="true" [page]="5" [autoGenerate]="true"></igx-grid>
         */
        set: /**
         * Sets the current page index.
         * <igx-grid #grid [data]="Data" [paging]="true" [page]="5" [autoGenerate]="true"></igx-grid>
         * @param {?} val
         * @return {?}
         */
        function (val) {
            if (val === this._page || val < 0 || val > this.totalPages - 1) {
                return;
            }
            this.onPagingDone.emit({ previous: this._page, current: val });
            this._page = val;
            this.cdr.markForCheck();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "perPage", {
        /**
         * Returns the number of visible items per page of the `IgxGridComponent`.
         * The default is 15.
         * ```html
         * let itemsPerPage = this.grid.perPage;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns the number of visible items per page of the `IgxGridComponent`.
         * The default is 15.
         * ```html
         * let itemsPerPage = this.grid.perPage;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this._perPage;
        },
        /**
         * Sets the number of visible items per page of the `IgxGridComponent`.
         * ```html
         * <igx-grid #grid [data]="Data" [paging]="true" [perPage]="5" [autoGenerate]="true"></igx-grid>
         * ```
         * @memberof IgxGridBaseComponent
         */
        set: /**
         * Sets the number of visible items per page of the `IgxGridComponent`.
         * ```html
         * <igx-grid #grid [data]="Data" [paging]="true" [perPage]="5" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} val
         * @return {?}
         */
        function (val) {
            if (val < 0) {
                return;
            }
            this.selectionService.clear();
            this._perPage = val;
            this.page = 0;
            this.endEdit(true);
            this.cdr.markForCheck();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "columnHiding", {
        /**
         * Returns whether the column hiding UI for the `IgxGridComponent` is enabled.
         * By default it is disabled (false).
         * ```typescript
         * let gridColHiding = this.grid.columnHiding;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns whether the column hiding UI for the `IgxGridComponent` is enabled.
         * By default it is disabled (false).
         * ```typescript
         * let gridColHiding = this.grid.columnHiding;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this._columnHiding;
        },
        /**
         * Sets whether the column hiding UI for the `IgxGridComponent` is enabled.
         * In order for the UI to work, you need to enable the toolbar as shown in the example below.
         * ```html
         * <igx-grid [data]="Data" [autoGenerate]="true" [showToolbar]="true" [columnHiding]="true"></igx-grid>
         * ```
         * @memberof IgxGridBaseComponent
         */
        set: /**
         * Sets whether the column hiding UI for the `IgxGridComponent` is enabled.
         * In order for the UI to work, you need to enable the toolbar as shown in the example below.
         * ```html
         * <igx-grid [data]="Data" [autoGenerate]="true" [showToolbar]="true" [columnHiding]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._columnHiding !== value) {
                this._columnHiding = value;
                if (this.gridAPI.grid) {
                    this.markForCheck();
                    if (this._ngAfterViewInitPassed) {
                        this.calculateGridSizes();
                    }
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "rowSelectable", {
        /**
         * Sets whether the `IgxGridRowComponent` selection is enabled.
         * By default it is set to false.
         * ```typescript
         * let rowSelectable = this.grid.rowSelectable;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Sets whether the `IgxGridRowComponent` selection is enabled.
         * By default it is set to false.
         * ```typescript
         * let rowSelectable = this.grid.rowSelectable;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this._rowSelection;
        },
        /**
         * Sets whether rows can be selected.
         * ```html
         * <igx-grid #grid [showToolbar]="true" [rowSelectable]="true" [columnHiding]="true"></igx-grid>
         * ```
         * @memberof IgxGridBaseComponent
         */
        set: /**
         * Sets whether rows can be selected.
         * ```html
         * <igx-grid #grid [showToolbar]="true" [rowSelectable]="true" [columnHiding]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._rowSelection = val;
            if (this.gridAPI.grid && this.columnList) {
                // should selection persist?
                this.allRowsSelected = false;
                this.deselectAllRows();
                this.calculateGridSizes();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "rowDraggable", {
        get: /**
         * @return {?}
         */
        function () {
            return this._rowDrag;
        },
        /**
         * Sets whether rows can be moved.
         * ```html
         * <igx-grid #grid [rowDraggable]="true"></igx-grid>
         * ```
         * @memberof IgxGridBaseComponent
         */
        set: /**
         * Sets whether rows can be moved.
         * ```html
         * <igx-grid #grid [rowDraggable]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._rowDrag = val;
            if (this.gridAPI.grid && this.columnList) {
                this.calculateGridSizes();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "rowEditable", {
        /**
     * Sets whether the `IgxGridRowComponent` is editable.
     * By default it is set to false.
     * ```typescript
     * let rowEditable = this.grid.rowEditable;
     * ```
     * @memberof IgxGridBaseComponent
     */
        get: /**
         * Sets whether the `IgxGridRowComponent` is editable.
         * By default it is set to false.
         * ```typescript
         * let rowEditable = this.grid.rowEditable;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this._rowEditable;
        },
        /**
        * Sets whether rows can be edited.
        * ```html
        * <igx-grid #grid [showToolbar]="true" [rowEditable]="true" [primaryKey]="'ProductID'" [columnHiding]="true"></igx-grid>
        * ```
        * @memberof IgxGridBaseComponent
        */
        set: /**
         * Sets whether rows can be edited.
         * ```html
         * <igx-grid #grid [showToolbar]="true" [rowEditable]="true" [primaryKey]="'ProductID'" [columnHiding]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} val
         * @return {?}
         */
        function (val) {
            if (val && (this.primaryKey === undefined || this.primaryKey === null)) {
                console.warn('The grid must have a `primaryKey` specified when using `rowEditable`!');
            }
            this._rowEditable = val;
            if (this.gridAPI.grid) {
                this.refreshGridState();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "height", {
        /**
         * Returns the height of the `IgxGridComponent`.
         * ```typescript
         * let gridHeight = this.grid.height;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns the height of the `IgxGridComponent`.
         * ```typescript
         * let gridHeight = this.grid.height;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this._height;
        },
        /**
         * Sets the height of the `IgxGridComponent`.
         * ```html
         * <igx-grid #grid [data]="Data" [height]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         * @memberof IgxGridBaseComponent
         */
        set: /**
         * Sets the height of the `IgxGridComponent`.
         * ```html
         * <igx-grid #grid [data]="Data" [height]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var _this = this;
            if (this._height !== value) {
                this._height = value;
                requestAnimationFrame(function () {
                    if (!_this._destroyed) {
                        _this.reflow();
                        _this.cdr.markForCheck();
                    }
                });
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "width", {
        /**
         * Returns the width of the `IgxGridComponent`.
         * ```typescript
         * let gridWidth = this.grid.width;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns the width of the `IgxGridComponent`.
         * ```typescript
         * let gridWidth = this.grid.width;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this._width;
        },
        /**
         * Sets the width of the `IgxGridComponent`.
         * ```html
         * <igx-grid #grid [data]="Data" [width]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         * @memberof IgxGridBaseComponent
         */
        set: /**
         * Sets the width of the `IgxGridComponent`.
         * ```html
         * <igx-grid #grid [data]="Data" [width]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var _this = this;
            if (this._width !== value) {
                this._width = value;
                requestAnimationFrame(function () {
                    // Calling reflow(), because the width calculation
                    // might make the horizontal scrollbar appear/disappear.
                    // This will change the height, which should be recalculated.
                    if (!_this._destroyed) {
                        _this.reflow();
                    }
                });
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "headerWidth", {
        /**
         * Returns the width of the header of the `IgxGridComponent`.
         * ```html
         * let gridHeaderWidth = this.grid.headerWidth;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns the width of the header of the `IgxGridComponent`.
         * ```html
         * let gridHeaderWidth = this.grid.headerWidth;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return parseInt(this._width, 10) - 17;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "rowHeight", {
        /**
         * Returns the row height.
         * ```typescript
         * const rowHeight = this.grid.rowHeight;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns the row height.
         * ```typescript
         * const rowHeight = this.grid.rowHeight;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this._rowHeight ? this._rowHeight : this.defaultRowHeight;
        },
        /**
         * Sets the row height.
         * ```html
         * <igx-grid #grid [data]="localData" [showToolbar]="true" [rowHeight]="100" [autoGenerate]="true"></igx-grid>
         * ```
         * @memberof IgxGridBaseComponent
         */
        set: /**
         * Sets the row height.
         * ```html
         * <igx-grid #grid [data]="localData" [showToolbar]="true" [rowHeight]="100" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._rowHeight = parseInt(value, 10);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "columnWidth", {
        /**
         * An @Input property that sets the default width of the `IgxGridComponent`'s columns.
         * ```html
         * <igx-grid #grid [data]="localData" [showToolbar]="true" [columnWidth]="100" [autoGenerate]="true"></igx-grid>
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * An \@Input property that sets the default width of the `IgxGridComponent`'s columns.
         * ```html
         * <igx-grid #grid [data]="localData" [showToolbar]="true" [columnWidth]="100" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this._columnWidth;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._columnWidth = value;
            this.columnWidthSetByUser = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "emptyGridMessage", {
        /**
         * An accessor that returns the message displayed when there are no records.
        */
        get: /**
         * An accessor that returns the message displayed when there are no records.
         * @return {?}
         */
        function () {
            return this._emptyGridMessage || this.resourceStrings.igx_grid_emptyGrid_message;
        },
        /**
         * An @Input property that sets the message displayed when there are no records.
         * ```html
         * <igx-grid #grid [data]="Data" [emptyGridMessage]="'The grid is empty'" [autoGenerate]="true"></igx-grid>
         * ```
         * @memberof IgxGridBaseComponent
         */
        set: /**
         * An \@Input property that sets the message displayed when there are no records.
         * ```html
         * <igx-grid #grid [data]="Data" [emptyGridMessage]="'The grid is empty'" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._emptyGridMessage = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "isLoading", {
        /**
         * An accessor that returns whether the grid is showing loading indicator.
         */
        get: /**
         * An accessor that returns whether the grid is showing loading indicator.
         * @return {?}
         */
        function () {
            return this._isLoading;
        },
        /**
         * An @Input property that sets whether the grid is going to show loading indicator.
         * ```html
         * <igx-grid #grid [data]="Data" [isLoading]="true" [autoGenerate]="true"></igx-grid>
         * ```
         * @memberof IgxGridBaseComponent
         */
        set: /**
         * An \@Input property that sets whether the grid is going to show loading indicator.
         * ```html
         * <igx-grid #grid [data]="Data" [isLoading]="true" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._isLoading = value;
            if (this.gridAPI.grid) {
                this.markForCheck();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "emptyFilteredGridMessage", {
        /**
         * An accessor that returns the message displayed when there are no records and the grid is filtered.
        */
        get: /**
         * An accessor that returns the message displayed when there are no records and the grid is filtered.
         * @return {?}
         */
        function () {
            return this._emptyFilteredGridMessage || this.resourceStrings.igx_grid_emptyFilteredGrid_message;
        },
        /**
         * An @Input property that sets the message displayed when there are no records and the grid is filtered.
         * ```html
         * <igx-grid #grid [data]="Data" [emptyGridMessage]="'The grid is empty'" [autoGenerate]="true"></igx-grid>
         * ```
         * @memberof IgxGridBaseComponent
         */
        set: /**
         * An \@Input property that sets the message displayed when there are no records and the grid is filtered.
         * ```html
         * <igx-grid #grid [data]="Data" [emptyGridMessage]="'The grid is empty'" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._emptyFilteredGridMessage = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "columnPinning", {
        /**
         * Returns if the built-in column pinning UI should be shown in the toolbar.
         * ```typescript
         *  let colPinning = this.grid.columnPinning;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns if the built-in column pinning UI should be shown in the toolbar.
         * ```typescript
         *  let colPinning = this.grid.columnPinning;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this._columnPinning;
        },
        /**
         * Sets if the built-in column pinning UI should be shown in the toolbar.
         * By default it's disabled.
         * ```html
         * <igx-grid #grid [data]="localData" [columnPinning]="'true" [height]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         * @memberof IgxGridBaseComponent
         */
        set: /**
         * Sets if the built-in column pinning UI should be shown in the toolbar.
         * By default it's disabled.
         * ```html
         * <igx-grid #grid [data]="localData" [columnPinning]="'true" [height]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._columnPinning !== value) {
                this._columnPinning = value;
                if (this.gridAPI.grid) {
                    this.markForCheck();
                    if (this._ngAfterViewInitPassed) {
                        this.calculateGridSizes();
                    }
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "allowFiltering", {
        /**
         * Returns if the filtering is enabled.
         * ```typescript
         *  let filtering = this.grid.allowFiltering;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns if the filtering is enabled.
         * ```typescript
         *  let filtering = this.grid.allowFiltering;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this._allowFiltering;
        },
        /**
         * Sets if the filtering is enabled.
         * By default it's disabled.
         * ```html
         * <igx-grid #grid [data]="localData" [allowFiltering]="'true" [height]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         * @memberof IgxGridBaseComponent
         */
        set: /**
         * Sets if the filtering is enabled.
         * By default it's disabled.
         * ```html
         * <igx-grid #grid [data]="localData" [allowFiltering]="'true" [height]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._allowFiltering !== value) {
                this._allowFiltering = value;
                if (this.calcHeight) {
                    this.calcHeight += value ? -FILTER_ROW_HEIGHT : FILTER_ROW_HEIGHT;
                }
                if (this._ngAfterViewInitPassed) {
                    if (this.maxLevelHeaderDepth) {
                        this.theadRow.nativeElement.style.height = (this.maxLevelHeaderDepth + 1) * this.defaultRowHeight +
                            (value && this.filterMode === FilterMode.quickFilter ? FILTER_ROW_HEIGHT : 0) + 1 + "px";
                    }
                }
                this.filteringService.isFilterRowVisible = false;
                this.filteringService.filteredColumn = null;
                this.filteringService.registerSVGIcons();
                if (this.gridAPI.grid) {
                    this.markForCheck();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "filterMode", {
        /**
         * Returns the filter mode.
         * ```typescript
         *  let filtering = this.grid.filterMode;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns the filter mode.
         * ```typescript
         *  let filtering = this.grid.filterMode;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this._filterMode;
        },
        /**
         * Sets filter mode.
         * By default it's set to FilterMode.quickFilter.
         * ```html
         * <igx-grid #grid [data]="localData" [filterMode]="'quickFilter'" [height]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         * @memberof IgxGridBaseComponent
         */
        set: /**
         * Sets filter mode.
         * By default it's set to FilterMode.quickFilter.
         * ```html
         * <igx-grid #grid [data]="localData" [filterMode]="'quickFilter'" [height]="'305px'" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._filterMode = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "summaryPosition", {
        /**
         * Returns the summary position.
         * ```typescript
         *  let summaryPosition = this.grid.summaryPosition;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns the summary position.
         * ```typescript
         *  let summaryPosition = this.grid.summaryPosition;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this._summaryPosition;
        },
        /**
         * Sets summary position.
         * By default it is bottom.
         * ```html
         * <igx-grid #grid [data]="localData" summaryPosition="top" [autoGenerate]="true"></igx-grid>
         * ```
         * @memberof IgxGridBaseComponent
         */
        set: /**
         * Sets summary position.
         * By default it is bottom.
         * ```html
         * <igx-grid #grid [data]="localData" summaryPosition="top" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._summaryPosition = value;
            if (this.gridAPI.grid) {
                this.markForCheck();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "summaryCalculationMode", {
        /**
         * Returns the summary calculation mode.
         * ```typescript
         *  let summaryCalculationMode = this.grid.summaryCalculationMode;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns the summary calculation mode.
         * ```typescript
         *  let summaryCalculationMode = this.grid.summaryCalculationMode;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this._summaryCalculationMode;
        },
        /**
         * Sets summary calculation mode.
         * By default it is rootAndChildLevels which means the summaries are calculated for the root level and each child level.
         * ```html
         * <igx-grid #grid [data]="localData" summaryCalculationMode="rootLevelOnly" [autoGenerate]="true"></igx-grid>
         * ```
         * @memberof IgxGridBaseComponent
         */
        set: /**
         * Sets summary calculation mode.
         * By default it is rootAndChildLevels which means the summaries are calculated for the root level and each child level.
         * ```html
         * <igx-grid #grid [data]="localData" summaryCalculationMode="rootLevelOnly" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._summaryCalculationMode = value;
            if (this.gridAPI.grid) {
                this.summaryService.resetSummaryHeight();
                this.endEdit(true);
                this.calculateGridHeight();
                this.cdr.markForCheck();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "headerGroupsList", {
        /**
         * A list of all `IgxGridHeaderGroupComponent`.
         * ```typescript
         * const headerGroupsList = this.grid.headerGroupsList;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * A list of all `IgxGridHeaderGroupComponent`.
         * ```typescript
         * const headerGroupsList = this.grid.headerGroupsList;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this.headerGroups ? flatten(this.headerGroups.toArray()) : [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "headerCellList", {
        /**
         * A list of all `IgxGridHeaderComponent`.
         * ```typescript
         * const headers = this.grid.headerCellList;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * A list of all `IgxGridHeaderComponent`.
         * ```typescript
         * const headers = this.grid.headerCellList;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this.headerGroupsList.map(function (headerGroup) { return headerGroup.headerCell; }).filter(function (headerCell) { return headerCell; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "filterCellList", {
        /**
         * A list of all `IgxGridFilteringCellComponent`.
         * ```typescript
         * const filterCells = this.grid.filterCellList;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * A list of all `IgxGridFilteringCellComponent`.
         * ```typescript
         * const filterCells = this.grid.filterCellList;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this.headerGroupsList.map(function (headerGroup) { return headerGroup.filterCell; }).filter(function (filterCell) { return filterCell; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "summariesRowList", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var res = new QueryList();
            if (!this._summaryRowList) {
                return res;
            }
            /** @type {?} */
            var sumList = this._summaryRowList.filter(function (item) {
                return item.element.nativeElement.parentElement !== null;
            });
            res.reset(sumList);
            return res;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "rowList", {
        /**
         * A list of `IgxGridRowComponent`.
         * ```typescript
         * const rowList = this.grid.rowList;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * A list of `IgxGridRowComponent`.
         * ```typescript
         * const rowList = this.grid.rowList;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            /** @type {?} */
            var res = new QueryList();
            if (!this._rowList) {
                return res;
            }
            /** @type {?} */
            var rList = this._rowList
                .filter(function (item) {
                return item.element.nativeElement.parentElement !== null;
            })
                .sort(function (a, b) {
                return a.index - b.index;
            });
            res.reset(rList);
            return res;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "dataRowList", {
        /**
         * A list of `IgxGridRowComponent`, currently rendered.
         * ```typescript
         * const dataList = this.grid.dataRowList;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * A list of `IgxGridRowComponent`, currently rendered.
         * ```typescript
         * const dataList = this.grid.dataRowList;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            /** @type {?} */
            var res = new QueryList();
            if (!this._dataRowList) {
                return res;
            }
            /** @type {?} */
            var rList = this._dataRowList.filter(function (item) {
                return item.element.nativeElement.parentElement !== null;
            }).sort(function (a, b) {
                return a.index - b.index;
            });
            res.reset(rList);
            return res;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "toolbarCustomContentTemplate", {
        /**
         * Returns the template which will be used by the toolbar to show custom content.
         * ```typescript
         * let customContentTemplate = this.grid.toolbarCustomContentTemplate;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns the template which will be used by the toolbar to show custom content.
         * ```typescript
         * let customContentTemplate = this.grid.toolbarCustomContentTemplate;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this.toolbarCustomContentTemplates.first;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "outletDirective", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._outletDirective;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "rowOutletDirective", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.rowEditingOutletDirective;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "parentRowOutletDirective", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "rowEditContainer", {
        /** @hidden */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.rowEditCustom ? this.rowEditCustom : this.defaultRowEditTemplate;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "rowInEditMode", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            /** @type {?} */
            var editRowState = this.crudService.row;
            return editRowState !== null ? this.rowList.find(function (e) { return e.rowID === editRowState.id; }) : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "firstEditableColumnIndex", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            /** @type {?} */
            var index = __spread(this.pinnedColumns, this.unpinnedColumns).filter(function (e) { return !e.columnGroup; }).findIndex(function (e) { return e.editable; });
            return index !== -1 ? index : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "lastEditableColumnIndex", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            /** @type {?} */
            var orderedColumns = __spread(this.pinnedColumns, this.unpinnedColumns).filter(function (e) { return !e.columnGroup; });
            /** @type {?} */
            var index = orderedColumns.reverse().findIndex(function (e) { return e.editable; });
            return index !== -1 ? orderedColumns.length - 1 - index : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "rowEditTabs", {
        /**
         * @hidden
         * TODO: Nav service logic doesn't handle 0 results from this querylist
         */
        get: /**
         * @hidden
         * TODO: Nav service logic doesn't handle 0 results from this querylist
         * @return {?}
         */
        function () {
            return this.rowEditTabsCUSTOM.length ? this.rowEditTabsCUSTOM : this.rowEditTabsDEFAULT;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "hostClass", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.getComponentDensityClass('igx-grid');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "bannerClass", {
        get: /**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var position = this.rowEditPositioningStrategy.isTop ? 'igx-banner__border-top' : 'igx-banner__border-bottom';
            return this.getComponentDensityClass('igx-banner') + " " + position;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "pipeTrigger", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._pipeTrigger;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "summaryPipeTrigger", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._summaryPipeTrigger;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "sortingExpressions", {
        /**
         * Returns the sorting state of the `IgxGridComponent`.
         * ```typescript
         * const sortingState = this.grid.sortingExpressions;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns the sorting state of the `IgxGridComponent`.
         * ```typescript
         * const sortingState = this.grid.sortingExpressions;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this._sortingExpressions;
        },
        /**
         * Sets the sorting state of the `IgxGridComponent`.
         * ```typescript
         * this.grid.sortingExpressions = [{
         *     fieldName: "ID",
         *     dir: SortingDirection.Desc,
         *     ignoreCase: true
         * }];
         * ```
         * @memberof IgxGridBaseComponent
         */
        set: /**
         * Sets the sorting state of the `IgxGridComponent`.
         * ```typescript
         * this.grid.sortingExpressions = [{
         *     fieldName: "ID",
         *     dir: SortingDirection.Desc,
         *     ignoreCase: true
         * }];
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._sortingExpressions = cloneArray(value);
            this.cdr.markForCheck();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "virtualizationState", {
        /**
         * Returns the state of the grid virtualization, including the start index and how many records are rendered.
         * ```typescript
         * const gridVirtState = this.grid1.virtualizationState;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns the state of the grid virtualization, including the start index and how many records are rendered.
         * ```typescript
         * const gridVirtState = this.grid1.virtualizationState;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this.verticalScrollContainer.state;
        },
        /**
         * @hidden
         */
        set: /**
         * @hidden
         * @param {?} state
         * @return {?}
         */
        function (state$$1) {
            this.verticalScrollContainer.state = state$$1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "totalItemCount", {
        /**
         * Returns the total number of records in the data source.
         * Works only with remote grid virtualization.
         * ```typescript
         * const itemCount = this.grid1.totalItemCount;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns the total number of records in the data source.
         * Works only with remote grid virtualization.
         * ```typescript
         * const itemCount = this.grid1.totalItemCount;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this.verticalScrollContainer.totalItemCount;
        },
        /**
         * Sets the total number of records in the data source.
         * This property is required for virtualization to function when the grid is bound remotely.
         * ```typescript
         * this.grid1.totalItemCount = 55;
         * ```
         * @memberof IgxGridBaseComponent
         */
        set: /**
         * Sets the total number of records in the data source.
         * This property is required for virtualization to function when the grid is bound remotely.
         * ```typescript
         * this.grid1.totalItemCount = 55;
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} count
         * @return {?}
         */
        function (count) {
            this.verticalScrollContainer.totalItemCount = count;
            this.cdr.detectChanges();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "maxLevelHeaderDepth", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            if (this._maxLevelHeaderDepth === null) {
                this._maxLevelHeaderDepth = this.hasColumnLayouts ?
                    this.columnList.reduce(function (acc, col) { return Math.max(acc, col.rowStart); }, 0) :
                    this.columnList.reduce(function (acc, col) { return Math.max(acc, col.level); }, 0);
            }
            return this._maxLevelHeaderDepth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "hiddenColumnsCount", {
        /**
         * Returns the number of hidden `IgxColumnComponent`.
         * ```typescript
         * const hiddenCol = this.grid.hiddenColumnsCount;
         * ``
         */
        get: /**
         * Returns the number of hidden `IgxColumnComponent`.
         * ```typescript
         * const hiddenCol = this.grid.hiddenColumnsCount;
         * ``
         * @return {?}
         */
        function () {
            return this.columnList.filter(function (col) { return col.columnGroup === false && col.hidden === true; }).length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "hiddenColumnsText", {
        /**
         * Returns the text to be displayed inside the toggle button
         * for the built-in column hiding UI of the`IgxColumnComponent`.
         * ```typescript
         * const hiddenColText = this.grid.hiddenColumnsText;
         * ``
         */
        get: /**
         * Returns the text to be displayed inside the toggle button
         * for the built-in column hiding UI of the`IgxColumnComponent`.
         * ```typescript
         * const hiddenColText = this.grid.hiddenColumnsText;
         * ``
         * @return {?}
         */
        function () {
            return this._hiddenColumnsText;
        },
        /**
         * Sets the text to be displayed inside the toggle button
         * for the built-in column hiding UI of the`IgxColumnComponent`.
         * ```typescript
         * <igx-grid [columnHiding]="true" [showToolbar]="true" [hiddenColumnsText]="'Hidden Columns'"></igx-grid>
         * ```
         * @memberof IgxGridBaseComponent
         */
        set: /**
         * Sets the text to be displayed inside the toggle button
         * for the built-in column hiding UI of the`IgxColumnComponent`.
         * ```typescript
         * <igx-grid [columnHiding]="true" [showToolbar]="true" [hiddenColumnsText]="'Hidden Columns'"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._hiddenColumnsText = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "pinnedColumnsText", {
        /**
         * Returns the text to be displayed inside the toggle button
         * for the built-in column pinning UI of the`IgxColumnComponent`.
         * ```typescript
         * const pinnedText = this.grid.pinnedColumnsText;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns the text to be displayed inside the toggle button
         * for the built-in column pinning UI of the`IgxColumnComponent`.
         * ```typescript
         * const pinnedText = this.grid.pinnedColumnsText;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this._pinnedColumnsText;
        },
        /**
         * Sets the text to be displayed inside the toggle button
         * for the built-in column pinning UI of the`IgxColumnComponent`.
         * ```html
         * <igx-grid [pinnedColumnsText]="'PinnedCols Text" [data]="data" [width]="'100%'" [height]="'500px'"></igx-grid>
         * ```
         * @memberof IgxGridBaseComponent
         */
        set: /**
         * Sets the text to be displayed inside the toggle button
         * for the built-in column pinning UI of the`IgxColumnComponent`.
         * ```html
         * <igx-grid [pinnedColumnsText]="'PinnedCols Text" [data]="data" [width]="'100%'" [height]="'500px'"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._pinnedColumnsText = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "transactions", {
        /**
         * Get transactions service for the grid.
         */
        get: /**
         * Get transactions service for the grid.
         * @return {?}
         */
        function () {
            return this._transactions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "currentRowState", {
        /**
         * @hidden
        */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._currentRowState;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "showToolbar", {
        /**
         * Returns whether the `IgxGridComponent`'s toolbar is shown or hidden.
         * ```typescript
         * const toolbarGrid = this.grid.showToolbar;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns whether the `IgxGridComponent`'s toolbar is shown or hidden.
         * ```typescript
         * const toolbarGrid = this.grid.showToolbar;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this._showToolbar;
        },
        /**
         * Shows or hides the `IgxGridComponent`'s toolbar.
         * ```html
         * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" ></igx-grid>
         * ```
         * @memberof IgxGridBaseComponent
         */
        set: /**
         * Shows or hides the `IgxGridComponent`'s toolbar.
         * ```html
         * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" ></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} newValue
         * @return {?}
         */
        function (newValue) {
            if (this._showToolbar !== newValue) {
                this._showToolbar = newValue;
                this.cdr.markForCheck();
                if (this._ngAfterViewInitPassed) {
                    this.calculateGridSizes();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "toolbarTitle", {
        /**
         * Returns the toolbar's title.
         * ```typescript
         * const toolbarTitle  = this.grid.toolbarTitle;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns the toolbar's title.
         * ```typescript
         * const toolbarTitle  = this.grid.toolbarTitle;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this._toolbarTitle;
        },
        /**
         * Sets the toolbar's title.
         * ```html
         * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" [toolbarTitle]="'My Grid'"></igx-grid>
         * ```
         * @memberof IgxGridBaseComponent
         */
        set: /**
         * Sets the toolbar's title.
         * ```html
         * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" [toolbarTitle]="'My Grid'"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} newValue
         * @return {?}
         */
        function (newValue) {
            if (this._toolbarTitle !== newValue) {
                this._toolbarTitle = newValue;
                this.cdr.markForCheck();
                if (this._ngAfterViewInitPassed) {
                    this.calculateGridSizes();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "exportExcel", {
        /**
         * Returns whether the option for exporting to MS Excel is enabled or disabled.
         * ```typescript
         * cosnt excelExporter = this.grid.exportExcel;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns whether the option for exporting to MS Excel is enabled or disabled.
         * ```typescript
         * cosnt excelExporter = this.grid.exportExcel;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this.getExportExcel();
        },
        /**
         * Enable or disable the option for exporting to MS Excel.
         * ```html
         * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" [exportExcel]="true"></igx-grid>
         * ```
         * @memberof IgxGridBaseComponent
         */
        set: /**
         * Enable or disable the option for exporting to MS Excel.
         * ```html
         * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" [exportExcel]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} newValue
         * @return {?}
         */
        function (newValue) {
            if (this._exportExcel !== newValue) {
                this._exportExcel = newValue;
                this.cdr.markForCheck();
                if (this._ngAfterViewInitPassed) {
                    this.calculateGridSizes();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "exportCsv", {
        /**
         * Returns whether the option for exporting to CSV is enabled or disabled.
         * ```typescript
         * const exportCsv = this.grid.exportCsv;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns whether the option for exporting to CSV is enabled or disabled.
         * ```typescript
         * const exportCsv = this.grid.exportCsv;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this.getExportCsv();
        },
        /**
         * Enable or disable the option for exporting to CSV.
         * ```html
         * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" [exportCsv]="true"></igx-grid>
         * ```
         * @memberof IgxGridBaseComponent
         */
        set: /**
         * Enable or disable the option for exporting to CSV.
         * ```html
         * <igx-grid [data]="localData" [showToolbar]="true" [autoGenerate]="true" [exportCsv]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} newValue
         * @return {?}
         */
        function (newValue) {
            if (this._exportCsv !== newValue) {
                this._exportCsv = newValue;
                this.cdr.markForCheck();
                if (this._ngAfterViewInitPassed) {
                    this.calculateGridSizes();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "exportText", {
        /**
         * Returns the textual content for the main export button.
         * ```typescript
         * const exportText = this.grid.exportText;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns the textual content for the main export button.
         * ```typescript
         * const exportText = this.grid.exportText;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this._exportText;
        },
        /**
         * Sets the textual content for the main export button.
         * ```html
         * <igx-grid [data]="localData" [showToolbar]="true" [exportText]="'My Exporter'" [exportCsv]="true"></igx-grid>
         * ```
         * @memberof IgxGridBaseComponent
         */
        set: /**
         * Sets the textual content for the main export button.
         * ```html
         * <igx-grid [data]="localData" [showToolbar]="true" [exportText]="'My Exporter'" [exportCsv]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} newValue
         * @return {?}
         */
        function (newValue) {
            if (this._exportText !== newValue) {
                this._exportText = newValue;
                this.cdr.markForCheck();
                if (this._ngAfterViewInitPassed) {
                    this.calculateGridSizes();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "exportExcelText", {
        /**
         * Returns the textual content for the MS Excel export button.
         * ```typescript
         * const excelText = this.grid.exportExcelText;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns the textual content for the MS Excel export button.
         * ```typescript
         * const excelText = this.grid.exportExcelText;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this._exportExcelText;
        },
        /**
         * Sets the textual content for the MS Excel export button.
         * ```html
         * <igx-grid [exportExcelText]="'My Excel Exporter" [showToolbar]="true" [exportText]="'My Exporter'" [exportCsv]="true"></igx-grid>
         * ```
         * @memberof IgxGridBaseComponent
         */
        set: /**
         * Sets the textual content for the MS Excel export button.
         * ```html
         * <igx-grid [exportExcelText]="'My Excel Exporter" [showToolbar]="true" [exportText]="'My Exporter'" [exportCsv]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} newValue
         * @return {?}
         */
        function (newValue) {
            if (this._exportExcelText !== newValue) {
                this._exportExcelText = newValue;
                this.cdr.markForCheck();
                if (this._ngAfterViewInitPassed) {
                    this.calculateGridSizes();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "exportCsvText", {
        /**
         * Returns the textual content for the CSV export button.
         * ```typescript
         * const csvText = this.grid.exportCsvText;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns the textual content for the CSV export button.
         * ```typescript
         * const csvText = this.grid.exportCsvText;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this._exportCsvText;
        },
        /**
         * Sets the textual content for the CSV export button.
         * ```html
         * <igx-grid [exportCsvText]="'My Csv Exporter" [showToolbar]="true" [exportText]="'My Exporter'" [exportExcel]="true"></igx-grid>
         * ```
         * @memberof IgxGridBaseComponent
         */
        set: /**
         * Sets the textual content for the CSV export button.
         * ```html
         * <igx-grid [exportCsvText]="'My Csv Exporter" [showToolbar]="true" [exportText]="'My Exporter'" [exportExcel]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @param {?} newValue
         * @return {?}
         */
        function (newValue) {
            if (this._exportCsvText !== newValue) {
                this._exportCsvText = newValue;
                this.cdr.markForCheck();
                if (this._ngAfterViewInitPassed) {
                    this.calculateGridSizes();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    IgxGridBaseComponent.prototype.verticalScrollHandler = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        this.verticalScrollContainer.onScroll(event);
        if (isEdge()) {
            this.wheelHandler(false);
        }
        this.disableTransitions = true;
        this.zone.run(function () {
            _this.zone.onStable.pipe(first()).subscribe(function () {
                _this.verticalScrollContainer.onChunkLoad.emit(_this.verticalScrollContainer.state);
            });
            if (_this.rowEditable) {
                _this.changeRowEditingOverlayStateOnScroll(_this.rowInEditMode);
            }
            _this.disableTransitions = false;
        });
        this.hideOverlays();
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    IgxGridBaseComponent.prototype.horizontalScrollHandler = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        /** @type {?} */
        var scrollLeft = event.target.scrollLeft;
        if (isEdge()) {
            this.wheelHandler(true);
        }
        this.headerContainer.onHScroll(scrollLeft);
        this._horizontalForOfs.forEach(function (vfor) { return vfor.onHScroll(scrollLeft); });
        this.cdr.markForCheck();
        this.zone.run(function () {
            _this.zone.onStable.pipe(first()).subscribe(function () {
                _this.parentVirtDir.onChunkLoad.emit(_this.headerContainer.state);
            });
        });
        this.hideOverlays();
    };
    /**
    * @hidden
    * @internal
    */
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    IgxGridBaseComponent.prototype.hideOverlays = /**
     * @hidden
     * \@internal
     * @return {?}
     */
    function () {
        var _this = this;
        this.overlayIDs.forEach(function (overlayID) {
            _this.overlayService.hide(overlayID);
            _this.overlayService.onClosed.pipe(filter(function (o) { return o.id === overlayID; }), takeUntil(_this.destroy$)).subscribe(function () {
                _this.nativeElement.focus();
            });
        });
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    IgxGridBaseComponent.prototype.keydownHandler = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var key = event.key.toLowerCase();
        if ((isNavigationKey(key) && event.keyCode !== 32) || key === 'tab' || key === 'pagedown' || key === 'pageup') {
            event.preventDefault();
            if (key === 'pagedown') {
                this.verticalScrollContainer.scrollNextPage();
                this.nativeElement.focus();
            }
            else if (key === 'pageup') {
                this.verticalScrollContainer.scrollPrevPage();
                this.nativeElement.focus();
            }
        }
    };
    /**
     * @return {?}
     */
    IgxGridBaseComponent.prototype._setupServices = /**
     * @return {?}
     */
    function () {
        this.gridAPI.grid = this;
        this.crudService.grid = this;
        this.navigation.grid = this;
        this.filteringService.grid = this;
        this.summaryService.grid = this;
    };
    /**
     * @return {?}
     */
    IgxGridBaseComponent.prototype._setupListeners = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var destructor = takeUntil(this.destroy$);
        this.onRowAdded.pipe(destructor).subscribe(function (args) { return _this.refreshGridState(args); });
        this.onRowDeleted.pipe(destructor).subscribe(function (args) {
            _this.summaryService.deleteOperation = true;
            _this.summaryService.clearSummaryCache(args);
        });
        this.transactions.onStateUpdate.pipe(takeUntil(this.destroy$)).subscribe(function () {
            _this.summaryService.clearSummaryCache();
            _this._pipeTrigger++;
            _this.markForCheck();
            if (_this.transactions.getAggregatedChanges(false).length === 0) {
                // Needs better check, calling 'transactions.clear()' will also trigger this
                if (_this.gridAPI.atInexistingPage()) {
                    _this.page--;
                }
            }
        });
        this.onPagingDone.pipe(destructor).subscribe(function () {
            _this.endEdit(true);
            _this.selectionService.clear();
            _this.selectionService.activeElement = null;
        });
        this.onColumnMoving.pipe(destructor).subscribe(function () { return _this.endEdit(true); });
        this.onColumnResized.pipe(destructor).subscribe(function () { return _this.endEdit(true); });
        this.overlayService.onOpened.pipe(takeUntil(this.destroy$)).subscribe(function (event) {
            if (_this.overlayService.getOverlayById(event.id).settings.outlet === _this.outletDirective &&
                _this.overlayIDs.indexOf(event.id) < 0) {
                _this.overlayIDs.push(event.id);
            }
        });
        this.overlayService.onClosed.pipe(takeUntil(this.destroy$)).subscribe(function (event) {
            /** @type {?} */
            var ind = _this.overlayIDs.indexOf(event.id);
            if (ind !== -1) {
                _this.overlayIDs.splice(ind, 1);
            }
        });
    };
    // TODO: Refactor
    /**
     * @hidden
     */
    // TODO: Refactor
    /**
     * @hidden
     * @return {?}
     */
    IgxGridBaseComponent.prototype.ngOnInit = 
    // TODO: Refactor
    /**
     * @hidden
     * @return {?}
     */
    function () {
        this._setupServices();
        this._setupListeners();
        this.columnListDiffer = this.differs.find([]).create(null);
        this.calcWidth = this._width && this._width.indexOf('%') === -1 ? parseInt(this._width, 10) : 0;
        this.shouldGenerate = this.autoGenerate;
        this._scrollWidth = this.getScrollWidth();
    };
    /**
     * @protected
     * @return {?}
     */
    IgxGridBaseComponent.prototype.setupColumns = /**
     * @protected
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.autoGenerate) {
            this.autogenerateColumns();
        }
        this.initColumns(this.columnList, function (col) { return _this.onColumnInit.emit(col); });
        this.columnListDiffer.diff(this.columnList);
        this.markForCheck();
        this.resetCaches();
        this._derivePossibleHeight();
        this.columnList.changes
            .pipe(takeUntil(this.destroy$))
            .subscribe(function (change) { _this.onColumnsChanged(change); });
    };
    /**
     * @hidden
     * @internal
     */
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    IgxGridBaseComponent.prototype.resetColumnsVisibleIndexCache = /**
     * @hidden
     * \@internal
     * @return {?}
     */
    function () {
        this.columnList.forEach(function (column) { return column.resetVisibleIndex(); });
    };
    /**
     * @hidden
     * @internal
     */
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    IgxGridBaseComponent.prototype.resetForOfCache = /**
     * @hidden
     * \@internal
     * @return {?}
     */
    function () {
        /** @type {?} */
        var firstVirtRow = this.dataRowList.first;
        if (firstVirtRow) {
            firstVirtRow.virtDirRow.assumeMaster();
        }
    };
    /**
     * @hidden
     * @internal
     */
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    IgxGridBaseComponent.prototype.resetColumnCollections = /**
     * @hidden
     * \@internal
     * @return {?}
     */
    function () {
        this._visibleColumns.length = 0;
        this._pinnedVisible.length = 0;
        this._unpinnedVisible.length = 0;
    };
    /**
     * @hidden
     * @internal
     */
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    IgxGridBaseComponent.prototype.resetCachedWidths = /**
     * @hidden
     * \@internal
     * @return {?}
     */
    function () {
        this._unpinnedWidth = NaN;
        this._pinnedWidth = NaN;
        this._totalWidth = NaN;
    };
    /**
     * @hidden
     * @internal
     */
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    IgxGridBaseComponent.prototype.resetCaches = /**
     * @hidden
     * \@internal
     * @return {?}
     */
    function () {
        this.resetForOfCache();
        this.resetColumnsVisibleIndexCache();
        this.resetColumnCollections();
        this.resetCachedWidths();
        this._columnGroups = this.columnList.some(function (col) { return col.columnGroup; });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxGridBaseComponent.prototype.ngAfterContentInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.setupColumns();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxGridBaseComponent.prototype.ngAfterViewInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        this.zone.runOutsideAngular(function () {
            _this.document.defaultView.addEventListener('resize', _this.resizeHandler);
            _this._keydownListener = _this.keydownHandler.bind(_this);
            _this.nativeElement.addEventListener('keydown', _this._keydownListener);
        });
        this.initPinning();
        this.onDensityChanged.pipe(takeUntil(this.destroy$)).subscribe(function () {
            requestAnimationFrame(function () {
                _this.summaryService.summaryHeight = 0;
                _this.reflow();
                _this.verticalScrollContainer.recalcUpdateSizes();
            });
        });
        this._ngAfterViewInitPassed = true;
        this.calculateGridSizes();
        // In some rare cases we get the AfterViewInit before the grid is added to the DOM
        // and as a result we get 0 width and can't size ourselves properly.
        // In order to prevent that add a mutation observer that watches if we have been added.
        if (!this.isAttachedToDom) {
            /** @type {?} */
            var config = { childList: true, subtree: true };
            /** @type {?} */
            var callback = function (mutationsList) {
                /** @type {?} */
                var childListHasChanged = mutationsList.filter(function (mutation) {
                    return mutation.type === 'childList';
                }).length > 0;
                if (childListHasChanged && _this.isAttachedToDom) {
                    _this.reflow();
                    _this._observer.disconnect();
                    _this._observer = null;
                }
            };
            this._observer = new MutationObserver(callback);
            this._observer.observe(this.document.body, config);
        }
        this._dataRowList.changes.pipe(takeUntil(this.destroy$)).subscribe(function (list) {
            return _this._horizontalForOfs = _this.combineForOfCollections(list.toArray()
                .filter(function (item) { return item.element.nativeElement.parentElement !== null; }), _this._summaryRowList);
        });
        this._summaryRowList.changes.pipe(takeUntil(this.destroy$)).subscribe(function (summaryList) {
            return _this._horizontalForOfs - _this.combineForOfCollections(_this._dataRowList, summaryList.toArray()
                .filter(function (item) { return item.element.nativeElement.parentElement !== null; }));
        });
        this.zone.runOutsideAngular(function () {
            _this._vScrollListener = _this.verticalScrollHandler.bind(_this);
            _this.verticalScrollContainer.getVerticalScroll().addEventListener('scroll', _this._vScrollListener);
        });
        this.zone.runOutsideAngular(function () {
            _this._hScrollListener = _this.horizontalScrollHandler.bind(_this);
            _this.parentVirtDir.getHorizontalScroll().addEventListener('scroll', _this._hScrollListener);
        });
        this._horizontalForOfs = this.combineForOfCollections(this._dataRowList, this._summaryRowList);
        /** @type {?} */
        var vertScrDC = this.verticalScrollContainer.dc.instance._viewContainer.element.nativeElement;
        vertScrDC.addEventListener('scroll', function (evt) { _this.scrollHandler(evt); });
        vertScrDC.addEventListener('wheel', function () { _this.wheelHandler(); });
        this.verticalScrollContainer.onDataChanged.pipe(takeUntil(this.destroy$)).subscribe(function () {
            requestAnimationFrame(function () {
                if (!_this._destroyed) {
                    _this.reflow();
                }
            });
        });
    };
    /**
     * @private
     * @param {?} dataList
     * @param {?} summaryList
     * @return {?}
     */
    IgxGridBaseComponent.prototype.combineForOfCollections = /**
     * @private
     * @param {?} dataList
     * @param {?} summaryList
     * @return {?}
     */
    function (dataList, summaryList) {
        return dataList.map(function (row) { return row.virtDirRow; }).concat(summaryList.map(function (row) { return row.virtDirRow; }));
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxGridBaseComponent.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        this.zone.runOutsideAngular(function () {
            _this.document.defaultView.removeEventListener('resize', _this.resizeHandler);
            _this.nativeElement.removeEventListener('keydown', _this._keydownListener);
            _this.verticalScrollContainer.getVerticalScroll().removeEventListener('scroll', _this._vScrollListener);
            _this.parentVirtDir.getHorizontalScroll().removeEventListener('scroll', _this._hScrollListener);
            /** @type {?} */
            var vertScrDC = _this.verticalScrollContainer.dc.instance._viewContainer.element.nativeElement;
            vertScrDC.removeEventListener('scroll', function (evt) { _this.scrollHandler(evt); });
            vertScrDC.removeEventListener('wheel', function () { _this.wheelHandler(); });
        });
        if (this._observer) {
            this._observer.disconnect();
        }
        this.destroy$.next(true);
        this.destroy$.complete();
        this._destroyed = true;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxGridBaseComponent.prototype.dataLoading = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onDataPreLoad.emit(event);
    };
    /**
     * Toggles the specified column's visibility.
     * ```typescript
     * this.grid1.toggleColumnVisibility({
     *       column: this.grid1.columns[0],
     *       newValue: true
     * });
     * ```
     * @memberof IgxGridBaseComponent
     */
    /**
     * Toggles the specified column's visibility.
     * ```typescript
     * this.grid1.toggleColumnVisibility({
     *       column: this.grid1.columns[0],
     *       newValue: true
     * });
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} args
     * @return {?}
     */
    IgxGridBaseComponent.prototype.toggleColumnVisibility = /**
     * Toggles the specified column's visibility.
     * ```typescript
     * this.grid1.toggleColumnVisibility({
     *       column: this.grid1.columns[0],
     *       newValue: true
     * });
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} args
     * @return {?}
     */
    function (args) {
        /** @type {?} */
        var col = args.column ? this.columnList.find(function (c) { return c === args.column; }) : undefined;
        if (!col) {
            return;
        }
        col.hidden = args.newValue;
        this.onColumnVisibilityChanged.emit(args);
        this.markForCheck();
    };
    Object.defineProperty(IgxGridBaseComponent.prototype, "nativeElement", {
        /**
         * Returns the native element of the `IgxGridComponent`.
         * ```typescript
         * const nativeEl = this.grid.nativeElement.
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns the native element of the `IgxGridComponent`.
         * ```typescript
         * const nativeEl = this.grid.nativeElement.
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "outlet", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @protected
         * @return {?}
         */
        function () {
            return this.outletDirective;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "defaultRowHeight", {
        /**
         * Returns the `IgxGridComponent`'s rows height.
         * ```typescript
         * const rowHeigh = this.grid.defaultRowHeight;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns the `IgxGridComponent`'s rows height.
         * ```typescript
         * const rowHeigh = this.grid.defaultRowHeight;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            switch (this.displayDensity) {
                case DisplayDensity.cosy:
                    return 40;
                case DisplayDensity.compact:
                    return 32;
                default:
                    return 50;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "defaultSummaryHeight", {
        get: /**
         * @return {?}
         */
        function () {
            switch (this.displayDensity) {
                case DisplayDensity.cosy:
                    return 30;
                case DisplayDensity.compact:
                    return 24;
                default:
                    return 36;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "defaultHeaderGroupMinWidth", {
        /**
         * Returns the `IgxGridHeaderGroupComponent`'s minimum allowed width.
         * Used internally for restricting header group component width.
         * The values below depend on the header cell default right/left padding values.
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns the `IgxGridHeaderGroupComponent`'s minimum allowed width.
         * Used internally for restricting header group component width.
         * The values below depend on the header cell default right/left padding values.
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            switch (this.displayDensity) {
                case DisplayDensity.cosy:
                    return 32;
                case DisplayDensity.compact:
                    return 24;
                default:
                    return 48;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "calcPinnedContainerMaxWidth", {
        /**
         * Returns the maximum width of the container for the pinned `IgxColumnComponent`s.
         * The width is 80% of the total grid width.
         * ```typescript
         * const maxPinnedColWidth = this.grid.calcPinnedContainerMaxWidth;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns the maximum width of the container for the pinned `IgxColumnComponent`s.
         * The width is 80% of the total grid width.
         * ```typescript
         * const maxPinnedColWidth = this.grid.calcPinnedContainerMaxWidth;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return (this.calcWidth * 80) / 100;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "unpinnedAreaMinWidth", {
        /**
         * Returns the minimum width of the container for the unpinned `IgxColumnComponent`s.
         * The width is 20% of the total grid width.
         * ```typescript
         * const minUnpinnedColWidth = this.grid.unpinnedAreaMinWidth;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns the minimum width of the container for the unpinned `IgxColumnComponent`s.
         * The width is 20% of the total grid width.
         * ```typescript
         * const minUnpinnedColWidth = this.grid.unpinnedAreaMinWidth;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return (this.calcWidth * 20) / 100;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "pinnedWidth", {
        /**
         * Returns the current width of the container for the pinned `IgxColumnComponent`s.
         * ```typescript
         * const pinnedWidth = this.grid.getPinnedWidth;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns the current width of the container for the pinned `IgxColumnComponent`s.
         * ```typescript
         * const pinnedWidth = this.grid.getPinnedWidth;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            if (!isNaN(this._pinnedWidth)) {
                return this._pinnedWidth;
            }
            this._pinnedWidth = this.getPinnedWidth();
            return this._pinnedWidth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "unpinnedWidth", {
        /**
         * Returns the current width of the container for the unpinned `IgxColumnComponent`s.
         * ```typescript
         * const unpinnedWidth = this.grid.getUnpinnedWidth;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns the current width of the container for the unpinned `IgxColumnComponent`s.
         * ```typescript
         * const unpinnedWidth = this.grid.getUnpinnedWidth;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            if (!isNaN(this._unpinnedWidth)) {
                return this._unpinnedWidth;
            }
            this._unpinnedWidth = this.getUnpinnedWidth();
            return this._unpinnedWidth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "featureColumnsWidth", {
        /**
         * @hidden
         * Gets the combined width of the columns that are specific to the enabled grid features. They are fixed.
         * TODO: Update for Angular 8. Calling parent class getter using super is not supported for now.
         */
        get: /**
         * @hidden
         * Gets the combined width of the columns that are specific to the enabled grid features. They are fixed.
         * TODO: Update for Angular 8. Calling parent class getter using super is not supported for now.
         * @return {?}
         */
        function () {
            return this.getFeatureColumnsWidth();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "summariesMargin", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.rowSelectable || this.rowDraggable ? this.featureColumnsWidth : 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "columns", {
        /**
         * Returns an array of `IgxColumnComponent`s.
         * ```typescript
         * const colums = this.grid.columns.
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns an array of `IgxColumnComponent`s.
         * ```typescript
         * const colums = this.grid.columns.
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this._columns;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "pinnedColumns", {
        /**
         * Returns an array of the pinned `IgxColumnComponent`s.
         * ```typescript
         * const pinnedColumns = this.grid.pinnedColumns.
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns an array of the pinned `IgxColumnComponent`s.
         * ```typescript
         * const pinnedColumns = this.grid.pinnedColumns.
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            if (this._pinnedVisible.length) {
                return this._pinnedVisible;
            }
            this._pinnedVisible = this._pinnedColumns.filter(function (col) { return !col.hidden; });
            return this._pinnedVisible;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "unpinnedColumns", {
        /**
         * Returns an array of unpinned `IgxColumnComponent`s.
         * ```typescript
         * const unpinnedColumns = this.grid.unpinnedColumns.
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns an array of unpinned `IgxColumnComponent`s.
         * ```typescript
         * const unpinnedColumns = this.grid.unpinnedColumns.
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            if (this._unpinnedVisible.length) {
                return this._unpinnedVisible;
            }
            this._unpinnedVisible = this._unpinnedColumns.filter(function (col) { return !col.hidden; });
            return this._unpinnedVisible;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the `width` to be set on `IgxGridHeaderGroupComponent`.
     * @memberof IgxGridBaseComponent
     */
    /**
     * Returns the `width` to be set on `IgxGridHeaderGroupComponent`.
     * \@memberof IgxGridBaseComponent
     * @param {?} column
     * @return {?}
     */
    IgxGridBaseComponent.prototype.getHeaderGroupWidth = /**
     * Returns the `width` to be set on `IgxGridHeaderGroupComponent`.
     * \@memberof IgxGridBaseComponent
     * @param {?} column
     * @return {?}
     */
    function (column) {
        if (this.hasColumnLayouts) {
            return '';
        }
        /** @type {?} */
        var colWidth = column.width;
        /** @type {?} */
        var minWidth = this.defaultHeaderGroupMinWidth;
        /** @type {?} */
        var isPercentageWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1;
        if (!isPercentageWidth && parseInt(column.width, 10) < minWidth) {
            return minWidth.toString();
        }
        return column.width;
    };
    /**
     * Returns the `IgxColumnComponent` by field name.
     * ```typescript
     * const myCol = this.grid1.getColumnByName("ID");
     * ```
     * @param name
     * @memberof IgxGridBaseComponent
     */
    /**
     * Returns the `IgxColumnComponent` by field name.
     * ```typescript
     * const myCol = this.grid1.getColumnByName("ID");
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} name
     * @return {?}
     */
    IgxGridBaseComponent.prototype.getColumnByName = /**
     * Returns the `IgxColumnComponent` by field name.
     * ```typescript
     * const myCol = this.grid1.getColumnByName("ID");
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} name
     * @return {?}
     */
    function (name) {
        return this.columnList.find(function (col) { return col.field === name; });
    };
    /**
     * Returns the `IgxColumnComponent` by index.
     * ```typescript
     * const myRow = this.grid1.getRowByIndex(1);
     * ```
     * @param index
     * @memberof IgxGridBaseComponent
     */
    /**
     * Returns the `IgxColumnComponent` by index.
     * ```typescript
     * const myRow = this.grid1.getRowByIndex(1);
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} index
     * @return {?}
     */
    IgxGridBaseComponent.prototype.getRowByIndex = /**
     * Returns the `IgxColumnComponent` by index.
     * ```typescript
     * const myRow = this.grid1.getRowByIndex(1);
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} index
     * @return {?}
     */
    function (index) {
        return this.gridAPI.get_row_by_index(index);
    };
    /**
     * Returns `IgxGridRowComponent` object by the specified primary key .
     * Requires that the `primaryKey` property is set.
     * ```typescript
     * const myRow = this.grid1.getRowByKey("cell5");
     * ```
     * @param keyValue
     * @memberof IgxGridBaseComponent
     */
    /**
     * Returns `IgxGridRowComponent` object by the specified primary key .
     * Requires that the `primaryKey` property is set.
     * ```typescript
     * const myRow = this.grid1.getRowByKey("cell5");
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} keyValue
     * @return {?}
     */
    IgxGridBaseComponent.prototype.getRowByKey = /**
     * Returns `IgxGridRowComponent` object by the specified primary key .
     * Requires that the `primaryKey` property is set.
     * ```typescript
     * const myRow = this.grid1.getRowByKey("cell5");
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} keyValue
     * @return {?}
     */
    function (keyValue) {
        return this.gridAPI.get_row_by_key(keyValue);
    };
    Object.defineProperty(IgxGridBaseComponent.prototype, "visibleColumns", {
        /**
         * Returns an array of visible `IgxColumnComponent`s.
         * ```typescript
         * const visibleColumns = this.grid.visibleColumns.
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns an array of visible `IgxColumnComponent`s.
         * ```typescript
         * const visibleColumns = this.grid.visibleColumns.
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            if (this._visibleColumns.length) {
                return this._visibleColumns;
            }
            this._visibleColumns = this.columnList.filter(function (c) { return !c.hidden; });
            return this._visibleColumns;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the `IgxGridCellComponent` that matches the conditions.
     * ```typescript
     * const myCell = this.grid1.getCellByColumn(2,"UnitPrice");
     * ```
     * @param rowIndex
     * @param columnField
     * @memberof IgxGridBaseComponent
     */
    /**
     * Returns the `IgxGridCellComponent` that matches the conditions.
     * ```typescript
     * const myCell = this.grid1.getCellByColumn(2,"UnitPrice");
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} rowIndex
     * @param {?} columnField
     * @return {?}
     */
    IgxGridBaseComponent.prototype.getCellByColumn = /**
     * Returns the `IgxGridCellComponent` that matches the conditions.
     * ```typescript
     * const myCell = this.grid1.getCellByColumn(2,"UnitPrice");
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} rowIndex
     * @param {?} columnField
     * @return {?}
     */
    function (rowIndex, columnField) {
        /** @type {?} */
        var columnId = this.columnList.map(function (column) { return column.field; }).indexOf(columnField);
        if (columnId !== -1) {
            return this.gridAPI.get_cell_by_index(rowIndex, columnId);
        }
    };
    /**
     * Returns an `IgxGridCellComponent` object by the specified primary key and column field.
     * Requires that the primaryKey property is set.
     * ```typescript
     * grid.getCellByKey(1, 'index');
     * ```
     * @param rowSelector match any rowID
     * @param columnField
     * @memberof IgxGridBaseComponent
     */
    /**
     * Returns an `IgxGridCellComponent` object by the specified primary key and column field.
     * Requires that the primaryKey property is set.
     * ```typescript
     * grid.getCellByKey(1, 'index');
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} rowSelector match any rowID
     * @param {?} columnField
     * @return {?}
     */
    IgxGridBaseComponent.prototype.getCellByKey = /**
     * Returns an `IgxGridCellComponent` object by the specified primary key and column field.
     * Requires that the primaryKey property is set.
     * ```typescript
     * grid.getCellByKey(1, 'index');
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} rowSelector match any rowID
     * @param {?} columnField
     * @return {?}
     */
    function (rowSelector, columnField) {
        return this.gridAPI.get_cell_by_key(rowSelector, columnField);
    };
    Object.defineProperty(IgxGridBaseComponent.prototype, "totalPages", {
        /**
         * Returns the total number of pages.
         * ```typescript
         * const totalPages = this.grid.totalPages;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns the total number of pages.
         * ```typescript
         * const totalPages = this.grid.totalPages;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            if (this.pagingState) {
                return this.pagingState.metadata.countPages;
            }
            return -1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "totalRecords", {
        /**
         * Returns the total number of records.
         * Only functions when paging is enabled.
         * ```typescript
         * const totalRecords = this.grid.totalRecords;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns the total number of records.
         * Only functions when paging is enabled.
         * ```typescript
         * const totalRecords = this.grid.totalRecords;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            if (this.pagingState) {
                return this.pagingState.metadata.countRecords;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "isFirstPage", {
        /**
         * Returns if the current page is the first page.
         * ```typescript
         * const firstPage = this.grid.isFirstPage;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns if the current page is the first page.
         * ```typescript
         * const firstPage = this.grid.isFirstPage;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this.page === 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "isLastPage", {
        /**
         * Returns if the current page is the last page.
         * ```typescript
         * const lastPage = this.grid.isLastPage;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns if the current page is the last page.
         * ```typescript
         * const lastPage = this.grid.isLastPage;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this.page + 1 >= this.totalPages;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "totalWidth", {
        /**
         * Returns the total width of the `IgxGridComponent`.
         * ```typescript
         * const gridWidth = this.grid.totalWidth;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns the total width of the `IgxGridComponent`.
         * ```typescript
         * const gridWidth = this.grid.totalWidth;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            if (!isNaN(this._totalWidth)) {
                return this._totalWidth;
            }
            // Take only top level columns
            /** @type {?} */
            var cols = this.visibleColumns.filter(function (col) { return col.level === 0 && !col.pinned; });
            /** @type {?} */
            var totalWidth = 0;
            /** @type {?} */
            var i = 0;
            for (i; i < cols.length; i++) {
                totalWidth += parseInt(cols[i].calcWidth, 10) || 0;
            }
            this._totalWidth = totalWidth;
            return totalWidth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "showRowCheckboxes", {
        get: /**
         * @return {?}
         */
        function () {
            return this.rowSelectable && this.columns.length > this.hiddenColumnsCount;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} from
     * @param {?} to
     * @param {?} pos
     * @return {?}
     */
    IgxGridBaseComponent.prototype._moveColumns = /**
     * @hidden
     * @protected
     * @param {?} from
     * @param {?} to
     * @param {?} pos
     * @return {?}
     */
    function (from, to, pos) {
        /** @type {?} */
        var list = this.columnList.toArray();
        /** @type {?} */
        var fromIndex = list.indexOf(from);
        /** @type {?} */
        var toIndex = list.indexOf(to);
        if (pos === DropPosition.BeforeDropTarget) {
            toIndex--;
            if (toIndex < 0) {
                toIndex = 0;
            }
        }
        if (pos === DropPosition.AfterDropTarget) {
            toIndex++;
        }
        list.splice.apply(list, __spread([toIndex, 0], list.splice(fromIndex, 1)));
        /** @type {?} */
        var newList = this._resetColumnList(list);
        this.columnList.reset(newList);
        this.columnList.notifyOnChanges();
        this._columns = this.columnList.toArray();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?=} list
     * @return {?}
     */
    IgxGridBaseComponent.prototype._resetColumnList = /**
     * @hidden
     * @protected
     * @param {?=} list
     * @return {?}
     */
    function (list) {
        if (!list) {
            list = this.columnList.toArray();
        }
        /** @type {?} */
        var newList = [];
        list.filter(function (c) { return c.level === 0; }).forEach(function (p) {
            newList.push(p);
            if (p.columnGroup) {
                newList = newList.concat(p.allChildren);
            }
        });
        return newList;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} from
     * @param {?} to
     * @param {?} position
     * @return {?}
     */
    IgxGridBaseComponent.prototype._reorderPinnedColumns = /**
     * @hidden
     * @protected
     * @param {?} from
     * @param {?} to
     * @param {?} position
     * @return {?}
     */
    function (from, to, position) {
        /** @type {?} */
        var pinned = this._pinnedColumns;
        /** @type {?} */
        var dropIndex = pinned.indexOf(to);
        if (to.columnGroup) {
            dropIndex += to.allChildren.length;
        }
        if (position === DropPosition.BeforeDropTarget) {
            dropIndex--;
        }
        if (position === DropPosition.AfterDropTarget) {
            dropIndex++;
        }
        pinned.splice.apply(pinned, __spread([dropIndex, 0], pinned.splice(pinned.indexOf(from), 1)));
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} parent
     * @param {?} from
     * @param {?} to
     * @param {?} pos
     * @return {?}
     */
    IgxGridBaseComponent.prototype._moveChildColumns = /**
     * @hidden
     * @protected
     * @param {?} parent
     * @param {?} from
     * @param {?} to
     * @param {?} pos
     * @return {?}
     */
    function (parent, from, to, pos) {
        /** @type {?} */
        var buffer = parent.children.toArray();
        /** @type {?} */
        var fromIndex = buffer.indexOf(from);
        /** @type {?} */
        var toIndex = buffer.indexOf(to);
        if (pos === DropPosition.BeforeDropTarget) {
            toIndex--;
        }
        if (pos === DropPosition.AfterDropTarget) {
            toIndex++;
        }
        buffer.splice.apply(buffer, __spread([toIndex, 0], buffer.splice(fromIndex, 1)));
        parent.children.reset(buffer);
    };
    /**
     * Moves a column to the specified drop target.
     * ```typescript
     * grid.moveColumn(compName, persDetails);
     * ```
      * @memberof IgxGridBaseComponent
      */
    /**
     * Moves a column to the specified drop target.
     * ```typescript
     * grid.moveColumn(compName, persDetails);
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} column
     * @param {?} dropTarget
     * @param {?=} pos
     * @return {?}
     */
    IgxGridBaseComponent.prototype.moveColumn = /**
     * Moves a column to the specified drop target.
     * ```typescript
     * grid.moveColumn(compName, persDetails);
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} column
     * @param {?} dropTarget
     * @param {?=} pos
     * @return {?}
     */
    function (column, dropTarget, pos) {
        if (pos === void 0) { pos = DropPosition.None; }
        /** @type {?} */
        var position = pos;
        /** @type {?} */
        var fromIndex = column.visibleIndex;
        /** @type {?} */
        var toIndex = dropTarget.visibleIndex;
        if (pos === DropPosition.BeforeDropTarget && fromIndex < toIndex) {
            position = DropPosition.BeforeDropTarget;
        }
        else if (pos === DropPosition.AfterDropTarget && fromIndex > toIndex) {
            position = DropPosition.AfterDropTarget;
        }
        else {
            position = DropPosition.None;
        }
        if ((column.level !== dropTarget.level) ||
            (column.topLevelParent !== dropTarget.topLevelParent)) {
            return;
        }
        this.endEdit(true);
        if (column.level) {
            this._moveChildColumns(column.parent, column, dropTarget, position);
        }
        if (dropTarget.pinned && column.pinned) {
            this._reorderPinnedColumns(column, dropTarget, position);
        }
        if (dropTarget.pinned && !column.pinned) {
            column.pin();
            this._reorderPinnedColumns(column, dropTarget, position);
        }
        if (!dropTarget.pinned && column.pinned) {
            column.unpin();
            /** @type {?} */
            var list = this.columnList.toArray();
            /** @type {?} */
            var fi = list.indexOf(column);
            /** @type {?} */
            var ti = list.indexOf(dropTarget);
            if (pos === DropPosition.BeforeDropTarget && fi < ti) {
                position = DropPosition.BeforeDropTarget;
            }
            else if (pos === DropPosition.AfterDropTarget && fi > ti) {
                position = DropPosition.AfterDropTarget;
            }
            else {
                position = DropPosition.None;
            }
        }
        this._moveColumns(column, dropTarget, position);
        this.cdr.detectChanges();
        /** @type {?} */
        var args = {
            source: column,
            target: dropTarget
        };
        this.onColumnMovingEnd.emit(args);
    };
    /**
     * Goes to the next page of the `IgxGridComponent`, if the grid is not already at the last page.
     * ```typescript
     * this.grid1.nextPage();
     * ```
     * @memberof IgxGridBaseComponent
     */
    /**
     * Goes to the next page of the `IgxGridComponent`, if the grid is not already at the last page.
     * ```typescript
     * this.grid1.nextPage();
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    IgxGridBaseComponent.prototype.nextPage = /**
     * Goes to the next page of the `IgxGridComponent`, if the grid is not already at the last page.
     * ```typescript
     * this.grid1.nextPage();
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    function () {
        if (!this.isLastPage) {
            this.page += 1;
        }
    };
    /**
     * Goes to the previous page of the `IgxGridComponent`, if the grid is not already at the first page.
     * ```typescript
     * this.grid1.previousPage();
     * ```
     * @memberof IgxGridBaseComponent
     */
    /**
     * Goes to the previous page of the `IgxGridComponent`, if the grid is not already at the first page.
     * ```typescript
     * this.grid1.previousPage();
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    IgxGridBaseComponent.prototype.previousPage = /**
     * Goes to the previous page of the `IgxGridComponent`, if the grid is not already at the first page.
     * ```typescript
     * this.grid1.previousPage();
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    function () {
        if (!this.isFirstPage) {
            this.page -= 1;
        }
    };
    /**
     * Goes to the desired page index.
     * ```typescript
     * this.grid1.paginate(1);
     * ```
     * @param val
     * @memberof IgxGridBaseComponent
     */
    /**
     * Goes to the desired page index.
     * ```typescript
     * this.grid1.paginate(1);
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} val
     * @return {?}
     */
    IgxGridBaseComponent.prototype.paginate = /**
     * Goes to the desired page index.
     * ```typescript
     * this.grid1.paginate(1);
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} val
     * @return {?}
     */
    function (val) {
        if (val < 0 || val > this.totalPages - 1) {
            return;
        }
        this.page = val;
    };
    /**
     * Manually marks the `IgxGridComponent` for change detection.
     * ```typescript
     * this.grid1.markForCheck();
     * ```
     * @memberof IgxGridBaseComponent
     */
    /**
     * Manually marks the `IgxGridComponent` for change detection.
     * ```typescript
     * this.grid1.markForCheck();
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    IgxGridBaseComponent.prototype.markForCheck = /**
     * Manually marks the `IgxGridComponent` for change detection.
     * ```typescript
     * this.grid1.markForCheck();
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    function () {
        this.cdr.detectChanges();
    };
    /**
     * Creates a new `IgxGridRowComponent` and adds the data record to the end of the data source.
     * ```typescript
     * const record = {
     *     ID: this.grid1.data[this.grid1.data.length - 1].ID + 1,
     *     Name: this.newRecord
     * };
     * this.grid1.addRow(record);
     * ```
     * @param data
     * @memberof IgxGridBaseComponent
     */
    /**
     * Creates a new `IgxGridRowComponent` and adds the data record to the end of the data source.
     * ```typescript
     * const record = {
     *     ID: this.grid1.data[this.grid1.data.length - 1].ID + 1,
     *     Name: this.newRecord
     * };
     * this.grid1.addRow(record);
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} data
     * @return {?}
     */
    IgxGridBaseComponent.prototype.addRow = /**
     * Creates a new `IgxGridRowComponent` and adds the data record to the end of the data source.
     * ```typescript
     * const record = {
     *     ID: this.grid1.data[this.grid1.data.length - 1].ID + 1,
     *     Name: this.newRecord
     * };
     * this.grid1.addRow(record);
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} data
     * @return {?}
     */
    function (data) {
        this.gridAPI.addRowToData(data);
        this.onRowAdded.emit({ data: data });
        this._pipeTrigger++;
        this.cdr.markForCheck();
    };
    /**
     * Removes the `IgxGridRowComponent` and the corresponding data record by primary key.
     * Requires that the `primaryKey` property is set.
     * The method accept rowSelector as a parameter, which is the rowID.
     * ```typescript
     * this.grid1.deleteRow(0);
     * ```
     * @param rowSelector
     * @memberof IgxGridBaseComponent
     */
    /**
     * Removes the `IgxGridRowComponent` and the corresponding data record by primary key.
     * Requires that the `primaryKey` property is set.
     * The method accept rowSelector as a parameter, which is the rowID.
     * ```typescript
     * this.grid1.deleteRow(0);
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} rowSelector
     * @return {?}
     */
    IgxGridBaseComponent.prototype.deleteRow = /**
     * Removes the `IgxGridRowComponent` and the corresponding data record by primary key.
     * Requires that the `primaryKey` property is set.
     * The method accept rowSelector as a parameter, which is the rowID.
     * ```typescript
     * this.grid1.deleteRow(0);
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} rowSelector
     * @return {?}
     */
    function (rowSelector) {
        if (this.primaryKey !== undefined && this.primaryKey !== null) {
            this.deleteRowById(rowSelector);
        }
    };
    /** @hidden */
    /**
     * @hidden
     * @param {?} rowId
     * @return {?}
     */
    IgxGridBaseComponent.prototype.deleteRowById = /**
     * @hidden
     * @param {?} rowId
     * @return {?}
     */
    function (rowId) {
        this.gridAPI.deleteRowById(rowId);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} rowID
     * @param {?} index
     * @return {?}
     */
    IgxGridBaseComponent.prototype.deleteRowFromData = /**
     * @hidden
     * @protected
     * @param {?} rowID
     * @param {?} index
     * @return {?}
     */
    function (rowID, index) {
        //  if there is a row (index !== 0) delete it
        //  if there is a row in ADD or UPDATE state change it's state to DELETE
        if (index !== -1) {
            if (this.transactions.enabled) {
                /** @type {?} */
                var transaction = { id: rowID, type: TransactionType.DELETE, newValue: null };
                this.transactions.add(transaction, this.data[index]);
            }
            else {
                this.data.splice(index, 1);
            }
        }
        else {
            /** @type {?} */
            var state$$1 = this.transactions.getState(rowID);
            this.transactions.add({ id: rowID, type: TransactionType.DELETE, newValue: null }, state$$1 && state$$1.recordRef);
        }
    };
    /**
     * Updates the `IgxGridRowComponent` and the corresponding data record by primary key.
     * Requires that the `primaryKey` property is set.
     * ```typescript
     * this.gridWithPK.updateCell('Updated', 1, 'ProductName');
     * ```
     * @param value the new value which is to be set.
     * @param rowSelector corresponds to rowID.
     * @param column corresponds to column field.
     * @memberof IgxGridBaseComponent
     */
    /**
     * Updates the `IgxGridRowComponent` and the corresponding data record by primary key.
     * Requires that the `primaryKey` property is set.
     * ```typescript
     * this.gridWithPK.updateCell('Updated', 1, 'ProductName');
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} value the new value which is to be set.
     * @param {?} rowSelector corresponds to rowID.
     * @param {?} column corresponds to column field.
     * @return {?}
     */
    IgxGridBaseComponent.prototype.updateCell = /**
     * Updates the `IgxGridRowComponent` and the corresponding data record by primary key.
     * Requires that the `primaryKey` property is set.
     * ```typescript
     * this.gridWithPK.updateCell('Updated', 1, 'ProductName');
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} value the new value which is to be set.
     * @param {?} rowSelector corresponds to rowID.
     * @param {?} column corresponds to column field.
     * @return {?}
     */
    function (value, rowSelector, column) {
        if (this.isDefined(this.primaryKey)) {
            /** @type {?} */
            var col = this.columnList.toArray().find(function (c) { return c.field === column; });
            if (col) {
                // Simplify
                /** @type {?} */
                var rowData = this.gridAPI.getRowData(rowSelector);
                /** @type {?} */
                var index = this.gridAPI.get_row_index_in_data(rowSelector);
                // If row passed is invalid
                if (index < 0) {
                    return;
                }
                /** @type {?} */
                var id = {
                    rowID: rowSelector,
                    columnID: col.index,
                    rowIndex: index
                };
                /** @type {?} */
                var cell = new IgxCell(id, index, col, rowData[col.field], rowData[col.field], rowData);
                /** @type {?} */
                var args = this.gridAPI.update_cell(cell, value);
                if (this.crudService.cell && this.crudService.sameCell(cell)) {
                    if (args.cancel) {
                        return;
                    }
                    this.gridAPI.escape_editMode();
                }
                this.cdr.markForCheck();
            }
        }
    };
    /**
     * Updates the `IgxGridRowComponent`, which is specified by
     * rowSelector parameter and the data source record with the passed value.
     * This method will apply requested update only if primary key is specified in the grid.
     * ```typescript
     * grid.updateRow({
     *       ProductID: 1, ProductName: 'Spearmint', InStock: true, UnitsInStock: 1, OrderDate: new Date('2005-03-21')
     *   }, 1);
     * ```
     * @param value
     * @param rowSelector correspond to rowID
     * @memberof IgxGridBaseComponent
     */
    /**
     * Updates the `IgxGridRowComponent`, which is specified by
     * rowSelector parameter and the data source record with the passed value.
     * This method will apply requested update only if primary key is specified in the grid.
     * ```typescript
     * grid.updateRow({
     *       ProductID: 1, ProductName: 'Spearmint', InStock: true, UnitsInStock: 1, OrderDate: new Date('2005-03-21')
     *   }, 1);
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} value
     * @param {?} rowSelector correspond to rowID
     * @return {?}
     */
    IgxGridBaseComponent.prototype.updateRow = /**
     * Updates the `IgxGridRowComponent`, which is specified by
     * rowSelector parameter and the data source record with the passed value.
     * This method will apply requested update only if primary key is specified in the grid.
     * ```typescript
     * grid.updateRow({
     *       ProductID: 1, ProductName: 'Spearmint', InStock: true, UnitsInStock: 1, OrderDate: new Date('2005-03-21')
     *   }, 1);
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} value
     * @param {?} rowSelector correspond to rowID
     * @return {?}
     */
    function (value, rowSelector) {
        if (this.isDefined(this.primaryKey)) {
            /** @type {?} */
            var editableCell = this.crudService.cell;
            if (editableCell && editableCell.id.rowID === rowSelector) {
                this.gridAPI.escape_editMode();
            }
            /** @type {?} */
            var row = new IgxRow(rowSelector, -1, this.gridAPI.getRowData(rowSelector));
            this.gridAPI.update_row(row, value);
            this.cdr.markForCheck();
        }
    };
    /**
     * Sort a single `IgxColumnComponent`.
     * Sort the `IgxGridComponent`'s `IgxColumnComponent` based on the provided array of sorting expressions.
     * ```typescript
     * this.grid.sort({ fieldName: name, dir: SortingDirection.Asc, ignoreCase: false });
     * ```
     * @memberof IgxGridBaseComponent
     */
    /**
     * Sort a single `IgxColumnComponent`.
     * Sort the `IgxGridComponent`'s `IgxColumnComponent` based on the provided array of sorting expressions.
     * ```typescript
     * this.grid.sort({ fieldName: name, dir: SortingDirection.Asc, ignoreCase: false });
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} expression
     * @return {?}
     */
    IgxGridBaseComponent.prototype.sort = /**
     * Sort a single `IgxColumnComponent`.
     * Sort the `IgxGridComponent`'s `IgxColumnComponent` based on the provided array of sorting expressions.
     * ```typescript
     * this.grid.sort({ fieldName: name, dir: SortingDirection.Asc, ignoreCase: false });
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} expression
     * @return {?}
     */
    function (expression) {
        this.endEdit(false);
        if (expression instanceof Array) {
            this.gridAPI.sort_multiple(expression);
        }
        else {
            this.gridAPI.sort(expression);
        }
        this.onSortingDone.emit(expression);
    };
    /**
     * Filters a single `IgxColumnComponent`.
     * ```typescript
     * public filter(term) {
     *      this.grid.filter("ProductName", term, IgxStringFilteringOperand.instance().condition("contains"));
     * }
     * ```
     * @param name
     * @param value
     * @param conditionOrExpressionTree
     * @param ignoreCase
     * @memberof IgxGridBaseComponent
     */
    /**
     * Filters a single `IgxColumnComponent`.
     * ```typescript
     * public filter(term) {
     *      this.grid.filter("ProductName", term, IgxStringFilteringOperand.instance().condition("contains"));
     * }
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} name
     * @param {?} value
     * @param {?=} conditionOrExpressionTree
     * @param {?=} ignoreCase
     * @return {?}
     */
    IgxGridBaseComponent.prototype.filter = /**
     * Filters a single `IgxColumnComponent`.
     * ```typescript
     * public filter(term) {
     *      this.grid.filter("ProductName", term, IgxStringFilteringOperand.instance().condition("contains"));
     * }
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} name
     * @param {?} value
     * @param {?=} conditionOrExpressionTree
     * @param {?=} ignoreCase
     * @return {?}
     */
    function (name, value, conditionOrExpressionTree, ignoreCase) {
        this.filteringService.filter(name, value, conditionOrExpressionTree, ignoreCase);
    };
    /**
     * Filters all the `IgxColumnComponent` in the `IgxGridComponent` with the same condition.
     * ```typescript
     * grid.filterGlobal('some', IgxStringFilteringOperand.instance().condition('contains'));
     * ```
     * @param value
     * @param condition
     * @param ignoreCase
     * @memberof IgxGridBaseComponent
     */
    /**
     * Filters all the `IgxColumnComponent` in the `IgxGridComponent` with the same condition.
     * ```typescript
     * grid.filterGlobal('some', IgxStringFilteringOperand.instance().condition('contains'));
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} value
     * @param {?=} condition
     * @param {?=} ignoreCase
     * @return {?}
     */
    IgxGridBaseComponent.prototype.filterGlobal = /**
     * Filters all the `IgxColumnComponent` in the `IgxGridComponent` with the same condition.
     * ```typescript
     * grid.filterGlobal('some', IgxStringFilteringOperand.instance().condition('contains'));
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} value
     * @param {?=} condition
     * @param {?=} ignoreCase
     * @return {?}
     */
    function (value, condition, ignoreCase) {
        this.filteringService.filterGlobal(value, condition, ignoreCase);
    };
    /**
     * Enables summaries for the specified column and applies your customSummary.
     * If you do not provide the customSummary, then the default summary for the column data type will be applied.
     * ```typescript
     * grid.enableSummaries([{ fieldName: 'ProductName' }, { fieldName: 'ID' }]);
     * ```
     * Enable summaries for the listed columns.
     * ```typescript
     * grid.enableSummaries('ProductName');
     * ```
     * @param rest
     * @memberof IgxGridBaseComponent
     */
    /**
     * Enables summaries for the specified column and applies your customSummary.
     * If you do not provide the customSummary, then the default summary for the column data type will be applied.
     * ```typescript
     * grid.enableSummaries([{ fieldName: 'ProductName' }, { fieldName: 'ID' }]);
     * ```
     * Enable summaries for the listed columns.
     * ```typescript
     * grid.enableSummaries('ProductName');
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {...?} rest
     * @return {?}
     */
    IgxGridBaseComponent.prototype.enableSummaries = /**
     * Enables summaries for the specified column and applies your customSummary.
     * If you do not provide the customSummary, then the default summary for the column data type will be applied.
     * ```typescript
     * grid.enableSummaries([{ fieldName: 'ProductName' }, { fieldName: 'ID' }]);
     * ```
     * Enable summaries for the listed columns.
     * ```typescript
     * grid.enableSummaries('ProductName');
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {...?} rest
     * @return {?}
     */
    function () {
        var rest = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            rest[_i] = arguments[_i];
        }
        if (rest.length === 1 && Array.isArray(rest[0])) {
            this._multipleSummaries(rest[0], true);
        }
        else {
            this._summaries(rest[0], true, rest[1]);
        }
        this.calculateGridHeight();
        this.cdr.detectChanges();
    };
    /**
     * Disable summaries for the specified column.
     * ```typescript
     * grid.disableSummaries('ProductName');
     * ```
     *
     * Disable summaries for the listed columns.
     * ```typescript
     * grid.disableSummaries([{ fieldName: 'ProductName' }]);
     * ```
     * @memberof IgxGridBaseComponent
     */
    /**
     * Disable summaries for the specified column.
     * ```typescript
     * grid.disableSummaries('ProductName');
     * ```
     *
     * Disable summaries for the listed columns.
     * ```typescript
     * grid.disableSummaries([{ fieldName: 'ProductName' }]);
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {...?} rest
     * @return {?}
     */
    IgxGridBaseComponent.prototype.disableSummaries = /**
     * Disable summaries for the specified column.
     * ```typescript
     * grid.disableSummaries('ProductName');
     * ```
     *
     * Disable summaries for the listed columns.
     * ```typescript
     * grid.disableSummaries([{ fieldName: 'ProductName' }]);
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {...?} rest
     * @return {?}
     */
    function () {
        var rest = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            rest[_i] = arguments[_i];
        }
        if (rest.length === 1 && Array.isArray(rest[0])) {
            this._disableMultipleSummaries(rest[0]);
        }
        else {
            this._summaries(rest[0], false);
        }
    };
    /**
     * If name is provided, clears the filtering state of the corresponding `IgxColumnComponent`,
     * otherwise clears the filtering state of all `IgxColumnComponent`s.
     * ```typescript
     * this.grid.clearFilter();
     * ```
     * @param name
     * @memberof IgxGridBaseComponent
     */
    /**
     * If name is provided, clears the filtering state of the corresponding `IgxColumnComponent`,
     * otherwise clears the filtering state of all `IgxColumnComponent`s.
     * ```typescript
     * this.grid.clearFilter();
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?=} name
     * @return {?}
     */
    IgxGridBaseComponent.prototype.clearFilter = /**
     * If name is provided, clears the filtering state of the corresponding `IgxColumnComponent`,
     * otherwise clears the filtering state of all `IgxColumnComponent`s.
     * ```typescript
     * this.grid.clearFilter();
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?=} name
     * @return {?}
     */
    function (name) {
        this.filteringService.clearFilter(name);
    };
    /**
     * If name is provided, clears the sorting state of the corresponding `IgxColumnComponent`,
     * otherwise clears the sorting state of all `IgxColumnComponent`.
     * ```typescript
     * this.grid.clearSort();
     * ```
     * @param name
     * @memberof IgxGridBaseComponent
     */
    /**
     * If name is provided, clears the sorting state of the corresponding `IgxColumnComponent`,
     * otherwise clears the sorting state of all `IgxColumnComponent`.
     * ```typescript
     * this.grid.clearSort();
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?=} name
     * @return {?}
     */
    IgxGridBaseComponent.prototype.clearSort = /**
     * If name is provided, clears the sorting state of the corresponding `IgxColumnComponent`,
     * otherwise clears the sorting state of all `IgxColumnComponent`.
     * ```typescript
     * this.grid.clearSort();
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?=} name
     * @return {?}
     */
    function (name) {
        if (!name) {
            this.sortingExpressions = [];
            return;
        }
        if (!this.gridAPI.get_column_by_name(name)) {
            return;
        }
        this.gridAPI.clear_sort(name);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?=} args
     * @return {?}
     */
    IgxGridBaseComponent.prototype.clearSummaryCache = /**
     * @hidden
     * @param {?=} args
     * @return {?}
     */
    function (args) {
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?=} args
     * @return {?}
     */
    IgxGridBaseComponent.prototype.refreshGridState = /**
     * @hidden
     * @param {?=} args
     * @return {?}
     */
    function (args) {
        this.endEdit(true);
        this.summaryService.clearSummaryCache(args);
    };
    // TODO: We have return values here. Move them to event args ??
    /**
     * Pins a column by field name. Returns whether the operation is successful.
     * ```typescript
     * this.grid.pinColumn("ID");
     * ```
     * @param columnName
     * @param index
     * @memberof IgxGridBaseComponent
     */
    // TODO: We have return values here. Move them to event args ??
    /**
     * Pins a column by field name. Returns whether the operation is successful.
     * ```typescript
     * this.grid.pinColumn("ID");
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} columnName
     * @param {?=} index
     * @return {?}
     */
    IgxGridBaseComponent.prototype.pinColumn = 
    // TODO: We have return values here. Move them to event args ??
    /**
     * Pins a column by field name. Returns whether the operation is successful.
     * ```typescript
     * this.grid.pinColumn("ID");
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} columnName
     * @param {?=} index
     * @return {?}
     */
    function (columnName, index) {
        /** @type {?} */
        var col = columnName instanceof IgxColumnComponent ? columnName : this.getColumnByName(columnName);
        return col.pin(index);
    };
    /**
     * Unpins a column by field name. Returns whether the operation is successful.
     * ```typescript
     * this.grid.pinColumn("ID");
     * ```
     * @param columnName
     * @param index
     * @memberof IgxGridBaseComponent
     */
    /**
     * Unpins a column by field name. Returns whether the operation is successful.
     * ```typescript
     * this.grid.pinColumn("ID");
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} columnName
     * @param {?=} index
     * @return {?}
     */
    IgxGridBaseComponent.prototype.unpinColumn = /**
     * Unpins a column by field name. Returns whether the operation is successful.
     * ```typescript
     * this.grid.pinColumn("ID");
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} columnName
     * @param {?=} index
     * @return {?}
     */
    function (columnName, index) {
        /** @type {?} */
        var col = columnName instanceof IgxColumnComponent ? columnName : this.getColumnByName(columnName);
        return col.unpin(index);
    };
    /**
     * Recalculates grid width/height dimensions. Should be run when changing DOM elements dimentions manually that affect the grid's size.
     * ```typescript
     * this.grid.reflow();
     * ```
     * @memberof IgxGridBaseComponent
     */
    /**
     * Recalculates grid width/height dimensions. Should be run when changing DOM elements dimentions manually that affect the grid's size.
     * ```typescript
     * this.grid.reflow();
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    IgxGridBaseComponent.prototype.reflow = /**
     * Recalculates grid width/height dimensions. Should be run when changing DOM elements dimentions manually that affect the grid's size.
     * ```typescript
     * this.grid.reflow();
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    function () {
        this.calculateGridSizes();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxGridBaseComponent.prototype.recalculateSummaries = /**
     * @hidden
     * @return {?}
     */
    function () {
    };
    /**
     * Finds the next occurrence of a given string in the grid and scrolls to the cell if it isn't visible.
     * Returns how many times the grid contains the string.
     * ```typescript
     * this.grid.findNext("financial");
     * ```
     * @param text the string to search.
     * @param caseSensitive optionally, if the search should be case sensitive (defaults to false).
     * @param exactMatch optionally, if the text should match the entire value  (defaults to false).
     * @memberof IgxGridBaseComponent
     */
    /**
     * Finds the next occurrence of a given string in the grid and scrolls to the cell if it isn't visible.
     * Returns how many times the grid contains the string.
     * ```typescript
     * this.grid.findNext("financial");
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} text the string to search.
     * @param {?=} caseSensitive optionally, if the search should be case sensitive (defaults to false).
     * @param {?=} exactMatch optionally, if the text should match the entire value  (defaults to false).
     * @return {?}
     */
    IgxGridBaseComponent.prototype.findNext = /**
     * Finds the next occurrence of a given string in the grid and scrolls to the cell if it isn't visible.
     * Returns how many times the grid contains the string.
     * ```typescript
     * this.grid.findNext("financial");
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} text the string to search.
     * @param {?=} caseSensitive optionally, if the search should be case sensitive (defaults to false).
     * @param {?=} exactMatch optionally, if the text should match the entire value  (defaults to false).
     * @return {?}
     */
    function (text, caseSensitive, exactMatch) {
        return this.find(text, 1, caseSensitive, exactMatch);
    };
    /**
     * Finds the previous occurrence of a given string in the grid and scrolls to the cell if it isn't visible.
     * Returns how many times the grid contains the string.
     * ```typescript
     * this.grid.findPrev("financial");
     * ````
     * @param text the string to search.
     * @param caseSensitive optionally, if the search should be case sensitive (defaults to false).
     * @param exactMatch optionally, if the text should match the entire value (defaults to false).
     * @memberof IgxGridBaseComponent
     */
    /**
     * Finds the previous occurrence of a given string in the grid and scrolls to the cell if it isn't visible.
     * Returns how many times the grid contains the string.
     * ```typescript
     * this.grid.findPrev("financial");
     * ````
     * \@memberof IgxGridBaseComponent
     * @param {?} text the string to search.
     * @param {?=} caseSensitive optionally, if the search should be case sensitive (defaults to false).
     * @param {?=} exactMatch optionally, if the text should match the entire value (defaults to false).
     * @return {?}
     */
    IgxGridBaseComponent.prototype.findPrev = /**
     * Finds the previous occurrence of a given string in the grid and scrolls to the cell if it isn't visible.
     * Returns how many times the grid contains the string.
     * ```typescript
     * this.grid.findPrev("financial");
     * ````
     * \@memberof IgxGridBaseComponent
     * @param {?} text the string to search.
     * @param {?=} caseSensitive optionally, if the search should be case sensitive (defaults to false).
     * @param {?=} exactMatch optionally, if the text should match the entire value (defaults to false).
     * @return {?}
     */
    function (text, caseSensitive, exactMatch) {
        return this.find(text, -1, caseSensitive, exactMatch);
    };
    /**
     * Reapplies the existing search.
     * Returns how many times the grid contains the last search.
     * ```typescript
     * this.grid.refreshSearch();
     * ```
     * @param updateActiveInfo
     * @memberof IgxGridBaseComponent
     */
    /**
     * Reapplies the existing search.
     * Returns how many times the grid contains the last search.
     * ```typescript
     * this.grid.refreshSearch();
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?=} updateActiveInfo
     * @return {?}
     */
    IgxGridBaseComponent.prototype.refreshSearch = /**
     * Reapplies the existing search.
     * Returns how many times the grid contains the last search.
     * ```typescript
     * this.grid.refreshSearch();
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?=} updateActiveInfo
     * @return {?}
     */
    function (updateActiveInfo) {
        var _this = this;
        if (this.lastSearchInfo.searchText) {
            this.rebuildMatchCache();
            if (updateActiveInfo) {
                /** @type {?} */
                var activeInfo_1 = IgxTextHighlightDirective.highlightGroupsMap.get(this.id);
                this.lastSearchInfo.matchInfoCache.forEach(function (match, i) {
                    if (match.column === activeInfo_1.column &&
                        match.row === activeInfo_1.row &&
                        match.index === activeInfo_1.index) {
                        _this.lastSearchInfo.activeMatchIndex = i;
                    }
                });
            }
            return this.find(this.lastSearchInfo.searchText, 0, this.lastSearchInfo.caseSensitive, this.lastSearchInfo.exactMatch, false);
        }
        else {
            return 0;
        }
    };
    /**
     * Removes all the highlights in the cell.
     * ```typescript
     * this.grid.clearSearch();
     * ```
     * @memberof IgxGridBaseComponent
     */
    /**
     * Removes all the highlights in the cell.
     * ```typescript
     * this.grid.clearSearch();
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    IgxGridBaseComponent.prototype.clearSearch = /**
     * Removes all the highlights in the cell.
     * ```typescript
     * this.grid.clearSearch();
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    function () {
        this.lastSearchInfo = {
            searchText: '',
            caseSensitive: false,
            exactMatch: false,
            activeMatchIndex: 0,
            matchInfoCache: []
        };
        this.rowList.forEach(function (row) {
            if (row.cells) {
                row.cells.forEach(function (c) {
                    c.clearHighlight();
                });
            }
        });
    };
    Object.defineProperty(IgxGridBaseComponent.prototype, "hasSortableColumns", {
        /**
         * Returns if the `IgxGridComponent` has sortable columns.
         * ```typescript
         * const sortableGrid = this.grid.hasSortableColumns;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns if the `IgxGridComponent` has sortable columns.
         * ```typescript
         * const sortableGrid = this.grid.hasSortableColumns;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this.columnList.some(function (col) { return col.sortable; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "hasEditableColumns", {
        /**
         * Returns if the `IgxGridComponent` has editable columns.
         * ```typescript
         * const editableGrid = this.grid.hasEditableColumns;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns if the `IgxGridComponent` has editable columns.
         * ```typescript
         * const editableGrid = this.grid.hasEditableColumns;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this.columnList.some(function (col) { return col.editable; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "hasFilterableColumns", {
        /**
         * Returns if the `IgxGridComponent` has fiterable columns.
         * ```typescript
         * const filterableGrid = this.grid.hasFilterableColumns;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns if the `IgxGridComponent` has fiterable columns.
         * ```typescript
         * const filterableGrid = this.grid.hasFilterableColumns;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this.columnList.some(function (col) { return col.filterable; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "hasSummarizedColumns", {
        /**
         * Returns if the `IgxGridComponent` has summarized columns.
         * ```typescript
         * const summarizedGrid = this.grid.hasSummarizedColumns;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns if the `IgxGridComponent` has summarized columns.
         * ```typescript
         * const summarizedGrid = this.grid.hasSummarizedColumns;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this.summaryService.hasSummarizedColumns;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "rootSummariesEnabled", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.summaryCalculationMode !== GridSummaryCalculationMode.childLevelsOnly;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "hasMovableColumns", {
        /**
         * Returns if the `IgxGridComponent` has moveable columns.
         * ```typescript
         * const movableGrid = this.grid.hasMovableColumns;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns if the `IgxGridComponent` has moveable columns.
         * ```typescript
         * const movableGrid = this.grid.hasMovableColumns;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this.columnList && this.columnList.some(function (col) { return col.movable; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "hasColumnGroups", {
        /**
         * Returns if the `IgxGridComponent` has column groups.
         * ```typescript
         * const groupGrid = this.grid.hasColumnGroups;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns if the `IgxGridComponent` has column groups.
         * ```typescript
         * const groupGrid = this.grid.hasColumnGroups;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this._columnGroups;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "hasColumnLayouts", {
        /**
         * Returns if the `IgxGridComponent` has column layouts for multi-row layout definition.
         * ```typescript
         * const layoutGrid = this.grid.hasColumnLayouts;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns if the `IgxGridComponent` has column layouts for multi-row layout definition.
         * ```typescript
         * const layoutGrid = this.grid.hasColumnLayouts;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return !!this.columnList.some(function (col) { return col.columnLayout; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "selectedCells", {
        /**
         * Returns an array of the selected `IgxGridCellComponent`s.
         * ```typescript
         * const selectedCells = this.grid.selectedCells;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns an array of the selected `IgxGridCellComponent`s.
         * ```typescript
         * const selectedCells = this.grid.selectedCells;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            if (this.dataRowList) {
                return this.dataRowList.map(function (row) { return row.cells.filter(function (cell) { return cell.selected; }); })
                    .reduce(function (a, b) { return a.concat(b); }, []);
            }
            return [];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "multiRowLayoutRowSize", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._multiRowLayoutRowSize;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "rowBasedHeight", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @protected
         * @return {?}
         */
        function () {
            return this.dataLength * this.rowHeight;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "isPercentWidth", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @protected
         * @return {?}
         */
        function () {
            return this._width && this._width.indexOf('%') !== -1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "isPercentHeight", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @protected
         * @return {?}
         */
        function () {
            return this._height && this._height.indexOf('%') !== -1;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     * Sets this._height
     */
    /**
     * @hidden
     * Sets this._height
     * @protected
     * @return {?}
     */
    IgxGridBaseComponent.prototype._derivePossibleHeight = /**
     * @hidden
     * Sets this._height
     * @protected
     * @return {?}
     */
    function () {
        if (!this.isPercentHeight || !this._height || !this.isAttachedToDom || this.rowBasedHeight === 0) {
            return;
        }
        if (!this.nativeElement.parentNode || !this.nativeElement.parentNode.clientHeight) {
            /** @type {?} */
            var viewPortHeight = document.documentElement.clientHeight;
            this._height = this.rowBasedHeight <= viewPortHeight ? null : viewPortHeight.toString();
        }
        else {
            /** @type {?} */
            var parentHeight = this.nativeElement.parentNode.getBoundingClientRect().height;
            this._height = this.rowBasedHeight <= parentHeight ? null : this._height;
        }
    };
    /**
     * @hidden
     * Sets columns defaultWidth property
     */
    /**
     * @hidden
     * Sets columns defaultWidth property
     * @protected
     * @return {?}
     */
    IgxGridBaseComponent.prototype._derivePossibleWidth = /**
     * @hidden
     * Sets columns defaultWidth property
     * @protected
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.columnWidthSetByUser) {
            this._columnWidth = this.getPossibleColumnWidth();
            this.columnList.forEach(function (column) {
                if (_this.hasColumnLayouts && parseInt(_this._columnWidth, 10)) {
                    /** @type {?} */
                    var columnWidthCombined = parseInt(_this._columnWidth, 10) * (column.colEnd ? column.colEnd - column.colStart : 1);
                    column.defaultWidth = columnWidthCombined + 'px';
                }
                else {
                    column.defaultWidth = _this._columnWidth;
                }
            });
            this.resetCachedWidths();
        }
    };
    Object.defineProperty(IgxGridBaseComponent.prototype, "defaultTargetBodyHeight", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @protected
         * @return {?}
         */
        function () {
            /** @type {?} */
            var allItems = this.totalItemCount || this.dataLength;
            return this.rowHeight * Math.min(this._defaultTargetRecordNumber, this.paging ? Math.min(allItems, this.perPage) : allItems);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     * Sets TBODY height i.e. this.calcHeight
     */
    /**
     * @hidden
     * Sets TBODY height i.e. this.calcHeight
     * @protected
     * @return {?}
     */
    IgxGridBaseComponent.prototype.calculateGridHeight = /**
     * @hidden
     * Sets TBODY height i.e. this.calcHeight
     * @protected
     * @return {?}
     */
    function () {
        this._derivePossibleHeight();
        // TODO: Calculate based on grid density
        if (this.maxLevelHeaderDepth) {
            this.theadRow.nativeElement.style.height = (this.maxLevelHeaderDepth + 1) * this.defaultRowHeight +
                (this.allowFiltering && this.filterMode === FilterMode.quickFilter ? FILTER_ROW_HEIGHT : 0) + 1 + "px";
        }
        this.summariesHeight = 0;
        if (!this._height) {
            this.calcHeight = null;
            if (this.hasSummarizedColumns && this.rootSummariesEnabled) {
                this.summariesHeight = this.summaryService.calcMaxSummaryHeight();
            }
            return;
        }
        if (this.hasSummarizedColumns && this.rootSummariesEnabled) {
            this.summariesHeight = this.summaryService.calcMaxSummaryHeight();
        }
        this.calcHeight = this._calculateGridBodyHeight();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    IgxGridBaseComponent.prototype.getGroupAreaHeight = /**
     * @hidden
     * @protected
     * @return {?}
     */
    function () {
        return 0;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    IgxGridBaseComponent.prototype.getToolbarHeight = /**
     * @hidden
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var toolbarHeight = 0;
        if (this.showToolbar && this.toolbarHtml != null) {
            toolbarHeight = this.toolbarHtml.nativeElement.firstElementChild ?
                this.toolbarHtml.nativeElement.offsetHeight : 0;
        }
        return toolbarHeight;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    IgxGridBaseComponent.prototype.getPagingHeight = /**
     * @hidden
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var pagingHeight = 0;
        if (this.paging && this.paginator) {
            pagingHeight = this.paginator.nativeElement.firstElementChild ?
                this.paginator.nativeElement.offsetHeight : 0;
        }
        return pagingHeight;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    IgxGridBaseComponent.prototype._calculateGridBodyHeight = /**
     * @hidden
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var footerBordersAndScrollbars = this.tfoot.nativeElement.offsetHeight -
            this.tfoot.nativeElement.clientHeight;
        /** @type {?} */
        var computed = this.document.defaultView.getComputedStyle(this.nativeElement);
        /** @type {?} */
        var toolbarHeight = this.getToolbarHeight();
        /** @type {?} */
        var pagingHeight = this.getPagingHeight();
        /** @type {?} */
        var groupAreaHeight = this.getGroupAreaHeight();
        /** @type {?} */
        var gridHeight;
        if (this.isPercentHeight) {
            /*height in %*/
            if (computed.getPropertyValue('height').indexOf('%') === -1) {
                gridHeight = parseInt(computed.getPropertyValue('height'), 10);
            }
            else {
                return this.defaultTargetBodyHeight;
            }
        }
        else {
            gridHeight = parseInt(this._height, 10);
        }
        /** @type {?} */
        var height = Math.abs(gridHeight - toolbarHeight -
            this.theadRow.nativeElement.offsetHeight -
            this.summariesHeight - pagingHeight -
            groupAreaHeight - footerBordersAndScrollbars -
            this.scr.nativeElement.clientHeight);
        if (height === 0 || isNaN(gridHeight)) {
            /** @type {?} */
            var bodyHeight = this.defaultTargetBodyHeight;
            return bodyHeight > 0 ? bodyHeight : null;
        }
        return height;
    };
    Object.defineProperty(IgxGridBaseComponent.prototype, "outerWidth", {
        get: /**
         * @return {?}
         */
        function () {
            return this.hasVerticalSroll() ? this.calcWidth + this.scrollWidth : this.calcWidth;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     * Gets the visible content height that includes header + tbody + footer.
     */
    /**
     * @hidden
     * Gets the visible content height that includes header + tbody + footer.
     * @return {?}
     */
    IgxGridBaseComponent.prototype.getVisibleContentHeight = /**
     * @hidden
     * Gets the visible content height that includes header + tbody + footer.
     * @return {?}
     */
    function () {
        /** @type {?} */
        var height = this.theadRow.nativeElement.clientHeight + this.tbody.nativeElement.clientHeight;
        if (this.hasSummarizedColumns) {
            height += this.tfoot.nativeElement.clientHeight;
        }
        return height;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?=} baseWidth
     * @return {?}
     */
    IgxGridBaseComponent.prototype.getPossibleColumnWidth = /**
     * @hidden
     * @param {?=} baseWidth
     * @return {?}
     */
    function (baseWidth) {
        if (baseWidth === void 0) { baseWidth = null; }
        /** @type {?} */
        var computedWidth;
        if (baseWidth !== null) {
            computedWidth = baseWidth;
        }
        else {
            computedWidth = this.calcWidth ||
                parseInt(this.document.defaultView.getComputedStyle(this.nativeElement).getPropertyValue('width'), 10);
        }
        if (this.showRowCheckboxes) {
            computedWidth -= this.headerCheckboxContainer ? this.headerCheckboxContainer.nativeElement.offsetWidth : 0;
        }
        /** @type {?} */
        var visibleChildColumns = this.visibleColumns.filter(function (c) { return !c.columnGroup; });
        // Column layouts related
        /** @type {?} */
        var visibleCols = [];
        /** @type {?} */
        var columnBlocks = this.visibleColumns.filter(function (c) { return c.columnGroup; });
        /** @type {?} */
        var colsPerBlock = columnBlocks.map(function (block) { return block.getInitialChildColumnSizes(block.children); });
        /** @type {?} */
        var combinedBlocksSize = colsPerBlock.reduce(function (acc, item) { return acc + item.length; }, 0);
        colsPerBlock.forEach(function (blockCols) { return visibleCols = visibleCols.concat(blockCols); });
        //
        /** @type {?} */
        var columnsWithSetWidths = this.hasColumnLayouts ?
            visibleCols.filter(function (c) { return c.widthSetByUser; }) :
            visibleChildColumns.filter(function (c) { return c.widthSetByUser; });
        /** @type {?} */
        var columnsToSize = this.hasColumnLayouts ?
            combinedBlocksSize - columnsWithSetWidths.length :
            visibleChildColumns.length - columnsWithSetWidths.length;
        /** @type {?} */
        var sumExistingWidths = columnsWithSetWidths
            .reduce(function (prev, curr) {
            /** @type {?} */
            var colWidth = curr.width;
            /** @type {?} */
            var widthValue = parseInt(colWidth, 10);
            /** @type {?} */
            var currWidth = colWidth && typeof colWidth === 'string' && colWidth.indexOf('%') !== -1 ?
                widthValue / 100 * computedWidth :
                widthValue;
            return prev + currWidth;
        }, 0);
        /** @type {?} */
        var columnWidth = Math.floor(!Number.isFinite(sumExistingWidths) ?
            Math.max(computedWidth / columnsToSize, MINIMUM_COLUMN_WIDTH) :
            Math.max((computedWidth - sumExistingWidths) / columnsToSize, MINIMUM_COLUMN_WIDTH));
        return columnWidth.toString();
    };
    /**
     * @hidden
     * Sets grid width i.e. this.calcWidth
     */
    /**
     * @hidden
     * Sets grid width i.e. this.calcWidth
     * @protected
     * @return {?}
     */
    IgxGridBaseComponent.prototype.calculateGridWidth = /**
     * @hidden
     * Sets grid width i.e. this.calcWidth
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var width;
        /** @type {?} */
        var computed = this.document.defaultView.getComputedStyle(this.nativeElement);
        /** @type {?} */
        var el = this.document.getElementById(this.nativeElement.id);
        if (this.isPercentWidth) {
            /* width in %*/
            width = computed.getPropertyValue('width').indexOf('%') === -1 ?
                parseInt(computed.getPropertyValue('width'), 10) : null;
        }
        else {
            width = parseInt(this._width, 10);
        }
        if (!width && el) {
            width = el.offsetWidth;
        }
        if (!width) {
            width = this.columnList.reduce(function (sum, item) { return sum + parseInt((item.width || item.defaultWidth), 10); }, 0);
        }
        if (this.hasVerticalSroll()) {
            width -= this.scrollWidth;
        }
        if (Number.isFinite(width) && width !== this.calcWidth) {
            this.calcWidth = width;
            this.cdr.detectChanges();
        }
        this._derivePossibleWidth();
    };
    /**
     * @return {?}
     */
    IgxGridBaseComponent.prototype.hasVerticalSroll = /**
     * @return {?}
     */
    function () {
        if (!this._ngAfterViewInitPassed) {
            return false;
        }
        /** @type {?} */
        var isScrollable = this.verticalScrollContainer.isScrollable();
        return !!(this.calcWidth && this.verticalScrollContainer.igxForOf &&
            this.verticalScrollContainer.igxForOf.length > 0 &&
            isScrollable);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} change
     * @return {?}
     */
    IgxGridBaseComponent.prototype.onColumnsChanged = /**
     * @hidden
     * @protected
     * @param {?} change
     * @return {?}
     */
    function (change) {
        var _this = this;
        /** @type {?} */
        var diff = this.columnListDiffer.diff(change);
        if (diff) {
            /** @type {?} */
            var added_1 = false;
            /** @type {?} */
            var removed_1 = false;
            this.initColumns(this.columnList);
            diff.forEachAddedItem(function (record) {
                _this.onColumnInit.emit(record.item);
                added_1 = true;
            });
            diff.forEachRemovedItem(function (record) {
                // Clear Filtering
                _this.gridAPI.clear_filter(record.item.field);
                // Clear Sorting
                _this.gridAPI.clear_sort(record.item.field);
                removed_1 = true;
            });
            this.resetCaches();
            if (added_1 || removed_1) {
                this.summaryService.clearSummaryCache();
                this.calculateGridSizes();
            }
        }
        this.markForCheck();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    IgxGridBaseComponent.prototype.calculateGridSizes = /**
     * @hidden
     * @protected
     * @return {?}
     */
    function () {
        /*
            TODO: (R.K.) This layered lasagne should be refactored
            ASAP. The reason I have to reset the caches so many times is because
            after teach `detectChanges` call they are filled with invalid
            state. Of course all of this happens midway through the grid
            sizing process which of course, uses values from the caches, thus resulting
            in a broken layout.
        */
        this.resetCaches();
        /** @type {?} */
        var hasScroll = this.hasVerticalSroll();
        this.calculateGridWidth();
        this.cdr.detectChanges();
        this.resetCaches();
        this.calculateGridHeight();
        if (this.rowEditable) {
            this.repositionRowEditingOverlay(this.rowInEditMode);
        }
        this.cdr.detectChanges();
        this.resetCaches();
        // in case scrollbar has appeared recalc to size correctly.
        if (hasScroll !== this.hasVerticalSroll()) {
            this.calculateGridWidth();
            this.cdr.detectChanges();
            this.resetCaches();
        }
    };
    /**
     * @hidden
     * Gets the combined width of the columns that are specific to the enabled grid features. They are fixed.
     * Method used to override the calculations.
     * TODO: Remove for Angular 8. Calling parent class getter using super is not supported for now.
     */
    /**
     * @hidden
     * Gets the combined width of the columns that are specific to the enabled grid features. They are fixed.
     * Method used to override the calculations.
     * TODO: Remove for Angular 8. Calling parent class getter using super is not supported for now.
     * @return {?}
     */
    IgxGridBaseComponent.prototype.getFeatureColumnsWidth = /**
     * @hidden
     * Gets the combined width of the columns that are specific to the enabled grid features. They are fixed.
     * Method used to override the calculations.
     * TODO: Remove for Angular 8. Calling parent class getter using super is not supported for now.
     * @return {?}
     */
    function () {
        /** @type {?} */
        var width = 0;
        if (this.headerCheckboxContainer) {
            width += this.headerCheckboxContainer.nativeElement.getBoundingClientRect().width;
        }
        if (this.headerDragContainer) {
            width += this.headerDragContainer.nativeElement.getBoundingClientRect().width;
        }
        return width;
    };
    /**
     * Gets calculated width of the pinned area.
     * ```typescript
     * const pinnedWidth = this.grid.getPinnedWidth();
     * ```
     * @param takeHidden If we should take into account the hidden columns in the pinned area.
     * @memberof IgxGridBaseComponent
     */
    /**
     * Gets calculated width of the pinned area.
     * ```typescript
     * const pinnedWidth = this.grid.getPinnedWidth();
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?=} takeHidden If we should take into account the hidden columns in the pinned area.
     * @return {?}
     */
    IgxGridBaseComponent.prototype.getPinnedWidth = /**
     * Gets calculated width of the pinned area.
     * ```typescript
     * const pinnedWidth = this.grid.getPinnedWidth();
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?=} takeHidden If we should take into account the hidden columns in the pinned area.
     * @return {?}
     */
    function (takeHidden) {
        if (takeHidden === void 0) { takeHidden = false; }
        var e_1, _a;
        /** @type {?} */
        var fc = takeHidden ? this._pinnedColumns : this.pinnedColumns;
        /** @type {?} */
        var sum = 0;
        try {
            for (var fc_1 = __values(fc), fc_1_1 = fc_1.next(); !fc_1_1.done; fc_1_1 = fc_1.next()) {
                var col = fc_1_1.value;
                if (col.level === 0) {
                    sum += parseInt(col.width, 10);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (fc_1_1 && !fc_1_1.done && (_a = fc_1.return)) _a.call(fc_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        sum += this.featureColumnsWidth;
        return sum;
    };
    /**
     * @hidden
     * Gets calculated width of the unpinned area
     * @param takeHidden If we should take into account the hidden columns in the pinned area.
     * @memberof IgxGridBaseComponent
     */
    /**
     * @hidden
     * Gets calculated width of the unpinned area
     * \@memberof IgxGridBaseComponent
     * @protected
     * @param {?=} takeHidden If we should take into account the hidden columns in the pinned area.
     * @return {?}
     */
    IgxGridBaseComponent.prototype.getUnpinnedWidth = /**
     * @hidden
     * Gets calculated width of the unpinned area
     * \@memberof IgxGridBaseComponent
     * @protected
     * @param {?=} takeHidden If we should take into account the hidden columns in the pinned area.
     * @return {?}
     */
    function (takeHidden) {
        if (takeHidden === void 0) { takeHidden = false; }
        /** @type {?} */
        var width = this.isPercentWidth ?
            this.calcWidth :
            parseInt(this._width, 10);
        if (this.hasVerticalSroll() && !this.isPercentWidth) {
            width -= this.scrollWidth;
        }
        return width - this.getPinnedWidth(takeHidden);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} fieldName
     * @param {?} hasSummary
     * @param {?=} summaryOperand
     * @return {?}
     */
    IgxGridBaseComponent.prototype._summaries = /**
     * @hidden
     * @protected
     * @param {?} fieldName
     * @param {?} hasSummary
     * @param {?=} summaryOperand
     * @return {?}
     */
    function (fieldName, hasSummary, summaryOperand) {
        /** @type {?} */
        var column = this.gridAPI.get_column_by_name(fieldName);
        if (column) {
            column.hasSummary = hasSummary;
            if (summaryOperand) {
                if (this.rootSummariesEnabled) {
                    this.summaryService.retriggerRootPipe++;
                }
                column.summaries = summaryOperand;
            }
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} expressions
     * @param {?} hasSummary
     * @return {?}
     */
    IgxGridBaseComponent.prototype._multipleSummaries = /**
     * @hidden
     * @protected
     * @param {?} expressions
     * @param {?} hasSummary
     * @return {?}
     */
    function (expressions, hasSummary) {
        var _this = this;
        expressions.forEach(function (element) {
            _this._summaries(element.fieldName, hasSummary, element.customSummary);
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} expressions
     * @return {?}
     */
    IgxGridBaseComponent.prototype._disableMultipleSummaries = /**
     * @hidden
     * @protected
     * @param {?} expressions
     * @return {?}
     */
    function (expressions) {
        var _this = this;
        expressions.forEach(function (column) {
            /** @type {?} */
            var columnName = column && column.fieldName ? column.fieldName : column;
            _this._summaries(columnName, false);
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} rec
     * @return {?}
     */
    IgxGridBaseComponent.prototype.resolveDataTypes = /**
     * @hidden
     * @protected
     * @param {?} rec
     * @return {?}
     */
    function (rec) {
        if (typeof rec === 'number') {
            return DataType.Number;
        }
        else if (typeof rec === 'boolean') {
            return DataType.Boolean;
        }
        else if (typeof rec === 'object' && rec instanceof Date) {
            return DataType.Date;
        }
        return DataType.String;
    };
    /**
     * @private
     * @return {?}
     */
    IgxGridBaseComponent.prototype.getScrollWidth = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var div = document.createElement('div');
        /** @type {?} */
        var style$$1 = div.style;
        style$$1.width = '100px';
        style$$1.height = '100px';
        style$$1.position = 'absolute';
        style$$1.top = '-10000px';
        style$$1.top = '-10000px';
        style$$1.overflow = 'scroll';
        document.body.appendChild(div);
        /** @type {?} */
        var scrollWidth = div.offsetWidth - div.clientWidth;
        document.body.removeChild(div);
        return scrollWidth;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    IgxGridBaseComponent.prototype.autogenerateColumns = /**
     * @hidden
     * @protected
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var data = this.gridAPI.get_data();
        /** @type {?} */
        var factory = this.resolver.resolveComponentFactory(IgxColumnComponent);
        /** @type {?} */
        var fields = this.generateDataFields(data);
        /** @type {?} */
        var columns = [];
        fields.forEach(function (field) {
            /** @type {?} */
            var ref = _this.viewRef.createComponent(factory, null, _this.viewRef.injector);
            ref.instance.field = field;
            ref.instance.dataType = _this.resolveDataTypes(data[0][field]);
            ref.changeDetectorRef.detectChanges();
            columns.push(ref.instance);
        });
        this.columnList.reset(columns);
        if (data && data.length > 0) {
            this.shouldGenerate = false;
        }
    };
    /**
     * @protected
     * @param {?} data
     * @return {?}
     */
    IgxGridBaseComponent.prototype.generateDataFields = /**
     * @protected
     * @param {?} data
     * @return {?}
     */
    function (data) {
        return Object.keys(data && data.length !== 0 ? data[0] : []);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} arr
     * @return {?}
     */
    IgxGridBaseComponent.prototype.onlyTopLevel = /**
     * @hidden
     * @param {?} arr
     * @return {?}
     */
    function (arr) {
        return arr.filter(function (c) { return c.level === 0; });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} collection
     * @param {?=} cb
     * @return {?}
     */
    IgxGridBaseComponent.prototype.initColumns = /**
     * @hidden
     * @protected
     * @param {?} collection
     * @param {?=} cb
     * @return {?}
     */
    function (collection, cb) {
        var _this = this;
        if (cb === void 0) { cb = null; }
        // XXX: Deprecate index
        this._columnGroups = this.columnList.some(function (col) { return col.columnGroup; });
        if (this.hasColumnLayouts) {
            // Set overall row layout size
            this.columnList.forEach(function (col) {
                if (col.columnLayout) {
                    /** @type {?} */
                    var layoutSize = col.children ?
                        col.children.reduce(function (acc, val) { return Math.max(val.rowStart + val.gridRowSpan - 1, acc); }, 1) :
                        1;
                    _this._multiRowLayoutRowSize = Math.max(layoutSize, _this._multiRowLayoutRowSize);
                }
            });
        }
        if (this.hasColumnLayouts && this.hasColumnGroups) {
            // invalid configuration - multi-row and column groups
            // remove column groups
            /** @type {?} */
            var columnLayoutColumns = this.columnList.filter(function (col) { return col.columnLayout || (col.parent && col.parent.columnLayout); });
            this.columnList.reset(columnLayoutColumns);
        }
        this._columns = this.columnList.toArray();
        collection.forEach(function (column) {
            column.grid = _this;
            column.defaultWidth = _this.columnWidth;
            _this.setColumnEditState(column);
            if (cb) {
                cb(column);
            }
        });
        this.reinitPinStates();
    };
    /**
     * @private
     * @param {?} column
     * @return {?}
     */
    IgxGridBaseComponent.prototype.setColumnEditState = /**
     * @private
     * @param {?} column
     * @return {?}
     */
    function (column) {
        // When rowEditable is true, then all columns, with defined field, excluding priamaryKey, are set to editable by default.
        if (this.rowEditable && column.editable === null &&
            column.field && column.field !== this.primaryKey) {
            column.editable = this.rowEditable;
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    IgxGridBaseComponent.prototype.reinitPinStates = /**
     * @hidden
     * @protected
     * @return {?}
     */
    function () {
        if (this.hasColumnGroups) {
            this._pinnedColumns = this.columnList.filter(function (c) { return c.pinned; });
        }
        this._unpinnedColumns = this.columnList.filter(function (c) { return !c.pinned; });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} fieldName
     * @return {?}
     */
    IgxGridBaseComponent.prototype.isColumnGrouped = /**
     * @hidden
     * @param {?} fieldName
     * @return {?}
     */
    function (fieldName) {
        return false;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @param {?} filteredData
     * @return {?}
     */
    IgxGridBaseComponent.prototype.onHeaderCheckboxClick = /**
     * @hidden
     * @param {?} event
     * @param {?} filteredData
     * @return {?}
     */
    function (event, filteredData) {
        this.allRowsSelected = event.checked;
        /** @type {?} */
        var newSelection = event.checked ?
            filteredData ?
                this.selection.add_items(this.id, this.selection.get_all_ids(filteredData, this.primaryKey)) :
                this.selection.get_all_ids(this.gridAPI.get_all_data(true), this.primaryKey) :
            filteredData ?
                this.selection.delete_items(this.id, this.selection.get_all_ids(filteredData, this.primaryKey)) :
                this.selection.get_empty();
        this.triggerRowSelectionChange(newSelection, null, event, event.checked);
        this.checkHeaderCheckboxStatus(event.checked);
    };
    Object.defineProperty(IgxGridBaseComponent.prototype, "headerCheckboxAriaLabel", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._filteringExpressionsTree.filteringOperands.length > 0 ?
                this.headerCheckbox && this.headerCheckbox.checked ? 'Deselect all filtered' : 'Select all filtered' :
                this.headerCheckbox && this.headerCheckbox.checked ? 'Deselect all' : 'Select all';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?=} headerStatus
     * @return {?}
     */
    IgxGridBaseComponent.prototype.checkHeaderCheckboxStatus = /**
     * @hidden
     * @param {?=} headerStatus
     * @return {?}
     */
    function (headerStatus) {
        if (headerStatus === undefined) {
            /** @type {?} */
            var filteredData = this.filteringService.filteredData;
            /** @type {?} */
            var dataLength = filteredData ? filteredData.length : this.dataLength;
            this.allRowsSelected = this.selection.are_all_selected(this.id, dataLength);
            if (this.headerCheckbox) {
                this.headerCheckbox.indeterminate = !this.allRowsSelected && !this.selection.are_none_selected(this.id);
                if (!this.headerCheckbox.indeterminate) {
                    this.headerCheckbox.checked =
                        this.allRowsSelected;
                }
            }
            this.cdr.markForCheck();
        }
        else if (this.headerCheckbox) {
            this.headerCheckbox.checked = headerStatus !== undefined ? headerStatus : false;
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} componentID
     * @param {?} filteredData
     * @param {?=} primaryKey
     * @return {?}
     */
    IgxGridBaseComponent.prototype.filteredItemsStatus = /**
     * @hidden
     * @param {?} componentID
     * @param {?} filteredData
     * @param {?=} primaryKey
     * @return {?}
     */
    function (componentID, filteredData, primaryKey) {
        var e_2, _a;
        /** @type {?} */
        var currSelection = this.selection.get(componentID);
        /** @type {?} */
        var atLeastOneSelected = false;
        /** @type {?} */
        var notAllSelected = false;
        if (currSelection) {
            try {
                for (var _b = __values(Object.keys(filteredData)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var key = _c.value;
                    /** @type {?} */
                    var dataItem = primaryKey ? filteredData[key][primaryKey] : filteredData[key];
                    if (currSelection.has(dataItem)) {
                        atLeastOneSelected = true;
                        if (notAllSelected) {
                            return 'indeterminate';
                        }
                    }
                    else {
                        notAllSelected = true;
                        if (atLeastOneSelected) {
                            return 'indeterminate';
                        }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
        return atLeastOneSelected ? 'allSelected' : 'noneSelected';
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} data
     * @return {?}
     */
    IgxGridBaseComponent.prototype.updateHeaderCheckboxStatusOnFilter = /**
     * @hidden
     * @param {?} data
     * @return {?}
     */
    function (data) {
        if (!data) {
            this.checkHeaderCheckboxStatus();
            return;
        }
        switch (this.filteredItemsStatus(this.id, data, this.primaryKey)) {
            case 'allSelected': {
                if (!this.allRowsSelected) {
                    this.allRowsSelected = true;
                }
                if (this.headerCheckbox.indeterminate) {
                    this.headerCheckbox.indeterminate = false;
                }
                break;
            }
            case 'noneSelected': {
                if (this.allRowsSelected) {
                    this.allRowsSelected = false;
                }
                if (this.headerCheckbox.indeterminate) {
                    this.headerCheckbox.indeterminate = false;
                }
                break;
            }
            default: {
                if (!this.headerCheckbox.indeterminate) {
                    this.headerCheckbox.indeterminate = true;
                }
                if (this.allRowsSelected) {
                    this.allRowsSelected = false;
                }
                break;
            }
        }
    };
    /**
     * Get current selection state.
     * Returns an array with selected rows' IDs (primaryKey or rowData)
     * ```typescript
     * const selectedRows = this.grid.selectedRows();
     * ```
     * @memberof IgxGridBaseComponent
     */
    /**
     * Get current selection state.
     * Returns an array with selected rows' IDs (primaryKey or rowData)
     * ```typescript
     * const selectedRows = this.grid.selectedRows();
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    IgxGridBaseComponent.prototype.selectedRows = /**
     * Get current selection state.
     * Returns an array with selected rows' IDs (primaryKey or rowData)
     * ```typescript
     * const selectedRows = this.grid.selectedRows();
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    function () {
        /** @type {?} */
        var selection;
        selection = this.selection.get(this.id);
        return selection ? Array.from(selection) : [];
    };
    /**
     * Select specified rows by ID.
     * ```typescript
     * this.grid.selectRows([1,2,5], true);
     * ```
     * @param rowIDs
     * @param clearCurrentSelection if true clears the current selection
     * @memberof IgxGridBaseComponent
     */
    /**
     * Select specified rows by ID.
     * ```typescript
     * this.grid.selectRows([1,2,5], true);
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} rowIDs
     * @param {?=} clearCurrentSelection if true clears the current selection
     * @return {?}
     */
    IgxGridBaseComponent.prototype.selectRows = /**
     * Select specified rows by ID.
     * ```typescript
     * this.grid.selectRows([1,2,5], true);
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} rowIDs
     * @param {?=} clearCurrentSelection if true clears the current selection
     * @return {?}
     */
    function (rowIDs, clearCurrentSelection) {
        var _this = this;
        /** @type {?} */
        var newSelection;
        /** @type {?} */
        var selectableRows = [];
        if (this.transactions.enabled) {
            selectableRows = rowIDs.filter(function (e) { return !_this.gridAPI.row_deleted_transaction(e); });
        }
        else {
            selectableRows = rowIDs;
        }
        newSelection = this.selection.add_items(this.id, selectableRows, clearCurrentSelection);
        this.triggerRowSelectionChange(newSelection);
    };
    /**
     * Deselect specified rows by ID.
     * ```typescript
     * this.grid.deselectRows([1,2,5]);
     * ```
     * @param rowIDs
     * @memberof IgxGridBaseComponent
     */
    /**
     * Deselect specified rows by ID.
     * ```typescript
     * this.grid.deselectRows([1,2,5]);
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} rowIDs
     * @return {?}
     */
    IgxGridBaseComponent.prototype.deselectRows = /**
     * Deselect specified rows by ID.
     * ```typescript
     * this.grid.deselectRows([1,2,5]);
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} rowIDs
     * @return {?}
     */
    function (rowIDs) {
        /** @type {?} */
        var newSelection;
        newSelection = this.selection.delete_items(this.id, rowIDs);
        this.triggerRowSelectionChange(newSelection);
    };
    /**
     * Selects all rows
     * Note: If filtering is in place, selectAllRows() and deselectAllRows() select/deselect all filtered rows.
     * ```typescript
     * this.grid.selectAllRows();
     * ```
     * @memberof IgxGridBaseComponent
     */
    /**
     * Selects all rows
     * Note: If filtering is in place, selectAllRows() and deselectAllRows() select/deselect all filtered rows.
     * ```typescript
     * this.grid.selectAllRows();
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    IgxGridBaseComponent.prototype.selectAllRows = /**
     * Selects all rows
     * Note: If filtering is in place, selectAllRows() and deselectAllRows() select/deselect all filtered rows.
     * ```typescript
     * this.grid.selectAllRows();
     * ```
     * \@memberof IgxGridBaseComponent
     * @return {?}
     */
    function () {
        this.triggerRowSelectionChange(this.selection.get_all_ids(this.gridAPI.get_all_data(true), this.primaryKey));
    };
    /**
     * Deselects all rows
     * ```typescript
     * this.grid.deselectAllRows();
     * ```
     * Note: If filtering is in place, selectAllRows() and deselectAllRows() select/deselect all filtered rows.
     */
    /**
     * Deselects all rows
     * ```typescript
     * this.grid.deselectAllRows();
     * ```
     * Note: If filtering is in place, selectAllRows() and deselectAllRows() select/deselect all filtered rows.
     * @return {?}
     */
    IgxGridBaseComponent.prototype.deselectAllRows = /**
     * Deselects all rows
     * ```typescript
     * this.grid.deselectAllRows();
     * ```
     * Note: If filtering is in place, selectAllRows() and deselectAllRows() select/deselect all filtered rows.
     * @return {?}
     */
    function () {
        this.triggerRowSelectionChange(this.selection.get_empty());
    };
    /**
     * @return {?}
     */
    IgxGridBaseComponent.prototype.clearCellSelection = /**
     * @return {?}
     */
    function () {
        this.selectionService.clear();
        this.selectionService.activeElement = null;
        this.cdr.markForCheck();
    };
    /**
     * @param {?} dir
     * @return {?}
     */
    IgxGridBaseComponent.prototype.dragScroll = /**
     * @param {?} dir
     * @return {?}
     */
    function (dir) {
        /** @type {?} */
        var scrollDelta = 48;
        /** @type {?} */
        var horizontal = this.parentVirtDir.getHorizontalScroll();
        /** @type {?} */
        var vertical = this.verticalScrollContainer.getVerticalScroll();
        switch (dir) {
            case DragScrollDirection.LEFT:
                horizontal.scrollLeft -= scrollDelta;
                break;
            case DragScrollDirection.RIGHT:
                horizontal.scrollLeft += scrollDelta;
                break;
            case DragScrollDirection.TOP:
                vertical.scrollTop -= scrollDelta;
                break;
            case DragScrollDirection.BOTTOM:
                vertical.scrollTop += scrollDelta;
                break;
            case DragScrollDirection.BOTTOMLEFT:
                horizontal.scrollLeft -= scrollDelta;
                vertical.scrollTop += scrollDelta;
                break;
            case DragScrollDirection.BOTTOMRIGHT:
                horizontal.scrollLeft += scrollDelta;
                vertical.scrollTop += scrollDelta;
                break;
            case DragScrollDirection.TOPLEFT:
                horizontal.scrollLeft -= scrollDelta;
                vertical.scrollTop -= scrollDelta;
                break;
            case DragScrollDirection.TOPRIGHT:
                horizontal.scrollLeft += scrollDelta;
                vertical.scrollTop -= scrollDelta;
                break;
            default:
                return;
        }
        this.wheelHandler();
    };
    /**
     * @param {?} arg
     * @return {?}
     */
    IgxGridBaseComponent.prototype.isDefined = /**
     * @param {?} arg
     * @return {?}
     */
    function (arg) {
        return arg !== undefined && arg !== null;
    };
    /**
     * @param {?} arg
     * @return {?}
     */
    IgxGridBaseComponent.prototype.selectRange = /**
     * @param {?} arg
     * @return {?}
     */
    function (arg) {
        var _this = this;
        if (!this.isDefined(arg)) {
            this.clearCellSelection();
            return;
        }
        if (arg instanceof Array) {
            arg.forEach(function (range) { return _this.setSelection(range); });
        }
        else {
            this.setSelection(arg);
        }
        this.cdr.markForCheck();
    };
    /**
     * @param {?} field
     * @return {?}
     */
    IgxGridBaseComponent.prototype.columnToVisibleIndex = /**
     * @param {?} field
     * @return {?}
     */
    function (field) {
        /** @type {?} */
        var visibleColumns = this.visibleColumns;
        if (typeof field === 'number') {
            return field;
        }
        return visibleColumns.find(function (column) { return column.field === field; }).visibleIndex;
    };
    /**
     * @param {?} range
     * @return {?}
     */
    IgxGridBaseComponent.prototype.setSelection = /**
     * @param {?} range
     * @return {?}
     */
    function (range) {
        /** @type {?} */
        var startNode = { row: range.rowStart, column: this.columnToVisibleIndex(range.columnStart) };
        /** @type {?} */
        var endNode = { row: range.rowEnd, column: this.columnToVisibleIndex(range.columnEnd) };
        this.selectionService.pointerState.node = startNode;
        this.selectionService.selectRange(endNode, this.selectionService.pointerState);
        this.selectionService.addRangeMeta(endNode, this.selectionService.pointerState);
        this.selectionService.initPointerState();
    };
    /**
     * @return {?}
     */
    IgxGridBaseComponent.prototype.getSelectedRanges = /**
     * @return {?}
     */
    function () {
        return this.selectionService.ranges;
    };
    /**
     * @param {?} source
     * @return {?}
     */
    IgxGridBaseComponent.prototype.extractDataFromSelection = /**
     * @param {?} source
     * @return {?}
     */
    function (source) {
        var e_3, _a, e_4, _b;
        /** @type {?} */
        var column;
        /** @type {?} */
        var record = {};
        /** @type {?} */
        var selectedData = [];
        /** @type {?} */
        var selectionMap = Array.from(this.selectionService.selection)
            .filter(function (tuple) { return tuple[0] < source.length; });
        /** @type {?} */
        var visibleColumns = this.visibleColumns
            .filter(function (col) { return !col.columnGroup; })
            .sort(function (a, b) { return a.visibleIndex - b.visibleIndex; });
        try {
            for (var selectionMap_1 = __values(selectionMap), selectionMap_1_1 = selectionMap_1.next(); !selectionMap_1_1.done; selectionMap_1_1 = selectionMap_1.next()) {
                var _c = __read(selectionMap_1_1.value, 2), row = _c[0], set = _c[1];
                if (!source[row]) {
                    continue;
                }
                /** @type {?} */
                var temp = Array.from(set);
                try {
                    for (var temp_1 = __values(temp), temp_1_1 = temp_1.next(); !temp_1_1.done; temp_1_1 = temp_1.next()) {
                        var each = temp_1_1.value;
                        column = visibleColumns[each];
                        if (column) {
                            record[column.field] = source[row][column.field];
                        }
                    }
                }
                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                finally {
                    try {
                        if (temp_1_1 && !temp_1_1.done && (_b = temp_1.return)) _b.call(temp_1);
                    }
                    finally { if (e_4) throw e_4.error; }
                }
                if (Object.keys(record).length) {
                    selectedData.push(record);
                }
                record = {};
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (selectionMap_1_1 && !selectionMap_1_1.done && (_a = selectionMap_1.return)) _a.call(selectionMap_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return selectedData;
    };
    /**
     * @return {?}
     */
    IgxGridBaseComponent.prototype.getSelectedData = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var source = this.verticalScrollContainer.igxForOf;
        return this.extractDataFromSelection(source);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} newSelectionAsSet
     * @param {?=} row
     * @param {?=} event
     * @param {?=} headerStatus
     * @return {?}
     */
    IgxGridBaseComponent.prototype.triggerRowSelectionChange = /**
     * @hidden
     * @param {?} newSelectionAsSet
     * @param {?=} row
     * @param {?=} event
     * @param {?=} headerStatus
     * @return {?}
     */
    function (newSelectionAsSet, row, event, headerStatus) {
        /** @type {?} */
        var oldSelectionAsSet = this.selection.get(this.id);
        /** @type {?} */
        var oldSelection = oldSelectionAsSet ? Array.from(oldSelectionAsSet) : [];
        /** @type {?} */
        var newSelection = newSelectionAsSet ? Array.from(newSelectionAsSet) : [];
        /** @type {?} */
        var args = { oldSelection: oldSelection, newSelection: newSelection, row: row, event: event };
        this.onRowSelectionChange.emit(args);
        newSelectionAsSet = this.selection.get_empty();
        for (var i = 0; i < args.newSelection.length; i++) {
            newSelectionAsSet.add(args.newSelection[i]);
        }
        this.selection.set(this.id, newSelectionAsSet);
        this.checkHeaderCheckboxStatus(headerStatus);
    };
    /**
     * @hidden
     */
    // @HostListener('scroll', ['$event'])
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    // @HostListener('scroll', ['$event'])
    IgxGridBaseComponent.prototype.scrollHandler = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    // @HostListener('scroll', ['$event'])
    function (event) {
        this.parentVirtDir.getHorizontalScroll().scrollLeft += event.target.scrollLeft;
        this.verticalScrollContainer.getVerticalScroll().scrollTop += event.target.scrollTop;
        event.target.scrollLeft = 0;
        event.target.scrollTop = 0;
    };
    /**
     * This method allows you to navigate to a position
     * in the grid based on provided `rowindex` and `visibleColumnIndex`,
     * also to execute a custom logic over the target element,
     * through a callback function that accepts { targetType: GridKeydownTargetType, target: Object }
     * ```typescript
     *  this.grid.navigateTo(10, 3, (args) => { args.target.nativeElement.focus(); });
     * ```
     * @memberof IgxGridBaseComponent
     */
    /**
     * This method allows you to navigate to a position
     * in the grid based on provided `rowindex` and `visibleColumnIndex`,
     * also to execute a custom logic over the target element,
     * through a callback function that accepts { targetType: GridKeydownTargetType, target: Object }
     * ```typescript
     *  this.grid.navigateTo(10, 3, (args) => { args.target.nativeElement.focus(); });
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} rowIndex
     * @param {?=} visibleColIndex
     * @param {?=} cb
     * @return {?}
     */
    IgxGridBaseComponent.prototype.navigateTo = /**
     * This method allows you to navigate to a position
     * in the grid based on provided `rowindex` and `visibleColumnIndex`,
     * also to execute a custom logic over the target element,
     * through a callback function that accepts { targetType: GridKeydownTargetType, target: Object }
     * ```typescript
     *  this.grid.navigateTo(10, 3, (args) => { args.target.nativeElement.focus(); });
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} rowIndex
     * @param {?=} visibleColIndex
     * @param {?=} cb
     * @return {?}
     */
    function (rowIndex, visibleColIndex, cb) {
        var _this = this;
        if (visibleColIndex === void 0) { visibleColIndex = -1; }
        if (cb === void 0) { cb = null; }
        if (rowIndex < 0 || rowIndex > this.verticalScrollContainer.igxForOf.length - 1
            || (visibleColIndex !== -1 && this.columnList.map(function (col) { return col.visibleIndex; }).indexOf(visibleColIndex) === -1)) {
            return;
        }
        this.wheelHandler();
        if (this.verticalScrollContainer.igxForOf.slice(rowIndex, rowIndex + 1).find(function (rec) { return rec.expression || rec.childGridsData; })) {
            visibleColIndex = -1;
        }
        if (visibleColIndex === -1 || (this.navigation.isColumnFullyVisible(visibleColIndex)
            && this.navigation.isColumnLeftFullyVisible(visibleColIndex))) {
            if (this.navigation.shouldPerformVerticalScroll(rowIndex)) {
                this.verticalScrollContainer.scrollTo(rowIndex);
                this.verticalScrollContainer.onChunkLoad
                    .pipe(first()).subscribe(function () {
                    _this.executeCallback(rowIndex, visibleColIndex, cb);
                });
            }
            else {
                this.executeCallback(rowIndex, visibleColIndex, cb);
            }
        }
        else {
            /** @type {?} */
            var unpinnedIndex = this.navigation.getColumnUnpinnedIndex(visibleColIndex);
            this.parentVirtDir.onChunkLoad
                .pipe(first())
                .subscribe(function () {
                if (_this.navigation.shouldPerformVerticalScroll(rowIndex)) {
                    _this.verticalScrollContainer.scrollTo(rowIndex);
                    _this.verticalScrollContainer.onChunkLoad
                        .pipe(first()).subscribe(function () {
                        _this.executeCallback(rowIndex, visibleColIndex, cb);
                    });
                }
                else {
                    _this.executeCallback(rowIndex, visibleColIndex, cb);
                }
            });
            this.navigation.horizontalScroll(rowIndex).scrollTo(unpinnedIndex);
        }
    };
    /**
    * Returns `ICellPosition` which defines the next cell,
    * according to the current position, that match specific criteria.
    * You can pass callback function as a third parameter of `getPreviousCell` method.
    * The callback function accepts IgxColumnComponent as a param
    * ```typescript
    *  const nextEditableCellPosition = this.grid.getNextCell(0, 3, (column) => column.editable);
    * ```
    * @memberof IgxGridBaseComponent
    */
    /**
     * Returns `ICellPosition` which defines the next cell,
     * according to the current position, that match specific criteria.
     * You can pass callback function as a third parameter of `getPreviousCell` method.
     * The callback function accepts IgxColumnComponent as a param
     * ```typescript
     *  const nextEditableCellPosition = this.grid.getNextCell(0, 3, (column) => column.editable);
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} currRowIndex
     * @param {?} curVisibleColIndex
     * @param {?=} callback
     * @return {?}
     */
    IgxGridBaseComponent.prototype.getNextCell = /**
     * Returns `ICellPosition` which defines the next cell,
     * according to the current position, that match specific criteria.
     * You can pass callback function as a third parameter of `getPreviousCell` method.
     * The callback function accepts IgxColumnComponent as a param
     * ```typescript
     *  const nextEditableCellPosition = this.grid.getNextCell(0, 3, (column) => column.editable);
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} currRowIndex
     * @param {?} curVisibleColIndex
     * @param {?=} callback
     * @return {?}
     */
    function (currRowIndex, curVisibleColIndex, callback) {
        if (callback === void 0) { callback = null; }
        /** @type {?} */
        var columns = this.columnList.filter(function (col) { return !col.columnGroup && col.visibleIndex >= 0; });
        if (!this.isValidPosition(currRowIndex, curVisibleColIndex)) {
            return { rowIndex: currRowIndex, visibleColumnIndex: curVisibleColIndex };
        }
        /** @type {?} */
        var colIndexes = callback ? columns.filter(function (col) { return callback(col); }).map(function (editCol) { return editCol.visibleIndex; }).sort(function (a, b) { return a - b; }) :
            columns.map(function (editCol) { return editCol.visibleIndex; }).sort(function (a, b) { return a - b; });
        /** @type {?} */
        var nextCellIndex = colIndexes.find(function (index) { return index > curVisibleColIndex; });
        if (this.verticalScrollContainer.igxForOf.slice(currRowIndex, currRowIndex + 1)
            .find(function (rec) { return !rec.expression && !rec.summaries && !rec.childGridsData; }) && nextCellIndex !== undefined) {
            return { rowIndex: currRowIndex, visibleColumnIndex: nextCellIndex };
        }
        else {
            if (colIndexes.length === 0 || this.getNextDataRowIndex(currRowIndex) === currRowIndex) {
                return { rowIndex: currRowIndex, visibleColumnIndex: curVisibleColIndex };
            }
            else {
                return { rowIndex: this.getNextDataRowIndex(currRowIndex), visibleColumnIndex: colIndexes[0] };
            }
        }
    };
    /**
    * Returns `ICellPosition` which defines the previous cell,
    * according to the current position, that match specific criteria.
    * You can pass callback function as a third parameter of `getPreviousCell` method.
    * The callback function accepts IgxColumnComponent as a param
    * ```typescript
    *  const previousEditableCellPosition = this.grid.getPreviousCell(0, 3, (column) => column.editable);
    * ```
    * @memberof IgxGridBaseComponent
    */
    /**
     * Returns `ICellPosition` which defines the previous cell,
     * according to the current position, that match specific criteria.
     * You can pass callback function as a third parameter of `getPreviousCell` method.
     * The callback function accepts IgxColumnComponent as a param
     * ```typescript
     *  const previousEditableCellPosition = this.grid.getPreviousCell(0, 3, (column) => column.editable);
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} currRowIndex
     * @param {?} curVisibleColIndex
     * @param {?=} callback
     * @return {?}
     */
    IgxGridBaseComponent.prototype.getPreviousCell = /**
     * Returns `ICellPosition` which defines the previous cell,
     * according to the current position, that match specific criteria.
     * You can pass callback function as a third parameter of `getPreviousCell` method.
     * The callback function accepts IgxColumnComponent as a param
     * ```typescript
     *  const previousEditableCellPosition = this.grid.getPreviousCell(0, 3, (column) => column.editable);
     * ```
     * \@memberof IgxGridBaseComponent
     * @param {?} currRowIndex
     * @param {?} curVisibleColIndex
     * @param {?=} callback
     * @return {?}
     */
    function (currRowIndex, curVisibleColIndex, callback) {
        if (callback === void 0) { callback = null; }
        /** @type {?} */
        var columns = this.columnList.filter(function (col) { return !col.columnGroup && col.visibleIndex >= 0; });
        if (!this.isValidPosition(currRowIndex, curVisibleColIndex)) {
            return { rowIndex: currRowIndex, visibleColumnIndex: curVisibleColIndex };
        }
        /** @type {?} */
        var colIndexes = callback ? columns.filter(function (col) { return callback(col); }).map(function (editCol) { return editCol.visibleIndex; }).sort(function (a, b) { return b - a; }) :
            columns.map(function (editCol) { return editCol.visibleIndex; }).sort(function (a, b) { return b - a; });
        /** @type {?} */
        var prevCellIndex = colIndexes.find(function (index) { return index < curVisibleColIndex; });
        if (this.verticalScrollContainer.igxForOf.slice(currRowIndex, currRowIndex + 1)
            .find(function (rec) { return !rec.expression && !rec.summaries && !rec.childGridsData; }) && prevCellIndex !== undefined) {
            return { rowIndex: currRowIndex, visibleColumnIndex: prevCellIndex };
        }
        else {
            if (colIndexes.length === 0 || this.getPrevDataRowIndex(currRowIndex) === currRowIndex) {
                return { rowIndex: currRowIndex, visibleColumnIndex: curVisibleColIndex };
            }
            else {
                return { rowIndex: this.getPrevDataRowIndex(currRowIndex), visibleColumnIndex: colIndexes[0] };
            }
        }
    };
    /**
     * @private
     * @param {?} rowIndex
     * @param {?=} visibleColIndex
     * @param {?=} cb
     * @return {?}
     */
    IgxGridBaseComponent.prototype.executeCallback = /**
     * @private
     * @param {?} rowIndex
     * @param {?=} visibleColIndex
     * @param {?=} cb
     * @return {?}
     */
    function (rowIndex, visibleColIndex, cb) {
        if (visibleColIndex === void 0) { visibleColIndex = -1; }
        if (cb === void 0) { cb = null; }
        if (!cb) {
            return;
        }
        /** @type {?} */
        var targetType;
        /** @type {?} */
        var target;
        /** @type {?} */
        var row = this.summariesRowList.filter(function (s) { return s.index !== 0; }).concat(this.rowList.toArray()).find(function (r) { return r.index === rowIndex; });
        if (!row) {
            return;
        }
        switch (row.nativeElement.tagName.toLowerCase()) {
            case 'igx-grid-groupby-row':
                targetType = GridKeydownTargetType.groupRow;
                target = row;
                break;
            case 'igx-grid-summary-row':
                targetType = GridKeydownTargetType.summaryCell;
                target = visibleColIndex !== -1 ?
                    row.summaryCells.find(function (c) { return c.visibleColumnIndex === visibleColIndex; }) : row.summaryCells.first;
                break;
            case 'igx-child-grid-row':
                targetType = GridKeydownTargetType.hierarchicalRow;
                target = row;
                break;
            default:
                targetType = GridKeydownTargetType.dataCell;
                target = visibleColIndex !== -1 ? row.cells.find(function (c) { return c.visibleColumnIndex === visibleColIndex; }) : row.cells.first;
                break;
        }
        /** @type {?} */
        var args = { targetType: targetType, target: target };
        cb(args);
    };
    /**
     * @private
     * @param {?} currentRowIndex
     * @return {?}
     */
    IgxGridBaseComponent.prototype.getPrevDataRowIndex = /**
     * @private
     * @param {?} currentRowIndex
     * @return {?}
     */
    function (currentRowIndex) {
        if (currentRowIndex <= 0) {
            return currentRowIndex;
        }
        /** @type {?} */
        var prevRow = this.verticalScrollContainer.igxForOf.slice(0, currentRowIndex).reverse()
            .find(function (rec) { return !rec.expression && !rec.summaries && !rec.childGridsData; });
        return prevRow ? this.verticalScrollContainer.igxForOf.indexOf(prevRow) : currentRowIndex;
    };
    /**
     * @private
     * @param {?} currentRowIndex
     * @return {?}
     */
    IgxGridBaseComponent.prototype.getNextDataRowIndex = /**
     * @private
     * @param {?} currentRowIndex
     * @return {?}
     */
    function (currentRowIndex) {
        if (currentRowIndex === this.verticalScrollContainer.igxForOf.length) {
            return currentRowIndex;
        }
        /** @type {?} */
        var nextRow = this.verticalScrollContainer.igxForOf.slice(currentRowIndex + 1, this.verticalScrollContainer.igxForOf.length)
            .find(function (rec) { return !rec.expression && !rec.summaries && !rec.childGridsData; });
        return nextRow ? this.verticalScrollContainer.igxForOf.indexOf(nextRow) : currentRowIndex;
    };
    /**
     * @private
     * @param {?} rowIndex
     * @param {?} colIndex
     * @return {?}
     */
    IgxGridBaseComponent.prototype.isValidPosition = /**
     * @private
     * @param {?} rowIndex
     * @param {?} colIndex
     * @return {?}
     */
    function (rowIndex, colIndex) {
        /** @type {?} */
        var rows = this.summariesRowList.filter(function (s) { return s.index !== 0; }).concat(this.rowList.toArray()).length;
        /** @type {?} */
        var cols = this.columnList.filter(function (col) { return !col.columnGroup && col.visibleIndex >= 0; }).length;
        if (rows < 1 || cols < 1) {
            return false;
        }
        if (rowIndex > -1 && rowIndex < this.verticalScrollContainer.igxForOf.length &&
            colIndex > -1 && colIndex <= this.unpinnedColumns[this.unpinnedColumns.length - 1].visibleIndex) {
            return true;
        }
        return false;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?=} isScroll
     * @return {?}
     */
    IgxGridBaseComponent.prototype.wheelHandler = /**
     * @hidden
     * @param {?=} isScroll
     * @return {?}
     */
    function (isScroll) {
        if (isScroll === void 0) { isScroll = false; }
        if (document.activeElement &&
            // tslint:disable-next-line:no-bitwise
            (document.activeElement.compareDocumentPosition(this.tbody.nativeElement) & Node.DOCUMENT_POSITION_CONTAINS ||
                // tslint:disable-next-line:no-bitwise
                (document.activeElement.compareDocumentPosition(this.tfoot.nativeElement) & Node.DOCUMENT_POSITION_CONTAINS && isScroll))) {
            ((/** @type {?} */ (document.activeElement))).blur();
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} index
     * @param {?} col
     * @return {?}
     */
    IgxGridBaseComponent.prototype.trackColumnChanges = /**
     * @hidden
     * @param {?} index
     * @param {?} col
     * @return {?}
     */
    function (index, col) {
        return col.field + col.calcWidth;
    };
    /**
     * @private
     * @param {?} text
     * @param {?} increment
     * @param {?=} caseSensitive
     * @param {?=} exactMatch
     * @param {?=} scroll
     * @return {?}
     */
    IgxGridBaseComponent.prototype.find = /**
     * @private
     * @param {?} text
     * @param {?} increment
     * @param {?=} caseSensitive
     * @param {?=} exactMatch
     * @param {?=} scroll
     * @return {?}
     */
    function (text, increment, caseSensitive, exactMatch, scroll) {
        if (!this.rowList) {
            return 0;
        }
        this.endEdit(false);
        if (!text) {
            this.clearSearch();
            return 0;
        }
        /** @type {?} */
        var caseSensitiveResolved = caseSensitive ? true : false;
        /** @type {?} */
        var exactMatchResolved = exactMatch ? true : false;
        /** @type {?} */
        var rebuildCache = false;
        if (this.lastSearchInfo.searchText !== text ||
            this.lastSearchInfo.caseSensitive !== caseSensitiveResolved ||
            this.lastSearchInfo.exactMatch !== exactMatchResolved) {
            this.lastSearchInfo = {
                searchText: text,
                activeMatchIndex: 0,
                caseSensitive: caseSensitiveResolved,
                exactMatch: exactMatchResolved,
                matchInfoCache: []
            };
            rebuildCache = true;
        }
        else {
            this.lastSearchInfo.activeMatchIndex += increment;
        }
        if (rebuildCache) {
            this.rowList.forEach(function (row) {
                if (row.cells) {
                    row.cells.forEach(function (c) {
                        c.highlightText(text, caseSensitiveResolved, exactMatchResolved);
                    });
                }
            });
            this.rebuildMatchCache();
        }
        if (this.lastSearchInfo.activeMatchIndex >= this.lastSearchInfo.matchInfoCache.length) {
            this.lastSearchInfo.activeMatchIndex = 0;
        }
        else if (this.lastSearchInfo.activeMatchIndex < 0) {
            this.lastSearchInfo.activeMatchIndex = this.lastSearchInfo.matchInfoCache.length - 1;
        }
        if (this.lastSearchInfo.matchInfoCache.length) {
            /** @type {?} */
            var matchInfo = this.lastSearchInfo.matchInfoCache[this.lastSearchInfo.activeMatchIndex];
            this.lastSearchInfo = __assign({}, this.lastSearchInfo);
            if (scroll !== false) {
                this.scrollTo(matchInfo.row, matchInfo.column);
            }
            IgxTextHighlightDirective.setActiveHighlight(this.id, {
                column: matchInfo.column,
                row: matchInfo.row,
                index: matchInfo.index,
            });
        }
        else {
            IgxTextHighlightDirective.clearActiveHighlight(this.id);
        }
        return this.lastSearchInfo.matchInfoCache.length;
    };
    Object.defineProperty(IgxGridBaseComponent.prototype, "filteredSortedData", {
        /**
         * Returns an array containing the filtered sorted data.
         * ```typescript
         * const filteredSortedData = this.grid1.filteredSortedData;
         * ```
         * @memberof IgxGridBaseComponent
         */
        get: /**
         * Returns an array containing the filtered sorted data.
         * ```typescript
         * const filteredSortedData = this.grid1.filteredSortedData;
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this._filteredSortedData;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._filteredSortedData = value;
            this.refreshSearch(true);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    IgxGridBaseComponent.prototype.initPinning = /**
     * @hidden
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var currentPinnedWidth = 0;
        /** @type {?} */
        var pinnedColumns = [];
        /** @type {?} */
        var unpinnedColumns = [];
        /** @type {?} */
        var newUnpinnedCols = [];
        this.calculateGridWidth();
        this.resetCaches();
        // When a column is a group or is inside a group, pin all related.
        this._pinnedColumns.forEach(function (col) {
            if (col.parent) {
                col.parent.pinned = true;
            }
            if (col.columnGroup) {
                col.children.forEach(function (child) { return child.pinned = true; });
            }
        });
        // Make sure we don't exceed unpinned area min width and get pinned and unpinned col collections.
        // We take into account top level columns (top level groups and non groups).
        // If top level is unpinned the pinning handles all children to be unpinned as well.
        for (var i = 0; i < this._columns.length; i++) {
            if (this._columns[i].pinned && !this._columns[i].parent) {
                // Pinned column. Check if with it the unpinned min width is exceeded.
                /** @type {?} */
                var colWidth = parseInt(this._columns[i].width, 10);
                if (currentPinnedWidth + colWidth > this.calcWidth - this.unpinnedAreaMinWidth) {
                    // unpinned min width is exceeded. Unpin the columns and add it to the unpinned collection.
                    this._columns[i].pinned = false;
                    unpinnedColumns.push(this._columns[i]);
                    newUnpinnedCols.push(this._columns[i]);
                }
                else {
                    // unpinned min width is not exceeded. Keep it pinned and add it to the pinned collection.
                    currentPinnedWidth += colWidth;
                    pinnedColumns.push(this._columns[i]);
                }
            }
            else if (this._columns[i].pinned && this._columns[i].parent) {
                if (this._columns[i].topLevelParent.pinned) {
                    pinnedColumns.push(this._columns[i]);
                }
                else {
                    this._columns[i].pinned = false;
                    unpinnedColumns.push(this._columns[i]);
                }
            }
            else {
                unpinnedColumns.push(this._columns[i]);
            }
        }
        if (newUnpinnedCols.length) {
            console.warn('igxGrid - The pinned area exceeds maximum pinned width. ' +
                'The following columns were unpinned to prevent further issues:' +
                newUnpinnedCols.map(function (col) { return '"' + col.header + '"'; }).toString() + '. For more info see our documentation.');
        }
        // Assign the applicaple collections.
        this._pinnedColumns = pinnedColumns;
        this._unpinnedColumns = unpinnedColumns;
        this.cdr.markForCheck();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} row
     * @param {?} column
     * @return {?}
     */
    IgxGridBaseComponent.prototype.scrollTo = /**
     * @hidden
     * @protected
     * @param {?} row
     * @param {?} column
     * @return {?}
     */
    function (row, column) {
        var _this = this;
        /** @type {?} */
        var delayScrolling = false;
        if (this.paging && typeof (row) !== 'number') {
            /** @type {?} */
            var rowIndex = this.filteredSortedData.indexOf(row);
            /** @type {?} */
            var page = Math.floor(rowIndex / this.perPage);
            if (this.page !== page) {
                delayScrolling = true;
                this.page = page;
            }
        }
        if (delayScrolling) {
            this.verticalScrollContainer.onDataChanged.pipe(first()).subscribe(function () {
                _this.scrollDirective(_this.verticalScrollContainer, typeof (row) === 'number' ? row : _this.verticalScrollContainer.igxForOf.indexOf(row));
            });
        }
        else {
            this.scrollDirective(this.verticalScrollContainer, typeof (row) === 'number' ? row : this.verticalScrollContainer.igxForOf.indexOf(row));
        }
        this.scrollToHorizontally(column);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} column
     * @return {?}
     */
    IgxGridBaseComponent.prototype.scrollToHorizontally = /**
     * @hidden
     * @protected
     * @param {?} column
     * @return {?}
     */
    function (column) {
        /** @type {?} */
        var columnIndex = typeof column === 'number' ? column : this.getColumnByName(column).visibleIndex;
        /** @type {?} */
        var scrollRow = this.rowList.find(function (r) { return r.virtDirRow; });
        /** @type {?} */
        var virtDir = scrollRow ? scrollRow.virtDirRow : null;
        if (this.pinnedColumns.length) {
            if (columnIndex >= this.pinnedColumns.length) {
                columnIndex -= this.pinnedColumns.length;
                this.scrollDirective(virtDir, columnIndex);
            }
        }
        else {
            this.scrollDirective(virtDir, columnIndex);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} directive
     * @param {?} goal
     * @return {?}
     */
    IgxGridBaseComponent.prototype.scrollDirective = /**
     * @hidden
     * @protected
     * @param {?} directive
     * @param {?} goal
     * @return {?}
     */
    function (directive, goal) {
        if (!directive) {
            return;
        }
        // directive.onChunkLoad.pipe(first())
        //     .subscribe(() => requestAnimationFrame(() => this.cdr.detectChanges()));
        directive.scrollTo(goal);
    };
    /**
     * @private
     * @return {?}
     */
    IgxGridBaseComponent.prototype.rebuildMatchCache = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this.lastSearchInfo.matchInfoCache = [];
        /** @type {?} */
        var caseSensitive = this.lastSearchInfo.caseSensitive;
        /** @type {?} */
        var exactMatch = this.lastSearchInfo.exactMatch;
        /** @type {?} */
        var searchText = caseSensitive ? this.lastSearchInfo.searchText : this.lastSearchInfo.searchText.toLowerCase();
        /** @type {?} */
        var data = this.filteredSortedData;
        /** @type {?} */
        var columnItems = this.visibleColumns.filter(function (c) { return !c.columnGroup; }).sort(function (c1, c2) { return c1.visibleIndex - c2.visibleIndex; });
        /** @type {?} */
        var numberPipe = new IgxDecimalPipeComponent(this.locale);
        /** @type {?} */
        var datePipe = new IgxDatePipeComponent(this.locale);
        data.forEach(function (dataRow) {
            columnItems.forEach(function (c) {
                /** @type {?} */
                var value = c.formatter ? c.formatter(dataRow[c.field]) :
                    c.dataType === 'number' ? numberPipe.transform(dataRow[c.field], _this.locale) :
                        c.dataType === 'date' ? datePipe.transform(dataRow[c.field], _this.locale)
                            : dataRow[c.field];
                if (value !== undefined && value !== null && c.searchable) {
                    /** @type {?} */
                    var searchValue = caseSensitive ? String(value) : String(value).toLowerCase();
                    if (exactMatch) {
                        if (searchValue === searchText) {
                            _this.lastSearchInfo.matchInfoCache.push({
                                row: dataRow,
                                column: c.field,
                                index: 0,
                            });
                        }
                    }
                    else {
                        /** @type {?} */
                        var occurenceIndex = 0;
                        /** @type {?} */
                        var searchIndex = searchValue.indexOf(searchText);
                        while (searchIndex !== -1) {
                            _this.lastSearchInfo.matchInfoCache.push({
                                row: dataRow,
                                column: c.field,
                                index: occurenceIndex++,
                            });
                            searchValue = searchValue.substring(searchIndex + searchText.length);
                            searchIndex = searchValue.indexOf(searchText);
                        }
                    }
                }
            });
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} _group
     * @return {?}
     */
    IgxGridBaseComponent.prototype.isExpandedGroup = /**
     * @hidden
     * @param {?} _group
     * @return {?}
     */
    function (_group) {
        return undefined;
    };
    /**
    * @hidden
    */
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    IgxGridBaseComponent.prototype.getGroupByRecords = /**
     * @hidden
     * @protected
     * @return {?}
     */
    function () {
        return null;
    };
    /**
     * @protected
     * @param {?} row
     * @return {?}
     */
    IgxGridBaseComponent.prototype.changeRowEditingOverlayStateOnScroll = /**
     * @protected
     * @param {?} row
     * @return {?}
     */
    function (row) {
        if (!this.rowEditable || this.rowEditingOverlay.collapsed) {
            return;
        }
        if (!row) {
            this.toggleRowEditingOverlay(false);
        }
        else {
            this.repositionRowEditingOverlay(row);
        }
    };
    /**
     * @param {?} id
     * @return {?}
     */
    IgxGridBaseComponent.prototype.openRowOverlay = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
        this.configureRowEditingOverlay(id, this.rowList.length <= MIN_ROW_EDITING_COUNT_THRESHOLD);
        this.rowEditingOverlay.open(this.rowEditSettings);
        this.rowEditPositioningStrategy.isTopInitialPosition = this.rowEditPositioningStrategy.isTop;
        this._wheelListener = this.rowEditingWheelHandler.bind(this);
        this.rowEditingOverlay.element.addEventListener('wheel', this._wheelListener);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxGridBaseComponent.prototype.closeRowEditingOverlay = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.rowEditingOverlay.element.removeEventListener('wheel', this._wheelListener);
        this.rowEditPositioningStrategy.isTopInitialPosition = null;
        this.rowEditingOverlay.close();
        this.rowEditingOverlay.element.parentElement.style.display = '';
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} show
     * @return {?}
     */
    IgxGridBaseComponent.prototype.toggleRowEditingOverlay = /**
     * @hidden
     * @param {?} show
     * @return {?}
     */
    function (show) {
        /** @type {?} */
        var rowStyle = this.rowEditingOverlay.element.style;
        if (show) {
            rowStyle.display = 'block';
        }
        else {
            rowStyle.display = 'none';
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} row
     * @return {?}
     */
    IgxGridBaseComponent.prototype.repositionRowEditingOverlay = /**
     * @hidden
     * @param {?} row
     * @return {?}
     */
    function (row) {
        if (!this.rowEditingOverlay.collapsed) {
            /** @type {?} */
            var rowStyle = this.rowEditingOverlay.element.parentElement.style;
            if (row) {
                rowStyle.display = '';
                this.configureRowEditingOverlay(row.rowID);
                this.rowEditingOverlay.reposition();
            }
            else {
                rowStyle.display = 'none';
            }
        }
    };
    /**
     * @private
     * @param {?} rowID
     * @param {?=} useOuter
     * @return {?}
     */
    IgxGridBaseComponent.prototype.configureRowEditingOverlay = /**
     * @private
     * @param {?} rowID
     * @param {?=} useOuter
     * @return {?}
     */
    function (rowID, useOuter) {
        if (useOuter === void 0) { useOuter = false; }
        this.rowEditSettings.outlet = useOuter ? this.parentRowOutletDirective : this.rowOutletDirective;
        this.rowEditPositioningStrategy.settings.container = this.tbody.nativeElement;
        /** @type {?} */
        var targetRow = this.gridAPI.get_row_by_key(rowID);
        if (!targetRow) {
            return;
        }
        this.rowEditPositioningStrategy.settings.target = targetRow.element.nativeElement;
        this.toggleRowEditingOverlay(true);
    };
    Object.defineProperty(IgxGridBaseComponent.prototype, "rowChangesCount", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            if (!this.crudService.row) {
                return 0;
            }
            /** @type {?} */
            var rowChanges = this.transactions.getAggregatedValue(this.crudService.row.id, false);
            return rowChanges ? Object.keys(rowChanges).length : 0;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @protected
     * @param {?} rowIndex
     * @param {?} value
     * @return {?}
     */
    IgxGridBaseComponent.prototype.writeToData = /**
     * @protected
     * @param {?} rowIndex
     * @param {?} value
     * @return {?}
     */
    function (rowIndex, value) {
        mergeObjects(this.gridAPI.get_all_data()[rowIndex], value);
    };
    /**
     * @param {?} commit
     * @param {?} row
     * @return {?}
     */
    IgxGridBaseComponent.prototype.endRowTransaction = /**
     * @param {?} commit
     * @param {?} row
     * @return {?}
     */
    function (commit, row) {
        row.newData = this.transactions.getAggregatedValue(row.id, true);
        /** @type {?} */
        var args = row.createEditEventArgs();
        if (!commit) {
            this.onRowEditCancel.emit(args);
            this.transactions.endPending(false);
        }
        else {
            args = this.gridAPI.update_row(row, row.newData);
        }
        if (args.cancel) {
            this.transactions.startPending();
            return;
        }
        this.crudService.endRowEdit();
        this.closeRowEditingOverlay();
    };
    // TODO: Refactor
    /**
     * Finishes the row transactions on the current row.
     * If `commit === true`, passes them from the pending state to the data (or transaction service)
     *
     * Binding to the event
     * ```html
     * <button igxButton (click)="grid.endEdit(true)">Commit Row</button>
     * ```
     * @param commit
     */
    // TODO: Refactor
    /**
     * Finishes the row transactions on the current row.
     * If `commit === true`, passes them from the pending state to the data (or transaction service)
     *
     * Binding to the event
     * ```html
     * <button igxButton (click)="grid.endEdit(true)">Commit Row</button>
     * ```
     * @param {?=} commit
     * @param {?=} event
     * @return {?}
     */
    IgxGridBaseComponent.prototype.endEdit = 
    // TODO: Refactor
    /**
     * Finishes the row transactions on the current row.
     * If `commit === true`, passes them from the pending state to the data (or transaction service)
     *
     * Binding to the event
     * ```html
     * <button igxButton (click)="grid.endEdit(true)">Commit Row</button>
     * ```
     * @param {?=} commit
     * @param {?=} event
     * @return {?}
     */
    function (commit, event) {
        if (commit === void 0) { commit = true; }
        /** @type {?} */
        var row = this.crudService.row;
        /** @type {?} */
        var cell = this.crudService.cell;
        /** @type {?} */
        var columnindex = cell ? cell.column.index : -1;
        /** @type {?} */
        var ri = row ? row.index : -1;
        // TODO: Merge the crudService with wht BaseAPI service
        if (!row && !cell) {
            return;
        }
        commit ? this.gridAPI.submit_value() : this.gridAPI.escape_editMode();
        if (!this.rowEditable || this.rowEditingOverlay && this.rowEditingOverlay.collapsed || !row) {
            return;
        }
        this.endRowTransaction(commit, row);
        /** @type {?} */
        var currentCell = this.gridAPI.get_cell_by_index(ri, columnindex);
        if (currentCell && event) {
            currentCell.nativeElement.focus();
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @private
     * @param {?} event
     * @return {?}
     */
    IgxGridBaseComponent.prototype.rowEditingWheelHandler = /**
     * @hidden
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.deltaY > 0) {
            this.verticalScrollContainer.scrollNext();
        }
        else {
            this.verticalScrollContainer.scrollPrev();
        }
    };
    Object.defineProperty(IgxGridBaseComponent.prototype, "dataWithAddedInTransactionRows", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            /** @type {?} */
            var result = (/** @type {?} */ (cloneArray(this.gridAPI.get_all_data())));
            if (this.transactions.enabled) {
                result.push.apply(result, __spread(this.transactions.getAggregatedChanges(true)
                    .filter(function (t) { return t.type === TransactionType.ADD; })
                    .map(function (t) { return t.newValue; })));
            }
            return result;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridBaseComponent.prototype, "dataLength", {
        get: /**
         * @return {?}
         */
        function () {
            return this.transactions.enabled ? this.dataWithAddedInTransactionRows.length : this.gridAPI.get_all_data().length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    IgxGridBaseComponent.prototype.hasHorizontalScroll = /**
     * @return {?}
     */
    function () {
        return this.totalWidth - this.unpinnedWidth > 0;
    };
    /**
     * @protected
     * @param {?} row
     * @return {?}
     */
    IgxGridBaseComponent.prototype._restoreVirtState = /**
     * @protected
     * @param {?} row
     * @return {?}
     */
    function (row) {
        // check virtualization state of data record added from cache
        // in case state is no longer valid - update it.
        /** @type {?} */
        var rowForOf = row.virtDirRow;
        /** @type {?} */
        var gridScrLeft = rowForOf.getHorizontalScroll().scrollLeft;
        /** @type {?} */
        var left = -parseInt(rowForOf.dc.instance._viewContainer.element.nativeElement.style.left, 10);
        /** @type {?} */
        var actualScrollLeft = left + rowForOf.getColumnScrollLeft(rowForOf.state.startIndex);
        if (gridScrLeft !== actualScrollLeft) {
            rowForOf.onHScroll(gridScrLeft);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    IgxGridBaseComponent.prototype.getExportExcel = /**
     * @hidden
     * @protected
     * @return {?}
     */
    function () {
        return this._exportExcel;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    IgxGridBaseComponent.prototype.getExportCsv = /**
     * @hidden
     * @protected
     * @return {?}
     */
    function () {
        return this._exportCsv;
    };
    /**
    * @hidden
    */
    /**
     * @hidden
     * @param {?} rowData
     * @return {?}
     */
    IgxGridBaseComponent.prototype.isSummaryRow = /**
     * @hidden
     * @param {?} rowData
     * @return {?}
     */
    function (rowData) {
        return rowData.summaries && (rowData.summaries instanceof Map);
    };
    Object.defineProperty(IgxGridBaseComponent.prototype, "isAttachedToDom", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @protected
         * @return {?}
         */
        function () {
            return this.document.body.contains(this.nativeElement);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} args
     * @return {?}
     */
    IgxGridBaseComponent.prototype.cachedViewLoaded = /**
     * @hidden
     * @param {?} args
     * @return {?}
     */
    function (args) {
        var _this = this;
        if (args.context['templateID'] === 'dataRow' && args.context['$implicit'] === args.oldContext['$implicit']) {
            args.view.detectChanges();
            /** @type {?} */
            var row = this.getRowByIndex(args.context.index);
            if (row && row.cells) {
                row.cells.forEach(function (c) {
                    c.highlightText(_this.lastSearchInfo.searchText, _this.lastSearchInfo.caseSensitive, _this.lastSearchInfo.exactMatch);
                });
            }
        }
        if (this.hasHorizontalScroll()) {
            /** @type {?} */
            var tmplId = args.context.templateID;
            /** @type {?} */
            var index_1 = args.context.index;
            args.view.detectChanges();
            /** @type {?} */
            var row = tmplId === 'dataRow' ? this.getRowByIndex(index_1) : null;
            /** @type {?} */
            var summaryRow = tmplId === 'summaryRow' ? this.summariesRowList.toArray().find(function (sr) { return sr.dataRowIndex === index_1; }) : null;
            if (row && row instanceof IgxRowComponent) {
                this._restoreVirtState(row);
            }
            else if (summaryRow) {
                this._restoreVirtState(summaryRow);
            }
        }
    };
    /** @nocollapse */
    IgxGridBaseComponent.ctorParameters = function () { return [
        { type: IgxGridSelectionService },
        { type: IgxGridCRUDService },
        { type: GridBaseAPIService },
        { type: IgxSelectionAPIService },
        { type: undefined, decorators: [{ type: Inject, args: [IgxGridTransaction,] }] },
        { type: ElementRef },
        { type: NgZone },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: ChangeDetectorRef },
        { type: ComponentFactoryResolver },
        { type: IterableDiffers },
        { type: ViewContainerRef },
        { type: IgxGridNavigationService },
        { type: IgxFilteringService },
        { type: IgxOverlayService, decorators: [{ type: Inject, args: [IgxOverlayService,] }] },
        { type: IgxGridSummaryService },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
    ]; };
    IgxGridBaseComponent.propDecorators = {
        resourceStrings: [{ type: Input }],
        autoGenerate: [{ type: Input }],
        emptyGridTemplate: [{ type: Input }],
        loadingGridTemplate: [{ type: Input }],
        filteringLogic: [{ type: Input }],
        filteringExpressionsTree: [{ type: Input }],
        locale: [{ type: Input }],
        paging: [{ type: Input }],
        page: [{ type: Input }],
        perPage: [{ type: Input }],
        paginationTemplate: [{ type: Input }],
        columnHiding: [{ type: Input }],
        rowSelectable: [{ type: Input }],
        rowDraggable: [{ type: Input }],
        rowEditable: [{ type: Input }],
        height: [{ type: HostBinding, args: ['style.height',] }, { type: Input }],
        width: [{ type: HostBinding, args: ['style.width',] }, { type: Input }],
        evenRowCSS: [{ type: Input }],
        oddRowCSS: [{ type: Input }],
        rowHeight: [{ type: Input }],
        columnWidth: [{ type: Input }],
        primaryKey: [{ type: Input }],
        emptyGridMessage: [{ type: Input }],
        isLoading: [{ type: Input }],
        emptyFilteredGridMessage: [{ type: Input }],
        columnHidingTitle: [{ type: Input }],
        columnPinning: [{ type: Input }],
        columnPinningTitle: [{ type: Input }],
        allowFiltering: [{ type: Input }],
        filterMode: [{ type: Input }],
        summaryPosition: [{ type: Input }],
        summaryCalculationMode: [{ type: Input }],
        onCellClick: [{ type: Output }],
        onSelection: [{ type: Output }],
        onRowSelectionChange: [{ type: Output }],
        onColumnPinning: [{ type: Output }],
        onCellEditCancel: [{ type: Output }],
        onCellEditEnter: [{ type: Output }],
        onCellEdit: [{ type: Output }],
        onRowEditEnter: [{ type: Output }],
        onRowEdit: [{ type: Output }],
        onRowEditCancel: [{ type: Output }],
        onColumnInit: [{ type: Output }],
        onSortingDone: [{ type: Output }],
        onFilteringDone: [{ type: Output }],
        onPagingDone: [{ type: Output }],
        onRowAdded: [{ type: Output }],
        onRowDeleted: [{ type: Output }],
        onDataPreLoad: [{ type: Output }],
        onColumnResized: [{ type: Output }],
        onContextMenu: [{ type: Output }],
        onDoubleClick: [{ type: Output }],
        onColumnVisibilityChanged: [{ type: Output }],
        onColumnMovingStart: [{ type: Output }],
        onColumnMoving: [{ type: Output }],
        onColumnMovingEnd: [{ type: Output }],
        onFocusChange: [{ type: Output }],
        onGridKeydown: [{ type: Output }],
        onRowDragStart: [{ type: Output }],
        onRowDragEnd: [{ type: Output }],
        resizeLine: [{ type: ViewChild, args: [IgxGridColumnResizerComponent,] }],
        columnList: [{ type: ContentChildren, args: [IgxColumnComponent, { read: IgxColumnComponent, descendants: true },] }],
        excelStyleSortingTemplateDirective: [{ type: ContentChild, args: [IgxExcelStyleSortingTemplateDirective, { read: IgxExcelStyleSortingTemplateDirective },] }],
        excelStyleMovingTemplateDirective: [{ type: ContentChild, args: [IgxExcelStyleMovingTemplateDirective, { read: IgxExcelStyleMovingTemplateDirective },] }],
        excelStyleHidingTemplateDirective: [{ type: ContentChild, args: [IgxExcelStyleHidingTemplateDirective, { read: IgxExcelStyleHidingTemplateDirective },] }],
        excelStylePinningTemplateDirective: [{ type: ContentChild, args: [IgxExcelStylePinningTemplateDirective, { read: IgxExcelStylePinningTemplateDirective },] }],
        headerGroups: [{ type: ViewChildren, args: [IgxGridHeaderGroupComponent, { read: IgxGridHeaderGroupComponent },] }],
        _rowList: [{ type: ViewChildren, args: ['row',] }],
        _summaryRowList: [{ type: ViewChildren, args: ['summaryRow', { read: IgxSummaryRowComponent },] }],
        _dataRowList: [{ type: ViewChildren, args: [IgxRowComponent, { read: IgxRowComponent },] }],
        emptyFilteredGridTemplate: [{ type: ViewChild, args: ['emptyFilteredGrid', { read: TemplateRef },] }],
        emptyGridDefaultTemplate: [{ type: ViewChild, args: ['defaultEmptyGrid', { read: TemplateRef },] }],
        loadingGridDefaultTemplate: [{ type: ViewChild, args: ['defaultLoadingGrid', { read: TemplateRef },] }],
        parentVirtDir: [{ type: ViewChild, args: ['scrollContainer', { read: IgxGridForOfDirective },] }],
        toolbarCustomContentTemplates: [{ type: ContentChildren, args: [IgxGridToolbarCustomContentDirective, { read: IgxGridToolbarCustomContentDirective, descendants: false },] }],
        verticalScrollContainer: [{ type: ViewChild, args: ['verticalScrollContainer', { read: IgxGridForOfDirective },] }],
        verticalScroll: [{ type: ViewChild, args: ['verticalScrollHolder', { read: IgxGridForOfDirective },] }],
        scr: [{ type: ViewChild, args: ['scr', { read: ElementRef },] }],
        paginator: [{ type: ViewChild, args: ['paginator', { read: ElementRef },] }],
        headerContainer: [{ type: ViewChild, args: ['headerContainer', { read: IgxGridForOfDirective },] }],
        headerCheckboxContainer: [{ type: ViewChild, args: ['headerCheckboxContainer',] }],
        headerDragContainer: [{ type: ViewChild, args: ['headerDragContainer',] }],
        headerGroupContainer: [{ type: ViewChild, args: ['headerGroupContainer',] }],
        headerCheckbox: [{ type: ViewChild, args: ['headerCheckbox', { read: IgxCheckboxComponent },] }],
        filteringRow: [{ type: ViewChild, args: ['filteringRow', { read: IgxGridFilteringRowComponent },] }],
        theadRow: [{ type: ViewChild, args: ['theadRow',] }],
        tbody: [{ type: ViewChild, args: ['tbody',] }],
        tfoot: [{ type: ViewChild, args: ['tfoot',] }],
        _outletDirective: [{ type: ViewChild, args: ['igxFilteringOverlayOutlet', { read: IgxOverlayOutletDirective },] }],
        rowEditingOutletDirective: [{ type: ViewChild, args: ['igxRowEditingOverlayOutlet', { read: IgxOverlayOutletDirective },] }],
        dragIndicatorIconBase: [{ type: ViewChild, args: ['dragIndicatorIconBase', { read: TemplateRef },] }],
        defaultRowEditTemplate: [{ type: ViewChild, args: ['defaultRowEditTemplate', { read: TemplateRef },] }],
        rowEditCustom: [{ type: ContentChild, args: [IgxRowEditTemplateDirective, { read: TemplateRef },] }],
        rowEditText: [{ type: ContentChild, args: [IgxRowEditTextDirective, { read: TemplateRef },] }],
        rowEditActions: [{ type: ContentChild, args: [IgxRowEditActionsDirective, { read: TemplateRef },] }],
        rowEditTabsDEFAULT: [{ type: ViewChildren, args: [IgxRowEditTabStopDirective,] }],
        rowEditTabsCUSTOM: [{ type: ContentChildren, args: [IgxRowEditTabStopDirective,] }],
        rowEditingOverlay: [{ type: ViewChild, args: [IgxToggleDirective,] }],
        tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
        hostClass: [{ type: HostBinding, args: ['attr.class',] }],
        hostRole: [{ type: HostBinding, args: ['attr.role',] }],
        sortingExpressions: [{ type: Input }],
        hiddenColumnsText: [{ type: Input }],
        pinnedColumnsText: [{ type: Input }],
        toolbar: [{ type: ViewChild, args: ['toolbar', { read: IgxGridToolbarComponent },] }],
        toolbarHtml: [{ type: ViewChild, args: ['toolbar', { read: ElementRef },] }],
        showToolbar: [{ type: Input }],
        toolbarTitle: [{ type: Input }],
        exportExcel: [{ type: Input }],
        exportCsv: [{ type: Input }],
        exportText: [{ type: Input }],
        exportExcelText: [{ type: Input }],
        exportCsvText: [{ type: Input }],
        onToolbarExporting: [{ type: Output }],
        onRangeSelection: [{ type: Output }]
    };
    __decorate([
        WatchChanges(),
        __metadata("design:type", Number),
        __metadata("design:paramtypes", [Number])
    ], IgxGridBaseComponent.prototype, "filteringLogic", null);
    __decorate([
        WatchChanges(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], IgxGridBaseComponent.prototype, "filteringExpressionsTree", null);
    __decorate([
        WatchChanges(),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], IgxGridBaseComponent.prototype, "rowSelectable", null);
    __decorate([
        WatchChanges(),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], IgxGridBaseComponent.prototype, "rowEditable", null);
    __decorate([
        WatchChanges(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], IgxGridBaseComponent.prototype, "height", null);
    __decorate([
        WatchChanges(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], IgxGridBaseComponent.prototype, "width", null);
    __decorate([
        WatchChanges(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], IgxGridBaseComponent.prototype, "rowHeight", null);
    __decorate([
        WatchChanges(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], IgxGridBaseComponent.prototype, "columnWidth", null);
    __decorate([
        WatchChanges(),
        __metadata("design:type", Object)
    ], IgxGridBaseComponent.prototype, "primaryKey", void 0);
    __decorate([
        WatchChanges(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], IgxGridBaseComponent.prototype, "columnPinning", null);
    __decorate([
        DeprecateProperty('onFocusChange event is deprecated. Use onGridKeydown event instead.'),
        __metadata("design:type", Object)
    ], IgxGridBaseComponent.prototype, "onFocusChange", void 0);
    __decorate([
        WatchChanges(),
        __metadata("design:type", Array),
        __metadata("design:paramtypes", [Array])
    ], IgxGridBaseComponent.prototype, "sortingExpressions", null);
    __decorate([
        WatchChanges(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], IgxGridBaseComponent.prototype, "hiddenColumnsText", null);
    __decorate([
        WatchChanges(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], IgxGridBaseComponent.prototype, "pinnedColumnsText", null);
    __decorate([
        WatchChanges(),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], IgxGridBaseComponent.prototype, "showToolbar", null);
    __decorate([
        WatchChanges(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], IgxGridBaseComponent.prototype, "toolbarTitle", null);
    __decorate([
        WatchChanges(),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], IgxGridBaseComponent.prototype, "exportExcel", null);
    __decorate([
        WatchChanges(),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], IgxGridBaseComponent.prototype, "exportCsv", null);
    __decorate([
        WatchChanges(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], IgxGridBaseComponent.prototype, "exportText", null);
    __decorate([
        WatchChanges(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], IgxGridBaseComponent.prototype, "exportExcelText", null);
    __decorate([
        WatchChanges(),
        __metadata("design:type", String),
        __metadata("design:paramtypes", [String])
    ], IgxGridBaseComponent.prototype, "exportCsvText", null);
    __decorate([
        DeprecateMethod('There is no need to call clearSummaryCache method.The summary cache is cleared automatically when needed.'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Object]),
        __metadata("design:returntype", void 0)
    ], IgxGridBaseComponent.prototype, "clearSummaryCache", null);
    __decorate([
        DeprecateMethod('There is no need to call recalculateSummaries method. The summaries are recalculated automatically when needed.'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], IgxGridBaseComponent.prototype, "recalculateSummaries", null);
    return IgxGridBaseComponent;
}(DisplayDensityBase));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxTemplateOutletDirective = /** @class */ (function () {
    function IgxTemplateOutletDirective(_viewContainerRef, _zone, cdr) {
        this._viewContainerRef = _viewContainerRef;
        this._zone = _zone;
        this.cdr = cdr;
        /**
         * The embedded views cache. Collection is key-value paired.
         * Key is the template id, value is the embedded view for the related template.
         */
        this._embeddedViewsMap = new Map();
        this.onViewCreated = new EventEmitter();
        this.onViewMoved = new EventEmitter();
        this.onCachedViewLoaded = new EventEmitter();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    IgxTemplateOutletDirective.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        /** @type {?} */
        var actionType = this._getActionType(changes);
        switch (actionType) {
            case TemplateOutletAction.CreateView:
                this._recreateView();
                break;
            case TemplateOutletAction.MoveView:
                this._moveView();
                break;
            case TemplateOutletAction.UseCachedView:
                this._useCachedView();
                break;
            case TemplateOutletAction.UpdateViewContext:
                this._updateExistingContext(this.igxTemplateOutletContext);
                break;
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxTemplateOutletDirective.prototype._recreateView = /**
     * @private
     * @return {?}
     */
    function () {
        // detach old and create new
        if (this._viewRef) {
            this._viewContainerRef.detach(this._viewContainerRef.indexOf(this._viewRef));
        }
        if (this.igxTemplateOutlet) {
            this._viewRef = this._viewContainerRef.createEmbeddedView(this.igxTemplateOutlet, this.igxTemplateOutletContext);
            this.onViewCreated.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext });
            /** @type {?} */
            var tmplId = this.igxTemplateOutletContext['templateID'];
            if (tmplId) {
                // if context contains a template id, check if we have a view for that template already stored in the cache
                // if not create a copy and add it to the cache in detached state.
                // Note: Views in detached state do not appear in the DOM, however they remain stored in memory.
                /** @type {?} */
                var res = this._embeddedViewsMap.get(this.igxTemplateOutletContext['templateID']);
                if (!res) {
                    this._embeddedViewsMap.set(this.igxTemplateOutletContext['templateID'], this._viewRef);
                }
            }
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxTemplateOutletDirective.prototype._moveView = /**
     * @private
     * @return {?}
     */
    function () {
        // using external view and inserting it in current view.
        /** @type {?} */
        var view = this.igxTemplateOutletContext['moveView'];
        /** @type {?} */
        var owner = this.igxTemplateOutletContext['owner'];
        if (view !== this._viewRef) {
            if (owner._viewContainerRef.indexOf(view) !== -1) {
                // detach in case view it is attached somewhere else at the moment.
                owner._viewContainerRef.detach(owner._viewContainerRef.indexOf(view));
            }
            if (this._viewRef && this._viewContainerRef.indexOf(this._viewRef) !== -1) {
                this._viewContainerRef.detach(this._viewContainerRef.indexOf(this._viewRef));
            }
            this._viewRef = view;
            this._viewContainerRef.insert(view, 0);
            this._updateExistingContext(this.igxTemplateOutletContext);
            this.onViewMoved.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext });
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxTemplateOutletDirective.prototype._useCachedView = /**
     * @private
     * @return {?}
     */
    function () {
        // use view for specific template cached in the current template outlet
        /** @type {?} */
        var tmplID = this.igxTemplateOutletContext['templateID'];
        /** @type {?} */
        var cachedView = tmplID ?
            this._embeddedViewsMap.get(tmplID) :
            null;
        // if view exists, but template has been changed and there is a view in the cache with the related template
        // then detach old view and insert the stored one with the matching template
        // after that update its context.
        this._viewContainerRef.detach(this._viewContainerRef.indexOf(this._viewRef));
        this._viewRef = cachedView;
        /** @type {?} */
        var oldContext = this._cloneContext(cachedView.context);
        this._viewContainerRef.insert(this._viewRef, 0);
        this._updateExistingContext(this.igxTemplateOutletContext);
        this.onCachedViewLoaded.emit({ owner: this, view: this._viewRef, context: this.igxTemplateOutletContext, oldContext: oldContext });
    };
    /**
     * @private
     * @param {?} changes
     * @return {?}
     */
    IgxTemplateOutletDirective.prototype._shouldRecreateView = /**
     * @private
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        /** @type {?} */
        var ctxChange = changes['igxTemplateOutletContext'];
        return !!changes['igxTemplateOutlet'] || (ctxChange && this._hasContextShapeChanged(ctxChange));
    };
    /**
     * @private
     * @param {?} ctxChange
     * @return {?}
     */
    IgxTemplateOutletDirective.prototype._hasContextShapeChanged = /**
     * @private
     * @param {?} ctxChange
     * @return {?}
     */
    function (ctxChange) {
        var e_1, _a;
        /** @type {?} */
        var prevCtxKeys = Object.keys(ctxChange.previousValue || {});
        /** @type {?} */
        var currCtxKeys = Object.keys(ctxChange.currentValue || {});
        if (prevCtxKeys.length === currCtxKeys.length) {
            try {
                for (var currCtxKeys_1 = __values(currCtxKeys), currCtxKeys_1_1 = currCtxKeys_1.next(); !currCtxKeys_1_1.done; currCtxKeys_1_1 = currCtxKeys_1.next()) {
                    var propName = currCtxKeys_1_1.value;
                    if (prevCtxKeys.indexOf(propName) === -1) {
                        return true;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (currCtxKeys_1_1 && !currCtxKeys_1_1.done && (_a = currCtxKeys_1.return)) _a.call(currCtxKeys_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return false;
        }
        else {
            return true;
        }
    };
    /**
     * @private
     * @param {?} ctx
     * @return {?}
     */
    IgxTemplateOutletDirective.prototype._updateExistingContext = /**
     * @private
     * @param {?} ctx
     * @return {?}
     */
    function (ctx) {
        var e_2, _a;
        try {
            for (var _b = __values(Object.keys(ctx)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var propName = _c.value;
                ((/** @type {?} */ (this._viewRef.context)))[propName] = ((/** @type {?} */ (this.igxTemplateOutletContext)))[propName];
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    /**
     * @private
     * @param {?} ctx
     * @return {?}
     */
    IgxTemplateOutletDirective.prototype._cloneContext = /**
     * @private
     * @param {?} ctx
     * @return {?}
     */
    function (ctx) {
        var e_3, _a;
        /** @type {?} */
        var clone = {};
        try {
            for (var _b = __values(Object.keys(ctx)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var propName = _c.value;
                clone[propName] = ctx[propName];
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return clone;
    };
    /**
     * @private
     * @param {?} changes
     * @return {?}
     */
    IgxTemplateOutletDirective.prototype._getActionType = /**
     * @private
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        /** @type {?} */
        var movedView = this.igxTemplateOutletContext['moveView'];
        /** @type {?} */
        var tmplID = this.igxTemplateOutletContext['templateID'];
        /** @type {?} */
        var cachedView = tmplID ?
            this._embeddedViewsMap.get(tmplID) :
            null;
        /** @type {?} */
        var shouldRecreate = this._shouldRecreateView(changes);
        if (movedView) {
            // view is moved from external source
            return TemplateOutletAction.MoveView;
        }
        else if (shouldRecreate && cachedView) {
            // should recreate (template or context change) and there is a matching template in cache
            return TemplateOutletAction.UseCachedView;
        }
        else if (!this._viewRef || shouldRecreate) {
            // no view or should recreate
            return TemplateOutletAction.CreateView;
        }
        else if (this.igxTemplateOutletContext) {
            // has context, update context
            return TemplateOutletAction.UpdateViewContext;
        }
    };
    IgxTemplateOutletDirective.decorators = [
        { type: Directive, args: [{ selector: '[igxTemplateOutlet]' },] }
    ];
    /** @nocollapse */
    IgxTemplateOutletDirective.ctorParameters = function () { return [
        { type: ViewContainerRef },
        { type: NgZone },
        { type: ChangeDetectorRef }
    ]; };
    IgxTemplateOutletDirective.propDecorators = {
        igxTemplateOutletContext: [{ type: Input }],
        igxTemplateOutlet: [{ type: Input }],
        onViewCreated: [{ type: Output }],
        onViewMoved: [{ type: Output }],
        onCachedViewLoaded: [{ type: Output }]
    };
    return IgxTemplateOutletDirective;
}());
/** @enum {number} */
var TemplateOutletAction = {
    CreateView: 0,
    MoveView: 1,
    UseCachedView: 2,
    UpdateViewContext: 3,
};
TemplateOutletAction[TemplateOutletAction.CreateView] = 'CreateView';
TemplateOutletAction[TemplateOutletAction.MoveView] = 'MoveView';
TemplateOutletAction[TemplateOutletAction.UseCachedView] = 'UseCachedView';
TemplateOutletAction[TemplateOutletAction.UpdateViewContext] = 'UpdateViewContext';
/**
 * @hidden
 */
var IgxTemplateOutletModule = /** @class */ (function () {
    function IgxTemplateOutletModule() {
    }
    IgxTemplateOutletModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxTemplateOutletDirective],
                    entryComponents: [],
                    exports: [IgxTemplateOutletDirective],
                    imports: [CommonModule]
                },] }
    ];
    return IgxTemplateOutletModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxSummaryDataPipe = /** @class */ (function () {
    function IgxSummaryDataPipe(gridAPI) {
        this.gridAPI = gridAPI;
    }
    /**
     * @param {?} id
     * @param {?=} trigger
     * @return {?}
     */
    IgxSummaryDataPipe.prototype.transform = /**
     * @param {?} id
     * @param {?=} trigger
     * @return {?}
     */
    function (id, trigger$$1) {
        if (trigger$$1 === void 0) { trigger$$1 = 0; }
        /** @type {?} */
        var summaryService = this.gridAPI.grid.summaryService;
        return summaryService.calculateSummaries(summaryService.rootSummaryID, this.gridAPI.get_summary_data());
    };
    IgxSummaryDataPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'igxGridSummaryDataPipe',
                    pure: true
                },] }
    ];
    /** @nocollapse */
    IgxSummaryDataPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };
    return IgxSummaryDataPipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxProcessBarTextTemplateDirective = /** @class */ (function () {
    function IgxProcessBarTextTemplateDirective(template) {
        this.template = template;
    }
    IgxProcessBarTextTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxProcessBarText]'
                },] }
    ];
    /** @nocollapse */
    IgxProcessBarTextTemplateDirective.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return IgxProcessBarTextTemplateDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var ONE_PERCENT = 0.01;
/** @type {?} */
var MIN_VALUE = 0;
/** @enum {string} */
var IgxTextAlign = {
    START: 'start',
    CENTER: 'center',
    END: 'end',
};
/** @enum {string} */
var IgxProgressType = {
    DANGER: 'danger',
    INFO: 'info',
    WARNING: 'warning',
    SUCCESS: 'success',
};
/**
 * @abstract
 */
var  /**
 * @abstract
 */
BaseProgress = /** @class */ (function () {
    function BaseProgress() {
        /**
         * @hidden
         */
        this.requestAnimationId = undefined;
        /**
         * @hidden
         */
        this._valueInPercent = MIN_VALUE;
        /**
         * @hidden
         */
        this._max = 100;
        /**
         * @hidden
         */
        this._value = MIN_VALUE;
        /**
         * @hidden
         */
        this._animate = true;
    }
    Object.defineProperty(BaseProgress.prototype, "valueInPercent", {
        /**
         *Returns the `IgxLinearProgressBarComponent`/`IgxCircularProgressBarComponent` value in percentage.
         *```typescript
         *@ViewChild("MyProgressBar")
         *public progressBar: IgxLinearProgressBarComponent; // IgxCircularProgressBarComponent
         *public valuePercent(event){
         *    let percentValue = this.progressBar.valueInPercent;
         *    alert(percentValue);
         *}
         *```
         */
        get: /**
         * Returns the `IgxLinearProgressBarComponent`/`IgxCircularProgressBarComponent` value in percentage.
         * ```typescript
         * \@ViewChild("MyProgressBar")
         * public progressBar: IgxLinearProgressBarComponent; // IgxCircularProgressBarComponent
         * public valuePercent(event){
         *    let percentValue = this.progressBar.valueInPercent;
         *    alert(percentValue);
         * }
         * ```
         * @return {?}
         */
        function () {
            return this._valueInPercent;
        },
        /**
         *Sets the `IgxLinearProgressBarComponent`/`IgxCircularProgressBarComponent` value in percentage.
         *```typescript
         *@ViewChild("MyProgressBar")
         *public progressBar: IgxLinearProgressBarComponent; // IgxCircularProgressBarComponent
         *    public setValue(event){
         *    this.progressBar.valueInPercent = 56;
         *}
         * //...
         *```
         *```html
         *<button igxButton="fab" igxRipple="" (click)="setValue()">setValue</button>
         *```
         */
        set: /**
         * Sets the `IgxLinearProgressBarComponent`/`IgxCircularProgressBarComponent` value in percentage.
         * ```typescript
         * \@ViewChild("MyProgressBar")
         * public progressBar: IgxLinearProgressBarComponent; // IgxCircularProgressBarComponent
         *    public setValue(event){
         *    this.progressBar.valueInPercent = 56;
         * }
         * //...
         * ```
         * ```html
         * <button igxButton="fab" igxRipple="" (click)="setValue()">setValue</button>
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._valueInPercent = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} val
     * @param {?} step
     * @return {?}
     */
    BaseProgress.prototype.runAnimation = /**
     * @hidden
     * @protected
     * @param {?} val
     * @param {?} step
     * @return {?}
     */
    function (val, step) {
        var _this = this;
        this.requestAnimationId = requestAnimationFrame(function () { return _this.updateProgressSmoothly.call(_this, val, step); });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} val
     * @param {?} step
     * @return {?}
     */
    BaseProgress.prototype.updateProgressSmoothly = /**
     * @hidden
     * @protected
     * @param {?} val
     * @param {?} step
     * @return {?}
     */
    function (val, step) {
        var _this = this;
        this._value += step;
        /** @type {?} */
        var passedValue = convertInPercentage(val, this._max);
        /** @type {?} */
        var progressValue = convertInPercentage(this._value, this._max);
        if (this.valueInPercent === passedValue) {
            this.updateProgress(val);
            cancelAnimationFrame(this.requestAnimationId);
        }
        else if (this.isInLimitRange(progressValue, passedValue, step)) {
            this.updateProgress(val);
            cancelAnimationFrame(this.requestAnimationId);
        }
        else {
            this.valueInPercent = progressValue;
            this.requestAnimationId = requestAnimationFrame(function () { return _this.updateProgressSmoothly.call(_this, val, step); });
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} val
     * @return {?}
     */
    BaseProgress.prototype.updateProgressDirectly = /**
     * @hidden
     * @protected
     * @param {?} val
     * @return {?}
     */
    function (val) {
        this._value = val;
        this.valueInPercent = convertInPercentage(this._value, this._max);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} currentValue
     * @param {?} prevValue
     * @param {?} step
     * @return {?}
     */
    BaseProgress.prototype.directionFlow = /**
     * @hidden
     * @protected
     * @param {?} currentValue
     * @param {?} prevValue
     * @param {?} step
     * @return {?}
     */
    function (currentValue, prevValue, step) {
        if (currentValue < prevValue) {
            return step;
        }
        return -step;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @private
     * @param {?} val
     * @param {?} comparator
     * @param {?} step
     * @return {?}
     */
    BaseProgress.prototype.isInLimitRange = /**
     * @hidden
     * @private
     * @param {?} val
     * @param {?} comparator
     * @param {?} step
     * @return {?}
     */
    function (val, comparator, step) {
        return this.isExceedingUpperLimit(val, comparator, step) || this.isExceedingLowerLimit(val, comparator, step);
    };
    /**
     * @hidden
     *
     *
     * @param val
     * @param comparator
     * @param step
     */
    /**
     * @hidden
     *
     *
     * @private
     * @param {?} val
     * @param {?} comparator
     * @param {?} step
     * @return {?}
     */
    BaseProgress.prototype.isExceedingUpperLimit = /**
     * @hidden
     *
     *
     * @private
     * @param {?} val
     * @param {?} comparator
     * @param {?} step
     * @return {?}
     */
    function (val, comparator, step) {
        return val > comparator && step > 0;
    };
    /**
     * @hidden
     *
     * @param val
     * @param comparator
     * @param step
     */
    /**
     * @hidden
     *
     * @private
     * @param {?} val
     * @param {?} comparator
     * @param {?} step
     * @return {?}
     */
    BaseProgress.prototype.isExceedingLowerLimit = /**
     * @hidden
     *
     * @private
     * @param {?} val
     * @param {?} comparator
     * @param {?} step
     * @return {?}
     */
    function (val, comparator, step) {
        return val < comparator && step < 0;
    };
    /**
     * @hidden
     * @param step
     */
    /**
     * @hidden
     * @private
     * @param {?} val
     * @return {?}
     */
    BaseProgress.prototype.updateProgress = /**
     * @hidden
     * @private
     * @param {?} val
     * @return {?}
     */
    function (val) {
        this._value = val;
        this.valueInPercent = convertInPercentage(this._value, this._max);
    };
    return BaseProgress;
}());
/** @type {?} */
var NEXT_LINEAR_ID = 0;
/** @type {?} */
var NEXT_CIRCULAR_ID = 0;
var IgxLinearProgressBarComponent = /** @class */ (function (_super) {
    __extends(IgxLinearProgressBarComponent, _super);
    function IgxLinearProgressBarComponent() {
        var _this = _super.call(this) || this;
        _this.valueMin = 0;
        _this.cssClass = 'igx-linear-bar';
        /**
         * Set `IgxLinearProgressBarComponent` to have striped style. By default it is set to false.
         * ```html
         * <igx-linear-bar [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
         * ```
         */
        _this.striped = false;
        /**
         * Set `IgxLinearProgressBarComponent` to have indeterminate. By default it is set to false.
         * ```html
         * <igx-linear-bar [indeterminate]="true"></igx-linear-bar>
         * ```
         */
        _this.indeterminate = false;
        /**
         * An \@Input property that sets the value of the `role` attribute. If not provided it will be automatically set to `progressbar`.
         * ```html
         * <igx-linear-bar role="progressbar"></igx-linear-bar>
         * ```
         */
        _this.role = 'progressbar';
        /**
         * An \@Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-linear-bar [id]="'igx-linear-bar-55'" [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
         * ```
         */
        _this.id = "igx-linear-bar-" + NEXT_LINEAR_ID++;
        /**
         * Set the position that defines where the text is aligned.
         * Possible options - `IgxTextAlign.START` (default), `IgxTextAlign.CENTER`, `IgxTextAlign.END`.
         * ```typescript
         * public positionCenter: IgxTextAlign;
         * public ngOnInit() {
         *    this.positionCenter = IgxTextAlign.CENTER;
         * }
         * //...
         * ```
         * ```html
         * <igx-linear-bar type="warning" [text]="'Custom text'" [textAlign]="positionCenter" [striped]="true"></igx-linear-bar>
         * ```
         */
        _this.textAlign = IgxTextAlign.START;
        /**
         * Set the text to be visible. By default it is set to true.
         * ```html
         * <igx-linear-bar type="default" [textVisibility]="false"></igx-linear-bar>
         * ```
         */
        _this.textVisibility = true;
        /**
         * Set the position that defines if the text should be aligned above the progress line. By default is set to false.
         * ```html
         * <igx-linear-bar type="danger" [textTop]="true"></igx-linear-bar>
         * ```
         */
        _this.textTop = false;
        /**
         * Set type of the `IgxLinearProgressBarComponent`. Possible options - `default`, `success`, `info`, `warning`, and `danger`.
         * ```html
         * <igx-linear-bar [striped]="false" [max]="100" [value]="0" type="danger"></igx-linear-bar>
         * ```
         */
        _this.type = 'default';
        /**
         * An event, which is triggered after a progress is changed.
         * ```typescript
         * public progressChange(event) {
         *    alert("Progress made!");
         * }
         * //...
         * ```
         * ```html
         * <igx-linear-bar (onProgressChanged)="progressChange($event)" type="success">
         * ```
         */
        _this.onProgressChanged = new EventEmitter();
        return _this;
    }
    Object.defineProperty(IgxLinearProgressBarComponent.prototype, "animate", {
        /**
         *Returns whether the `IgxLinearProgressBarComponent` has animation true/false.
         *```typescript
         *@ViewChild("MyProgressBar")
         *public progressBar: IgxLinearProgressBarComponent;
         *public animationStatus(event) {
         *    let animationStatus = this.progressBar.animate;
         *    alert(animationStatus);
         *}
         *```
         */
        get: /**
         * Returns whether the `IgxLinearProgressBarComponent` has animation true/false.
         * ```typescript
         * \@ViewChild("MyProgressBar")
         * public progressBar: IgxLinearProgressBarComponent;
         * public animationStatus(event) {
         *    let animationStatus = this.progressBar.animate;
         *    alert(animationStatus);
         * }
         * ```
         * @return {?}
         */
        function () {
            return this._animate;
        },
        /**
         *Animation on progress `IgxLinearProgressBarComponent`. By default it is set to true.
         *```html
         *<igx-linear-bar [animate]="false" [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
         *```
         */
        set: /**
         * Animation on progress `IgxLinearProgressBarComponent`. By default it is set to true.
         * ```html
         * <igx-linear-bar [animate]="false" [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
         * ```
         * @param {?} animate
         * @return {?}
         */
        function (animate$$1) {
            this._animate = animate$$1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxLinearProgressBarComponent.prototype, "max", {
        /**
         *Returns the the maximum progress value of the `IgxLinearProgressBarComponent`.
         *```typescript
         *@ViewChild("MyProgressBar")
         *public progressBar: IgxLinearProgressBarComponent;
         *public maxValue(event) {
         *    let max = this.progressBar.max;
         *    alert(max);
         *}
         *```
         */
        get: /**
         * Returns the the maximum progress value of the `IgxLinearProgressBarComponent`.
         * ```typescript
         * \@ViewChild("MyProgressBar")
         * public progressBar: IgxLinearProgressBarComponent;
         * public maxValue(event) {
         *    let max = this.progressBar.max;
         *    alert(max);
         * }
         * ```
         * @return {?}
         */
        function () {
            return this._max;
        },
        /**
         *Set maximum value that can be passed. By default it is set to 100.
         *```html
         *<igx-linear-bar [striped]="false" [max]="200" [value]="0"></igx-linear-bar>
         *```
         */
        set: /**
         * Set maximum value that can be passed. By default it is set to 100.
         * ```html
         * <igx-linear-bar [striped]="false" [max]="200" [value]="0"></igx-linear-bar>
         * ```
         * @param {?} maxNum
         * @return {?}
         */
        function (maxNum) {
            this._max = maxNum;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxLinearProgressBarComponent.prototype, "step", {
        /**
         *Returns the value which update the progress indicator of the `IgxLinearProgressBarComponent`.
         *```typescript
         *@ViewChild("MyProgressBar")
         *public progressBar: IgxLinearProgressBarComponent;
         *public stepValue(event) {
         *    let step = this.progressBar.step;
         *    alert(step);
         *}
         *```
         */
        get: /**
         * Returns the value which update the progress indicator of the `IgxLinearProgressBarComponent`.
         * ```typescript
         * \@ViewChild("MyProgressBar")
         * public progressBar: IgxLinearProgressBarComponent;
         * public stepValue(event) {
         *    let step = this.progressBar.step;
         *    alert(step);
         * }
         * ```
         * @return {?}
         */
        function () {
            if (this._step) {
                return this._step;
            }
            return this._max * ONE_PERCENT;
        },
        /**
         *Sets the value by which progress indicator is updated. By default it is 1% of the maximum value.
         *```html
         *<igx-linear-bar [striped]="false" [max]="200" [value]="0" [step]="1"></igx-linear-bar>
         *```
         */
        set: /**
         * Sets the value by which progress indicator is updated. By default it is 1% of the maximum value.
         * ```html
         * <igx-linear-bar [striped]="false" [max]="200" [value]="0" [step]="1"></igx-linear-bar>
         * ```
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._step = Number(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxLinearProgressBarComponent.prototype, "value", {
        /**
        *Returns value that indicates the current `IgxLinearProgressBarComponent` position.
        *```typescript
        *@ViewChild("MyProgressBar")
        *public progressBar: IgxLinearProgressBarComponent;
        *public getValue(event) {
        *    let value = this.progressBar.value;
        *    alert(value);
        *}
        *```
        */
        get: /**
         * Returns value that indicates the current `IgxLinearProgressBarComponent` position.
         * ```typescript
         * \@ViewChild("MyProgressBar")
         * public progressBar: IgxLinearProgressBarComponent;
         * public getValue(event) {
         *    let value = this.progressBar.value;
         *    alert(value);
         * }
         * ```
         * @return {?}
         */
        function () {
            return this._value;
        },
        /**
         *Set value that indicates the current `IgxLinearProgressBarComponent` position.
         *```html
         *<igx-linear-bar [striped]="false" [max]="200" [value]="50"></igx-linear-bar>
         *```
         */
        set: /**
         * Set value that indicates the current `IgxLinearProgressBarComponent` position.
         * ```html
         * <igx-linear-bar [striped]="false" [max]="200" [value]="50"></igx-linear-bar>
         * ```
         * @param {?} val
         * @return {?}
         */
        function (val) {
            val = Number(val);
            if (this._value === val || this.indeterminate) {
                return;
            }
            /** @type {?} */
            var valueInRange = getValueInProperRange(val, this.max);
            if (isNaN(valueInRange)) {
                return;
            }
            /** @type {?} */
            var changedValues = {
                currentValue: valueInRange,
                previousValue: this._value
            };
            /** @type {?} */
            var updateValue = _super.prototype.directionFlow.call(this, this._value, val, this.step);
            if (this._animate && val >= this.step) {
                _super.prototype.runAnimation.call(this, valueInRange, updateValue);
            }
            else {
                _super.prototype.updateProgressDirectly.call(this, valueInRange);
            }
            this.onProgressChanged.emit(changedValues);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxLinearProgressBarComponent.prototype, "danger", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.type === IgxProgressType.DANGER;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxLinearProgressBarComponent.prototype, "info", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.type === IgxProgressType.INFO;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxLinearProgressBarComponent.prototype, "warning", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.type === IgxProgressType.WARNING;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxLinearProgressBarComponent.prototype, "success", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.type === IgxProgressType.SUCCESS;
        },
        enumerable: true,
        configurable: true
    });
    IgxLinearProgressBarComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-linear-bar',
                    template: "<div class=\"igx-linear-bar__base\">\n    <div class=\"igx-linear-bar__indicator\"\n    [style.width.%]=\"valueInPercent\"></div>\n</div>\n\n<span\n    class=\"igx-linear-bar__value\"\n    [ngClass]=\"{\n        'igx-linear-bar__value--start': textAlign === 'start',\n        'igx-linear-bar__value--center': textAlign === 'center',\n        'igx-linear-bar__value--end': textAlign === 'end',\n        'igx-linear-bar__value--top': textTop,\n        'igx-linear-bar__value--hidden': !textVisibility\n    }\">\n        {{text ? text : valueInPercent + '%'}}\n</span>\n"
                }] }
    ];
    /** @nocollapse */
    IgxLinearProgressBarComponent.ctorParameters = function () { return []; };
    IgxLinearProgressBarComponent.propDecorators = {
        animate: [{ type: Input }],
        max: [{ type: HostBinding, args: ['attr.aria-valuemax',] }, { type: Input }],
        step: [{ type: Input }],
        valueMin: [{ type: HostBinding, args: ['attr.aria-valuemin',] }],
        cssClass: [{ type: HostBinding, args: ['class.igx-linear-bar',] }],
        striped: [{ type: HostBinding, args: ['class.igx-linear-bar--striped',] }, { type: Input }],
        indeterminate: [{ type: HostBinding, args: ['class.igx-linear-bar--indeterminate',] }, { type: Input }],
        role: [{ type: HostBinding, args: ['attr.role',] }, { type: Input }],
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        textAlign: [{ type: Input }],
        textVisibility: [{ type: Input }],
        textTop: [{ type: Input }],
        text: [{ type: Input }],
        type: [{ type: Input }],
        value: [{ type: HostBinding, args: ['attr.aria-valuenow',] }, { type: Input }],
        onProgressChanged: [{ type: Output }],
        danger: [{ type: HostBinding, args: ['class.igx-linear-bar--danger',] }],
        info: [{ type: HostBinding, args: ['class.igx-linear-bar--info',] }],
        warning: [{ type: HostBinding, args: ['class.igx-linear-bar--warning',] }],
        success: [{ type: HostBinding, args: ['class.igx-linear-bar--success',] }]
    };
    return IgxLinearProgressBarComponent;
}(BaseProgress));
var IgxCircularProgressBarComponent = /** @class */ (function (_super) {
    __extends(IgxCircularProgressBarComponent, _super);
    function IgxCircularProgressBarComponent(renderer) {
        var _this = _super.call(this) || this;
        _this.renderer = renderer;
        _this.STROKE_OPACITY_DVIDER = 100;
        _this.STROKE_OPACITY_ADDITION = .2;
        /**
         * @hidden
         */
        _this.cssClass = 'igx-circular-bar';
        /**
         * An event, which is triggered after a progress is changed.
         * ```typescript
         * public progressChange(event) {
         *    alert("Progress made!");
         * }
         * //...
         * ```
         * ```html
         * <igx-circular-bar [value]="currentValue" (onProgressChanged)="progressChange($event)"></igx-circular-bar>
         * ```
         */
        _this.onProgressChanged = new EventEmitter();
        /**
         * An \@Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-circular-bar [id]="'igx-circular-bar-55'" [value]="50"></igx-circular-bar>
         * ```
         */
        _this.id = "igx-circular-bar-" + NEXT_CIRCULAR_ID++;
        /**
         * An \@Input property that sets the value of the `indeterminate` attribute. If not provided it will be automatically set to false.
         * ```html
         * <igx-circular-bar [indeterminate]="true"></igx-circular-bar>
         * ```
         */
        _this.indeterminate = false;
        /**
         * Sets the text visibility. By default it is set to true.
         * ```html
         * <igx-circular-bar [textVisibility]="false"></igx-circular-bar>
         * ```
         */
        _this.textVisibility = true;
        _this._circleRadius = 46;
        _this._circumference = 2 * Math.PI * _this._circleRadius;
        return _this;
    }
    Object.defineProperty(IgxCircularProgressBarComponent.prototype, "context", {
        /**
         * @hidden
        */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return {
                $implicit: { value: this.value, valueInPercent: this.valueInPercent, max: this.max }
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxCircularProgressBarComponent.prototype, "animate", {
        /**
         *Returns whether the `IgxCircularProgressBarComponent` has animation true/false.
         *```typescript
         *@ViewChild("MyProgressBar")
         *public progressBar: IgxCircularProgressBarComponent;
         *public animationStatus(event) {
         *    let animationStatus = this.progressBar.animate;
         *    alert(animationStatus);
         *}
         *```
         */
        get: /**
         * Returns whether the `IgxCircularProgressBarComponent` has animation true/false.
         * ```typescript
         * \@ViewChild("MyProgressBar")
         * public progressBar: IgxCircularProgressBarComponent;
         * public animationStatus(event) {
         *    let animationStatus = this.progressBar.animate;
         *    alert(animationStatus);
         * }
         * ```
         * @return {?}
         */
        function () {
            return this._animate;
        },
        /**
        *Animation on progress `IgxCircularProgressBarComponent`. By default it is set to true.
         *```html
         *<igx-circular-bar [animate]="false" [value]="50"></igx-circular-bar>
         *```
         */
        set: /**
         * Animation on progress `IgxCircularProgressBarComponent`. By default it is set to true.
         * ```html
         * <igx-circular-bar [animate]="false" [value]="50"></igx-circular-bar>
         * ```
         * @param {?} animate
         * @return {?}
         */
        function (animate$$1) {
            this._animate = animate$$1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxCircularProgressBarComponent.prototype, "max", {
        /**
         *Returns the the maximum progress value of the `IgxCircularProgressBarComponent`.
         *```typescript
         *@ViewChild("MyProgressBar")
         *public progressBar: IgxCircularProgressBarComponent;
         *public maxValue(event) {
         *    let max = this.progressBar.max;
         *    alert(max);
         *}
         *```
         *```html
         *<igx-circular-bar [max]="245" [animate]="false" [value]="currentValue"></igx-circular-bar>
         *```
         */
        get: /**
         * Returns the the maximum progress value of the `IgxCircularProgressBarComponent`.
         * ```typescript
         * \@ViewChild("MyProgressBar")
         * public progressBar: IgxCircularProgressBarComponent;
         * public maxValue(event) {
         *    let max = this.progressBar.max;
         *    alert(max);
         * }
         * ```
         * ```html
         * <igx-circular-bar [max]="245" [animate]="false" [value]="currentValue"></igx-circular-bar>
         * ```
         * @return {?}
         */
        function () {
            return this._max;
        },
        /**
         *Set maximum value that can be passed. By default it is set to 100.
         *```html
         *<igx-circular-bar [max]="200" [value]="0"></igx-circular-bar>
         *```
         */
        set: /**
         * Set maximum value that can be passed. By default it is set to 100.
         * ```html
         * <igx-circular-bar [max]="200" [value]="0"></igx-circular-bar>
         * ```
         * @param {?} maxNum
         * @return {?}
         */
        function (maxNum) {
            this._max = maxNum;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxCircularProgressBarComponent.prototype, "step", {
        /**
         *Returns the value which update the progress indicator of the `IgxCircularProgressBarComponent`.
         *```typescript
         *@ViewChild("MyProgressBar")
         *public progressBar: IgxCircularProgressBarComponent;
         *public stepValue(event) {
         *    let step = this.progressBar.step;
         *    alert(step);
         *}
         *```
         */
        get: /**
         * Returns the value which update the progress indicator of the `IgxCircularProgressBarComponent`.
         * ```typescript
         * \@ViewChild("MyProgressBar")
         * public progressBar: IgxCircularProgressBarComponent;
         * public stepValue(event) {
         *    let step = this.progressBar.step;
         *    alert(step);
         * }
         * ```
         * @return {?}
         */
        function () {
            if (this._step) {
                return this._step;
            }
            return this._max * ONE_PERCENT;
        },
        /**
         *Sets the value by which progress indicator is updated. By default it is 1% of the maximum value.
         *```html
         *<igx-circular-bar [striped]="false" [max]="200" [value]="0" [step]="1"></igx-circular-bar>
         *```
        */
        set: /**
         * Sets the value by which progress indicator is updated. By default it is 1% of the maximum value.
         * ```html
         * <igx-circular-bar [striped]="false" [max]="200" [value]="0" [step]="1"></igx-circular-bar>
         * ```
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this._step = Number(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxCircularProgressBarComponent.prototype, "value", {
        /**
         *Returns value that indicates the current `IgxCircularProgressBarComponent` position.
         *```typescript
         *@ViewChild("MyProgressBar")
         *public progressBar: IgxCircularProgressBarComponent;
         *public getValue(event) {
         *    let value = this.progressBar.value;
         *    alert(value);
         *}
         *```
         *```html
         *<button igxButton="fab" igxRipple="" (click)="getValue()">Click</button>
         *```
         */
        get: /**
         * Returns value that indicates the current `IgxCircularProgressBarComponent` position.
         * ```typescript
         * \@ViewChild("MyProgressBar")
         * public progressBar: IgxCircularProgressBarComponent;
         * public getValue(event) {
         *    let value = this.progressBar.value;
         *    alert(value);
         * }
         * ```
         * ```html
         * <button igxButton="fab" igxRipple="" (click)="getValue()">Click</button>
         * ```
         * @return {?}
         */
        function () {
            return this._value;
        },
        /**
         *Set value that indicates the current `IgxCircularProgressBarComponent` position.
         *```html
         *<igx-circular-bar [value]="50"></igx-circular-bar>
         *```
         */
        set: /**
         * Set value that indicates the current `IgxCircularProgressBarComponent` position.
         * ```html
         * <igx-circular-bar [value]="50"></igx-circular-bar>
         * ```
         * @param {?} val
         * @return {?}
         */
        function (val) {
            val = Number(val);
            if (this._value === val || this.indeterminate) {
                return;
            }
            /** @type {?} */
            var valueInProperRange = getValueInProperRange(val, this.max);
            if (isNaN(valueInProperRange)) {
                return;
            }
            /** @type {?} */
            var changedValues = {
                currentValue: valueInProperRange,
                previousValue: this._value
            };
            /** @type {?} */
            var updateValue = _super.prototype.directionFlow.call(this, this._value, val, this.step);
            if (this.animate && val >= this.step) {
                _super.prototype.runAnimation.call(this, valueInProperRange, updateValue);
            }
            else {
                this.updateProgressDirectly(valueInProperRange);
            }
            this.onProgressChanged.emit(changedValues);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} val
     * @param {?} step
     * @return {?}
     */
    IgxCircularProgressBarComponent.prototype.updateProgressSmoothly = /**
     * @hidden
     * @param {?} val
     * @param {?} step
     * @return {?}
     */
    function (val, step) {
        // Set frames for the animation
        /** @type {?} */
        var FRAMES = [{
                strokeDashoffset: this.getProgress(this._value),
                strokeOpacity: (this._value / this.STROKE_OPACITY_DVIDER) + this.STROKE_OPACITY_ADDITION
            }, {
                strokeDashoffset: this.getProgress(this.valueInPercent),
                strokeOpacity: (this.valueInPercent / this.STROKE_OPACITY_DVIDER) + this.STROKE_OPACITY_ADDITION
            }];
        this._svgCircle.nativeElement.animate(FRAMES, {
            easing: 'ease-out',
            fill: 'forwards'
        });
        _super.prototype.updateProgressSmoothly.call(this, val, step);
    };
    Object.defineProperty(IgxCircularProgressBarComponent.prototype, "textContent", {
        /**
         * @hidden
        */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.text;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
    */
    /**
     * @hidden
     * @param {?} val
     * @return {?}
     */
    IgxCircularProgressBarComponent.prototype.updateProgressDirectly = /**
     * @hidden
     * @param {?} val
     * @return {?}
     */
    function (val) {
        _super.prototype.updateProgressDirectly.call(this, val);
        this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke-dashoffset', this.getProgress(this.valueInPercent));
        this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke-opacity', (this.valueInPercent / this.STROKE_OPACITY_DVIDER) + this.STROKE_OPACITY_ADDITION);
    };
    /**
     * @private
     * @param {?} percentage
     * @return {?}
     */
    IgxCircularProgressBarComponent.prototype.getProgress = /**
     * @private
     * @param {?} percentage
     * @return {?}
     */
    function (percentage) {
        return this._circumference - (percentage * this._circumference / 100);
    };
    IgxCircularProgressBarComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-circular-bar',
                    template: "<svg #svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\"\n    viewBox=\"0 0 100 100\"\n    preserveAspectRatio=\"xMidYMid meet\"\n    role=\"progressbar\"\n    aria-valuemin=\"0\"\n    [attr.aria-valuemax]=\"max\"\n    [attr.aria-valuenow]=\"value\">\n    <circle class=\"igx-circular-bar__inner\" cx=\"50\" cy=\"50\" r=\"46\" />\n    <circle #circle class=\"igx-circular-bar__outer\" cx=\"50\" cy=\"50\" r=\"46\" />\n    <text [class.igx-circular-bar__text--hidden]=\"!textVisibility\" text-anchor=\"middle\" x=\"50\" y=\"60\">\n        <ng-container *ngTemplateOutlet=\"textTemplate ? textTemplate.template : defaultTextTemplate; context: context\">\n        </ng-container>\n    </text>\n\n    <ng-template #defaultTextTemplate>\n        <tspan class=\"igx-circular-bar__text\"> {{textContent ? textContent: valueInPercent + '%'}}</tspan>\n    </ng-template>\n</svg>\n"
                }] }
    ];
    /** @nocollapse */
    IgxCircularProgressBarComponent.ctorParameters = function () { return [
        { type: Renderer2 }
    ]; };
    IgxCircularProgressBarComponent.propDecorators = {
        cssClass: [{ type: HostBinding, args: ['class.igx-circular-bar',] }],
        onProgressChanged: [{ type: Output }],
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        indeterminate: [{ type: HostBinding, args: ['class.igx-circular-bar--indeterminate',] }, { type: Input }],
        textVisibility: [{ type: Input }],
        text: [{ type: Input }],
        textTemplate: [{ type: ContentChild, args: [IgxProcessBarTextTemplateDirective, { read: IgxProcessBarTextTemplateDirective },] }],
        animate: [{ type: Input }],
        max: [{ type: Input }],
        step: [{ type: Input }],
        value: [{ type: Input }],
        _svgCircle: [{ type: ViewChild, args: ['circle',] }]
    };
    return IgxCircularProgressBarComponent;
}(BaseProgress));
/**
 * @param {?} value
 * @param {?} max
 * @param {?=} min
 * @return {?}
 */
function getValueInProperRange(value, max, min) {
    if (min === void 0) { min = 0; }
    return Math.max(Math.min(value, max), min);
}
/**
 * @param {?} value
 * @param {?} max
 * @return {?}
 */
function convertInPercentage(value, max) {
    return Math.floor(100 * value / max);
}
/**
 * @hidden
 */
var IgxProgressBarModule = /** @class */ (function () {
    function IgxProgressBarModule() {
    }
    IgxProgressBarModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxLinearProgressBarComponent, IgxCircularProgressBarComponent, IgxProcessBarTextTemplateDirective],
                    exports: [IgxLinearProgressBarComponent, IgxCircularProgressBarComponent, IgxProcessBarTextTemplateDirective],
                    imports: [CommonModule]
                },] }
    ];
    return IgxProgressBarModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxGridCellStylesPipe = /** @class */ (function () {
    function IgxGridCellStylesPipe() {
    }
    /**
     * @param {?} cssClasses
     * @param {?} _value
     * @param {?} data
     * @param {?} field
     * @return {?}
     */
    IgxGridCellStylesPipe.prototype.transform = /**
     * @param {?} cssClasses
     * @param {?} _value
     * @param {?} data
     * @param {?} field
     * @return {?}
     */
    function (cssClasses, _value, data, field) {
        if (!cssClasses) {
            return '';
        }
        /** @type {?} */
        var result = [];
        Object.entries(cssClasses).forEach(function (_a) {
            var _b = __read(_a, 2), cssClass = _b[0], callbackOrValue = _b[1];
            /** @type {?} */
            var apply = typeof callbackOrValue === 'function' ? callbackOrValue(data, field) : callbackOrValue;
            if (apply) {
                result.push(cssClass);
            }
        });
        return result.join(' ');
    };
    IgxGridCellStylesPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'igxCellStyles'
                },] }
    ];
    return IgxGridCellStylesPipe;
}());
/**
 * @hidden
 * \@internal
 */
var IgxGridNotGroupedPipe = /** @class */ (function () {
    function IgxGridNotGroupedPipe() {
    }
    /**
     * @param {?} value
     * @return {?}
     */
    IgxGridNotGroupedPipe.prototype.transform = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return value.filter(function (item) { return !item.columnGroup; });
    };
    IgxGridNotGroupedPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'igxNotGrouped'
                },] }
    ];
    return IgxGridNotGroupedPipe;
}());
var IgxGridTopLevelColumns = /** @class */ (function () {
    function IgxGridTopLevelColumns() {
    }
    /**
     * @param {?} value
     * @return {?}
     */
    IgxGridTopLevelColumns.prototype.transform = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return value.filter(function (item) { return item.level === 0; });
    };
    IgxGridTopLevelColumns.decorators = [
        { type: Pipe, args: [{
                    name: 'igxTopLevel'
                },] }
    ];
    return IgxGridTopLevelColumns;
}());
/**
 * @hidden
 */
var IgxGridFilterConditionPipe = /** @class */ (function () {
    function IgxGridFilterConditionPipe() {
    }
    /**
     * @param {?} value
     * @return {?}
     */
    IgxGridFilterConditionPipe.prototype.transform = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return value.split(/(?=[A-Z])/).join(' ');
    };
    IgxGridFilterConditionPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'filterCondition',
                    pure: true
                },] }
    ];
    return IgxGridFilterConditionPipe;
}());
/**
 * @hidden
 */
var IgxGridTransactionPipe = /** @class */ (function () {
    function IgxGridTransactionPipe(gridAPI) {
        this.gridAPI = gridAPI;
    }
    /**
     * @param {?} collection
     * @param {?} id
     * @param {?} pipeTrigger
     * @return {?}
     */
    IgxGridTransactionPipe.prototype.transform = /**
     * @param {?} collection
     * @param {?} id
     * @param {?} pipeTrigger
     * @return {?}
     */
    function (collection, id, pipeTrigger) {
        /** @type {?} */
        var grid = this.gridAPI.grid;
        if (collection && grid.transactions.enabled) {
            /** @type {?} */
            var result = DataUtil.mergeTransactions(cloneArray(collection), grid.transactions.getAggregatedChanges(true), grid.primaryKey);
            return result;
        }
        return collection;
    };
    IgxGridTransactionPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'gridTransaction',
                    pure: true
                },] }
    ];
    /** @nocollapse */
    IgxGridTransactionPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };
    return IgxGridTransactionPipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxGridPipesModule = /** @class */ (function () {
    function IgxGridPipesModule() {
    }
    IgxGridPipesModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        IgxDatePipeComponent,
                        IgxDecimalPipeComponent,
                        IgxGridFilterConditionPipe,
                        IgxGridTransactionPipe,
                        IgxGridNotGroupedPipe,
                        IgxGridTopLevelColumns,
                        IgxGridCellStylesPipe
                    ],
                    exports: [
                        IgxDatePipeComponent,
                        IgxDecimalPipeComponent,
                        IgxGridFilterConditionPipe,
                        IgxGridTransactionPipe,
                        IgxGridNotGroupedPipe,
                        IgxGridTopLevelColumns,
                        IgxGridCellStylesPipe
                    ],
                    imports: [
                        CommonModule
                    ]
                },] }
    ];
    return IgxGridPipesModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxExcelStyleColumnMovingComponent = /** @class */ (function () {
    function IgxExcelStyleColumnMovingComponent() {
    }
    Object.defineProperty(IgxExcelStyleColumnMovingComponent.prototype, "visibleColumns", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return this.grid.visibleColumns.filter(function (col) { return !(col instanceof IgxColumnGroupComponent); });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxExcelStyleColumnMovingComponent.prototype, "canNotMoveLeft", {
        get: /**
         * @return {?}
         */
        function () {
            return this.column.visibleIndex === 0 ||
                (this.grid.unpinnedColumns.indexOf(this.column) === 0 && this.column.disablePinning) ||
                (this.column.level !== 0 && !this.findColumn(0, this.visibleColumns));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxExcelStyleColumnMovingComponent.prototype, "canNotMoveRight", {
        get: /**
         * @return {?}
         */
        function () {
            return this.column.visibleIndex === this.visibleColumns.length - 1 ||
                (this.column.level !== 0 && !this.findColumn(1, this.visibleColumns));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} moveDirection
     * @return {?}
     */
    IgxExcelStyleColumnMovingComponent.prototype.onMoveButtonClicked = /**
     * @param {?} moveDirection
     * @return {?}
     */
    function (moveDirection) {
        /** @type {?} */
        var targetColumn;
        if (this.column.pinned) {
            if (this.column.isLastPinned && moveDirection === 1) {
                targetColumn = this.grid.unpinnedColumns[0];
                moveDirection = 0;
            }
            else {
                targetColumn = this.findColumn(moveDirection, this.grid.pinnedColumns);
            }
        }
        else if (this.grid.unpinnedColumns.indexOf(this.column) === 0 && moveDirection === 0) {
            targetColumn = this.grid.pinnedColumns[this.grid.pinnedColumns.length - 1];
            moveDirection = 1;
        }
        else {
            targetColumn = this.findColumn(moveDirection, this.grid.unpinnedColumns);
        }
        this.grid.moveColumn(this.column, targetColumn, moveDirection);
    };
    /**
     * @private
     * @param {?} moveDirection
     * @param {?} columns
     * @return {?}
     */
    IgxExcelStyleColumnMovingComponent.prototype.findColumn = /**
     * @private
     * @param {?} moveDirection
     * @param {?} columns
     * @return {?}
     */
    function (moveDirection, columns) {
        /** @type {?} */
        var index = columns.indexOf(this.column);
        if (moveDirection === 0) {
            while (index > 0) {
                index--;
                if (columns[index].level === this.column.level && columns[index].parent === this.column.parent) {
                    return columns[index];
                }
            }
        }
        else {
            while (index < columns.length - 1) {
                index++;
                if (columns[index].level === this.column.level && columns[index].parent === this.column.parent) {
                    return columns[index];
                }
            }
        }
    };
    IgxExcelStyleColumnMovingComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-excel-style-column-moving',
                    template: "<header>\n    {{ grid.resourceStrings.igx_grid_excel_filter_moving_header }}\n</header>\n<section class=\"igx-excel-filter__move-buttons\">\n    <button [displayDensity]=\"displayDensity\"\n        igxButton\n        [disabled]=\"canNotMoveLeft\"\n        (click)=\"onMoveButtonClicked(0)\">\n        <igx-icon>arrow_back</igx-icon>\n        <span>\n            {{ displayDensity==='compact'?\n            grid.resourceStrings.igx_grid_excel_filter_moving_left_short:\n            grid.resourceStrings.igx_grid_excel_filter_moving_left }}\n        </span>\n    </button>\n    <button [displayDensity]=\"displayDensity\"\n        igxButton\n        [disabled]=\"canNotMoveRight\"\n        (click)=\"onMoveButtonClicked(1)\">\n        <span>\n            {{ displayDensity==='compact'?\n            grid.resourceStrings.igx_grid_excel_filter_moving_right_short:\n            grid.resourceStrings.igx_grid_excel_filter_moving_right }}\n        </span>\n        <igx-icon>arrow_forwards</igx-icon>\n    </button>\n</section>\n"
                }] }
    ];
    /** @nocollapse */
    IgxExcelStyleColumnMovingComponent.ctorParameters = function () { return []; };
    IgxExcelStyleColumnMovingComponent.propDecorators = {
        column: [{ type: Input }],
        grid: [{ type: Input }],
        displayDensity: [{ type: Input }]
    };
    return IgxExcelStyleColumnMovingComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 * @abstract
 */
var IgxListBase = /** @class */ (function (_super) {
    __extends(IgxListBase, _super);
    function IgxListBase(_displayDensityOptions) {
        var _this = _super.call(this, _displayDensityOptions) || this;
        _this._displayDensityOptions = _displayDensityOptions;
        return _this;
    }
    /** @nocollapse */
    IgxListBase.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
    ]; };
    return IgxListBase;
}(DisplayDensityBase));
/** @enum {number} */
var IgxListPanState = {
    NONE: 0, LEFT: 1, RIGHT: 2,
};
IgxListPanState[IgxListPanState.NONE] = 'NONE';
IgxListPanState[IgxListPanState.LEFT] = 'LEFT';
IgxListPanState[IgxListPanState.RIGHT] = 'RIGHT';
var IgxEmptyListTemplateDirective = /** @class */ (function () {
    function IgxEmptyListTemplateDirective(template) {
        this.template = template;
    }
    IgxEmptyListTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxEmptyList]'
                },] }
    ];
    /** @nocollapse */
    IgxEmptyListTemplateDirective.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return IgxEmptyListTemplateDirective;
}());
var IgxDataLoadingTemplateDirective = /** @class */ (function () {
    function IgxDataLoadingTemplateDirective(template) {
        this.template = template;
    }
    IgxDataLoadingTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxDataLoading]'
                },] }
    ];
    /** @nocollapse */
    IgxDataLoadingTemplateDirective.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return IgxDataLoadingTemplateDirective;
}());
var IgxListItemLeftPanningTemplateDirective = /** @class */ (function () {
    function IgxListItemLeftPanningTemplateDirective(template) {
        this.template = template;
    }
    IgxListItemLeftPanningTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxListItemLeftPanning]'
                },] }
    ];
    /** @nocollapse */
    IgxListItemLeftPanningTemplateDirective.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return IgxListItemLeftPanningTemplateDirective;
}());
var IgxListItemRightPanningTemplateDirective = /** @class */ (function () {
    function IgxListItemRightPanningTemplateDirective(template) {
        this.template = template;
    }
    IgxListItemRightPanningTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxListItemRightPanning]'
                },] }
    ];
    /** @nocollapse */
    IgxListItemRightPanningTemplateDirective.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return IgxListItemRightPanningTemplateDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var EVENT_SUFFIX = 'precise';
/**
 * Touch gestures manager based on Hammer.js
 * Use with caution, this will track references for single manager per element. Very TBD. Much TODO.
 * @hidden
 */
var HammerGesturesManager = /** @class */ (function () {
    function HammerGesturesManager(_zone, doc) {
        this._zone = _zone;
        this.doc = doc;
        /**
         * Event option defaults for each recognizer, see http://hammerjs.github.io/api/ for API listing.
         */
        this.hammerOptions = {
            // D.P. #447 Force TouchInput due to PointerEventInput bug (https://github.com/hammerjs/hammer.js/issues/1065)
            // see https://github.com/IgniteUI/igniteui-angular/issues/447#issuecomment-324601803
            inputClass: Hammer.TouchInput,
            recognizers: [
                [Hammer.Pan, { threshold: 0 }],
                [Hammer.Pinch, { enable: true }],
                [Hammer.Rotate, { enable: true }],
                [Hammer.Swipe, {
                        direction: Hammer.DIRECTION_HORIZONTAL
                    }]
            ]
        };
        this._hammerManagers = [];
    }
    /**
     * @param {?} eventName
     * @return {?}
     */
    HammerGesturesManager.prototype.supports = /**
     * @param {?} eventName
     * @return {?}
     */
    function (eventName) {
        return eventName.toLowerCase().endsWith('.' + EVENT_SUFFIX);
    };
    /**
     * Add listener extended with options for Hammer.js. Will use defaults if none are provided.
     * Modeling after other event plugins for easy future modifications.
     */
    /**
     * Add listener extended with options for Hammer.js. Will use defaults if none are provided.
     * Modeling after other event plugins for easy future modifications.
     * @param {?} element
     * @param {?} eventName
     * @param {?} eventHandler
     * @param {?=} options
     * @return {?}
     */
    HammerGesturesManager.prototype.addEventListener = /**
     * Add listener extended with options for Hammer.js. Will use defaults if none are provided.
     * Modeling after other event plugins for easy future modifications.
     * @param {?} element
     * @param {?} eventName
     * @param {?} eventHandler
     * @param {?=} options
     * @return {?}
     */
    function (element, eventName, eventHandler, options) {
        var _this = this;
        if (options === void 0) { options = null; }
        // Creating the manager bind events, must be done outside of angular
        return this._zone.runOutsideAngular(function () {
            /** @type {?} */
            var mc = _this.getManagerForElement(element);
            if (mc === null) {
                // new Hammer is a shortcut for Manager with defaults
                mc = new Hammer(element, _this.hammerOptions);
                _this.addManagerForElement(element, mc);
            }
            /** @type {?} */
            var handler = function (eventObj) { _this._zone.run(function () { eventHandler(eventObj); }); };
            mc.on(eventName, handler);
            return function () { mc.off(eventName, handler); };
        });
    };
    /**
     * Add listener extended with options for Hammer.js. Will use defaults if none are provided.
     * Modeling after other event plugins for easy future modifications.
     *
     * @param target Can be one of either window, body or document(fallback default).
     */
    /**
     * Add listener extended with options for Hammer.js. Will use defaults if none are provided.
     * Modeling after other event plugins for easy future modifications.
     *
     * @param {?} target Can be one of either window, body or document(fallback default).
     * @param {?} eventName
     * @param {?} eventHandler
     * @return {?}
     */
    HammerGesturesManager.prototype.addGlobalEventListener = /**
     * Add listener extended with options for Hammer.js. Will use defaults if none are provided.
     * Modeling after other event plugins for easy future modifications.
     *
     * @param {?} target Can be one of either window, body or document(fallback default).
     * @param {?} eventName
     * @param {?} eventHandler
     * @return {?}
     */
    function (target, eventName, eventHandler) {
        /** @type {?} */
        var element = this.getGlobalEventTarget(target);
        // Creating the manager bind events, must be done outside of angular
        return this.addEventListener((/** @type {?} */ (element)), eventName, eventHandler);
    };
    /**
     * Exposes [Dom]Adapter.getGlobalEventTarget to get global event targets.
     * Supported: window, document, body. Defaults to document for invalid args.
     * @param target Target name
     */
    /**
     * Exposes [Dom]Adapter.getGlobalEventTarget to get global event targets.
     * Supported: window, document, body. Defaults to document for invalid args.
     * @param {?} target Target name
     * @return {?}
     */
    HammerGesturesManager.prototype.getGlobalEventTarget = /**
     * Exposes [Dom]Adapter.getGlobalEventTarget to get global event targets.
     * Supported: window, document, body. Defaults to document for invalid args.
     * @param {?} target Target name
     * @return {?}
     */
    function (target) {
        return ÉµgetDOM().getGlobalEventTarget(this.doc, target);
    };
    /**
     * Set HammerManager options.
     *
     * @param element The DOM element used to create the manager on.
     *
     * ### Example
     *
     * ```ts
     * manager.setManagerOption(myElem, "pan", { pointers: 1 });
     * ```
     */
    /**
     * Set HammerManager options.
     *
     * @param {?} element The DOM element used to create the manager on.
     *
     * ### Example
     *
     * ```ts
     * manager.setManagerOption(myElem, "pan", { pointers: 1 });
     * ```
     * @param {?} event
     * @param {?} options
     * @return {?}
     */
    HammerGesturesManager.prototype.setManagerOption = /**
     * Set HammerManager options.
     *
     * @param {?} element The DOM element used to create the manager on.
     *
     * ### Example
     *
     * ```ts
     * manager.setManagerOption(myElem, "pan", { pointers: 1 });
     * ```
     * @param {?} event
     * @param {?} options
     * @return {?}
     */
    function (element, event, options) {
        /** @type {?} */
        var manager = this.getManagerForElement(element);
        manager.get(event).set(options);
    };
    /**
     * Add an element and manager map to the internal collection.
     *
     * @param element The DOM element used to create the manager on.
     */
    /**
     * Add an element and manager map to the internal collection.
     *
     * @param {?} element The DOM element used to create the manager on.
     * @param {?} manager
     * @return {?}
     */
    HammerGesturesManager.prototype.addManagerForElement = /**
     * Add an element and manager map to the internal collection.
     *
     * @param {?} element The DOM element used to create the manager on.
     * @param {?} manager
     * @return {?}
     */
    function (element, manager) {
        this._hammerManagers.push({ element: element, manager: manager });
    };
    /**
     * Get HammerManager for the element or null
     *
     * @param element The DOM element used to create the manager on.
     */
    /**
     * Get HammerManager for the element or null
     *
     * @param {?} element The DOM element used to create the manager on.
     * @return {?}
     */
    HammerGesturesManager.prototype.getManagerForElement = /**
     * Get HammerManager for the element or null
     *
     * @param {?} element The DOM element used to create the manager on.
     * @return {?}
     */
    function (element) {
        /** @type {?} */
        var result = this._hammerManagers.filter(function (value, index, array) {
            return value.element === element;
        });
        return result.length ? result[0].manager : null;
    };
    /**
     * Destroys the HammerManager for the element, removing event listeners in the process.
     *
     * @param element The DOM element used to create the manager on.
     */
    /**
     * Destroys the HammerManager for the element, removing event listeners in the process.
     *
     * @param {?} element The DOM element used to create the manager on.
     * @return {?}
     */
    HammerGesturesManager.prototype.removeManagerForElement = /**
     * Destroys the HammerManager for the element, removing event listeners in the process.
     *
     * @param {?} element The DOM element used to create the manager on.
     * @return {?}
     */
    function (element) {
        /** @type {?} */
        var index = null;
        for (var i = 0; i < this._hammerManagers.length; i++) {
            if (element === this._hammerManagers[i].element) {
                index = i;
                break;
            }
        }
        if (index !== null) {
            /** @type {?} */
            var item = this._hammerManagers.splice(index, 1)[0];
            // destroy also
            item.manager.destroy();
        }
    };
    /** Destroys all internally tracked HammerManagers, removing event listeners in the process. */
    /**
     * Destroys all internally tracked HammerManagers, removing event listeners in the process.
     * @return {?}
     */
    HammerGesturesManager.prototype.destroy = /**
     * Destroys all internally tracked HammerManagers, removing event listeners in the process.
     * @return {?}
     */
    function () {
        var e_1, _a;
        try {
            for (var _b = __values(this._hammerManagers), _c = _b.next(); !_c.done; _c = _b.next()) {
                var item = _c.value;
                item.manager.destroy();
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        this._hammerManagers = [];
    };
    HammerGesturesManager.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    HammerGesturesManager.ctorParameters = function () { return [
        { type: NgZone },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
    ]; };
    return HammerGesturesManager;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * The Ignite UI List Item component is a container intended for row items in the Ignite UI for Angular List component.
 *
 * Example:
 * ```html
 * <igx-list>
 *   <igx-list-item isHeader="true">Contacts</igx-list-item>
 *   <igx-list-item *ngFor="let contact of contacts">
 *     <span class="name">{{ contact.name }}</span>
 *     <span class="phone">{{ contact.phone }}</span>
 *   </igx-list-item>
 * </igx-list>
 * ```
 */
var IgxListItemComponent = /** @class */ (function () {
    function IgxListItemComponent(list, elementRef, _renderer) {
        this.list = list;
        this.elementRef = elementRef;
        this._renderer = _renderer;
        /**
         * @hidden
         */
        this._panState = IgxListPanState.NONE;
        /**
         * @hidden
         */
        this.panOffset = 0;
        /**
         * @hidden
         */
        this._index = null;
        /**
         * @hidden
         */
        this.lastPanDir = IgxListPanState.NONE;
        /**
         * Sets/gets whether the `list item` is hidden.
         * By default the `hidden` value is `false`.
         * ```html
         * <igx-list-item [hidden] = "true">Hidden Item</igx-list-item>
         * ```
         * ```typescript
         * let isHidden =  this.listItem.hidden;
         * ```
         * \@memberof IgxListItemComponent
         */
        this.hidden = false;
        /**
         * Gets the `touch-action` style of the `list item`.
         * ```typescript
         * let touchAction = this.listItem.touchAction;
         * ```
         */
        this.touchAction = 'pan-y';
    }
    Object.defineProperty(IgxListItemComponent.prototype, "role", {
        /**
         * Gets the `role` attribute of the `list item`.
         * ```typescript
         * let itemRole =  this.listItem.role;
         * ```
         * @memberof IgxListItemComponent
         */
        get: /**
         * Gets the `role` attribute of the `list item`.
         * ```typescript
         * let itemRole =  this.listItem.role;
         * ```
         * \@memberof IgxListItemComponent
         * @return {?}
         */
        function () {
            return this.isHeader ? 'separator' : 'listitem';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxListItemComponent.prototype, "headerStyle", {
        /**
         * Indicates whether `list item` should have header style.
         * ```typescript
         * let headerStyle =  this.listItem.headerStyle;
         * ```
         * @memberof IgxListItemComponent
         */
        get: /**
         * Indicates whether `list item` should have header style.
         * ```typescript
         * let headerStyle =  this.listItem.headerStyle;
         * ```
         * \@memberof IgxListItemComponent
         * @return {?}
         */
        function () {
            return this.isHeader;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxListItemComponent.prototype, "innerStyle", {
        /**
         * Applies the inner style of the `list item` if the item is not counted as header.
         * ```typescript
         * let innerStyle =  this.listItem.innerStyle;
         * ```
         * @memberof IgxListItemComponent
         */
        get: /**
         * Applies the inner style of the `list item` if the item is not counted as header.
         * ```typescript
         * let innerStyle =  this.listItem.innerStyle;
         * ```
         * \@memberof IgxListItemComponent
         * @return {?}
         */
        function () {
            return !this.isHeader;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxListItemComponent.prototype, "display", {
        /**
         * Returns string value which describes the display mode of the `list item`.
         * ```typescript
         * let isHidden = this.listItem.display;
         * ```
         * @memberof IgxListItemComponent
         */
        get: /**
         * Returns string value which describes the display mode of the `list item`.
         * ```typescript
         * let isHidden = this.listItem.display;
         * ```
         * \@memberof IgxListItemComponent
         * @return {?}
         */
        function () {
            return this.hidden ? 'none' : '';
        },
        enumerable: true,
        configurable: true
    });
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} evt
     * @return {?}
     */
    IgxListItemComponent.prototype.clicked = /**
     * @hidden
     * @param {?} evt
     * @return {?}
     */
    function (evt) {
        this.list.onItemClicked.emit({ item: this, event: evt, direction: this.lastPanDir });
        this.lastPanDir = IgxListPanState.NONE;
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} ev
     * @return {?}
     */
    IgxListItemComponent.prototype.panStart = /**
     * @hidden
     * @param {?} ev
     * @return {?}
     */
    function (ev) {
        if (this.isTrue(this.isHeader)) {
            return;
        }
        if (!this.isTrue(this.list.allowLeftPanning) && !this.isTrue(this.list.allowRightPanning)) {
            return;
        }
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} ev
     * @return {?}
     */
    IgxListItemComponent.prototype.panMove = /**
     * @hidden
     * @param {?} ev
     * @return {?}
     */
    function (ev) {
        if (this.isTrue(this.isHeader)) {
            return;
        }
        if (!this.isTrue(this.list.allowLeftPanning) && !this.isTrue(this.list.allowRightPanning)) {
            return;
        }
        /** @type {?} */
        var isPanningToLeft = ev.deltaX < 0;
        if (isPanningToLeft && this.isTrue(this.list.allowLeftPanning)) {
            this.showLeftPanTemplate();
            this.setContentElementLeft(Math.max(this.maxLeft, ev.deltaX));
        }
        else if (!isPanningToLeft && this.isTrue(this.list.allowRightPanning)) {
            this.showRightPanTemplate();
            this.setContentElementLeft(Math.min(this.maxRight, ev.deltaX));
        }
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} ev
     * @return {?}
     */
    IgxListItemComponent.prototype.panEnd = /**
     * @hidden
     * @param {?} ev
     * @return {?}
     */
    function (ev) {
        if (this.isTrue(this.isHeader)) {
            return;
        }
        if (!this.isTrue(this.list.allowLeftPanning) && !this.isTrue(this.list.allowRightPanning)) {
            return;
        }
        // the translation offset of the current list item content
        /** @type {?} */
        var relativeOffset = this.panOffset;
        /** @type {?} */
        var widthTriggeringGrip = this.width * this.list.panEndTriggeringThreshold;
        if (relativeOffset === 0) {
            return; // no panning has occured
        }
        /** @type {?} */
        var dir = relativeOffset > 0 ? IgxListPanState.RIGHT : IgxListPanState.LEFT;
        this.lastPanDir = dir;
        /** @type {?} */
        var oldPanState = this._panState;
        if (Math.abs(relativeOffset) < widthTriggeringGrip) {
            this.setContentElementLeft(0);
            this._panState = IgxListPanState.NONE;
            this.hideLeftAndRightPanTemplates();
            return;
        }
        /** @type {?} */
        var args = { item: this, direction: dir, keepItem: false };
        if (dir === IgxListPanState.LEFT) {
            this.list.onLeftPan.emit(args);
        }
        else {
            this.list.onRightPan.emit(args);
        }
        if (args.keepItem === true) {
            this.setContentElementLeft(0);
            this._panState = IgxListPanState.NONE;
        }
        else {
            if (dir === IgxListPanState.LEFT) {
                this.setContentElementLeft(this.maxLeft);
                this._panState = IgxListPanState.LEFT;
            }
            else {
                this.setContentElementLeft(this.maxRight);
                this._panState = IgxListPanState.RIGHT;
            }
        }
        if (oldPanState !== this._panState) {
            /** @type {?} */
            var args2 = { oldState: oldPanState, newState: this._panState, item: this };
            this.list.onPanStateChange.emit(args2);
        }
        this.hideLeftAndRightPanTemplates();
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @private
     * @return {?}
     */
    IgxListItemComponent.prototype.showLeftPanTemplate = /**
     * @hidden
     * @private
     * @return {?}
     */
    function () {
        this.setLeftAndRightTemplatesVisibility('visible', 'hidden');
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @private
     * @return {?}
     */
    IgxListItemComponent.prototype.showRightPanTemplate = /**
     * @hidden
     * @private
     * @return {?}
     */
    function () {
        this.setLeftAndRightTemplatesVisibility('hidden', 'visible');
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @private
     * @return {?}
     */
    IgxListItemComponent.prototype.hideLeftAndRightPanTemplates = /**
     * @hidden
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        setTimeout(function () {
            _this.setLeftAndRightTemplatesVisibility('hidden', 'hidden');
        }, 500);
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @private
     * @param {?} leftVisibility
     * @param {?} rightVisibility
     * @return {?}
     */
    IgxListItemComponent.prototype.setLeftAndRightTemplatesVisibility = /**
     * @hidden
     * @private
     * @param {?} leftVisibility
     * @param {?} rightVisibility
     * @return {?}
     */
    function (leftVisibility, rightVisibility) {
        if (this.leftPanningTemplateElement && this.leftPanningTemplateElement.nativeElement) {
            this.leftPanningTemplateElement.nativeElement.style.visibility = leftVisibility;
        }
        if (this.rightPanningTemplateElement && this.rightPanningTemplateElement.nativeElement) {
            this.rightPanningTemplateElement.nativeElement.style.visibility = rightVisibility;
        }
    };
    Object.defineProperty(IgxListItemComponent.prototype, "panState", {
        /**
         * Gets the `panState` of a `list item`.
         * ```typescript
         * let itemPanState =  this.listItem.panState;
         * ```
         * @memberof IgxListItemComponent
         */
        get: /**
         * Gets the `panState` of a `list item`.
         * ```typescript
         * let itemPanState =  this.listItem.panState;
         * ```
         * \@memberof IgxListItemComponent
         * @return {?}
         */
        function () {
            return this._panState;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxListItemComponent.prototype, "index", {
        /**
         * Gets the `index` of a `list item`.
         * ```typescript
         * let itemIndex =  this.listItem.index;
         * ```
         * @memberof IgxListItemComponent
         */
        get: /**
         * Gets the `index` of a `list item`.
         * ```typescript
         * let itemIndex =  this.listItem.index;
         * ```
         * \@memberof IgxListItemComponent
         * @return {?}
         */
        function () {
            return this._index !== null ? this._index : this.list.children.toArray().indexOf(this);
        },
        /**
         * Sets the `index` of the `list item`.
         * ```typescript
         * this.listItem.index = index;
         * ```
         * @memberof IgxListItemComponent
         */
        set: /**
         * Sets the `index` of the `list item`.
         * ```typescript
         * this.listItem.index = index;
         * ```
         * \@memberof IgxListItemComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._index = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxListItemComponent.prototype, "element", {
        /**
         * Returns an element reference to the list item.
         * ```typescript
         * let listItemElement =  this.listItem.element.
         * ```
         * @memberof IgxListItemComponent
         */
        get: /**
         * Returns an element reference to the list item.
         * ```typescript
         * let listItemElement =  this.listItem.element.
         * ```
         * \@memberof IgxListItemComponent
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxListItemComponent.prototype, "contentElement", {
        /**
         * Returns a reference container which contains the list item's content.
         * ```typescript
         * let listItemContainer =  this.listItem.contentElement.
         * ```
         * @memberof IgxListItemComponent
         */
        get: /**
         * Returns a reference container which contains the list item's content.
         * ```typescript
         * let listItemContainer =  this.listItem.contentElement.
         * ```
         * \@memberof IgxListItemComponent
         * @return {?}
         */
        function () {
            /** @type {?} */
            var candidates = this.element.getElementsByClassName('igx-list__item-content');
            return (candidates && candidates.length > 0) ? candidates[0] : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxListItemComponent.prototype, "context", {
        /**
         * Returns the `context` object which represents the `template context` binding into the `list item container`
         * by providing the `$implicit` declaration which is the `IgxListItemComponent` itself.
         * ```typescript
         * let listItemComponent = this.listItem.context;
         * ```
         */
        get: /**
         * Returns the `context` object which represents the `template context` binding into the `list item container`
         * by providing the `$implicit` declaration which is the `IgxListItemComponent` itself.
         * ```typescript
         * let listItemComponent = this.listItem.context;
         * ```
         * @return {?}
         */
        function () {
            return {
                $implicit: this
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxListItemComponent.prototype, "width", {
        /**
         * Gets the width of a `list item`.
         * ```typescript
         * let itemWidth = this.listItem.width;
         * ```
         * @memberof IgxListItemComponent
         */
        get: /**
         * Gets the width of a `list item`.
         * ```typescript
         * let itemWidth = this.listItem.width;
         * ```
         * \@memberof IgxListItemComponent
         * @return {?}
         */
        function () {
            if (this.element) {
                return this.element.offsetWidth;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxListItemComponent.prototype, "maxLeft", {
        /**
         * Gets the maximum left position of the `list item`.
         * ```typescript
         * let maxLeft = this.listItem.maxLeft;
         * ```
         * @memberof IgxListItemComponent
         */
        get: /**
         * Gets the maximum left position of the `list item`.
         * ```typescript
         * let maxLeft = this.listItem.maxLeft;
         * ```
         * \@memberof IgxListItemComponent
         * @return {?}
         */
        function () {
            return -this.width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxListItemComponent.prototype, "maxRight", {
        /**
         * Gets the maximum right position of the `list item`.
         * ```typescript
         * let maxRight = this.listItem.maxRight;
         * ```
         * @memberof IgxListItemComponent
         */
        get: /**
         * Gets the maximum right position of the `list item`.
         * ```typescript
         * let maxRight = this.listItem.maxRight;
         * ```
         * \@memberof IgxListItemComponent
         * @return {?}
         */
        function () {
            return this.width;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *@hidden
     */
    /**
     * @hidden
     * @private
     * @param {?} value
     * @return {?}
     */
    IgxListItemComponent.prototype.setContentElementLeft = /**
     * @hidden
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.panOffset = value;
        this.contentElement.style.transform = 'translateX(' + value + 'px)';
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @private
     * @param {?} value
     * @return {?}
     */
    IgxListItemComponent.prototype.isTrue = /**
     * @hidden
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (typeof (value) === 'boolean') {
            return value;
        }
        else {
            return value === 'true';
        }
    };
    IgxListItemComponent.decorators = [
        { type: Component, args: [{
                    providers: [HammerGesturesManager],
                    selector: 'igx-list-item',
                    template: "   \n<div *ngIf=\"!isHeader && list.listItemLeftPanningTemplate != null\" #leftPanningTmpl class=\"igx-list__item-right\"\n    [style.width.px]=\"this.element.offsetWidth\" [style.height.px]=\"this.element.offsetHeight\">\n    <ng-container *ngTemplateOutlet=\"list.listItemLeftPanningTemplate.template; context: context\">\n    </ng-container>\n</div>\n\n<div *ngIf=\"!isHeader && list.listItemRightPanningTemplate != null\" #rightPanningTmpl class=\"igx-list__item-left\"\n    [style.width.px]=\"this.element.offsetWidth\" [style.height.px]=\"this.element.offsetHeight\">\n    <ng-container *ngTemplateOutlet=\"list.listItemRightPanningTemplate.template; context: context\">\n    </ng-container>\n</div>\n\n<ng-template #itemsContent>\n    <ng-content></ng-content>\n</ng-template>\n    \n<ng-container *ngIf=\"isHeader\">\n    <ng-container *ngTemplateOutlet=\"itemsContent\">\n    </ng-container>\n</ng-container>\n\n<ng-container *ngIf=\"!isHeader\">\n    <div class=\"igx-list__item-content\">\n        <ng-container *ngTemplateOutlet=\"itemsContent\">\n        </ng-container>\n    </div>\n</ng-container>\n",
                    changeDetection: ChangeDetectionStrategy.OnPush
                }] }
    ];
    /** @nocollapse */
    IgxListItemComponent.ctorParameters = function () { return [
        { type: IgxListBase },
        { type: ElementRef },
        { type: Renderer2 }
    ]; };
    IgxListItemComponent.propDecorators = {
        leftPanningTemplateElement: [{ type: ViewChild, args: ['leftPanningTmpl',] }],
        rightPanningTemplateElement: [{ type: ViewChild, args: ['rightPanningTmpl',] }],
        isHeader: [{ type: Input }],
        hidden: [{ type: Input }],
        role: [{ type: HostBinding, args: ['attr.role',] }],
        ariaLabel: [{ type: HostBinding, args: ['attr.aria-label',] }],
        touchAction: [{ type: HostBinding, args: ['style.touch-action',] }],
        headerStyle: [{ type: HostBinding, args: ['class.igx-list__header',] }],
        innerStyle: [{ type: HostBinding, args: ['class.igx-list__item-base',] }],
        display: [{ type: HostBinding, args: ['style.display',] }],
        clicked: [{ type: HostListener, args: ['click', ['$event'],] }],
        panStart: [{ type: HostListener, args: ['panstart', ['$event'],] }],
        panMove: [{ type: HostListener, args: ['panmove', ['$event'],] }],
        panEnd: [{ type: HostListener, args: ['panend', ['$event'],] }],
        index: [{ type: Input }]
    };
    return IgxListItemComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var NEXT_ID$l = 0;
/**
 * **Ignite UI for Angular List** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/list.html)
 *
 * The Ignite UI List displays rows of items and supports one or more header items as well as search and filtering
 * of list items. Each list item is completely templateable and will support any valid HTML or Angular component.
 *
 * Example:
 * ```html
 * <igx-list>
 *   <igx-list-item isHeader="true">Contacts</igx-list-item>
 *   <igx-list-item *ngFor="let contact of contacts">
 *     <span class="name">{{ contact.name }}</span>
 *     <span class="phone">{{ contact.phone }}</span>
 *   </igx-list-item>
 * </igx-list>
 * ```
 */
var IgxListComponent = /** @class */ (function (_super) {
    __extends(IgxListComponent, _super);
    function IgxListComponent(element, _displayDensityOptions) {
        var _this = _super.call(this, _displayDensityOptions) || this;
        _this.element = element;
        _this._displayDensityOptions = _displayDensityOptions;
        /**
         * Provides a threshold after which the item's panning will be completed automatically.
         * By default this property is set to 0.5 which is 50% of the list item's width.
         * ```typescript
         * this.list.panEndTriggeringThreshold = 0.8;
         * ```
         */
        _this.panEndTriggeringThreshold = 0.5;
        /**
         * Sets/gets the `id` of the list.
         * If not set, the `id` of the first list component will be `"igx-list-0"`.
         * ```html
         * <igx-list id = "my-first-list"></igx-list>
         * ```
         * ```typescript
         * let listId =  this.list.id;
         * ```
         * \@memberof IgxListComponent
         */
        _this.id = "igx-list-" + NEXT_ID$l++;
        /**
         * Sets/gets whether the left panning of an item is allowed.
         * Default value is `false`.
         * ```html
         *  <igx-list [allowLeftPanning] = "true"></igx-list>
         * ```
         * ```typescript
         * let isLeftPanningAllowed = this.list.allowLeftPanning;
         * ```
         * \@memberof IgxListComponent
         */
        _this.allowLeftPanning = false;
        /**
         * Sets/gets whether the right panning of an item is allowed.
         * Default value is `false`.
         * ```html
         *  <igx-list [allowRightPanning] = "true"></igx-list>
         * ```
         * ```typescript
         * let isRightPanningAllowed = this.list.allowRightPanning;
         * ```
         * \@memberof IgxListComponent
         */
        _this.allowRightPanning = false;
        /**
         * Sets/gets whether the list is currently loading data.
         * Set it to display the dataLoadingTemplate while data is being retrieved.
         * Default value is `false`.
         * ```html
         *  <igx-list [isLoading]="true"></igx-list>
         * ```
         * ```typescript
         * let isLoading = this.list.isLoading;
         * ```
         * \@memberof IgxListComponent
         */
        _this.isLoading = false;
        /**
         * Emits an event within the current list when left pan gesture is executed on a list item.
         * Provides a reference to an object of type `IListItemPanningEventArgs` as an event argument.
         * ```html
         * <igx-list [allowLeftPanning]="true" (onLeftPan)="onLeftPan($event)"></igx-list>
         * ```
         * \@memberof IgxListComponent
         */
        _this.onLeftPan = new EventEmitter();
        /**
         * Emits an event within the current list when right pan gesture is executed on a list item.
         * Provides a reference to an object of type `IListItemPanningEventArgs` as an event argument.
         * ```html
         * <igx-list [allowRightPanning]="true" (onRightPan)="onRightPan($event)"></igx-list>
         * ```
         * \@memberof IgxListComponent
         */
        _this.onRightPan = new EventEmitter();
        /**
         * Emits an event within the current list when pan gesture is executed on list item.
         * Provides references to the `IgxListItemComponent` and `IgxListPanState` as event arguments.
         * ```html
         * <igx-list (onPanStateChange) = "onPanStateChange($event)"></igx-list>
         * ```
         * \@memberof IgxListComponent
         */
        _this.onPanStateChange = new EventEmitter();
        /**
         * Emits an event within the current list when a list item has been clicked.
         * Provides references to the `IgxListItemComponent` and `Event` as event arguments.
         *  ```html
         * <igx-list (onItemClicked) = "onItemClicked($event)"></igx-list>
         * ```
         * \@memberof IgxListComponent
         */
        _this.onItemClicked = new EventEmitter();
        return _this;
    }
    Object.defineProperty(IgxListComponent.prototype, "sortedChildren", {
        /**
         * @hidden
         * @internal
         */
        get: /**
         * @hidden
         * \@internal
         * @protected
         * @return {?}
         */
        function () {
            if (this.children !== undefined) {
                return this.children.toArray()
                    .sort(function (a, b) {
                    return a.index - b.index;
                });
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxListComponent.prototype, "role", {
        /**
         * Gets the `role` attribute.
         * ```typescript
         * let listRole =  this.list.role;
         * ```
         * @memberof IgxListComponent
         */
        get: /**
         * Gets the `role` attribute.
         * ```typescript
         * let listRole =  this.list.role;
         * ```
         * \@memberof IgxListComponent
         * @return {?}
         */
        function () {
            return 'list';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxListComponent.prototype, "isListEmpty", {
        /**
         * Returns boolean indicating if the list is empty.
         * ```typescript
         * let isEmpty =  this.list.isListEmpty;
         * ```
         * @memberof IgxListComponent
         */
        get: /**
         * Returns boolean indicating if the list is empty.
         * ```typescript
         * let isEmpty =  this.list.isListEmpty;
         * ```
         * \@memberof IgxListComponent
         * @return {?}
         */
        function () {
            return !this.children || this.children.length === 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxListComponent.prototype, "cssClass", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return !this.isListEmpty && this.displayDensity === DisplayDensity.comfortable;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxListComponent.prototype, "cssClassCompact", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return !this.isListEmpty && this.displayDensity === DisplayDensity.compact;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxListComponent.prototype, "cssClassCosy", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return !this.isListEmpty && this.displayDensity === DisplayDensity.cosy;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxListComponent.prototype, "items", {
        /**
         * Returns the `items` in the list excluding the headers.
         * ```typescript
         * let listItems: IgxListItemComponent[] = this.list.items;
         * ```
         * @memberof IgxListComponent
         */
        get: /**
         * Returns the `items` in the list excluding the headers.
         * ```typescript
         * let listItems: IgxListItemComponent[] = this.list.items;
         * ```
         * \@memberof IgxListComponent
         * @return {?}
         */
        function () {
            var e_1, _a;
            /** @type {?} */
            var items = [];
            if (this.children !== undefined) {
                try {
                    for (var _b = __values(this.sortedChildren), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var child = _c.value;
                        if (!child.isHeader) {
                            items.push(child);
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            return items;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxListComponent.prototype, "headers", {
        /**
         * Returns the headers in the list.
         * ```typescript
         * let listHeaders: IgxListItemComponent[] =  this.list.headers;
         * ```
         * @memberof IgxListComponent
         */
        get: /**
         * Returns the headers in the list.
         * ```typescript
         * let listHeaders: IgxListItemComponent[] =  this.list.headers;
         * ```
         * \@memberof IgxListComponent
         * @return {?}
         */
        function () {
            var e_2, _a;
            /** @type {?} */
            var headers = [];
            if (this.children !== undefined) {
                try {
                    for (var _b = __values(this.children.toArray()), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var child = _c.value;
                        if (child.isHeader) {
                            headers.push(child);
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            }
            return headers;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxListComponent.prototype, "context", {
        /**
         * Returns the `context` object which represents the `template context` binding into the `list container`
         * by providing the `$implicit` declaration which is the `IgxListComponent` itself.
         * ```typescript
         * let listComponent =  this.list.context;
         * ```
         */
        get: /**
         * Returns the `context` object which represents the `template context` binding into the `list container`
         * by providing the `$implicit` declaration which is the `IgxListComponent` itself.
         * ```typescript
         * let listComponent =  this.list.context;
         * ```
         * @return {?}
         */
        function () {
            return {
                $implicit: this
            };
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxListComponent.prototype, "template", {
        /**
         * Returns the `template` of an empty list.
         * ```typescript
         * let listTemplate = this.list.template;
         * ```
         * @memberof IgxListComponent
         */
        get: /**
         * Returns the `template` of an empty list.
         * ```typescript
         * let listTemplate = this.list.template;
         * ```
         * \@memberof IgxListComponent
         * @return {?}
         */
        function () {
            if (this.isLoading) {
                return this.dataLoadingTemplate ? this.dataLoadingTemplate.template : this.defaultDataLoadingTemplate;
            }
            else {
                return this.emptyListTemplate ? this.emptyListTemplate.template : this.defaultEmptyListTemplate;
            }
        },
        enumerable: true,
        configurable: true
    });
    IgxListComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-list',
                    template: "<ng-content></ng-content>\n\n<ng-template #defaultEmptyList>\n    <article class=\"message\">\n        <p>There are no items in the list.</p>\n    </article>\n</ng-template>\n\n<ng-template #defaultDataLoading>\n    <article class=\"message\">\n        <p>Loading data from the server...</p>\n    </article>\n</ng-template>\n\n<ng-container *ngIf=\"!children || children.length === 0 || isLoading\">\n    <ng-container *ngTemplateOutlet=\"template; context: context\">\n    </ng-container>\n</ng-container>\n",
                    providers: [{ provide: IgxListBase, useExisting: IgxListComponent }]
                }] }
    ];
    /** @nocollapse */
    IgxListComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
    ]; };
    IgxListComponent.propDecorators = {
        children: [{ type: ContentChildren, args: [forwardRef(function () { return IgxListItemComponent; }),] }],
        emptyListTemplate: [{ type: ContentChild, args: [IgxEmptyListTemplateDirective, { read: IgxEmptyListTemplateDirective },] }],
        dataLoadingTemplate: [{ type: ContentChild, args: [IgxDataLoadingTemplateDirective, { read: IgxDataLoadingTemplateDirective },] }],
        listItemLeftPanningTemplate: [{ type: ContentChild, args: [IgxListItemLeftPanningTemplateDirective, { read: IgxListItemLeftPanningTemplateDirective },] }],
        listItemRightPanningTemplate: [{ type: ContentChild, args: [IgxListItemRightPanningTemplateDirective, { read: IgxListItemRightPanningTemplateDirective },] }],
        panEndTriggeringThreshold: [{ type: Input }],
        defaultEmptyListTemplate: [{ type: ViewChild, args: ['defaultEmptyList', { read: TemplateRef },] }],
        defaultDataLoadingTemplate: [{ type: ViewChild, args: ['defaultDataLoading', { read: TemplateRef },] }],
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        allowLeftPanning: [{ type: Input }],
        allowRightPanning: [{ type: Input }],
        isLoading: [{ type: Input }],
        onLeftPan: [{ type: Output }],
        onRightPan: [{ type: Output }],
        onPanStateChange: [{ type: Output }],
        onItemClicked: [{ type: Output }],
        role: [{ type: HostBinding, args: ['attr.role',] }],
        isListEmpty: [{ type: HostBinding, args: ['class.igx-list-empty',] }],
        cssClass: [{ type: HostBinding, args: ['class.igx-list',] }],
        cssClassCompact: [{ type: HostBinding, args: ['class.igx-list--compact',] }],
        cssClassCosy: [{ type: HostBinding, args: ['class.igx-list--cosy',] }]
    };
    return IgxListComponent;
}(IgxListBase));
/**
 * @hidden
 */
var IgxListModule = /** @class */ (function () {
    function IgxListModule() {
    }
    IgxListModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxListComponent, IgxListItemComponent,
                        IgxDataLoadingTemplateDirective, IgxEmptyListTemplateDirective,
                        IgxListItemLeftPanningTemplateDirective, IgxListItemRightPanningTemplateDirective],
                    exports: [IgxListComponent, IgxListItemComponent,
                        IgxDataLoadingTemplateDirective, IgxEmptyListTemplateDirective,
                        IgxListItemLeftPanningTemplateDirective, IgxListItemRightPanningTemplateDirective],
                    imports: [CommonModule, IgxRippleModule]
                },] }
    ];
    return IgxListModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxExcelStyleSearchFilterPipe = /** @class */ (function () {
    function IgxExcelStyleSearchFilterPipe() {
    }
    /**
     * @param {?} items
     * @param {?} searchText
     * @return {?}
     */
    IgxExcelStyleSearchFilterPipe.prototype.transform = /**
     * @param {?} items
     * @param {?} searchText
     * @return {?}
     */
    function (items, searchText) {
        if (!items || !items.length) {
            return [];
        }
        if (!searchText) {
            return items;
        }
        searchText = searchText.toLowerCase();
        /** @type {?} */
        var result = items.filter(function (it, i) { return (i === 0 && it.isSpecial) ||
            (it.value || it.value === 0) &&
                it.value.toString().toLowerCase().indexOf(searchText) > -1; });
        return result.length > 1 ? result : [];
    };
    IgxExcelStyleSearchFilterPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'excelStyleSearchFilter'
                },] }
    ];
    return IgxExcelStyleSearchFilterPipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxGridExcelStyleFilteringModule = /** @class */ (function () {
    function IgxGridExcelStyleFilteringModule() {
    }
    IgxGridExcelStyleFilteringModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        IgxGridExcelStyleFilteringComponent,
                        IgxExcelStyleSortingComponent,
                        IgxExcelStyleColumnMovingComponent,
                        IgxExcelStyleSearchComponent,
                        IgxExcelStyleCustomDialogComponent,
                        IgxExcelStyleDefaultExpressionComponent,
                        IgxExcelStyleDateExpressionComponent,
                        IgxExcelStyleSortingTemplateDirective,
                        IgxExcelStyleHidingTemplateDirective,
                        IgxExcelStyleMovingTemplateDirective,
                        IgxExcelStylePinningTemplateDirective,
                        IgxExcelStyleSearchFilterPipe
                    ],
                    exports: [
                        IgxGridExcelStyleFilteringComponent,
                        IgxExcelStyleSortingTemplateDirective,
                        IgxExcelStyleHidingTemplateDirective,
                        IgxExcelStyleMovingTemplateDirective,
                        IgxExcelStylePinningTemplateDirective,
                        IgxExcelStyleDateExpressionComponent
                    ],
                    imports: [
                        CommonModule,
                        FormsModule,
                        IgxGridPipesModule,
                        IgxButtonModule,
                        IgxButtonGroupModule,
                        IgxDatePickerModule,
                        IgxIconModule,
                        IgxRippleModule,
                        IgxInputGroupModule,
                        IgxDropDownModule,
                        IgxForOfModule,
                        IgxCheckboxModule,
                        IgxFilterModule,
                        IgxToggleModule,
                        IgxListModule
                    ],
                    entryComponents: [
                        IgxGridExcelStyleFilteringComponent
                    ],
                    providers: [
                        IgxSelectionAPIService
                    ]
                },] }
    ];
    return IgxGridExcelStyleFilteringModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var ghostBackgroundClass = 'igx-grid__tr--ghost';
/** @type {?} */
var gridCellClass = 'igx-grid__td';
/** @type {?} */
var rowSelectedClass = 'igx-grid__tr--selected';
/** @type {?} */
var cellSelectedClass = 'igx-grid__td--selected';
/** @type {?} */
var cellActiveClass = 'igx-grid__td--active';
/**
 * @hidden
 */
var IgxRowDragDirective = /** @class */ (function (_super) {
    __extends(IgxRowDragDirective, _super);
    function IgxRowDragDirective() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._rowDragStarted = false;
        _this.transitionEndEvent = function (evt) {
            if (_this.dragGhost) {
                _this.dragGhost.removeEventListener('transitionend', _this.transitionEndEvent, false);
            }
            _this.endDragging();
        };
        return _this;
    }
    Object.defineProperty(IgxRowDragDirective.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () {
            return this.row;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            this.row = val;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} event
     * @return {?}
     */
    IgxRowDragDirective.prototype.onPointerDown = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        this._rowDragStarted = false;
        _super.prototype.onPointerDown.call(this, event);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    IgxRowDragDirective.prototype.onPointerMove = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        _super.prototype.onPointerMove.call(this, event);
        if (this._dragStarted && !this._rowDragStarted) {
            this._rowDragStarted = true;
            /** @type {?} */
            var args = {
                owner: this,
                dragData: this.row,
                cancel: false
            };
            this.row.grid.onRowDragStart.emit(args);
            if (args.cancel) {
                this.dragGhost.parentNode.removeChild(this.dragGhost);
                this.dragGhost = null;
                this._dragStarted = false;
                this._clicked = false;
                return;
            }
            this.row.dragging = true;
            this.row.grid.rowDragging = true;
            this.row.grid.markForCheck();
            this.subscription$ = fromEvent(this.row.grid.document.defaultView, 'keydown').subscribe(function (ev) {
                if (ev.key === "Escape" /* ESCAPE */ || ev.key === "Esc" /* ESCAPE_IE */) {
                    _this._lastDropArea = false;
                    _this.onPointerUp(event);
                }
            });
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    IgxRowDragDirective.prototype.onPointerUp = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        if (!this._clicked) {
            return;
        }
        /** @type {?} */
        var args = {
            owner: this,
            dragData: this.row,
            animation: false
        };
        this.zone.run(function () {
            _this.row.grid.onRowDragEnd.emit(args);
        });
        if (args.animation) {
            this.animateOnRelease = true;
        }
        /** @type {?} */
        var dropArea = this._lastDropArea;
        _super.prototype.onPointerUp.call(this, event);
        if (!dropArea && this.animateOnRelease) {
            this.dragGhost.addEventListener('transitionend', this.transitionEndEvent, false);
        }
        else {
            this.endDragging();
        }
    };
    /**
     * @protected
     * @param {?} event
     * @return {?}
     */
    IgxRowDragDirective.prototype.createDragGhost = /**
     * @protected
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.row.grid.endEdit(true);
        this.row.grid.markForCheck();
        _super.prototype.createDragGhost.call(this, event, this.row.nativeElement);
        /** @type {?} */
        var ghost = this.dragGhost;
        /** @type {?} */
        var gridRect = this.row.grid.nativeElement.getBoundingClientRect();
        /** @type {?} */
        var rowRect = this.row.nativeElement.getBoundingClientRect();
        ghost.style.overflow = 'hidden';
        ghost.style.width = gridRect.width + 'px';
        ghost.style.height = rowRect.height + 'px';
        this.renderer.addClass(ghost, ghostBackgroundClass);
        this.renderer.removeClass(ghost, rowSelectedClass);
        /** @type {?} */
        var ghostCells = ghost.getElementsByClassName(gridCellClass);
        for (var index = 0; index < ghostCells.length; index++) {
            this.renderer.removeClass(ghostCells[index], cellSelectedClass);
            this.renderer.removeClass(ghostCells[index], cellActiveClass);
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxRowDragDirective.prototype._unsubscribe = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.subscription$ && !this.subscription$.closed) {
            this.subscription$.unsubscribe();
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxRowDragDirective.prototype.endDragging = /**
     * @private
     * @return {?}
     */
    function () {
        this.onTransitionEnd(null);
        this.row.dragging = false;
        this.row.grid.rowDragging = false;
        this.row.grid.markForCheck();
        this._unsubscribe();
    };
    IgxRowDragDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxRowDrag]'
                },] }
    ];
    IgxRowDragDirective.propDecorators = {
        data: [{ type: Input, args: ['igxRowDrag',] }]
    };
    return IgxRowDragDirective;
}(IgxDragDirective));
/**
 * @hidden
 */
var IgxDragIndicatorIconDirective = /** @class */ (function () {
    function IgxDragIndicatorIconDirective() {
    }
    IgxDragIndicatorIconDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxDragIndicatorIcon]'
                },] }
    ];
    return IgxDragIndicatorIconDirective;
}());
var IgxRowDragModule = /** @class */ (function () {
    function IgxRowDragModule() {
    }
    IgxRowDragModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxRowDragDirective, IgxDragIndicatorIconDirective],
                    entryComponents: [],
                    exports: [IgxRowDragDirective, IgxDragIndicatorIconDirective],
                    imports: []
                },] }
    ];
    return IgxRowDragModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxGridCommonModule = /** @class */ (function () {
    function IgxGridCommonModule() {
    }
    IgxGridCommonModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        IgxGridCellComponent,
                        IgxColumnComponent,
                        IgxColumnGroupComponent,
                        IgxColumnLayoutComponent,
                        IgxGridHeaderComponent,
                        IgxGridToolbarComponent,
                        IgxGridToolbarCustomContentDirective,
                        IgxCellFooterTemplateDirective,
                        IgxCellHeaderTemplateDirective,
                        IgxCellEditorTemplateDirective,
                        IgxCellTemplateDirective,
                        IgxRowEditTemplateDirective,
                        IgxRowEditActionsDirective,
                        IgxRowEditTextDirective,
                        IgxRowEditTabStopDirective,
                        IgxColumnResizerDirective,
                        IgxResizeHandleDirective,
                        IgxColumnMovingDragDirective,
                        IgxColumnMovingDropDirective,
                        IgxGridBodyDirective,
                        IgxGridFilteringCellComponent,
                        IgxGridFilteringRowComponent,
                        IgxSummaryDataPipe,
                        IgxRowComponent,
                        IgxGridHeaderGroupComponent,
                        IgxSummaryRowComponent,
                        IgxSummaryCellComponent,
                        IgxGridDragSelectDirective,
                        IgxGridColumnResizerComponent,
                        IgxFilterCellTemplateDirective
                    ],
                    entryComponents: [
                        IgxColumnComponent,
                        IgxColumnGroupComponent,
                        IgxColumnLayoutComponent
                    ],
                    exports: [
                        IgxGridCellComponent,
                        IgxColumnComponent,
                        IgxColumnGroupComponent,
                        IgxColumnLayoutComponent,
                        IgxGridHeaderComponent,
                        IgxGridToolbarComponent,
                        IgxGridToolbarCustomContentDirective,
                        IgxCellFooterTemplateDirective,
                        IgxCellHeaderTemplateDirective,
                        IgxCellEditorTemplateDirective,
                        IgxCellTemplateDirective,
                        IgxRowEditTemplateDirective,
                        IgxRowEditActionsDirective,
                        IgxRowEditTextDirective,
                        IgxRowEditTabStopDirective,
                        IgxColumnResizerDirective,
                        IgxColumnMovingDragDirective,
                        IgxColumnMovingDropDirective,
                        IgxGridBodyDirective,
                        IgxRowComponent,
                        IgxSummaryDataPipe,
                        IgxButtonModule,
                        IgxDatePickerModule,
                        IgxIconModule,
                        IgxRippleModule,
                        IgxInputGroupModule,
                        IgxToggleModule,
                        IgxForOfModule,
                        IgxTemplateOutletModule,
                        IgxFocusModule,
                        IgxTextHighlightModule,
                        IgxTextSelectionModule,
                        IgxCheckboxModule,
                        IgxBadgeModule,
                        IgxChipsModule,
                        IgxDragDropModule,
                        IgxColumnHidingModule,
                        IgxDropDownModule,
                        IgxButtonGroupModule,
                        IgxColumnPinningModule,
                        IgxProgressBarModule,
                        IgxGridFilteringCellComponent,
                        IgxGridFilteringRowComponent,
                        IgxGridHeaderGroupComponent,
                        IgxSummaryRowComponent,
                        IgxSummaryCellComponent,
                        IgxGridDragSelectDirective,
                        IgxGridColumnResizerComponent,
                        IgxFilterModule,
                        IgxGridPipesModule,
                        IgxGridExcelStyleFilteringModule,
                        IgxFilterCellTemplateDirective,
                        IgxRowDragModule
                    ],
                    imports: [
                        CommonModule,
                        FormsModule,
                        IgxButtonModule,
                        IgxDatePickerModule,
                        IgxIconModule,
                        IgxRippleModule,
                        IgxInputGroupModule,
                        IgxToggleModule,
                        IgxForOfModule,
                        IgxTemplateOutletModule,
                        IgxFocusModule,
                        IgxTextHighlightModule,
                        IgxTextSelectionModule,
                        IgxCheckboxModule,
                        IgxBadgeModule,
                        IgxChipsModule,
                        IgxDragDropModule,
                        IgxColumnHidingModule,
                        IgxDropDownModule,
                        IgxButtonGroupModule,
                        IgxColumnPinningModule,
                        IgxProgressBarModule,
                        IgxFilterModule,
                        IgxGridPipesModule,
                        IgxGridExcelStyleFilteringModule,
                        IgxRowDragModule
                    ],
                    providers: [
                        IgxGridSelectionService,
                        IgxSelectionAPIService,
                        IgxColumnMovingService,
                        IgxGridNavigationService,
                        IgxColumnResizingService,
                        IgxGridSummaryService,
                        { provide: IgxGridTransaction, useClass: IgxBaseTransactionService }
                    ]
                },] }
    ];
    return IgxGridCommonModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxGridAPIService = /** @class */ (function (_super) {
    __extends(IgxGridAPIService, _super);
    function IgxGridAPIService() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {?} expression
     * @return {?}
     */
    IgxGridAPIService.prototype.groupBy = /**
     * @param {?} expression
     * @return {?}
     */
    function (expression) {
        /** @type {?} */
        var groupingState = cloneArray(this.grid.groupingExpressions);
        /** @type {?} */
        var sortingState = cloneArray(this.grid.sortingExpressions);
        this.prepare_sorting_expression([sortingState, groupingState], expression);
        this.grid.groupingExpressions = groupingState;
        this.arrange_sorting_expressions();
    };
    /**
     * @param {?} expressions
     * @return {?}
     */
    IgxGridAPIService.prototype.groupBy_multiple = /**
     * @param {?} expressions
     * @return {?}
     */
    function (expressions) {
        var e_1, _a;
        /** @type {?} */
        var groupingState = cloneArray(this.grid.groupingExpressions);
        /** @type {?} */
        var sortingState = cloneArray(this.grid.sortingExpressions);
        try {
            for (var expressions_1 = __values(expressions), expressions_1_1 = expressions_1.next(); !expressions_1_1.done; expressions_1_1 = expressions_1.next()) {
                var each = expressions_1_1.value;
                this.prepare_sorting_expression([sortingState, groupingState], each);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (expressions_1_1 && !expressions_1_1.done && (_a = expressions_1.return)) _a.call(expressions_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        this.grid.groupingExpressions = groupingState;
        this.arrange_sorting_expressions();
    };
    /**
     * @param {?=} name
     * @return {?}
     */
    IgxGridAPIService.prototype.clear_groupby = /**
     * @param {?=} name
     * @return {?}
     */
    function (name) {
        var _this = this;
        var e_2, _a;
        /** @type {?} */
        var groupingState = cloneArray(this.grid.groupingExpressions);
        /** @type {?} */
        var sortingState = cloneArray(this.grid.sortingExpressions);
        if (name) {
            /** @type {?} */
            var names_1 = typeof name === 'string' ? [name] : name;
            /** @type {?} */
            var groupedCols = groupingState.filter(function (state$$1) { return names_1.indexOf(state$$1.fieldName) < 0; });
            /** @type {?} */
            var newSortingExpr = sortingState.filter(function (state$$1) { return names_1.indexOf(state$$1.fieldName) < 0; });
            this.grid.groupingExpressions = groupedCols;
            this.grid.sortingExpressions = newSortingExpr;
            names_1.forEach(function (colName) {
                /** @type {?} */
                var grExprIndex = groupingState.findIndex(function (exp) { return exp.fieldName === colName; });
                /** @type {?} */
                var grpExpandState = _this.grid.groupingExpansionState;
                /* remove expansion states related to the cleared group
                and all with deeper hierarchy than the cleared group */
                _this.grid.groupingExpansionState = grpExpandState
                    .filter(function (val) {
                    return val.hierarchy && val.hierarchy.length <= grExprIndex;
                });
            });
        }
        else {
            // clear all
            this.grid.groupingExpressions = [];
            this.grid.groupingExpansionState = [];
            var _loop_1 = function (grExpr) {
                /** @type {?} */
                var sortExprIndex = sortingState.findIndex(function (exp) { return exp.fieldName === grExpr.fieldName; });
                if (sortExprIndex > -1) {
                    sortingState.splice(sortExprIndex, 1);
                }
            };
            try {
                for (var groupingState_1 = __values(groupingState), groupingState_1_1 = groupingState_1.next(); !groupingState_1_1.done; groupingState_1_1 = groupingState_1.next()) {
                    var grExpr = groupingState_1_1.value;
                    _loop_1(grExpr);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (groupingState_1_1 && !groupingState_1_1.done && (_a = groupingState_1.return)) _a.call(groupingState_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            this.grid.sortingExpressions = sortingState;
        }
    };
    /**
     * @param {?} groupRow
     * @return {?}
     */
    IgxGridAPIService.prototype.groupBy_get_expanded_for_group = /**
     * @param {?} groupRow
     * @return {?}
     */
    function (groupRow) {
        /** @type {?} */
        var grState = this.grid.groupingExpansionState;
        /** @type {?} */
        var hierarchy = DataUtil.getHierarchy(groupRow);
        return grState.find(function (state$$1) {
            return DataUtil.isHierarchyMatch(state$$1.hierarchy || [{ fieldName: groupRow.expression.fieldName, value: groupRow.value }], hierarchy);
        });
    };
    /**
     * @param {?} groupRow
     * @param {?} rowID
     * @return {?}
     */
    IgxGridAPIService.prototype.groupBy_is_row_in_group = /**
     * @param {?} groupRow
     * @param {?} rowID
     * @return {?}
     */
    function (groupRow, rowID) {
        /** @type {?} */
        var grid = this.grid;
        /** @type {?} */
        var rowInGroup = false;
        groupRow.records.forEach(function (row) {
            if (grid.primaryKey ? row[grid.primaryKey] === rowID : row === rowID) {
                rowInGroup = true;
            }
        });
        return rowInGroup;
    };
    /**
     * @param {?} groupRow
     * @return {?}
     */
    IgxGridAPIService.prototype.groupBy_toggle_group = /**
     * @param {?} groupRow
     * @return {?}
     */
    function (groupRow) {
        /** @type {?} */
        var grid = this.grid;
        /** @type {?} */
        var expansionState = grid.groupingExpansionState;
        /** @type {?} */
        var toggleRowEditingOverlay;
        /** @type {?} */
        var isEditRowInGroup = false;
        if (grid.rowEditable) {
            /** @type {?} */
            var rowState = this.grid.crudService.row;
            // Toggle only row editing overlays that are inside current expanded/collapsed group.
            isEditRowInGroup = rowState ? this.groupBy_is_row_in_group(groupRow, rowState.id) : false;
        }
        /** @type {?} */
        var state$$1 = this.groupBy_get_expanded_for_group(groupRow);
        if (state$$1) {
            state$$1.expanded = !state$$1.expanded;
            if (isEditRowInGroup) {
                toggleRowEditingOverlay = state$$1.expanded;
            }
        }
        else {
            expansionState.push({
                expanded: !grid.groupsExpanded,
                hierarchy: DataUtil.getHierarchy(groupRow)
            });
            if (isEditRowInGroup) {
                toggleRowEditingOverlay = false;
            }
        }
        this.grid.groupingExpansionState = expansionState;
        if (grid.rowEditable) {
            grid.repositionRowEditingOverlay(grid.rowInEditMode);
        }
    };
    /**
     * @protected
     * @param {?} fieldName
     * @return {?}
     */
    IgxGridAPIService.prototype.remove_grouping_expression = /**
     * @protected
     * @param {?} fieldName
     * @return {?}
     */
    function (fieldName) {
        /** @type {?} */
        var groupingExpressions = this.grid.groupingExpressions;
        /** @type {?} */
        var index = groupingExpressions.findIndex(function (expr) { return expr.fieldName === fieldName; });
        if (index !== -1) {
            groupingExpressions.splice(index, 1);
        }
    };
    /**
     * @return {?}
     */
    IgxGridAPIService.prototype.arrange_sorting_expressions = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var groupingState = this.grid.groupingExpressions;
        this.grid.sortingExpressions.sort(function (a, b) {
            /** @type {?} */
            var groupExprA = groupingState.find(function (expr) { return expr.fieldName === a.fieldName; });
            /** @type {?} */
            var groupExprB = groupingState.find(function (expr) { return expr.fieldName === b.fieldName; });
            if (groupExprA && groupExprB) {
                return groupingState.indexOf(groupExprA) > groupingState.indexOf(groupExprB) ? 1 : -1;
            }
            else if (groupExprA) {
                return -1;
            }
            else if (groupExprB) {
                return 1;
            }
            else {
                return 0;
            }
        });
    };
    /**
     * @param {?} gRow
     * @return {?}
     */
    IgxGridAPIService.prototype.get_groupBy_record_id = /**
     * @param {?} gRow
     * @return {?}
     */
    function (gRow) {
        /** @type {?} */
        var recordId = '{ ';
        /** @type {?} */
        var hierrarchy = DataUtil.getHierarchy(gRow);
        for (var i = 0; i < hierrarchy.length; i++) {
            /** @type {?} */
            var groupByKey = hierrarchy[i];
            recordId += "'" + groupByKey.fieldName + "': '" + groupByKey.value + "'";
            if (i < hierrarchy.length - 1) {
                recordId += ', ';
            }
        }
        recordId += ' }';
        return recordId;
    };
    return IgxGridAPIService;
}(GridBaseAPIService));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxGroupByRowTemplateDirective = /** @class */ (function () {
    function IgxGroupByRowTemplateDirective(template) {
        this.template = template;
    }
    IgxGroupByRowTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxGroupByRow]'
                },] }
    ];
    /** @nocollapse */
    IgxGroupByRowTemplateDirective.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return IgxGroupByRowTemplateDirective;
}());
/**
 * @hidden
 */
var IgxGroupAreaDropDirective = /** @class */ (function (_super) {
    __extends(IgxGroupAreaDropDirective, _super);
    function IgxGroupAreaDropDirective(elementRef, renderer, zone) {
        var _this = _super.call(this, elementRef, renderer, zone) || this;
        _this.elementRef = elementRef;
        _this.renderer = renderer;
        _this.zone = zone;
        _this.hovered = false;
        return _this;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    IgxGroupAreaDropDirective.prototype.onDragEnter = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var drag = event.detail.owner;
        /** @type {?} */
        var column = drag.column;
        if (!this.columnBelongsToGrid(column)) {
            return;
        }
        /** @type {?} */
        var grid = (/** @type {?} */ (column.grid));
        /** @type {?} */
        var isGrouped = grid.groupingExpressions.findIndex(function (item) { return item.fieldName === column.field; }) !== -1;
        if (column.groupable && !isGrouped && !column.columnGroup) {
            drag.icon.innerText = 'group_work';
            this.hovered = true;
        }
        else {
            drag.icon.innerText = 'block';
            this.hovered = false;
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    IgxGroupAreaDropDirective.prototype.onDragLeave = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var drag = event.detail.owner;
        /** @type {?} */
        var column = drag.column;
        if (!this.columnBelongsToGrid(column)) {
            return;
        }
        event.detail.owner.icon.innerText = 'block';
        this.hovered = false;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    IgxGroupAreaDropDirective.prototype.onDragDrop = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var drag = event.detail.owner;
        if (drag instanceof IgxColumnMovingDragDirective) {
            /** @type {?} */
            var column_1 = drag.column;
            if (!this.columnBelongsToGrid(column_1)) {
                return;
            }
            /** @type {?} */
            var grid = (/** @type {?} */ (column_1.grid));
            /** @type {?} */
            var isGrouped = grid.groupingExpressions.findIndex(function (item) { return item.fieldName === column_1.field; }) !== -1;
            if (column_1.groupable && !isGrouped && !column_1.columnGroup) {
                grid.groupBy({ fieldName: column_1.field, dir: SortingDirection.Asc, ignoreCase: column_1.sortingIgnoreCase,
                    strategy: column_1.sortStrategy, groupingComparer: column_1.groupingComparer });
            }
        }
    };
    /**
     * @private
     * @param {?} elem
     * @param {?} attr
     * @return {?}
     */
    IgxGroupAreaDropDirective.prototype.closestParentByAttr = /**
     * @private
     * @param {?} elem
     * @param {?} attr
     * @return {?}
     */
    function (elem, attr) {
        return elem.hasAttribute(attr) ?
            elem :
            this.closestParentByAttr(elem.parentElement, attr);
    };
    /**
     * @private
     * @param {?} column
     * @return {?}
     */
    IgxGroupAreaDropDirective.prototype.columnBelongsToGrid = /**
     * @private
     * @param {?} column
     * @return {?}
     */
    function (column) {
        /** @type {?} */
        var elem = this.elementRef.nativeElement;
        /** @type {?} */
        var closestGridID = this.closestParentByAttr(elem, 'igxGroupAreaDrop').getAttribute('gridId');
        if (!column) {
            return false;
        }
        else {
            /** @type {?} */
            var grid = (/** @type {?} */ (column.grid));
            if (!grid || grid.id !== closestGridID) {
                return false;
            }
            return true;
        }
    };
    IgxGroupAreaDropDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxGroupAreaDrop]'
                },] }
    ];
    /** @nocollapse */
    IgxGroupAreaDropDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 },
        { type: NgZone }
    ]; };
    IgxGroupAreaDropDirective.propDecorators = {
        hovered: [{ type: HostBinding, args: ['class.igx-drop-area--hover',] }]
    };
    return IgxGroupAreaDropDirective;
}(IgxDropDirective));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var NEXT_ID$m = 0;
/**
 * **Ignite UI for Angular Grid** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid.html)
 *
 * The Ignite UI Grid is used for presenting and manipulating tabular data in the simplest way possible.  Once data
 * has been bound, it can be manipulated through filtering, sorting & editing operations.
 *
 * Example:
 * ```html
 * <igx-grid [data]="employeeData" autoGenerate="false">
 *   <igx-column field="first" header="First Name"></igx-column>
 *   <igx-column field="last" header="Last Name"></igx-column>
 *   <igx-column field="role" header="Role"></igx-column>
 * </igx-grid>
 * ```
 */
var IgxGridComponent = /** @class */ (function (_super) {
    __extends(IgxGridComponent, _super);
    function IgxGridComponent(selectionService, crudService, colResizingService, gridAPI, selection, _transactions, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions) {
        var _this = _super.call(this, selectionService, crudService, gridAPI, selection, _transactions, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions) || this;
        _this.colResizingService = colResizingService;
        _this.document = document;
        _this.overlayService = overlayService;
        _this._displayDensityOptions = _displayDensityOptions;
        _this._id = "igx-grid-" + NEXT_ID$m++;
        /**
         * @hidden
         */
        _this._groupingExpressions = [];
        /**
         * @hidden
         */
        _this._groupingExpandState = [];
        _this._hideGroupedColumns = false;
        _this._dropAreaMessage = null;
        _this._filteredData = null;
        /**
         * An \@Input property that determines whether created groups are rendered expanded or collapsed.
         * The default rendered state is expanded.
         * ```html
         * <igx-grid #grid [data]="Data" [groupsExpanded]="false" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridComponent
         */
        _this.groupsExpanded = true;
        /**
         * A hierarchical representation of the group by records.
         * ```typescript
         * let groupRecords = this.grid.groupsRecords;
         * ```
         * \@memberof IgxGridComponent
         */
        _this.groupsRecords = [];
        /**
         * Emitted when a new `IgxColumnComponent` gets grouped/ungrouped, or multiple columns get
         * grouped/ungrouped at once by using the Group By API.
         * The `onGroupingDone` event would be raised only once if several columns get grouped at once by calling
         * the `groupBy()` or `clearGrouping()` API methods and passing an array as an argument.
         * The event arguments provide the `expressions`, `groupedColumns` and `ungroupedColumns` properties, which contain
         * the `ISortingExpression` and the `IgxColumnComponent` related to the grouping/ungrouping operation.
         * Please note that `groupedColumns` and `ungroupedColumns` show only the **newly** changed columns (affected by the **last**
         * grouping/ungrouping operation), not all columns which are currently grouped/ungrouped.
         * columns.
         * ```typescript
         * groupingDone(event: IGroupingDoneEventArgs){
         *     const expressions = event.expressions;
         *     //the newly grouped columns
         *     const groupedColumns = event.groupedColumns;
         *     //the newly ungrouped columns
         *     const ungroupedColumns = event.ungroupedColumns;
         * }
         * ```
         * ```html
         * <igx-grid #grid [data]="localData" (onGroupingDone)="groupingDone($event)" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridComponent
         */
        _this.onGroupingDone = new EventEmitter();
        _this.onFocusChange = new EventEmitter();
        /**
         * The custom template, if any, that should be used when rendering the row drag indicator icon
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.dragIndicatorIconTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-grid #grid>
         *      ...
         *      <ng-template igxDragIndicatorIcon>
         *          <igx-icon fontSet="material">info</igx-icon>
         *      </ng-template>
         *  </igx-grid>
         * ```
         */
        _this.dragIndicatorIconTemplate = null;
        _this._gridAPI = (/** @type {?} */ (gridAPI));
        return _this;
    }
    Object.defineProperty(IgxGridComponent.prototype, "id", {
        /**
         * An @Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-grid [id]="'igx-grid-1'" [data]="Data" [autoGenerate]="true"></igx-grid>
         * ```
         * @memberof IgxGridComponent
         */
        get: /**
         * An \@Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-grid [id]="'igx-grid-1'" [data]="Data" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */
        function () {
            return this._id;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._id = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridComponent.prototype, "data", {
        /**
         * An @Input property that lets you fill the `IgxGridComponent` with an array of data.
         * ```html
         * <igx-grid [data]="Data" [autoGenerate]="true"></igx-grid>
         * ```
         * @memberof IgxGridBaseComponent
        */
        get: /**
         * An \@Input property that lets you fill the `IgxGridComponent` with an array of data.
         * ```html
         * <igx-grid [data]="Data" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridBaseComponent
         * @return {?}
         */
        function () {
            return this._data;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._data = value;
            if (this._ngAfterViewInitPassed &&
                this.calcHeight === null &&
                this.isPercentHeight) {
                /* the body should be auto-sized in this case before igxFor renders the whole data */
                /** @type {?} */
                var bodyHeight = this.defaultTargetBodyHeight;
                this.calcHeight = bodyHeight > 0 ? bodyHeight : null;
            }
            this.summaryService.clearSummaryCache();
            if (this.shouldGenerate) {
                this.setupColumns();
                this.reflow();
            }
            this.cdr.markForCheck();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridComponent.prototype, "filteredData", {
        /**
         * Returns an array of objects containing the filtered data in the `IgxGridComponent`.
         * ```typescript
         * let filteredData = this.grid.filteredData;
         * ```
         * @memberof IgxGridComponent
         */
        get: /**
         * Returns an array of objects containing the filtered data in the `IgxGridComponent`.
         * ```typescript
         * let filteredData = this.grid.filteredData;
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */
        function () {
            return this._filteredData;
        },
        /**
         * Sets an array of objects containing the filtered data in the `IgxGridComponent`.
         * ```typescript
         * this.grid.filteredData = [{
         *       ID: 1,
         *       Name: "A"
         * }];
         * ```
         * @memberof IgxGridComponent
         */
        set: /**
         * Sets an array of objects containing the filtered data in the `IgxGridComponent`.
         * ```typescript
         * this.grid.filteredData = [{
         *       ID: 1,
         *       Name: "A"
         * }];
         * ```
         * \@memberof IgxGridComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._filteredData = value;
            if (this.rowSelectable) {
                this.updateHeaderCheckboxStatusOnFilter(this._filteredData);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridComponent.prototype, "groupingExpressions", {
        /**
         * Returns the group by state of the `IgxGridComponent`.
         * ```typescript
         * let groupByState = this.grid.groupingExpressions;
         * ```
         * @memberof IgxGridComponent
         */
        get: /**
         * Returns the group by state of the `IgxGridComponent`.
         * ```typescript
         * let groupByState = this.grid.groupingExpressions;
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */
        function () {
            return this._groupingExpressions;
        },
        /**
         * Sets the group by state of the `IgxGridComponent` and emits the `onGroupingDone`
         * event with the appropriate arguments.
         * ```typescript
         * this.grid.groupingExpressions = [{
         *     fieldName: "ID",
         *     dir: SortingDirection.Asc,
         *     ignoreCase: false
         * }];
         * ```
         * @memberof IgxGridComponent
         */
        set: /**
         * Sets the group by state of the `IgxGridComponent` and emits the `onGroupingDone`
         * event with the appropriate arguments.
         * ```typescript
         * this.grid.groupingExpressions = [{
         *     fieldName: "ID",
         *     dir: SortingDirection.Asc,
         *     ignoreCase: false
         * }];
         * ```
         * \@memberof IgxGridComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var _this = this;
            if (value && value.length > 10) {
                throw Error('Maximum amount of grouped columns is 10.');
            }
            /** @type {?} */
            var oldExpressions = this.groupingExpressions;
            /** @type {?} */
            var newExpressions = value;
            this._groupingExpressions = cloneArray(value);
            this.chipsGoupingExpressions = cloneArray(value);
            if (this._gridAPI.grid) {
                /* grouping should work in conjunction with sorting
                and without overriding separate sorting expressions */
                this._applyGrouping();
                this._gridAPI.arrange_sorting_expressions();
                this.cdr.markForCheck();
            }
            else {
                // setter called before grid is registered in grid API service
                this.sortingExpressions.unshift.apply(this.sortingExpressions, this._groupingExpressions);
            }
            if (JSON.stringify(oldExpressions) !== JSON.stringify(newExpressions) && this.columnList) {
                /** @type {?} */
                var groupedCols_1 = [];
                /** @type {?} */
                var ungroupedCols_1 = [];
                /** @type {?} */
                var groupedColsArr = newExpressions.filter(function (obj) {
                    return !oldExpressions.some(function (obj2) {
                        return obj.fieldName === obj2.fieldName;
                    });
                });
                groupedColsArr.forEach(function (elem) {
                    groupedCols_1.push(_this.getColumnByName(elem.fieldName));
                }, this);
                /** @type {?} */
                var ungroupedColsArr = oldExpressions.filter(function (obj) {
                    return !newExpressions.some(function (obj2) {
                        return obj.fieldName === obj2.fieldName;
                    });
                });
                ungroupedColsArr.forEach(function (elem) {
                    ungroupedCols_1.push(_this.getColumnByName(elem.fieldName));
                }, this);
                this.cdr.detectChanges();
                /** @type {?} */
                var groupingDoneArgs = {
                    expressions: newExpressions,
                    groupedColumns: groupedCols_1,
                    ungroupedColumns: ungroupedCols_1
                };
                this.onGroupingDone.emit(groupingDoneArgs);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridComponent.prototype, "groupingExpansionState", {
        /**
         * Returns a list of expansion states for group rows.
         * Includes only states that differ from the default one (controlled through groupsExpanded and states that the user has changed.
         * Contains the expansion state (expanded: boolean) and the unique identifier for the group row (Array).
         * ```typescript
         * const groupExpState = this.grid.groupingExpansionState;
         * ```
         * @memberof IgxGridComponent
         */
        get: /**
         * Returns a list of expansion states for group rows.
         * Includes only states that differ from the default one (controlled through groupsExpanded and states that the user has changed.
         * Contains the expansion state (expanded: boolean) and the unique identifier for the group row (Array).
         * ```typescript
         * const groupExpState = this.grid.groupingExpansionState;
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */
        function () {
            return this._groupingExpandState;
        },
        /**
         * Sets a list of expansion states for group rows.
         * ```typescript
         *      this.grid.groupingExpansionState = [{
         *      expanded: false,
         *      hierarchy: [{ fieldName: 'ID', value: 1 }]
         *   }];
         * // You can use DataUtil.getHierarchy(groupRow) to get the group `IgxGridRowComponent` hierarchy.
         * ```
         * @memberof IgxGridComponent
         */
        set: /**
         * Sets a list of expansion states for group rows.
         * ```typescript
         *      this.grid.groupingExpansionState = [{
         *      expanded: false,
         *      hierarchy: [{ fieldName: 'ID', value: 1 }]
         *   }];
         * // You can use DataUtil.getHierarchy(groupRow) to get the group `IgxGridRowComponent` hierarchy.
         * ```
         * \@memberof IgxGridComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._groupingExpandState = cloneArray(value);
            this.cdr.detectChanges();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridComponent.prototype, "hideGroupedColumns", {
        /**
         * An @Input property that sets whether the grouped columns should be hidden as well.
         * The default value is "false"
         * ```html
         * <igx-grid #grid [data]="localData" [hideGroupedColumns]="true" [autoGenerate]="true"></igx-grid>
         * ```
         * @memberof IgxGridComponent
         */
        get: /**
         * An \@Input property that sets whether the grouped columns should be hidden as well.
         * The default value is "false"
         * ```html
         * <igx-grid #grid [data]="localData" [hideGroupedColumns]="true" [autoGenerate]="true"></igx-grid>
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */
        function () {
            return this._hideGroupedColumns;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value) {
                this.groupingDiffer = this.differs.find(this.groupingExpressions).create();
            }
            else {
                this.groupingDiffer = null;
            }
            if (this.columnList && this.groupingExpressions) {
                this._setGroupColsVisibility(value);
            }
            this._hideGroupedColumns = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridComponent.prototype, "dropAreaMessage", {
        /**
         * An accessor that returns the message displayed inside the GroupBy drop area where columns can be dragged on.
        */
        get: /**
         * An accessor that returns the message displayed inside the GroupBy drop area where columns can be dragged on.
         * @return {?}
         */
        function () {
            return this._dropAreaMessage || this.resourceStrings.igx_grid_groupByArea_message;
        },
        /**
         * An @Input property that sets the message displayed inside the GroupBy drop area where columns can be dragged on.
         * Note: The grid needs to have at least one groupable column in order the GroupBy area to be displayed.
         * ```html
         * <igx-grid dropAreaMessage="Drop here to group!">
         *      <igx-column [groupable]="true" field="ID"></igx-column>
         * </igx-grid>
         * ```
         * @memberof IgxGridComponent
         */
        set: /**
         * An \@Input property that sets the message displayed inside the GroupBy drop area where columns can be dragged on.
         * Note: The grid needs to have at least one groupable column in order the GroupBy area to be displayed.
         * ```html
         * <igx-grid dropAreaMessage="Drop here to group!">
         *      <igx-column [groupable]="true" field="ID"></igx-column>
         * </igx-grid>
         * ```
         * \@memberof IgxGridComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._dropAreaMessage = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridComponent.prototype, "groupsRowList", {
        /**
         * A list of all group rows.
         * ```typescript
         * const groupList = this.grid.groupsRowList;
         * ```
         * @memberof IgxGridComponent
         */
        get: /**
         * A list of all group rows.
         * ```typescript
         * const groupList = this.grid.groupsRowList;
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */
        function () {
            /** @type {?} */
            var res = new QueryList();
            if (!this._groupsRowList) {
                return res;
            }
            /** @type {?} */
            var rList = this._groupsRowList.filter(function (item) {
                return item.element.nativeElement.parentElement !== null;
            });
            res.reset(rList);
            return res;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridComponent.prototype, "groupAreaHostClass", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.getComponentDensityClass('igx-drop-area');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridComponent.prototype, "groupRowTemplate", {
        /**
         * Returns the template reference of the `IgxGridComponent`'s group row.
         * ```
         * const groupRowTemplate = this.grid.groupRowTemplate;
         * ```
         * @memberof IgxGridComponent
         */
        get: /**
         * Returns the template reference of the `IgxGridComponent`'s group row.
         * ```
         * const groupRowTemplate = this.grid.groupRowTemplate;
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */
        function () {
            return this._groupRowTemplate;
        },
        /**
         * Sets the template reference of the `IgxGridComponent`'s group `IgxGridRowComponent`.
         * ```typescript
         * this.grid.groupRowTemplate = myRowTemplate.
         * ```
         * @memberof IgxGridComponent
         */
        set: /**
         * Sets the template reference of the `IgxGridComponent`'s group `IgxGridRowComponent`.
         * ```typescript
         * this.grid.groupRowTemplate = myRowTemplate.
         * ```
         * \@memberof IgxGridComponent
         * @param {?} template
         * @return {?}
         */
        function (template) {
            this._groupRowTemplate = template;
            this.markForCheck();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxGridComponent.prototype, "groupAreaTemplate", {
        /**
         * Returns the template reference of the `IgxGridComponent`'s group area.
         * ```typescript
         * const groupAreaTemplate = this.grid.groupAreaTemplate;
         * ```
         * @memberof IgxGridComponent
         */
        get: /**
         * Returns the template reference of the `IgxGridComponent`'s group area.
         * ```typescript
         * const groupAreaTemplate = this.grid.groupAreaTemplate;
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */
        function () {
            return this._groupAreaTemplate;
        },
        /**
         * Sets the template reference of the `IgxGridComponent`'s group area.
         * ```typescript
         * this.grid.groupAreaTemplate = myAreaTemplate.
         * ```
         * @memberof IgxGridComponent
         */
        set: /**
         * Sets the template reference of the `IgxGridComponent`'s group area.
         * ```typescript
         * this.grid.groupAreaTemplate = myAreaTemplate.
         * ```
         * \@memberof IgxGridComponent
         * @param {?} template
         * @return {?}
         */
        function (template) {
            this._groupAreaTemplate = template;
            this.markForCheck();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Groups by a new `IgxColumnComponent` based on the provided expression, or modifies an existing one.
     * Also allows for multiple columns to be grouped at once if an array of `ISortingExpression` is passed.
     * The onGroupingDone event would get raised only **once** if this method gets called multiple times with the same arguments.
     * ```typescript
     * this.grid.groupBy({ fieldName: name, dir: SortingDirection.Asc, ignoreCase: false });
     * this.grid.groupBy([
            { fieldName: name1, dir: SortingDirection.Asc, ignoreCase: false },
            { fieldName: name2, dir: SortingDirection.Desc, ignoreCase: true },
            { fieldName: name3, dir: SortingDirection.Desc, ignoreCase: false }
        ]);
     * ```
     * @memberof IgxGridComponent
     */
    /**
     * Groups by a new `IgxColumnComponent` based on the provided expression, or modifies an existing one.
     * Also allows for multiple columns to be grouped at once if an array of `ISortingExpression` is passed.
     * The onGroupingDone event would get raised only **once** if this method gets called multiple times with the same arguments.
     * ```typescript
     * this.grid.groupBy({ fieldName: name, dir: SortingDirection.Asc, ignoreCase: false });
     * this.grid.groupBy([
     * { fieldName: name1, dir: SortingDirection.Asc, ignoreCase: false },
     * { fieldName: name2, dir: SortingDirection.Desc, ignoreCase: true },
     * { fieldName: name3, dir: SortingDirection.Desc, ignoreCase: false }
     * ]);
     * ```
     * \@memberof IgxGridComponent
     * @param {?} expression
     * @return {?}
     */
    IgxGridComponent.prototype.groupBy = /**
     * Groups by a new `IgxColumnComponent` based on the provided expression, or modifies an existing one.
     * Also allows for multiple columns to be grouped at once if an array of `ISortingExpression` is passed.
     * The onGroupingDone event would get raised only **once** if this method gets called multiple times with the same arguments.
     * ```typescript
     * this.grid.groupBy({ fieldName: name, dir: SortingDirection.Asc, ignoreCase: false });
     * this.grid.groupBy([
     * { fieldName: name1, dir: SortingDirection.Asc, ignoreCase: false },
     * { fieldName: name2, dir: SortingDirection.Desc, ignoreCase: true },
     * { fieldName: name3, dir: SortingDirection.Desc, ignoreCase: false }
     * ]);
     * ```
     * \@memberof IgxGridComponent
     * @param {?} expression
     * @return {?}
     */
    function (expression) {
        this.endEdit(true);
        this._gridAPI.submit_value();
        if (expression instanceof Array) {
            this._gridAPI.groupBy_multiple(expression);
        }
        else {
            this._gridAPI.groupBy(expression);
        }
        this.cdr.detectChanges();
        this.calculateGridSizes();
    };
    /**
     * Clears all grouping in the grid, if no parameter is passed.
     * If a parameter is provided, clears grouping for a particular column or an array of columns.
     * ```typescript
     * this.grid.clearGrouping(); //clears all grouping
     * this.grid.clearGrouping("ID"); //ungroups a single column
     * this.grid.clearGrouping(["ID", "Column1", "Column2"]); //ungroups multiple columns
     * ```
     *
     */
    /**
     * Clears all grouping in the grid, if no parameter is passed.
     * If a parameter is provided, clears grouping for a particular column or an array of columns.
     * ```typescript
     * this.grid.clearGrouping(); //clears all grouping
     * this.grid.clearGrouping("ID"); //ungroups a single column
     * this.grid.clearGrouping(["ID", "Column1", "Column2"]); //ungroups multiple columns
     * ```
     *
     * @param {?=} name
     * @return {?}
     */
    IgxGridComponent.prototype.clearGrouping = /**
     * Clears all grouping in the grid, if no parameter is passed.
     * If a parameter is provided, clears grouping for a particular column or an array of columns.
     * ```typescript
     * this.grid.clearGrouping(); //clears all grouping
     * this.grid.clearGrouping("ID"); //ungroups a single column
     * this.grid.clearGrouping(["ID", "Column1", "Column2"]); //ungroups multiple columns
     * ```
     *
     * @param {?=} name
     * @return {?}
     */
    function (name) {
        this._gridAPI.clear_groupby(name);
        this.calculateGridSizes();
    };
    /**
     * Returns if a group is expanded or not.
     * ```typescript
     * public groupRow: IGroupByRecord;
     * const expandedGroup = this.grid.isExpandedGroup(this.groupRow);
     * ```
     * @memberof IgxGridComponent
     */
    /**
     * Returns if a group is expanded or not.
     * ```typescript
     * public groupRow: IGroupByRecord;
     * const expandedGroup = this.grid.isExpandedGroup(this.groupRow);
     * ```
     * \@memberof IgxGridComponent
     * @param {?} group
     * @return {?}
     */
    IgxGridComponent.prototype.isExpandedGroup = /**
     * Returns if a group is expanded or not.
     * ```typescript
     * public groupRow: IGroupByRecord;
     * const expandedGroup = this.grid.isExpandedGroup(this.groupRow);
     * ```
     * \@memberof IgxGridComponent
     * @param {?} group
     * @return {?}
     */
    function (group) {
        /** @type {?} */
        var state$$1 = this._getStateForGroupRow(group);
        return state$$1 ? state$$1.expanded : this.groupsExpanded;
    };
    /**
     * Toggles the expansion state of a group.
     * ```typescript
     * public groupRow: IGroupByRecord;
     * const toggleExpGroup = this.grid.toggleGroup(this.groupRow);
     * ```
     * @memberof IgxGridComponent
     */
    /**
     * Toggles the expansion state of a group.
     * ```typescript
     * public groupRow: IGroupByRecord;
     * const toggleExpGroup = this.grid.toggleGroup(this.groupRow);
     * ```
     * \@memberof IgxGridComponent
     * @param {?} groupRow
     * @return {?}
     */
    IgxGridComponent.prototype.toggleGroup = /**
     * Toggles the expansion state of a group.
     * ```typescript
     * public groupRow: IGroupByRecord;
     * const toggleExpGroup = this.grid.toggleGroup(this.groupRow);
     * ```
     * \@memberof IgxGridComponent
     * @param {?} groupRow
     * @return {?}
     */
    function (groupRow) {
        this._toggleGroup(groupRow);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} record
     * @return {?}
     */
    IgxGridComponent.prototype.isGroupByRecord = /**
     * @hidden
     * @param {?} record
     * @return {?}
     */
    function (record) {
        // return record.records instance of GroupedRecords fails under Webpack
        return record.records && record.records.length;
    };
    /**
     * Toggles the expansion state of all group rows recursively.
     * ```typescript
     * this.grid.toggleAllGroupRows;
     * ```
     * @memberof IgxGridComponent
     */
    /**
     * Toggles the expansion state of all group rows recursively.
     * ```typescript
     * this.grid.toggleAllGroupRows;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    IgxGridComponent.prototype.toggleAllGroupRows = /**
     * Toggles the expansion state of all group rows recursively.
     * ```typescript
     * this.grid.toggleAllGroupRows;
     * ```
     * \@memberof IgxGridComponent
     * @return {?}
     */
    function () {
        this.groupingExpansionState = [];
        this.groupsExpanded = !this.groupsExpanded;
        this.cdr.detectChanges();
    };
    Object.defineProperty(IgxGridComponent.prototype, "hasGroupableColumns", {
        /**
         * Returns if the `IgxGridComponent` has groupable columns.
         * ```typescript
         * const groupableGrid = this.grid.hasGroupableColumns;
         * ```
         * @memberof IgxGridComponent
         */
        get: /**
         * Returns if the `IgxGridComponent` has groupable columns.
         * ```typescript
         * const groupableGrid = this.grid.hasGroupableColumns;
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */
        function () {
            return this.columnList.some(function (col) { return col.groupable && !col.columnGroup; });
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    IgxGridComponent.prototype._setGroupColsVisibility = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        var _this = this;
        this.groupingExpressions.forEach(function (expr) {
            /** @type {?} */
            var col = _this.getColumnByName(expr.fieldName);
            col.hidden = value;
        });
    };
    Object.defineProperty(IgxGridComponent.prototype, "dropAreaVisible", {
        /**
         * Returns if the grid's group by drop area is visible.
         * ```typescript
         * const dropVisible = this.grid.dropAreaVisible;
         * ```
         * @memberof IgxGridComponent
         */
        get: /**
         * Returns if the grid's group by drop area is visible.
         * ```typescript
         * const dropVisible = this.grid.dropAreaVisible;
         * ```
         * \@memberof IgxGridComponent
         * @return {?}
         */
        function () {
            return (this.draggedColumn && this.draggedColumn.groupable) ||
                !this.chipsGoupingExpressions.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} groupRow
     * @return {?}
     */
    IgxGridComponent.prototype._getStateForGroupRow = /**
     * @hidden
     * @protected
     * @param {?} groupRow
     * @return {?}
     */
    function (groupRow) {
        return this._gridAPI.groupBy_get_expanded_for_group(groupRow);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} groupRow
     * @return {?}
     */
    IgxGridComponent.prototype._toggleGroup = /**
     * @hidden
     * @protected
     * @param {?} groupRow
     * @return {?}
     */
    function (groupRow) {
        this._gridAPI.groupBy_toggle_group(groupRow);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    IgxGridComponent.prototype._applyGrouping = /**
     * @hidden
     * @protected
     * @return {?}
     */
    function () {
        this._gridAPI.sort_multiple(this._groupingExpressions);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} fieldName
     * @return {?}
     */
    IgxGridComponent.prototype.isColumnGrouped = /**
     * @hidden
     * @param {?} fieldName
     * @return {?}
     */
    function (fieldName) {
        return this.groupingExpressions.find(function (exp) { return exp.fieldName === fieldName; }) ? true : false;
    };
    /**
    * @hidden
    */
    /**
     * @hidden
     * @param {?} rowData
     * @param {?} rowIndex
     * @return {?}
     */
    IgxGridComponent.prototype.getContext = /**
     * @hidden
     * @param {?} rowData
     * @param {?} rowIndex
     * @return {?}
     */
    function (rowData, rowIndex) {
        return {
            $implicit: rowData,
            index: rowIndex,
            templateID: this.isGroupByRecord(rowData) ? 'groupRow' : this.isSummaryRow(rowData) ? 'summaryRow' : 'dataRow'
        };
    };
    Object.defineProperty(IgxGridComponent.prototype, "template", {
        /**
        * @hidden
        */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            if (this.filteredData && this.filteredData.length === 0) {
                return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyFilteredGridTemplate;
            }
            if (this.isLoading && (!this.data || this.dataLength === 0)) {
                return this.loadingGridTemplate ? this.loadingGridTemplate : this.loadingGridDefaultTemplate;
            }
            if (this.dataLength === 0) {
                return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyGridDefaultTemplate;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    IgxGridComponent.prototype.getGroupByRecords = /**
     * @hidden
     * @protected
     * @return {?}
     */
    function () {
        if (this.groupingExpressions && this.groupingExpressions.length) {
            /** @type {?} */
            var state$$1 = {
                expressions: this.groupingExpressions,
                expansion: this.groupingExpansionState,
                defaultExpanded: this.groupsExpanded
            };
            return DataUtil.group(cloneArray(this.filteredSortedData), state$$1, this).metadata;
        }
        else {
            return null;
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxGridComponent.prototype.onChipRemoved = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.clearGrouping(event.owner.id);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxGridComponent.prototype.chipsOrderChanged = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var newGrouping = [];
        var _loop_1 = function (i) {
            /** @type {?} */
            var expr = this_1.groupingExpressions.filter(function (item) {
                return item.fieldName === event.chipsArray[i].id;
            })[0];
            if (!this_1.getColumnByName(expr.fieldName).groupable) {
                return { value: void 0 };
            }
            newGrouping.push(expr);
        };
        var this_1 = this;
        for (var i = 0; i < event.chipsArray.length; i++) {
            var state_1 = _loop_1(i);
            if (typeof state_1 === "object")
                return state_1.value;
        }
        this.groupingExpansionState = [];
        this.chipsGoupingExpressions = newGrouping;
        if (event.originalEvent instanceof KeyboardEvent) {
            // When reordered using keyboard navigation, we don't have `onMoveEnd` event.
            this.groupingExpressions = this.chipsGoupingExpressions;
        }
        this.markForCheck();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxGridComponent.prototype.chipsMovingEnded = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.groupingExpressions = this.chipsGoupingExpressions;
        this.markForCheck();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxGridComponent.prototype.onChipClicked = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var sortingExpr = this.sortingExpressions;
        /** @type {?} */
        var columnExpr = sortingExpr.find(function (expr) { return expr.fieldName === event.owner.id; });
        columnExpr.dir = 3 - columnExpr.dir;
        this.sort(columnExpr);
        this.markForCheck();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxGridComponent.prototype.onChipKeyDown = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.originalEvent.key === ' ' || event.originalEvent.key === 'Spacebar' || event.originalEvent.key === 'Enter') {
            /** @type {?} */
            var sortingExpr = this.sortingExpressions;
            /** @type {?} */
            var columnExpr = sortingExpr.find(function (expr) { return expr.fieldName === event.owner.id; });
            columnExpr.dir = 3 - columnExpr.dir;
            this.sort(columnExpr);
            this.markForCheck();
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    IgxGridComponent.prototype.getGroupAreaHeight = /**
     * @hidden
     * @protected
     * @return {?}
     */
    function () {
        return this.groupArea ? this.groupArea.nativeElement.offsetHeight : 0;
    };
    /**
     * @hidden
     * Gets the combined width of the columns that are specific to the enabled grid features. They are fixed.
     * TODO: Remove for Angular 8. Calling parent class getter using super is not supported for now.
     */
    /**
     * @hidden
     * Gets the combined width of the columns that are specific to the enabled grid features. They are fixed.
     * TODO: Remove for Angular 8. Calling parent class getter using super is not supported for now.
     * @return {?}
     */
    IgxGridComponent.prototype.getFeatureColumnsWidth = /**
     * @hidden
     * Gets the combined width of the columns that are specific to the enabled grid features. They are fixed.
     * TODO: Remove for Angular 8. Calling parent class getter using super is not supported for now.
     * @return {?}
     */
    function () {
        /** @type {?} */
        var width = _super.prototype.getFeatureColumnsWidth.call(this);
        if (this.groupingExpressions.length && this.headerGroupContainer) {
            width += this.headerGroupContainer.nativeElement.offsetWidth;
        }
        return width;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} row
     * @param {?} column
     * @return {?}
     */
    IgxGridComponent.prototype.scrollTo = /**
     * @hidden
     * @protected
     * @param {?} row
     * @param {?} column
     * @return {?}
     */
    function (row, column) {
        if (this.groupingExpressions && this.groupingExpressions.length
            && typeof (row) !== 'number') {
            /** @type {?} */
            var groupByRecords = this.getGroupByRecords();
            /** @type {?} */
            var rowIndex = this.filteredSortedData.indexOf(row);
            /** @type {?} */
            var groupByRecord = groupByRecords[rowIndex];
            if (groupByRecord && !this.isExpandedGroup(groupByRecord)) {
                this.toggleGroup(groupByRecord);
            }
        }
        _super.prototype.scrollTo.call(this, row, column);
    };
    Object.defineProperty(IgxGridComponent.prototype, "dropAreaTemplateResolved", {
        /**
        * @hidden
        */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            if (this.dropAreaTemplate) {
                return this.dropAreaTemplate;
            }
            else {
                return this.defaultDropAreaTemplate;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} expression
     * @return {?}
     */
    IgxGridComponent.prototype.getGroupByChipTitle = /**
     * @hidden
     * @param {?} expression
     * @return {?}
     */
    function (expression) {
        return this.getColumnByName(expression.fieldName).header || expression.fieldName;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxGridComponent.prototype.ngAfterContentInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (this.allowFiltering && this.hasColumnLayouts) {
            this.filterMode = FilterMode.excelStyleFilter;
        }
        if (this.groupTemplate) {
            this._groupRowTemplate = this.groupTemplate.template;
        }
        _super.prototype.ngAfterContentInit.call(this);
        if (this.hideGroupedColumns && this.columnList && this.groupingExpressions) {
            this._setGroupColsVisibility(this.hideGroupedColumns);
        }
    };
    /**
     * @return {?}
     */
    IgxGridComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        _super.prototype.ngOnInit.call(this);
        this.onGroupingDone.pipe(takeUntil(this.destroy$)).subscribe(function (args) {
            _this.endEdit(true);
            _this.summaryService.updateSummaryCache(args);
        });
    };
    /**
     * @return {?}
     */
    IgxGridComponent.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
        var _this = this;
        _super.prototype.ngDoCheck.call(this);
        if (this.groupingDiffer) {
            /** @type {?} */
            var changes = this.groupingDiffer.diff(this.groupingExpressions);
            if (changes && this.columnList) {
                changes.forEachAddedItem(function (rec) {
                    /** @type {?} */
                    var col = _this.getColumnByName(rec.item.fieldName);
                    col.hidden = true;
                });
                changes.forEachRemovedItem(function (rec) {
                    /** @type {?} */
                    var col = _this.getColumnByName(rec.item.fieldName);
                    col.hidden = false;
                });
            }
        }
    };
    /**
     * @return {?}
     */
    IgxGridComponent.prototype.getSelectedData = /**
     * @return {?}
     */
    function () {
        if (this.groupingExpressions.length) {
            /** @type {?} */
            var source_1 = [];
            /** @type {?} */
            var process = function (record) {
                if (record.expression || record.summaries) {
                    source_1.push(null);
                    return;
                }
                source_1.push(record);
            };
            this.verticalScrollContainer.igxForOf.forEach(process);
            return this.extractDataFromSelection(source_1);
        }
        else {
            return _super.prototype.getSelectedData.call(this);
        }
    };
    IgxGridComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    providers: [IgxGridNavigationService, IgxGridSummaryService, IgxGridSelectionService, IgxGridCRUDService,
                        { provide: GridBaseAPIService, useClass: IgxGridAPIService },
                        { provide: IgxGridBaseComponent, useExisting: forwardRef(function () { return IgxGridComponent; }) },
                        IgxFilteringService, IgxColumnResizingService, IgxForOfSyncService
                    ],
                    selector: 'igx-grid',
                    template: "<igx-grid-toolbar [style.width.px]=\"outerWidth\" role=\"rowgroup\" *ngIf=\"showToolbar\" [gridID]=\"id\" [displayDensity]=\"displayDensity\" #toolbar>\n</igx-grid-toolbar>\n\n<ng-template #defaultPager let-api>\n    <button [disabled]=\"api.isFirstPage\" (click)=\"api.paginate(0)\" igxButton=\"icon\" igxRipple igxRippleCentered=\"true\">\n        <igx-icon fontSet=\"material\">first_page</igx-icon>\n    </button>\n    <button [disabled]=\"api.isFirstPage\" (click)=\"api.previousPage()\" igxButton=\"icon\" igxRipple igxRippleCentered=\"true\">\n        <igx-icon fontSet=\"material\">chevron_left</igx-icon>\n    </button>\n    <span>{{ api.page + 1 }} of {{ api.totalPages }}</span>\n    <button [disabled]=\"api.isLastPage\" (click)=\"api.nextPage()\" igxRipple igxRippleCentered=\"true\" igxButton=\"icon\">\n        <igx-icon fontSet=\"material\">chevron_right</igx-icon>\n    </button>\n        <button [disabled]=\"api.isLastPage\" (click)=\"api.paginate(api.totalPages - 1)\" igxButton=\"icon\" igxRipple igxRippleCentered=\"true\">\n        <igx-icon fontSet=\"material\">last_page</igx-icon>\n    </button>\n    <select style=\"margin-left: 1rem;\" (change)=\"api.perPage = $event.target.value\">\n            <option [value]=\"val\" [selected]=\"api.perPage == val\" *ngFor=\"let val of [5, 10, 15, 25, 50, 100, 500]\">{{ val }}</option>\n    </select>\n</ng-template>\n\n<div [style.width.px]='outerWidth' class=\"igx-grid__grouparea\" *ngIf=\"groupingExpressions.length > 0 || hasGroupableColumns\" #groupArea>\n    <igx-chips-area (onReorder)=\"chipsOrderChanged($event)\" (onMoveEnd)=\"chipsMovingEnded()\">\n        <ng-container *ngFor=\"let expr of chipsGoupingExpressions; let last = last;\">\n            <igx-chip [id]=\"expr.fieldName\" [attr.title]=\"getGroupByChipTitle(expr)\" [removable]=\"getColumnByName(expr.fieldName).groupable\" [draggable]=\"getColumnByName(expr.fieldName).groupable\" [displayDensity]=\"displayDensity\"\n                    (onKeyDown)=\"onChipKeyDown($event)\" (onRemove)=\"onChipRemoved($event)\" (onClick)=\"getColumnByName(expr.fieldName).groupable ? onChipClicked($event): null\" [disabled]='!getColumnByName(expr.fieldName).groupable'>\n                    <span>{{ getGroupByChipTitle(expr) }}</span>\n                    <igx-icon igxSuffix>{{ expr.dir == 1 ? 'arrow_upward' : 'arrow_downward' }}</igx-icon>\n            </igx-chip>\n            <span class=\"igx-grid__grouparea-connector\">\n                <igx-icon [style.visibility]=\"(!last || dropAreaVisible) ? 'visible' : 'hidden'\" >arrow_forward</igx-icon>\n            </span>\n        </ng-container>\n        <div igxGroupAreaDrop [style.visibility]=\"dropAreaVisible ? 'visible' : 'hidden'\" [class]=\"groupAreaHostClass\" [attr.gridId]='this.id'>\n            <ng-container *ngTemplateOutlet=\"dropAreaTemplateResolved\"></ng-container>\n        </div>\n    </igx-chips-area>\n</div>\n\n<div class=\"igx-grid__thead\">\n    <div class=\"igx-grid__thead-wrapper\" [class.igx-grid__tr--mrl]='hasColumnLayouts' role=\"rowgroup\" [style.width.px]='calcWidth + 1' #theadRow>\n        <div class=\"igx-grid__tr\" role=\"row\" [style.width.px]='calcWidth + 1'>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"left\" class=\"igx-grid__scroll-on-drag-left\" [style.left.px]=\"featureColumnsWidth\"></span>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"left\" class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n            <ng-container *ngIf=\"groupingExpressions.length > 0\">\n                <div class=\"igx-grid__header-indentation igx-grid__row-indentation--level-{{groupingExpressions.length}}\" [ngClass]=\"{\n                    'igx-grid__header-indentation--no-border': rowSelectable || rowDraggable\n                }\" #headerGroupContainer>\n                    <igx-icon *ngIf=\"groupsExpanded\" role=\"button\" class=\"igx-grid__group-expand-btn\" (click)=\"toggleAllGroupRows()\" [ngClass]=\"{\n                        'igx-grid__group-expand-btn--push': filteringService.isFilterRowVisible\n                    }\">unfold_less</igx-icon>\n                    <igx-icon *ngIf=\"!groupsExpanded\" role=\"button\" class=\"igx-grid__group-expand-btn\" (click)=\"toggleAllGroupRows()\"[ngClass]=\"{\n                        'igx-grid__group-expand-btn--push': filteringService.isFilterRowVisible\n                    }\">unfold_more</igx-icon>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"rowDraggable\">\n                <div class=\"igx-grid__drag-indicator\" [ngClass]=\"{\n                    'igx-grid__drag-indicator--header': !rowSelectable\n                }\" #headerDragContainer>\n                    <div style=\"visibility: hidden;\">\n                        <ng-container *ngTemplateOutlet=\"this.dragIndicatorIconTemplate ? this.dragIndicatorIconTemplate : this.dragIndicatorIconBase\"></ng-container>\n                    </div>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"showRowCheckboxes\">\n                <div class=\"igx-grid__cbx-selection\" #headerCheckboxContainer [ngClass]=\"{\n                    'igx-grid__cbx-selection--push': filteringService.isFilterRowVisible\n                }\">\n                    <igx-checkbox [checked]=\"allRowsSelected\" (change)=\"onHeaderCheckboxClick($event, filteredData)\" disableRipple=\"true\" [aria-label]=\"headerCheckboxAriaLabel\" #headerCheckbox></igx-checkbox>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"pinnedColumns.length > 0\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width.px]=\"getHeaderGroupWidth(col)\" [style.flex-basis.px]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n            <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\" [igxForScrollOrientation]=\"'horizontal'\" [igxForScrollContainer]=\"parentVirtDir\"\n                [igxForContainerSize]='unpinnedWidth' [igxForTrackBy]='trackColumnChanges'  [igxForSizePropName]='\"calcWidth\"' #headerContainer>\n                <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width.px]=\"getHeaderGroupWidth(col)\" [style.flex-basis.px]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n            </ng-template>\n            </div>\n            <igx-grid-filtering-row #filteringRow [style.width.px]='calcWidth' *ngIf=\"filteringService.isFilterRowVisible\" [column]=\"filteringService.filteredColumn\"></igx-grid-filtering-row>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div class=\"igx-grid__thead-thumb\" [hidden]='!hasVerticalSroll()' [style.width.px]=\"scrollWidth\"></div>\n</div>\n\n<div igxGridBody class=\"igx-grid__tbody\">\n    <div class=\"igx-grid__tbody-content\" role=\"rowgroup\" (onDragStop)=\"selectionService.dragMode = $event\" (onDragScroll)=\"dragScroll($event)\" [igxGridDragSelect]=\"selectionService.dragMode\" [style.height.px]='calcHeight' [style.width.px]='calcWidth + 1' #tbody (scroll)='scrollHandler($event)' (wheel)=\"wheelHandler()\">\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"left\" class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"left\" class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n        <ng-template igxGridFor let-rowData [igxGridForOf]=\"data\n        | gridTransaction:id:pipeTrigger\n        | gridFiltering:filteringExpressionsTree:id:pipeTrigger\n        | gridSort:sortingExpressions:id:pipeTrigger\n        | gridPreGroupBy:groupingExpressions:groupingExpansionState:groupsExpanded:id:groupsRecords:pipeTrigger\n        | gridPaging:page:perPage:id:pipeTrigger\n        | gridPostGroupBy:groupingExpressions:groupingExpansionState:groupsExpanded:id:pipeTrigger\n        | gridSummary:hasSummarizedColumns:summaryCalculationMode:summaryPosition:id:pipeTrigger:summaryPipeTrigger\"\n        let-rowIndex=\"index\" [igxForScrollOrientation]=\"'vertical'\"  [igxForScrollContainer]='verticalScroll'\n        [igxForContainerSize]='calcHeight' [igxForItemSize]=\"hasColumnLayouts ? rowHeight * multiRowLayoutRowSize : rowHeight\" #verticalScrollContainer (onChunkPreload)=\"dataLoading($event)\">\n            <ng-template #record_template>\n                <igx-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [rowData]=\"rowData\" #row>\n                </igx-grid-row>\n            </ng-template>\n            <ng-template #group_template>\n                <igx-grid-groupby-row [gridID]=\"id\" [index]=\"rowIndex\" [groupRow]=\"rowData\" #row>\n                </igx-grid-groupby-row>\n            </ng-template>\n            <ng-template #summary_template>\n                <igx-grid-summary-row [gridID]=\"id\" [summaries]=\"rowData.summaries\" [indentation]=\"groupingExpressions.length\" [index]=\"rowIndex\" class=\"igx-grid__summaries--body\" #summaryRow>\n                </igx-grid-summary-row>\n            </ng-template>\n            <ng-template [igxTemplateOutlet]='isGroupByRecord(rowData) ? group_template : isSummaryRow(rowData) ? summary_template : record_template'\n                [igxTemplateOutletContext]='getContext(rowData, rowIndex)'\n                (onCachedViewLoaded)='cachedViewLoaded($event)'>\n            </ng-template>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"template\"></ng-container>\n        <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div [hidden]='!hasVerticalSroll()' class=\"igx-grid__tbody-scrollbar\" [style.width.px]=\"scrollWidth\" [style.height.px]='calcHeight'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #verticalScrollHolder ></ng-template>\n    </div>\n</div>\n\n\n<div class=\"igx-grid__tfoot\" role=\"rowgroup\" [style.height.px]='summariesHeight' #tfoot>\n    <igx-grid-summary-row [style.width.px]='calcWidth' [style.height.px]='summariesHeight' *ngIf=\"hasSummarizedColumns && rootSummariesEnabled\" [gridID]=\"id\" [summaries]=\"id | igxGridSummaryDataPipe:summaryService.retriggerRootPipe\" [indentation]=\"groupingExpressions.length\" [index]=\"0\" class=\"igx-grid__summaries\"  #summaryRow>\n    </igx-grid-summary-row>\n    <div class=\"igx-grid__tfoot-thumb\" [hidden]='!hasVerticalSroll()' [style.height.px]='summariesHeight' [style.width.px]=\"scrollWidth\"></div>\n</div>\n\n<div class=\"igx-grid__scroll\" [style.height]=\"'18px'\" #scr [hidden]=\"unpinnedWidth - totalWidth >= 0\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]='pinnedWidth' [hidden]=\"pinnedWidth === 0\"></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]='unpinnedWidth'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #scrollContainer>\n        </ng-template>\n    </div>\n</div>\n\n<div class=\"igx-paginator igx-grid-paginator\" *ngIf=\"paging && totalRecords\" #paginator>\n    <ng-container *ngTemplateOutlet=\"paginationTemplate ? paginationTemplate : defaultPager; context: { $implicit: this }\">\n    </ng-container>\n</div>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyFilteredGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultLoadingGrid>\n    <div class=\"igx-grid__loading\">\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n</ng-template>\n\n<ng-template #defaultDropArea>\n    <igx-icon fontSet=\"material\" class=\"igx-drop-area__icon\">group_work</igx-icon>\n    <span class=\"igx-drop-area__text\">{{dropAreaMessage}}</span>\n</ng-template>\n\n<div *ngIf=\"rowEditable\" igxToggle>\n    <div [className]=\"bannerClass\">\n        <ng-container *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: endEdit.bind(this) }\"></ng-container>\n    </div>\n</div>\n\n<ng-template #defaultRowEditText>\n    You have {{ rowChangesCount }} changes in this row\n</ng-template>\n\n<ng-template #defaultRowEditActions>\n    <button igxButton igxRowEditTabStop (click)=\"endEdit(false, $event)\">Cancel</button>\n    <button igxButton igxRowEditTabStop (click)=\"endEdit(true, $event)\">Done</button>\n</ng-template>\n\n<ng-template #defaultRowEditTemplate>\n    <div class=\"igx-banner__message\">\n        <span class=\"igx-banner__text\">\n            <ng-container *ngTemplateOutlet=\"rowEditText ? rowEditText : defaultRowEditText; context: { $implicit: rowChangesCount }\"></ng-container>\n        </span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <ng-container *ngTemplateOutlet=\"rowEditActions ? rowEditActions : defaultRowEditActions; context: { $implicit: endEdit.bind(this) }\"></ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #dragIndicatorIconBase>\n    <igx-icon fontSet=\"material\">drag_indicator</igx-icon>\n</ng-template>\n\n<igx-grid-column-resizer *ngIf=\"colResizingService.showResizer\"></igx-grid-column-resizer>\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet></div>\n"
                }] }
    ];
    /** @nocollapse */
    IgxGridComponent.ctorParameters = function () { return [
        { type: IgxGridSelectionService },
        { type: IgxGridCRUDService },
        { type: IgxColumnResizingService },
        { type: GridBaseAPIService },
        { type: IgxSelectionAPIService },
        { type: undefined, decorators: [{ type: Inject, args: [IgxGridTransaction,] }] },
        { type: ElementRef },
        { type: NgZone },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: ChangeDetectorRef },
        { type: ComponentFactoryResolver },
        { type: IterableDiffers },
        { type: ViewContainerRef },
        { type: IgxGridNavigationService },
        { type: IgxFilteringService },
        { type: IgxOverlayService, decorators: [{ type: Inject, args: [IgxOverlayService,] }] },
        { type: IgxGridSummaryService },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
    ]; };
    IgxGridComponent.propDecorators = {
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        data: [{ type: Input }],
        groupingExpressions: [{ type: Input }],
        groupingExpansionState: [{ type: Input }],
        groupsExpanded: [{ type: Input }],
        hideGroupedColumns: [{ type: Input }],
        dropAreaMessage: [{ type: Input }],
        dropAreaTemplate: [{ type: Input }],
        onGroupingDone: [{ type: Output }],
        onFocusChange: [{ type: Output }],
        groupTemplate: [{ type: ContentChild, args: [IgxGroupByRowTemplateDirective, { read: IgxGroupByRowTemplateDirective },] }],
        dragIndicatorIconTemplate: [{ type: ContentChild, args: [IgxDragIndicatorIconDirective, { read: TemplateRef },] }],
        _groupsRowList: [{ type: ViewChildren, args: [IgxGridGroupByRowComponent, { read: IgxGridGroupByRowComponent },] }],
        defaultDropAreaTemplate: [{ type: ViewChild, args: ['defaultDropArea', { read: TemplateRef },] }],
        groupArea: [{ type: ViewChild, args: ['groupArea',] }]
    };
    return IgxGridComponent;
}(IgxGridBaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxGridRowComponent = /** @class */ (function (_super) {
    __extends(IgxGridRowComponent, _super);
    function IgxGridRowComponent(gridAPI, crudService, selectionService, selection, element, cdr) {
        var _this = 
        // D.P. constructor duplication due to es6 compilation, might be obsolete in the future
        _super.call(this, gridAPI, crudService, selectionService, selection, element, cdr) || this;
        _this.gridAPI = gridAPI;
        _this.crudService = crudService;
        _this.selectionService = selectionService;
        _this.element = element;
        _this.cdr = cdr;
        return _this;
    }
    Object.defineProperty(IgxGridRowComponent.prototype, "hasColumnLayouts", {
        get: /**
         * @return {?}
         */
        function () {
            return this.grid.hasColumnLayouts;
        },
        enumerable: true,
        configurable: true
    });
    IgxGridRowComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-grid-row',
                    template: "<ng-container *ngIf=\"grid.groupingExpressions.length > 0\">\n    <div class=\"igx-grid__row-indentation igx-grid__row-indentation--level-{{grid.groupingExpressions.length}}\"></div>\n</ng-container>\n<ng-container *ngIf=\"rowDraggable\">\n    <div [class]=\"resolveDragIndicatorClasses\" [igxRowDrag]=\"this\">\n        <ng-container *ngTemplateOutlet=\"this.grid.dragIndicatorIconTemplate ? this.grid.dragIndicatorIconTemplate : this.grid.dragIndicatorIconBase\"></ng-container>\n    </div>\n</ng-container>\n<ng-container *ngIf=\"showRowCheckboxes\">\n    <div class=\"igx-grid__cbx-selection\">\n        <igx-checkbox [checked]=\"isSelected\" [disabled]=\"deleted\" (change)=\"onCheckboxClick($event)\" disableRipple=\"true\" [disableTransitions]=\"grid.disableTransitions\" [aria-label]=\"rowCheckboxAriaLabel\"></igx-checkbox>\n    </div>\n</ng-container>\n\n<ng-container *ngIf=\"!grid.hasColumnLayouts\">\n    <ng-container *ngIf=\"pinnedColumns.length > 0\">\n        <igx-grid-cell *ngFor=\"let col of pinnedColumns | igxNotGrouped\"\n            class=\"igx-grid__td igx-grid__td--fw igx-grid__td--pinned\"\n            [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n            [ngClass]=\"col.cellClasses | igxCellStyles:rowData[col.field]:rowData:col.field\"\n            [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n            [column]=\"col\"\n            [formatter]=\"col.formatter\"\n            [row]=\"this\"\n            [lastPinned]=\"col.isLastPinned\"\n            [style.min-height.px]=\"grid.rowHeight || 32\"\n            [rowData]=\"rowData\"\n            [style.min-width.px]=\"col.width\"\n            [style.flex-basis.px]=\"col.width\"\n            [width]=\"col.getCellWidth()\"\n            [visibleColumnIndex]=\"col.visibleIndex\"\n            [value]=\"rowData[col.field]\"\n            [cellTemplate]=\"col.bodyTemplate\">\n        </igx-grid-cell>\n    </ng-container>\n    <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\" [igxForScrollContainer]=\"grid.parentVirtDir\" [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth' [igxForSizePropName]='\"calcWidth\"' [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n        <igx-grid-cell\n            class=\"igx-grid__td igx-grid__td--fw\"\n            [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n            [ngClass]=\"col.cellClasses | igxCellStyles:rowData[col.field]:rowData:col.field\"\n            [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n            [column]=\"col\"\n            [formatter]=\"col.formatter\"\n            [row]=\"this\"\n            [style.min-height.px]=\"grid.rowHeight || 32\"\n            [rowData]=\"rowData\"\n            [style.min-width.px]=\"col.width\"\n            [style.flex-basis.px]=\"col.width\"\n            [width]=\"col.getCellWidth()\"\n            [visibleColumnIndex]=\"col.visibleIndex\"\n            [value]=\"rowData[col.field]\"\n            [cellTemplate]=\"col.bodyTemplate\">\n        </igx-grid-cell>\n    </ng-template>\n</ng-container>\n\n<ng-container *ngIf=\"grid.hasColumnLayouts\">\n    <ng-container *ngIf=\"pinnedColumns.length > 0\">\n        <div *ngFor=\"let col of pinnedColumns | igxTopLevel\" class=\"igx-grid__mrl-block\"\n        [ngClass]=\"{'igx-grid__th--pinned-last': col.hasLastPinnedChildColumn}\"\n        [ngStyle]=\"{'grid-template-rows':col.getGridTemplate(true, false),\n        'grid-template-columns':col.getGridTemplate(false, false),\n        'z-index': col.pinned ? 1 : null,\n        '-ms-grid-rows':col.getGridTemplate(true, true),\n        '-ms-grid-columns':col.getGridTemplate(false, true)}\">\n            <igx-grid-cell *ngFor=\"let child of col.children\"\n                class=\"igx-grid__td igx-grid__td--fw igx-grid__td--pinned\"\n                [class.igx-grid__td--number]=\"child.dataType === 'number'\"\n                [ngClass]=\"child.cellClasses | igxCellStyles:rowData[child.field]:rowData:child.field\"\n                [editMode]=\"child.editable && crudService.isInEditMode(index, child.index)\"\n                [column]=\"child\"\n                [formatter]=\"child.formatter\"\n                [row]=\"this\"\n                [style.min-height.px]=\"grid.rowHeight || 32\"\n                [rowData]=\"rowData\"\n                [visibleColumnIndex]=\"child.visibleIndex\"\n                [value]=\"rowData[child.field]\"\n                [cellTemplate]=\"child.bodyTemplate\"></igx-grid-cell>\n        </div>\n    </ng-container>\n    <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\" [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth' [igxForSizePropName]='\"calcWidth\"' [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n        <div class=\"igx-grid__mrl-block\"\n        [ngStyle]=\"{'grid-template-rows':col.getGridTemplate(true, false),\n     'grid-template-columns':col.getGridTemplate(false, false),\n     '-ms-grid-rows':col.getGridTemplate(true, true),\n     '-ms-grid-columns':col.getGridTemplate(false, true)}\">\n            <igx-grid-cell *ngFor=\"let child of col.children\"\n                class=\"igx-grid__td igx-grid__td--fw\"\n                [class.igx-grid__td--number]=\"child.dataType === 'number'\"\n                [ngClass]=\"child.cellClasses | igxCellStyles:rowData[child.field]:rowData:child.field\"\n                [editMode]=\"child.editable && crudService.isInEditMode(index, child.index)\"\n                [column]=\"child\"\n                [formatter]=\"child.formatter\"\n                [row]=\"this\"\n                [style.min-height.px]=\"grid.rowHeight || 32\"\n                [rowData]=\"rowData\"\n                [visibleColumnIndex]=\"child.visibleIndex\"\n                [value]=\"rowData[child.field]\"\n                [cellTemplate]=\"child.bodyTemplate\"></igx-grid-cell>\n        </div>\n    </ng-template>\n</ng-container>\n",
                    providers: [{ provide: IgxRowComponent, useExisting: forwardRef(function () { return IgxGridRowComponent; }) }]
                }] }
    ];
    /** @nocollapse */
    IgxGridRowComponent.ctorParameters = function () { return [
        { type: GridBaseAPIService },
        { type: IgxGridCRUDService },
        { type: IgxGridSelectionService },
        { type: IgxSelectionAPIService },
        { type: ElementRef },
        { type: ChangeDetectorRef }
    ]; };
    IgxGridRowComponent.propDecorators = {
        hasColumnLayouts: [{ type: HostBinding, args: ['class.igx-grid__tr--mrl',] }]
    };
    return IgxGridRowComponent;
}(IgxRowComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxGridSummaryPipe = /** @class */ (function () {
    function IgxGridSummaryPipe(gridAPI) {
        this.gridAPI = (/** @type {?} */ (gridAPI));
    }
    /**
     * @param {?} flatData
     * @param {?} hasSummary
     * @param {?} summaryCalculationMode
     * @param {?} summaryPosition
     * @param {?} id
     * @param {?} pipeTrigger
     * @param {?} summaryPipeTrigger
     * @return {?}
     */
    IgxGridSummaryPipe.prototype.transform = /**
     * @param {?} flatData
     * @param {?} hasSummary
     * @param {?} summaryCalculationMode
     * @param {?} summaryPosition
     * @param {?} id
     * @param {?} pipeTrigger
     * @param {?} summaryPipeTrigger
     * @return {?}
     */
    function (flatData, hasSummary, summaryCalculationMode, summaryPosition, id, pipeTrigger, summaryPipeTrigger) {
        if (!flatData || !hasSummary || summaryCalculationMode === GridSummaryCalculationMode.rootLevelOnly) {
            return flatData;
        }
        return this.addSummaryRows(id, flatData, summaryPosition);
    };
    /**
     * @private
     * @param {?} gridId
     * @param {?} collection
     * @param {?} summaryPosition
     * @return {?}
     */
    IgxGridSummaryPipe.prototype.addSummaryRows = /**
     * @private
     * @param {?} gridId
     * @param {?} collection
     * @param {?} summaryPosition
     * @return {?}
     */
    function (gridId, collection, summaryPosition) {
        /** @type {?} */
        var recordsWithSummary = [];
        /** @type {?} */
        var lastChildMap = new Map();
        /** @type {?} */
        var grid = this.gridAPI.grid;
        /** @type {?} */
        var maxSummaryHeight = grid.summaryService.calcMaxSummaryHeight();
        for (var i = 0; i < collection.length; i++) {
            /** @type {?} */
            var record = collection[i];
            recordsWithSummary.push(record);
            /** @type {?} */
            var recordId = void 0;
            /** @type {?} */
            var groupByRecord = null;
            if (grid.isGroupByRecord(record)) {
                groupByRecord = (/** @type {?} */ (record));
                recordId = this.gridAPI.get_groupBy_record_id(groupByRecord);
            }
            else {
                recordId = this.gridAPI.get_row_id(record);
            }
            if (summaryPosition === GridSummaryPosition.bottom && lastChildMap.has(recordId)) {
                /** @type {?} */
                var groupRecords = lastChildMap.get(recordId);
                for (var j = 0; j < groupRecords.length; j++) {
                    /** @type {?} */
                    var groupRecord = groupRecords[j];
                    /** @type {?} */
                    var groupRecordId = this.gridAPI.get_groupBy_record_id(groupRecord);
                    /** @type {?} */
                    var records = this.removeDeletedRecord(grid, groupRecord.records.slice());
                    /** @type {?} */
                    var summaries = grid.summaryService.calculateSummaries(groupRecordId, records);
                    /** @type {?} */
                    var summaryRecord = {
                        summaries: summaries,
                        max: maxSummaryHeight
                    };
                    recordsWithSummary.push(summaryRecord);
                }
            }
            if (groupByRecord === null || !grid.isExpandedGroup(groupByRecord)) {
                continue;
            }
            if (summaryPosition === GridSummaryPosition.top) {
                /** @type {?} */
                var records = this.removeDeletedRecord(grid, groupByRecord.records.slice());
                /** @type {?} */
                var summaries = grid.summaryService.calculateSummaries(recordId, records);
                /** @type {?} */
                var summaryRecord = {
                    summaries: summaries,
                    max: maxSummaryHeight
                };
                recordsWithSummary.push(summaryRecord);
            }
            else if (summaryPosition === GridSummaryPosition.bottom) {
                /** @type {?} */
                var lastChild = groupByRecord;
                while (lastChild.groups && lastChild.groups.length > 0 && grid.isExpandedGroup(lastChild)) {
                    lastChild = lastChild.groups[lastChild.groups.length - 1];
                }
                /** @type {?} */
                var lastChildId = void 0;
                if (grid.isExpandedGroup(lastChild)) {
                    lastChildId = this.gridAPI.get_row_id(lastChild.records[lastChild.records.length - 1]);
                }
                else {
                    lastChildId = this.gridAPI.get_groupBy_record_id(lastChild);
                }
                /** @type {?} */
                var groupRecords = lastChildMap.get(lastChildId);
                if (!groupRecords) {
                    groupRecords = [];
                    lastChildMap.set(lastChildId, groupRecords);
                }
                groupRecords.unshift(groupByRecord);
            }
        }
        return recordsWithSummary;
    };
    /**
     * @private
     * @param {?} grid
     * @param {?} data
     * @return {?}
     */
    IgxGridSummaryPipe.prototype.removeDeletedRecord = /**
     * @private
     * @param {?} grid
     * @param {?} data
     * @return {?}
     */
    function (grid, data) {
        if (!grid.transactions.enabled) {
            return data;
        }
        /** @type {?} */
        var deletedRows = grid.transactions.getTransactionLog().filter(function (t) { return t.type === 'delete'; }).map(function (t) { return t.id; });
        deletedRows.forEach(function (rowID) {
            /** @type {?} */
            var tempData = grid.primaryKey ? data.map(function (rec) { return rec[grid.primaryKey]; }) : data;
            /** @type {?} */
            var index = tempData.indexOf(rowID);
            if (index !== -1) {
                data.splice(index, 1);
            }
        });
        return data;
    };
    IgxGridSummaryPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'gridSummary',
                    pure: true
                },] }
    ];
    /** @nocollapse */
    IgxGridSummaryPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };
    return IgxGridSummaryPipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxGridModule = /** @class */ (function () {
    function IgxGridModule() {
    }
    /**
     * @return {?}
     */
    IgxGridModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: IgxGridModule
        };
    };
    IgxGridModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        IgxGridComponent,
                        IgxGridRowComponent,
                        IgxGridGroupByRowComponent,
                        IgxGroupByRowTemplateDirective,
                        IgxGroupAreaDropDirective,
                        IgxGridPreGroupingPipe,
                        IgxGridPostGroupingPipe,
                        IgxGridPagingPipe,
                        IgxGridSortingPipe,
                        IgxGridFilteringPipe,
                        IgxGridSummaryPipe
                    ],
                    exports: [
                        IgxGridComponent,
                        IgxGridGroupByRowComponent,
                        IgxGridRowComponent,
                        IgxGroupByRowTemplateDirective,
                        IgxGroupAreaDropDirective,
                        IgxGridCommonModule,
                        IgxGridPreGroupingPipe,
                        IgxGridPostGroupingPipe,
                        IgxGridPagingPipe,
                        IgxGridSortingPipe,
                        IgxGridFilteringPipe,
                        IgxGridSummaryPipe
                    ],
                    imports: [
                        CommonModule,
                        FormsModule,
                        IgxChipsModule,
                        IgxGridCommonModule
                    ]
                },] }
    ];
    __decorate([
        DeprecateMethod('IgxGridModule.forRoot method is deprecated. Use IgxGridModule instead.'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], IgxGridModule, "forRoot", null);
    return IgxGridModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxTreeGridAPIService = /** @class */ (function (_super) {
    __extends(IgxTreeGridAPIService, _super);
    function IgxTreeGridAPIService() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {?=} transactions
     * @return {?}
     */
    IgxTreeGridAPIService.prototype.get_all_data = /**
     * @param {?=} transactions
     * @return {?}
     */
    function (transactions) {
        /** @type {?} */
        var grid = this.grid;
        /** @type {?} */
        var data = transactions ? grid.dataWithAddedInTransactionRows : grid.flatData;
        return data ? data : [];
    };
    /**
     * @return {?}
     */
    IgxTreeGridAPIService.prototype.get_summary_data = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var grid = this.grid;
        /** @type {?} */
        var data = grid.processedRootRecords.filter(function (row) { return row.isFilteredOutParent === undefined || row.isFilteredOutParent === false; })
            .map(function (rec) { return rec.data; });
        if (grid.transactions.enabled) {
            /** @type {?} */
            var deletedRows = grid.transactions.getTransactionLog().filter(function (t) { return t.type === TransactionType.DELETE; }).map(function (t) { return t.id; });
            deletedRows.forEach(function (rowID) {
                /** @type {?} */
                var tempData = grid.primaryKey ? data.map(function (rec) { return rec[grid.primaryKey]; }) : data;
                /** @type {?} */
                var index = tempData.indexOf(rowID);
                if (index !== -1) {
                    data.splice(index, 1);
                }
            });
        }
        return data;
    };
    /**
     * @param {?} rowID
     * @return {?}
     */
    IgxTreeGridAPIService.prototype.expand_row = /**
     * @param {?} rowID
     * @return {?}
     */
    function (rowID) {
        /** @type {?} */
        var grid = this.grid;
        /** @type {?} */
        var expandedStates = grid.expansionStates;
        expandedStates.set(rowID, true);
        grid.expansionStates = expandedStates;
        if (grid.rowEditable) {
            grid.endEdit(true);
        }
    };
    /**
     * @param {?} rowID
     * @return {?}
     */
    IgxTreeGridAPIService.prototype.collapse_row = /**
     * @param {?} rowID
     * @return {?}
     */
    function (rowID) {
        /** @type {?} */
        var grid = this.grid;
        /** @type {?} */
        var expandedStates = grid.expansionStates;
        expandedStates.set(rowID, false);
        grid.expansionStates = expandedStates;
        if (grid.rowEditable) {
            grid.endEdit(true);
        }
    };
    /**
     * @param {?} rowID
     * @return {?}
     */
    IgxTreeGridAPIService.prototype.toggle_row_expansion = /**
     * @param {?} rowID
     * @return {?}
     */
    function (rowID) {
        /** @type {?} */
        var grid = this.grid;
        /** @type {?} */
        var expandedStates = grid.expansionStates;
        /** @type {?} */
        var treeRecord = grid.records.get(rowID);
        if (treeRecord) {
            /** @type {?} */
            var isExpanded = this.get_row_expansion_state(treeRecord);
            expandedStates.set(rowID, !isExpanded);
            grid.expansionStates = expandedStates;
        }
        if (grid.rowEditable) {
            grid.endEdit(true);
        }
    };
    /**
     * @param {?} row
     * @param {?} expanded
     * @param {?=} event
     * @param {?=} visibleColumnIndex
     * @return {?}
     */
    IgxTreeGridAPIService.prototype.trigger_row_expansion_toggle = /**
     * @param {?} row
     * @param {?} expanded
     * @param {?=} event
     * @param {?=} visibleColumnIndex
     * @return {?}
     */
    function (row, expanded, event, visibleColumnIndex) {
        var _this = this;
        /** @type {?} */
        var grid = this.grid;
        if (row.expanded === expanded ||
            ((!row.children || !row.children.length) && (!grid.loadChildrenOnDemand ||
                (grid.hasChildrenKey && !row.data[grid.hasChildrenKey])))) {
            return;
        }
        /** @type {?} */
        var args = {
            rowID: row.rowID,
            expanded: expanded,
            event: event,
            cancel: false
        };
        grid.onRowToggle.emit(args);
        if (args.cancel) {
            return;
        }
        visibleColumnIndex = visibleColumnIndex ? visibleColumnIndex : 0;
        /** @type {?} */
        var expandedStates = grid.expansionStates;
        expandedStates.set(row.rowID, expanded);
        grid.expansionStates = expandedStates;
        if (grid.rowEditable) {
            grid.endEdit(true);
        }
        requestAnimationFrame(function () {
            /** @type {?} */
            var el = _this.grid.selectionService.activeElement;
            if (el) {
                /** @type {?} */
                var cell = _this.get_cell_by_visible_index(el.row, el.column);
                if (cell) {
                    cell.nativeElement.focus();
                }
            }
        });
    };
    /**
     * @param {?} record
     * @return {?}
     */
    IgxTreeGridAPIService.prototype.expand_path_to_record = /**
     * @param {?} record
     * @return {?}
     */
    function (record) {
        /** @type {?} */
        var grid = this.grid;
        /** @type {?} */
        var expandedStates = grid.expansionStates;
        while (record.parent) {
            record = record.parent;
            /** @type {?} */
            var expanded = this.get_row_expansion_state(record);
            if (!expanded) {
                expandedStates.set(record.rowID, true);
            }
        }
        grid.expansionStates = expandedStates;
        if (grid.rowEditable) {
            grid.endEdit(true);
        }
    };
    /**
     * @param {?} record
     * @return {?}
     */
    IgxTreeGridAPIService.prototype.get_row_expansion_state = /**
     * @param {?} record
     * @return {?}
     */
    function (record) {
        /** @type {?} */
        var grid = this.grid;
        /** @type {?} */
        var states = grid.expansionStates;
        /** @type {?} */
        var expanded = states.get(record.rowID);
        if (expanded !== undefined) {
            return expanded;
        }
        else {
            return record.children && record.children.length && record.level < grid.expansionDepth;
        }
    };
    /**
     * @protected
     * @param {?} value
     * @param {?} rowID
     * @param {?} index
     * @return {?}
     */
    IgxTreeGridAPIService.prototype.update_row_in_array = /**
     * @protected
     * @param {?} value
     * @param {?} rowID
     * @param {?} index
     * @return {?}
     */
    function (value, rowID, index) {
        /** @type {?} */
        var grid = this.grid;
        if (grid.primaryKey && grid.foreignKey) {
            _super.prototype.update_row_in_array.call(this, value, rowID, index);
        }
        else {
            /** @type {?} */
            var record = grid.records.get(rowID);
            /** @type {?} */
            var childData = record.parent ? record.parent.data[grid.childDataKey] : grid.data;
            index = grid.primaryKey ? childData.map(function (c) { return c[grid.primaryKey]; }).indexOf(rowID) :
                childData.indexOf(rowID);
            childData[index] = value;
        }
    };
    /**
     * @param {?} column
     * @return {?}
     */
    IgxTreeGridAPIService.prototype.should_apply_number_style = /**
     * @param {?} column
     * @return {?}
     */
    function (column) {
        return column.dataType === DataType.Number && column.visibleIndex !== 0;
    };
    /**
     * @param {?} rowID
     * @return {?}
     */
    IgxTreeGridAPIService.prototype.deleteRowById = /**
     * @param {?} rowID
     * @return {?}
     */
    function (rowID) {
        /** @type {?} */
        var treeGrid = this.grid;
        /** @type {?} */
        var flatDataWithCascadeOnDeleteAndTransactions = treeGrid.primaryKey &&
            treeGrid.foreignKey &&
            treeGrid.cascadeOnDelete &&
            treeGrid.transactions.enabled;
        if (flatDataWithCascadeOnDeleteAndTransactions) {
            treeGrid.transactions.startPending();
        }
        _super.prototype.deleteRowById.call(this, rowID);
        if (flatDataWithCascadeOnDeleteAndTransactions) {
            treeGrid.transactions.endPending(true);
        }
    };
    /**
     * @param {?} rowID
     * @param {?} index
     * @return {?}
     */
    IgxTreeGridAPIService.prototype.deleteRowFromData = /**
     * @param {?} rowID
     * @param {?} index
     * @return {?}
     */
    function (rowID, index) {
        /** @type {?} */
        var treeGrid = this.grid;
        /** @type {?} */
        var record = treeGrid.records.get(rowID);
        if (treeGrid.primaryKey && treeGrid.foreignKey) {
            index = treeGrid.primaryKey ?
                treeGrid.data.map(function (c) { return c[treeGrid.primaryKey]; }).indexOf(rowID) :
                treeGrid.data.indexOf(rowID);
            _super.prototype.deleteRowFromData.call(this, rowID, index);
            if (treeGrid.cascadeOnDelete) {
                if (record && record.children && record.children.length > 0) {
                    for (var i = 0; i < record.children.length; i++) {
                        /** @type {?} */
                        var child = record.children[i];
                        _super.prototype.deleteRowById.call(this, child.rowID);
                    }
                }
            }
        }
        else {
            /** @type {?} */
            var collection = record.parent ? record.parent.data[treeGrid.childDataKey] : treeGrid.data;
            index = treeGrid.primaryKey ?
                collection.map(function (c) { return c[treeGrid.primaryKey]; }).indexOf(rowID) :
                collection.indexOf(rowID);
            /** @type {?} */
            var selectedChildren = [];
            this.get_selected_children(record, selectedChildren);
            if (selectedChildren.length > 0) {
                treeGrid.deselectRows(selectedChildren);
            }
            if (treeGrid.transactions.enabled) {
                /** @type {?} */
                var path = treeGrid.generateRowPath(rowID);
                treeGrid.transactions.add({
                    id: rowID,
                    type: TransactionType.DELETE,
                    newValue: null,
                    path: path
                }, collection[index]);
            }
            else {
                collection.splice(index, 1);
            }
        }
    };
    /**
     * Updates related row of provided grid's data source with provided new row value
     * @param grid Grid to update data for
     * @param rowID ID of the row to update
     * @param rowValueInDataSource Initial value of the row as it is in data source
     * @param rowCurrentValue Current value of the row as it is with applied previous transactions
     * @param rowNewValue New value of the row
     */
    /**
     * Updates related row of provided grid's data source with provided new row value
     * @protected
     * @param {?} grid Grid to update data for
     * @param {?} rowID ID of the row to update
     * @param {?} rowValueInDataSource Initial value of the row as it is in data source
     * @param {?} rowCurrentValue Current value of the row as it is with applied previous transactions
     * @param {?} rowNewValue New value of the row
     * @return {?}
     */
    IgxTreeGridAPIService.prototype.updateData = /**
     * Updates related row of provided grid's data source with provided new row value
     * @protected
     * @param {?} grid Grid to update data for
     * @param {?} rowID ID of the row to update
     * @param {?} rowValueInDataSource Initial value of the row as it is in data source
     * @param {?} rowCurrentValue Current value of the row as it is with applied previous transactions
     * @param {?} rowNewValue New value of the row
     * @return {?}
     */
    function (grid, rowID, rowValueInDataSource, rowCurrentValue, rowNewValue) {
        if (grid.transactions.enabled) {
            /** @type {?} */
            var path = grid.generateRowPath(rowID);
            /** @type {?} */
            var transaction = {
                id: rowID,
                type: TransactionType.UPDATE,
                newValue: rowNewValue,
                path: path
            };
            grid.transactions.add(transaction, rowCurrentValue);
        }
        else {
            mergeObjects(rowValueInDataSource, rowNewValue);
        }
    };
    /**
     * @param {?} record
     * @param {?} selectedRowIDs
     * @return {?}
     */
    IgxTreeGridAPIService.prototype.get_selected_children = /**
     * @param {?} record
     * @param {?} selectedRowIDs
     * @return {?}
     */
    function (record, selectedRowIDs) {
        var e_1, _a;
        /** @type {?} */
        var grid = this.grid;
        if (!record.children || record.children.length === 0) {
            return;
        }
        try {
            for (var _b = __values(record.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var child = _c.value;
                if (grid.selection.is_item_selected(grid.id, child.rowID)) {
                    selectedRowIDs.push(child.rowID);
                }
                this.get_selected_children(child, selectedRowIDs);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * @param {?} rowID
     * @return {?}
     */
    IgxTreeGridAPIService.prototype.row_deleted_transaction = /**
     * @param {?} rowID
     * @return {?}
     */
    function (rowID) {
        return this.row_deleted_parent(rowID) || _super.prototype.row_deleted_transaction.call(this, rowID);
    };
    /**
     * @private
     * @param {?} rowID
     * @return {?}
     */
    IgxTreeGridAPIService.prototype.row_deleted_parent = /**
     * @private
     * @param {?} rowID
     * @return {?}
     */
    function (rowID) {
        /** @type {?} */
        var grid = this.grid;
        if (!grid) {
            return false;
        }
        if ((grid.cascadeOnDelete && grid.foreignKey) || grid.childDataKey) {
            /** @type {?} */
            var node = grid.records.get(rowID);
            while (node) {
                /** @type {?} */
                var state$$1 = grid.transactions.getState(node.rowID);
                if (state$$1 && state$$1.type === TransactionType.DELETE) {
                    return true;
                }
                node = node.parent;
            }
        }
        return false;
    };
    return IgxTreeGridAPIService;
}(GridBaseAPIService));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxTreeGridNavigationService = /** @class */ (function (_super) {
    __extends(IgxTreeGridNavigationService, _super);
    function IgxTreeGridNavigationService() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @protected
     * @param {?=} visibleIndex
     * @param {?=} isSummary
     * @return {?}
     */
    IgxTreeGridNavigationService.prototype.getCellSelector = /**
     * @protected
     * @param {?=} visibleIndex
     * @param {?=} isSummary
     * @return {?}
     */
    function (visibleIndex, isSummary) {
        if (isSummary === void 0) { isSummary = false; }
        if (isSummary) {
            return 'igx-grid-summary-cell';
        }
        if (visibleIndex === 0) {
            return 'igx-tree-grid-cell';
        }
        return 'igx-grid-cell';
    };
    /**
     * @protected
     * @return {?}
     */
    IgxTreeGridNavigationService.prototype.getRowSelector = /**
     * @protected
     * @return {?}
     */
    function () {
        return 'igx-tree-grid-row';
    };
    return IgxTreeGridNavigationService;
}(IgxGridNavigationService));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxRowLoadingIndicatorTemplateDirective = /** @class */ (function () {
    function IgxRowLoadingIndicatorTemplateDirective(template) {
        this.template = template;
    }
    IgxRowLoadingIndicatorTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxRowLoadingIndicator]'
                },] }
    ];
    /** @nocollapse */
    IgxRowLoadingIndicatorTemplateDirective.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return IgxRowLoadingIndicatorTemplateDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var NEXT_ID$n = 0;
/**
 * **Ignite UI for Angular Tree Grid** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid.html)
 *
 * The Ignite UI Tree Grid displays and manipulates hierarchical data with consistent schema formatted as a table and
 * provides features such as sorting, filtering, editing, column pinning, paging, column moving and hiding.
 *
 * Example:
 * ```html
 * <igx-tree-grid [data]="employeeData" primaryKey="employeeID" foreignKey="PID" autoGenerate="false">
 *   <igx-column field="first" header="First Name"></igx-column>
 *   <igx-column field="last" header="Last Name"></igx-column>
 *   <igx-column field="role" header="Role"></igx-column>
 * </igx-tree-grid>
 * ```
 */
var IgxTreeGridComponent = /** @class */ (function (_super) {
    __extends(IgxTreeGridComponent, _super);
    function IgxTreeGridComponent(selectionService, crudService, colResizingService, gridAPI, selection, _transactions, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions) {
        var _this = _super.call(this, selectionService, crudService, gridAPI, selection, _transactions, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions) || this;
        _this.colResizingService = colResizingService;
        _this._transactions = _transactions;
        _this.document = document;
        _this.overlayService = overlayService;
        _this._displayDensityOptions = _displayDensityOptions;
        _this._id = "igx-tree-grid-" + NEXT_ID$n++;
        /**
         * Returns a map of all `ITreeGridRecord`s.
         * ```typescript
         * // gets the record with primaryKey=2
         * const states = this.grid.records.get(2);
         * ```
         * \@memberof IgxTreeGridComponent
         */
        _this.records = new Map();
        /**
         * Returns a map of all processed (filtered and sorted) `ITreeGridRecord`s.
         * ```typescript
         * // gets the processed record with primaryKey=2
         * const states = this.grid.processedRecords.get(2);
         * ```
         * \@memberof IgxTreeGridComponent
         */
        _this.processedRecords = new Map();
        /**
         * An \@Input property indicating whether child records should be deleted when their parent gets deleted.
         * By default it is set to true and deletes all children along with the parent.
         * ```html
         * <igx-tree-grid [data]="employeeData" [primaryKey]="'employeeID'" [foreignKey]="'parentID'" cascadeOnDelete="false">
         * </igx-tree-grid>
         * ```
         * \@memberof IgxTreeGridComponent
         */
        _this.cascadeOnDelete = true;
        _this._expansionDepth = Infinity;
        _this._expansionStates = new Map();
        /**
         * The custom template, if any, that should be used when rendering the row drag indicator icon
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.dragIndicatorIconTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-grid #grid>
         *      ...
         *      <ng-template igxDragIndicatorIcon>
         *          <igx-icon fontSet="material">info</igx-icon>
         *      </ng-template>
         *  </igx-grid>
         * ```
         */
        _this.dragIndicatorIconTemplate = null;
        /**
         * Emitted when the expanded state of a row gets changed.
         * ```typescript
         * rowToggle(event: IRowToggleEventArgs){
         *  // the id of the row
         *  const rowID = event.rowID;
         *  // the new expansion state
         *  const newExpandedState = event.expanded;
         *  // the original event that triggered onRowToggle
         *  const originalEvent = event.event;
         *  // whether the event should be cancelled
         *  event.cancel = true;
         * }
         * ```
         * ```html
         * <igx-tree-grid [data]="employeeData" (onRowToggle)="rowToggle($event)" [autoGenerate]="true"></igx-tree-grid>
         * ```
         * \@memberof IgxTreeGridComponent
         */
        _this.onRowToggle = new EventEmitter();
        /**
         * @hidden
         */
        _this.loadingRows = new Set();
        _this._filteredData = null;
        _this._gridAPI = (/** @type {?} */ (gridAPI));
        return _this;
    }
    Object.defineProperty(IgxTreeGridComponent.prototype, "id", {
        /**
         * An @Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-tree-grid [id]="'igx-tree-grid-1'"></igx-tree-grid>
         * ```
         * @memberof IgxTreeGridComponent
         */
        get: /**
         * An \@Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-tree-grid [id]="'igx-tree-grid-1'"></igx-tree-grid>
         * ```
         * \@memberof IgxTreeGridComponent
         * @return {?}
         */
        function () {
            return this._id;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._id = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTreeGridComponent.prototype, "data", {
        /**
         * An @Input property that lets you fill the `IgxTreeGridComponent` with an array of data.
         * ```html
         * <igx-tree-grid [data]="Data" [autoGenerate]="true"></igx-tree-grid>
         * ```
         * @memberof IgxTreeGridComponent
         */
        get: /**
         * An \@Input property that lets you fill the `IgxTreeGridComponent` with an array of data.
         * ```html
         * <igx-tree-grid [data]="Data" [autoGenerate]="true"></igx-tree-grid>
         * ```
         * \@memberof IgxTreeGridComponent
         * @return {?}
         */
        function () {
            return this._data;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._data = value;
            this.summaryService.clearSummaryCache();
            if (this.shouldGenerate) {
                this.setupColumns();
                this.reflow();
            }
            this.cdr.markForCheck();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTreeGridComponent.prototype, "filteredData", {
        /**
         * Returns an array of objects containing the filtered data in the `IgxGridComponent`.
         * ```typescript
         * let filteredData = this.grid.filteredData;
         * ```
         * @memberof IgxTreeGridComponent
         */
        get: /**
         * Returns an array of objects containing the filtered data in the `IgxGridComponent`.
         * ```typescript
         * let filteredData = this.grid.filteredData;
         * ```
         * \@memberof IgxTreeGridComponent
         * @return {?}
         */
        function () {
            return this._filteredData;
        },
        /**
         * Sets an array of objects containing the filtered data in the `IgxGridComponent`.
         * ```typescript
         * this.grid.filteredData = [{
         *       ID: 1,
         *       Name: "A"
         * }];
         * ```
         * @memberof IgxTreeGridComponent
         */
        set: /**
         * Sets an array of objects containing the filtered data in the `IgxGridComponent`.
         * ```typescript
         * this.grid.filteredData = [{
         *       ID: 1,
         *       Name: "A"
         * }];
         * ```
         * \@memberof IgxTreeGridComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._filteredData = value;
            if (this.rowSelectable) {
                this.updateHeaderCheckboxStatusOnFilter(this._filteredData);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTreeGridComponent.prototype, "transactions", {
        /**
         * Get transactions service for the grid.
         * @experimental @hidden
         */
        get: /**
         * Get transactions service for the grid.
         * \@experimental \@hidden
         * @return {?}
         */
        function () {
            return this._transactions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTreeGridComponent.prototype, "expansionDepth", {
        /**
         * An @Input property that sets the count of levels to be expanded in the `IgxTreeGridComponent`. By default it is
         * set to `Infinity` which means all levels would be expanded.
         * ```html
         * <igx-tree-grid #grid [data]="employeeData" [childDataKey]="'employees'" expansionDepth="1" [autoGenerate]="true"></igx-tree-grid>
         * ```
         * @memberof IgxTreeGridComponent
         */
        get: /**
         * An \@Input property that sets the count of levels to be expanded in the `IgxTreeGridComponent`. By default it is
         * set to `Infinity` which means all levels would be expanded.
         * ```html
         * <igx-tree-grid #grid [data]="employeeData" [childDataKey]="'employees'" expansionDepth="1" [autoGenerate]="true"></igx-tree-grid>
         * ```
         * \@memberof IgxTreeGridComponent
         * @return {?}
         */
        function () {
            return this._expansionDepth;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._expansionDepth = value;
            this.cdr.markForCheck();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTreeGridComponent.prototype, "expansionStates", {
        /**
         * Returns a list of key-value pairs [row ID, expansion state]. Includes only states that differ from the default one.
         * ```typescript
         * const expansionStates = this.grid.expansionStates;
         * ```
         * @memberof IgxTreeGridComponent
         */
        get: /**
         * Returns a list of key-value pairs [row ID, expansion state]. Includes only states that differ from the default one.
         * ```typescript
         * const expansionStates = this.grid.expansionStates;
         * ```
         * \@memberof IgxTreeGridComponent
         * @return {?}
         */
        function () {
            return this._expansionStates;
        },
        /**
         * Sets a list of key-value pairs [row ID, expansion state].
         * ```typescript
         * const states = new Map<any, boolean>();
         * states.set(1, true);
         * this.grid.expansionStates = states;
         * ```
         * @memberof IgxTreeGridComponent
         */
        set: /**
         * Sets a list of key-value pairs [row ID, expansion state].
         * ```typescript
         * const states = new Map<any, boolean>();
         * states.set(1, true);
         * this.grid.expansionStates = states;
         * ```
         * \@memberof IgxTreeGridComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._expansionStates = this.cloneMap(value);
            this.cdr.detectChanges();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTreeGridComponent.prototype, "rowLoadingIndicatorTemplate", {
        /**
         * An @Input property that provides a template for the row loading indicator when load on demand is enabled.
         * ```html
         * <ng-template #rowLoadingTemplate>
         *     <igx-icon fontSet="material">loop</igx-icon>
         * </ng-template>
         *
         * <igx-tree-grid #grid [data]="employeeData" [primaryKey]="'ID'" [foreignKey]="'parentID'"
         *                [loadChildrenOnDemand]="loadChildren"
         *                [rowLoadingIndicatorTemplate]="rowLoadingTemplate">
         * </igx-tree-grid>
         * ```
         * @memberof IgxTreeGridComponent
         */
        get: /**
         * An \@Input property that provides a template for the row loading indicator when load on demand is enabled.
         * ```html
         * <ng-template #rowLoadingTemplate>
         *     <igx-icon fontSet="material">loop</igx-icon>
         * </ng-template>
         *
         * <igx-tree-grid #grid [data]="employeeData" [primaryKey]="'ID'" [foreignKey]="'parentID'"
         *                [loadChildrenOnDemand]="loadChildren"
         *                [rowLoadingIndicatorTemplate]="rowLoadingTemplate">
         * </igx-tree-grid>
         * ```
         * \@memberof IgxTreeGridComponent
         * @return {?}
         */
        function () {
            return this._rowLoadingIndicatorTemplate;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._rowLoadingIndicatorTemplate = value;
            this.cdr.markForCheck();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTreeGridComponent.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        _super.prototype.ngOnInit.call(this);
        this.onRowToggle.pipe(takeUntil(this.destroy$)).subscribe(function (args) {
            _this.loadChildrenOnRowExpansion(args);
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTreeGridComponent.prototype.ngAfterContentInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (this.rowLoadingTemplate) {
            this._rowLoadingIndicatorTemplate = this.rowLoadingTemplate.template;
        }
        _super.prototype.ngAfterContentInit.call(this);
    };
    /**
     * @private
     * @param {?} args
     * @return {?}
     */
    IgxTreeGridComponent.prototype.loadChildrenOnRowExpansion = /**
     * @private
     * @param {?} args
     * @return {?}
     */
    function (args) {
        var _this = this;
        if (this.loadChildrenOnDemand) {
            /** @type {?} */
            var parentID_1 = args.rowID;
            if (args.expanded && !this._expansionStates.has(parentID_1)) {
                this.loadingRows.add(parentID_1);
                this.loadChildrenOnDemand(parentID_1, function (children) {
                    _this.loadingRows.delete(parentID_1);
                    _this.addChildRows(children, parentID_1);
                    _this.cdr.markForCheck();
                    requestAnimationFrame(function () {
                        /** @type {?} */
                        var cellID = _this.selection.first_item(_this.id + "-cell");
                        if (cellID) {
                            /** @type {?} */
                            var cell = _this._gridAPI.get_cell_by_index(cellID.rowIndex, cellID.columnID);
                            if (cell) {
                                cell.nativeElement.focus();
                            }
                        }
                    });
                });
            }
        }
    };
    /**
     * @private
     * @param {?} children
     * @param {?} parentID
     * @return {?}
     */
    IgxTreeGridComponent.prototype.addChildRows = /**
     * @private
     * @param {?} children
     * @param {?} parentID
     * @return {?}
     */
    function (children, parentID) {
        var _this = this;
        var e_1, _a, _b;
        if (this.primaryKey && this.foreignKey) {
            try {
                for (var children_1 = __values(children), children_1_1 = children_1.next(); !children_1_1.done; children_1_1 = children_1.next()) {
                    var child = children_1_1.value;
                    child[this.foreignKey] = parentID;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (children_1_1 && !children_1_1.done && (_a = children_1.return)) _a.call(children_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            (_b = this.data).push.apply(_b, __spread(children));
        }
        else if (this.childDataKey) {
            /** @type {?} */
            var parent_1 = this.records.get(parentID);
            /** @type {?} */
            var parentData = parent_1.data;
            if (this.transactions.enabled && this.transactions.getAggregatedChanges(true).length) {
                /** @type {?} */
                var path = [];
                while (parent_1) {
                    path.push(parent_1.rowID);
                    parent_1 = parent_1.parent;
                }
                /** @type {?} */
                var collection = this.data;
                /** @type {?} */
                var record = void 0;
                var _loop_1 = function (i) {
                    /** @type {?} */
                    var pid = path[i];
                    record = collection.find(function (r) { return r[_this.primaryKey] === pid; });
                    if (!record) {
                        return "break";
                    }
                    collection = record[this_1.childDataKey];
                };
                var this_1 = this;
                for (var i = path.length - 1; i >= 0; i--) {
                    var state_1 = _loop_1(i);
                    if (state_1 === "break")
                        break;
                }
                if (record) {
                    parentData = record;
                }
            }
            parentData[this.childDataKey] = children;
        }
        this._pipeTrigger++;
    };
    /**
     * @private
     * @param {?} mapIn
     * @return {?}
     */
    IgxTreeGridComponent.prototype.cloneMap = /**
     * @private
     * @param {?} mapIn
     * @return {?}
     */
    function (mapIn) {
        /** @type {?} */
        var mapCloned = new Map();
        mapIn.forEach(function (value, key, mapObj) {
            mapCloned.set(key, value);
        });
        return mapCloned;
    };
    /**
     * Expands the `IgxTreeGridRowComponent` with the specified rowID.
     * @param rowID The identifier of the row to be expanded.
     * ```typescript
     * this.grid.expandRow(2);
     * ```
     * @memberof IgxTreeGridComponent
     */
    /**
     * Expands the `IgxTreeGridRowComponent` with the specified rowID.
     * \@memberof IgxTreeGridComponent
     * @param {?} rowID The identifier of the row to be expanded.
     * ```typescript
     * this.grid.expandRow(2);
     * ```
     * @return {?}
     */
    IgxTreeGridComponent.prototype.expandRow = /**
     * Expands the `IgxTreeGridRowComponent` with the specified rowID.
     * \@memberof IgxTreeGridComponent
     * @param {?} rowID The identifier of the row to be expanded.
     * ```typescript
     * this.grid.expandRow(2);
     * ```
     * @return {?}
     */
    function (rowID) {
        this._gridAPI.expand_row(rowID);
    };
    /**
     * Collapses the `IgxTreeGridRowComponent` with the specified rowID.
     * @param rowID The identifier of the row to be collapsed.
     * ```typescript
     * this.grid.collapseRow(2);
     * ```
     * @memberof IgxTreeGridComponent
     */
    /**
     * Collapses the `IgxTreeGridRowComponent` with the specified rowID.
     * \@memberof IgxTreeGridComponent
     * @param {?} rowID The identifier of the row to be collapsed.
     * ```typescript
     * this.grid.collapseRow(2);
     * ```
     * @return {?}
     */
    IgxTreeGridComponent.prototype.collapseRow = /**
     * Collapses the `IgxTreeGridRowComponent` with the specified rowID.
     * \@memberof IgxTreeGridComponent
     * @param {?} rowID The identifier of the row to be collapsed.
     * ```typescript
     * this.grid.collapseRow(2);
     * ```
     * @return {?}
     */
    function (rowID) {
        this._gridAPI.collapse_row(rowID);
    };
    /**
     * Toggles the expansion state of the `IgxTreeGridRowComponent` with the specified rowID.
     * @param rowID The identifier of the row to be toggled.
     * ```typescript
     * this.grid.toggleRow(2);
     * ```
     * @memberof IgxTreeGridComponent
     */
    /**
     * Toggles the expansion state of the `IgxTreeGridRowComponent` with the specified rowID.
     * \@memberof IgxTreeGridComponent
     * @param {?} rowID The identifier of the row to be toggled.
     * ```typescript
     * this.grid.toggleRow(2);
     * ```
     * @return {?}
     */
    IgxTreeGridComponent.prototype.toggleRow = /**
     * Toggles the expansion state of the `IgxTreeGridRowComponent` with the specified rowID.
     * \@memberof IgxTreeGridComponent
     * @param {?} rowID The identifier of the row to be toggled.
     * ```typescript
     * this.grid.toggleRow(2);
     * ```
     * @return {?}
     */
    function (rowID) {
        this._gridAPI.toggle_row_expansion(rowID);
    };
    /**
     * Expands all rows.
     * ```typescript
     * this.grid.expandAll();
     * ```
     * @memberof IgxTreeGridComponent
     */
    /**
     * Expands all rows.
     * ```typescript
     * this.grid.expandAll();
     * ```
     * \@memberof IgxTreeGridComponent
     * @return {?}
     */
    IgxTreeGridComponent.prototype.expandAll = /**
     * Expands all rows.
     * ```typescript
     * this.grid.expandAll();
     * ```
     * \@memberof IgxTreeGridComponent
     * @return {?}
     */
    function () {
        this._expansionDepth = Infinity;
        this.expansionStates = new Map();
    };
    /**
     * Collapses all rows.
     * ```typescript
     * this.grid.collapseAll();
     * ```
     * @memberof IgxTreeGridComponent
     */
    /**
     * Collapses all rows.
     * ```typescript
     * this.grid.collapseAll();
     * ```
     * \@memberof IgxTreeGridComponent
     * @return {?}
     */
    IgxTreeGridComponent.prototype.collapseAll = /**
     * Collapses all rows.
     * ```typescript
     * this.grid.collapseAll();
     * ```
     * \@memberof IgxTreeGridComponent
     * @return {?}
     */
    function () {
        this._expansionDepth = 0;
        this.expansionStates = new Map();
    };
    /**
     * Creates a new `IgxTreeGridRowComponent` with the given data. If a parentRowID is not specified, the newly created
     * row would be added at the root level. Otherwise, it would be added as a child of the row whose primaryKey matches
     * the specified parentRowID. If the parentRowID does not exist, an error would be thrown.
     * ```typescript
     * const record = {
     *     ID: this.grid.data[this.grid1.data.length - 1].ID + 1,
     *     Name: this.newRecord
     * };
     * this.grid.addRow(record, 1); // Adds a new child row to the row with ID=1.
     * ```
     * @param data
     * @param parentRowID
     * @memberof IgxTreeGridComponent
     */
    /**
     * Creates a new `IgxTreeGridRowComponent` with the given data. If a parentRowID is not specified, the newly created
     * row would be added at the root level. Otherwise, it would be added as a child of the row whose primaryKey matches
     * the specified parentRowID. If the parentRowID does not exist, an error would be thrown.
     * ```typescript
     * const record = {
     *     ID: this.grid.data[this.grid1.data.length - 1].ID + 1,
     *     Name: this.newRecord
     * };
     * this.grid.addRow(record, 1); // Adds a new child row to the row with ID=1.
     * ```
     * \@memberof IgxTreeGridComponent
     * @param {?} data
     * @param {?=} parentRowID
     * @return {?}
     */
    IgxTreeGridComponent.prototype.addRow = /**
     * Creates a new `IgxTreeGridRowComponent` with the given data. If a parentRowID is not specified, the newly created
     * row would be added at the root level. Otherwise, it would be added as a child of the row whose primaryKey matches
     * the specified parentRowID. If the parentRowID does not exist, an error would be thrown.
     * ```typescript
     * const record = {
     *     ID: this.grid.data[this.grid1.data.length - 1].ID + 1,
     *     Name: this.newRecord
     * };
     * this.grid.addRow(record, 1); // Adds a new child row to the row with ID=1.
     * ```
     * \@memberof IgxTreeGridComponent
     * @param {?} data
     * @param {?=} parentRowID
     * @return {?}
     */
    function (data, parentRowID) {
        if (parentRowID) {
            /** @type {?} */
            var parentRecord = this.records.get(parentRowID);
            if (!parentRecord) {
                throw Error('Invalid parent row ID!');
            }
            this.summaryService.clearSummaryCache({ rowID: parentRecord.rowID });
            if (this.primaryKey && this.foreignKey) {
                data[this.foreignKey] = parentRowID;
                _super.prototype.addRow.call(this, data);
            }
            else {
                /** @type {?} */
                var parentData = parentRecord.data;
                /** @type {?} */
                var childKey = this.childDataKey;
                if (this.transactions.enabled) {
                    /** @type {?} */
                    var rowId = this.primaryKey ? data[this.primaryKey] : data;
                    /** @type {?} */
                    var path = [];
                    path.push.apply(path, __spread(this.generateRowPath(parentRowID)));
                    path.push(parentRowID);
                    this.transactions.add((/** @type {?} */ ({
                        id: rowId,
                        path: path,
                        newValue: data,
                        type: TransactionType.ADD
                    })), null);
                }
                else {
                    if (!parentData[childKey]) {
                        parentData[childKey] = [];
                    }
                    parentData[childKey].push(data);
                }
                this.onRowAdded.emit({ data: data });
                this._pipeTrigger++;
                this.cdr.markForCheck();
            }
        }
        else {
            if (this.primaryKey && this.foreignKey) {
                /** @type {?} */
                var rowID = data[this.foreignKey];
                this.summaryService.clearSummaryCache({ rowID: rowID });
            }
            _super.prototype.addRow.call(this, data);
        }
    };
    /** @hidden */
    /**
     * @hidden
     * @param {?} rowId
     * @return {?}
     */
    IgxTreeGridComponent.prototype.deleteRowById = /**
     * @hidden
     * @param {?} rowId
     * @return {?}
     */
    function (rowId) {
        //  if this is flat self-referencing data, and CascadeOnDelete is set to true
        //  and if we have transactions we should start pending transaction. This allows
        //  us in case of delete action to delete all child rows as single undo action
        this._gridAPI.deleteRowById(rowId);
    };
    /** @hidden */
    /**
     * @hidden
     * @param {?} rowId
     * @return {?}
     */
    IgxTreeGridComponent.prototype.generateRowPath = /**
     * @hidden
     * @param {?} rowId
     * @return {?}
     */
    function (rowId) {
        /** @type {?} */
        var path = [];
        /** @type {?} */
        var record = this.records.get(rowId);
        while (record.parent) {
            path.push(record.parent.rowID);
            record = record.parent;
        }
        return path.reverse();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} row
     * @param {?} column
     * @return {?}
     */
    IgxTreeGridComponent.prototype.scrollTo = /**
     * @hidden
     * @protected
     * @param {?} row
     * @param {?} column
     * @return {?}
     */
    function (row, column) {
        var _this = this;
        /** @type {?} */
        var delayScrolling = false;
        /** @type {?} */
        var record;
        if (typeof (row) !== 'number') {
            /** @type {?} */
            var rowData = row;
            /** @type {?} */
            var rowID = this._gridAPI.get_row_id(rowData);
            record = this.processedRecords.get(rowID);
            this._gridAPI.expand_path_to_record(record);
            if (this.paging) {
                /** @type {?} */
                var rowIndex = this.processedExpandedFlatData.indexOf(rowData);
                /** @type {?} */
                var page = Math.floor(rowIndex / this.perPage);
                if (this.page !== page) {
                    delayScrolling = true;
                    this.page = page;
                }
            }
        }
        if (delayScrolling) {
            this.verticalScrollContainer.onDataChanged.pipe(first()).subscribe(function () {
                _this.scrollDirective(_this.verticalScrollContainer, typeof (row) === 'number' ? row : _this.verticalScrollContainer.igxForOf.indexOf(record));
            });
        }
        else {
            this.scrollDirective(this.verticalScrollContainer, typeof (row) === 'number' ? row : this.verticalScrollContainer.igxForOf.indexOf(record));
        }
        this.scrollToHorizontally(column);
    };
    /**
    * @hidden
    */
    /**
     * @hidden
     * @param {?} rowData
     * @param {?} rowIndex
     * @return {?}
     */
    IgxTreeGridComponent.prototype.getContext = /**
     * @hidden
     * @param {?} rowData
     * @param {?} rowIndex
     * @return {?}
     */
    function (rowData, rowIndex) {
        return {
            $implicit: rowData,
            index: rowIndex,
            templateID: this.isSummaryRow(rowData) ? 'summaryRow' : 'dataRow'
        };
    };
    /**
     * @return {?}
     */
    IgxTreeGridComponent.prototype.getSelectedData = /**
     * @return {?}
     */
    function () {
        /** @type {?} */
        var source = [];
        /** @type {?} */
        var process = function (record) {
            if (record.summaries) {
                source.push(null);
                return;
            }
            source.push(record.data);
        };
        this.verticalScrollContainer.igxForOf.forEach(process);
        return this.extractDataFromSelection(source);
    };
    Object.defineProperty(IgxTreeGridComponent.prototype, "template", {
        /**
        * @hidden
        */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            if (this.filteredData && this.filteredData.length === 0) {
                return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyFilteredGridTemplate;
            }
            if (this.isLoading && (!this.data || this.dataLength === 0)) {
                return this.loadingGridTemplate ? this.loadingGridTemplate : this.loadingGridDefaultTemplate;
            }
            if (this.dataLength === 0) {
                return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyGridDefaultTemplate;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @protected
     * @param {?} rowIndex
     * @param {?} value
     * @return {?}
     */
    IgxTreeGridComponent.prototype.writeToData = /**
     * @protected
     * @param {?} rowIndex
     * @param {?} value
     * @return {?}
     */
    function (rowIndex, value) {
        mergeObjects(this.flatData[rowIndex], value);
    };
    /**
     * @hidden
    */
    /**
     * @hidden
     * @protected
     * @param {?} collection
     * @param {?=} cb
     * @return {?}
     */
    IgxTreeGridComponent.prototype.initColumns = /**
     * @hidden
     * @protected
     * @param {?} collection
     * @param {?=} cb
     * @return {?}
     */
    function (collection, cb) {
        if (cb === void 0) { cb = null; }
        if (this.hasColumnLayouts) {
            // invalid configuration - tree grid should not allow column layouts
            // remove column layouts
            /** @type {?} */
            var nonColumnLayoutColumns = this.columnList.filter(function (col) { return !col.columnLayout && !(col.parent && col.parent.columnLayout); });
            this.columnList.reset(nonColumnLayoutColumns);
        }
        _super.prototype.initColumns.call(this, collection, cb);
    };
    IgxTreeGridComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-tree-grid',
                    template: "<igx-grid-toolbar role=\"rowgroup\" [style.width.px]='outerWidth' *ngIf=\"showToolbar\" [gridID]=\"id\" [displayDensity]=\"displayDensity\" #toolbar>\n</igx-grid-toolbar>\n\n<ng-template #defaultPager let-api>\n    <button [disabled]=\"api.isFirstPage\" (click)=\"api.paginate(0)\" igxButton=\"icon\" igxRipple igxRippleCentered=\"true\">\n        <igx-icon fontSet=\"material\">first_page</igx-icon>\n    </button>\n    <button [disabled]=\"api.isFirstPage\" (click)=\"api.previousPage()\" igxButton=\"icon\" igxRipple igxRippleCentered=\"true\">\n        <igx-icon fontSet=\"material\">chevron_left</igx-icon>\n    </button>\n    <span>{{ api.page + 1 }} of {{ api.totalPages }}</span>\n    <button [disabled]=\"api.isLastPage\" (click)=\"api.nextPage()\" igxRipple igxRippleCentered=\"true\" igxButton=\"icon\">\n        <igx-icon fontSet=\"material\">chevron_right</igx-icon>\n    </button>\n        <button [disabled]=\"api.isLastPage\" (click)=\"api.paginate(api.totalPages - 1)\" igxButton=\"icon\" igxRipple igxRippleCentered=\"true\">\n        <igx-icon fontSet=\"material\">last_page</igx-icon>\n    </button>\n    <select style=\"margin-left: 1rem;\" (change)=\"api.perPage = $event.target.value\">\n            <option [value]=\"val\" [selected]=\"api.perPage == val\" *ngFor=\"let val of [5, 10, 15, 25, 50, 100, 500]\">{{ val }}</option>\n    </select>\n</ng-template>\n\n<div class=\"igx-grid__thead\">\n    <div class=\"igx-grid__thead-wrapper\" role=\"rowgroup\" [style.width.px]='calcWidth + 1' #theadRow>\n        <div class=\"igx-grid__tr\" [style.width.px]='calcWidth + 1' role=\"row\">\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"left\" class=\"igx-grid__scroll-on-drag-left\" [style.left.px]=\"featureColumnsWidth\"></span>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"left\" class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n            <ng-container *ngIf=\"rowDraggable\">\n                <div class=\"igx-grid__drag-indicator\" #headerDragContainer>\n                        <div style=\"visibility: hidden;\">\n                                <ng-container *ngTemplateOutlet=\"this.dragIndicatorIconTemplate ? this.dragIndicatorIconTemplate : this.dragIndicatorIconBase\"></ng-container>\n                            </div>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"rowSelectable\">\n                <div class=\"igx-grid__cbx-selection\" #headerCheckboxContainer  [ngClass]=\"{\n                    'igx-grid__cbx-selection--push': filteringService.isFilterRowVisible\n                }\">\n                    <igx-checkbox [checked]=\"allRowsSelected\" (change)=\"onHeaderCheckboxClick($event, filteredData)\" disableRipple=\"true\" [aria-label]=\"headerCheckboxAriaLabel\" #headerCheckbox></igx-checkbox>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"pinnedColumns.length > 0\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width.px]=\"getHeaderGroupWidth(col)\" [style.flex-basis.px]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n            <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\" [igxForScrollOrientation]=\"'horizontal'\" [igxForScrollContainer]=\"parentVirtDir\"\n                [igxForContainerSize]='unpinnedWidth' [igxForTrackBy]='trackColumnChanges' [igxForSizePropName]=\"'calcWidth'\" #headerContainer>\n                <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width.px]=\"getHeaderGroupWidth(col)\" [style.flex-basis.px]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n            </ng-template>\n    </div>\n    <igx-grid-filtering-row #filteringRow *ngIf=\"filteringService.isFilterRowVisible\" [column]=\"filteringService.filteredColumn\"></igx-grid-filtering-row>\n</div>\n    <div class=\"igx-grid__thead-thumb\" [hidden]='!hasVerticalSroll()' [style.width.px]=\"scrollWidth\"></div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n</div>\n\n<div igxGridBody class=\"igx-grid__tbody\">\n    <div class=\"igx-grid__tbody-content\" role=\"rowgroup\" (onDragStop)=\"selectionService.dragMode = $event\" (onDragScroll)=\"dragScroll($event)\" [igxGridDragSelect]=\"selectionService.dragMode\" [style.height.px]='calcHeight' [style.width.px]='calcWidth' #tbody (scroll)='scrollHandler($event)' (wheel)=\"wheelHandler()\">\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"left\" class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"left\" class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n        <ng-template igxGridFor let-rowData [igxGridForOf]=\"data\n        | treeGridTransaction:id:pipeTrigger\n        | treeGridHierarchizing:primaryKey:foreignKey:childDataKey:id:pipeTrigger\n        | treeGridFiltering:filteringExpressionsTree:id:pipeTrigger\n        | treeGridSorting:sortingExpressions:id:pipeTrigger\n        | treeGridFlattening:id:expansionDepth:expansionStates:pipeTrigger\n        | treeGridPaging:page:perPage:id:pipeTrigger\n        | treeGridSummary:hasSummarizedColumns:summaryCalculationMode:summaryPosition:id:pipeTrigger:summaryPipeTrigger\"\n        let-rowIndex=\"index\" [igxForScrollOrientation]=\"'vertical'\"  [igxForScrollContainer]='verticalScroll'\n        [igxForContainerSize]='calcHeight' [igxForItemSize]=\"rowHeight\" #verticalScrollContainer (onChunkPreload)=\"dataLoading($event)\">\n            <ng-template #record_template>\n                <igx-tree-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [treeRow]=\"rowData\" #row>\n                </igx-tree-grid-row>\n            </ng-template>\n            <ng-template #summary_template>\n                <igx-grid-summary-row [gridID]=\"id\" [summaries]=\"rowData.summaries\" [firstCellIndentation]=\"rowData.cellIndentation\" [index]=\"rowIndex\" class=\"igx-grid__summaries--body\" #summaryRow>\n                </igx-grid-summary-row>\n            </ng-template>\n\n            <ng-template [igxTemplateOutlet]='isSummaryRow(rowData) ? summary_template : record_template'\n                [igxTemplateOutletContext]='getContext(rowData, rowIndex)'\n                (onCachedViewLoaded)='cachedViewLoaded($event)'>\n            </ng-template>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"template\"></ng-container>\n        <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div [hidden]='!hasVerticalSroll()' class=\"igx-grid__tbody-scrollbar\" [style.width.px]=\"scrollWidth\" [style.height.px]='calcHeight'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #verticalScrollHolder></ng-template>\n    </div>\n</div>\n\n<div class=\"igx-grid__tfoot\"  [style.width.px]='outerWidth' role=\"rowgroup\" [style.height.px]='summariesHeight' #tfoot>\n    <igx-grid-summary-row [style.width.px]='calcWidth' [style.height.px]='summariesHeight' *ngIf=\"hasSummarizedColumns && rootSummariesEnabled\" [gridID]=\"id\" [summaries]=\"id | igxGridSummaryDataPipe:summaryService.retriggerRootPipe\" [index]=\"0\" class=\"igx-grid__summaries\"  #summaryRow>\n    </igx-grid-summary-row>\n    <div class=\"igx-grid__tfoot-thumb\" [hidden]='!hasVerticalSroll()' [style.height.px]='summariesHeight' [style.width.px]=\"scrollWidth\"></div>\n</div>\n\n<div class=\"igx-grid__scroll\" [style.height]=\"'18px'\" #scr [hidden]=\"unpinnedWidth - totalWidth >= 0\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]='pinnedWidth' [hidden]=\"pinnedWidth === 0\"></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]='unpinnedWidth'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #scrollContainer>\n        </ng-template>\n    </div>\n</div>\n\n<div class=\"igx-paginator igx-grid-paginator\" *ngIf=\"paging && totalRecords\" #paginator>\n    <ng-container *ngTemplateOutlet=\"paginationTemplate ? paginationTemplate : defaultPager; context: { $implicit: this }\">\n    </ng-container>\n</div>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyFilteredGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultLoadingGrid>\n    <div class=\"igx-grid__loading\">\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n</ng-template>\n\n<div *ngIf=\"rowEditable\" igxToggle>\n    <div [className]=\"bannerClass\">\n        <ng-container *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: endEdit.bind(this) }\"></ng-container>\n    </div>\n</div>\n\n<ng-template #defaultRowEditTemplate >\n    <div class=\"igx-banner__message\">\n        <span class=\"igx-banner__text\">You have {{ rowChangesCount }} changes in this row</span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <button igxButton igxRowEditTabStop (click)=\"endEdit(false, $event)\">Cancel</button>\n            <button igxButton igxRowEditTabStop (click)=\"endEdit(true, $event)\">Done</button>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #dragIndicatorIconBase>\n        <igx-icon fontSet=\"material\">drag_indicator</igx-icon>\n    </ng-template>\n\n<igx-grid-column-resizer *ngIf=\"colResizingService.showResizer\"></igx-grid-column-resizer>\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet></div>\n",
                    providers: [
                        IgxGridSelectionService, IgxGridCRUDService, IgxTreeGridNavigationService, IgxGridSummaryService,
                        { provide: GridBaseAPIService, useClass: IgxTreeGridAPIService },
                        { provide: IgxGridBaseComponent, useExisting: forwardRef(function () { return IgxTreeGridComponent; }) }, IgxFilteringService, IgxForOfSyncService
                    ]
                }] }
    ];
    /** @nocollapse */
    IgxTreeGridComponent.ctorParameters = function () { return [
        { type: IgxGridSelectionService },
        { type: IgxGridCRUDService },
        { type: IgxColumnResizingService },
        { type: GridBaseAPIService },
        { type: IgxSelectionAPIService },
        { type: IgxHierarchicalTransactionService, decorators: [{ type: Inject, args: [IgxGridTransaction,] }] },
        { type: ElementRef },
        { type: NgZone },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: ChangeDetectorRef },
        { type: ComponentFactoryResolver },
        { type: IterableDiffers },
        { type: ViewContainerRef },
        { type: IgxTreeGridNavigationService },
        { type: IgxFilteringService },
        { type: IgxOverlayService, decorators: [{ type: Inject, args: [IgxOverlayService,] }] },
        { type: IgxGridSummaryService },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
    ]; };
    IgxTreeGridComponent.propDecorators = {
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        data: [{ type: Input }],
        childDataKey: [{ type: Input }],
        foreignKey: [{ type: Input }],
        hasChildrenKey: [{ type: Input }],
        cascadeOnDelete: [{ type: Input }],
        expansionDepth: [{ type: Input }],
        expansionStates: [{ type: Input }],
        rowLoadingTemplate: [{ type: ContentChild, args: [IgxRowLoadingIndicatorTemplateDirective, { read: IgxRowLoadingIndicatorTemplateDirective },] }],
        dragIndicatorIconTemplate: [{ type: ContentChild, args: [IgxDragIndicatorIconDirective, { read: TemplateRef },] }],
        rowLoadingIndicatorTemplate: [{ type: Input }],
        loadChildrenOnDemand: [{ type: Input }],
        onRowToggle: [{ type: Output }],
        dragIndicatorIconBase: [{ type: ViewChild, args: ['dragIndicatorIconBase', { read: TemplateRef },] }]
    };
    return IgxTreeGridComponent;
}(IgxGridBaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxTreeGridRowComponent = /** @class */ (function (_super) {
    __extends(IgxTreeGridRowComponent, _super);
    function IgxTreeGridRowComponent(gridAPI, crudService, selectionService, selection, element, cdr) {
        var _this = 
        // D.P. constructor duplication due to es6 compilation, might be obsolete in the future
        _super.call(this, gridAPI, crudService, selectionService, selection, element, cdr) || this;
        _this.gridAPI = gridAPI;
        _this.crudService = crudService;
        _this.selectionService = selectionService;
        _this.element = element;
        _this.cdr = cdr;
        return _this;
    }
    Object.defineProperty(IgxTreeGridRowComponent.prototype, "treeRow", {
        /**
         * The `ITreeGridRecord` passed to the row component.
         *
         * ```typescript
         * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;
         * const treeRow = row.treeRow;
         * ```
         */
        get: /**
         * The `ITreeGridRecord` passed to the row component.
         *
         * ```typescript
         * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;
         * const treeRow = row.treeRow;
         * ```
         * @return {?}
         */
        function () {
            return this._treeRow;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._treeRow !== value) {
                this._treeRow = value;
                this.rowData = this._treeRow.data;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTreeGridRowComponent.prototype, "expanded", {
        /**
         * Returns a value indicating whether the row component is expanded.
         *
         * ```typescript
         * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;
         * const expanded = row.expanded;
         * ```
         */
        get: /**
         * Returns a value indicating whether the row component is expanded.
         *
         * ```typescript
         * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;
         * const expanded = row.expanded;
         * ```
         * @return {?}
         */
        function () {
            return this._treeRow.expanded;
        },
        /**
         * Sets a value indicating whether the row component is expanded.
         *
         * ```typescript
         * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;
         * row.expanded = true;
         * ```
         */
        set: /**
         * Sets a value indicating whether the row component is expanded.
         *
         * ```typescript
         * const row = this.grid.getRowByKey(1) as IgxTreeGridRowComponent;
         * row.expanded = true;
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            ((/** @type {?} */ (this.gridAPI))).trigger_row_expansion_toggle(this._treeRow, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTreeGridRowComponent.prototype, "showIndicator", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.grid.loadChildrenOnDemand ?
                this.grid.expansionStates.has(this.rowID) ?
                    this.treeRow.children && this.treeRow.children.length :
                    this.grid.hasChildrenKey ?
                        this.rowData[this.grid.hasChildrenKey] :
                        true :
                this.treeRow.children && this.treeRow.children.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @return {?}
     */
    IgxTreeGridRowComponent.prototype.resolveClasses = /**
     * @hidden
     * @protected
     * @return {?}
     */
    function () {
        /** @type {?} */
        var classes = _super.prototype.resolveClasses.call(this);
        /** @type {?} */
        var filteredClass = this.treeRow.isFilteredOutParent ? 'igx-grid__tr--filtered' : '';
        return classes + " " + filteredClass;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTreeGridRowComponent.prototype.ngDoCheck = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.isLoading = this.grid.loadChildrenOnDemand ? this.grid.loadingRows.has(this.rowID) : false;
        _super.prototype.ngDoCheck.call(this);
    };
    IgxTreeGridRowComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-tree-grid-row',
                    template: "<ng-container *ngIf=\"rowDraggable\">\n    <div [class]=\"resolveDragIndicatorClasses\" [igxRowDrag]=\"this\">\n        <ng-container *ngTemplateOutlet=\"this.grid.dragIndicatorIconTemplate ? this.grid.dragIndicatorIconTemplate : this.grid.dragIndicatorIconBase\"></ng-container>\n    </div>\n</ng-container>\n<ng-container *ngIf=\"rowSelectable\">\n    <div class=\"igx-grid__cbx-selection\">\n        <igx-checkbox [checked]=\"isSelected\" [disabled]=\"deleted\" (change)=\"onCheckboxClick($event)\" disableRipple=\"true\" [disableTransitions]=\"grid.disableTransitions\" [aria-label]=\"rowCheckboxAriaLabel\"></igx-checkbox>\n    </div>\n</ng-container>\n<ng-container *ngIf=\"pinnedColumns.length > 0\">\n    <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxNotGrouped\">\n        <ng-template #cellTemplate>\n            <igx-grid-cell\n                class=\"igx-grid__td igx-grid__td--fw igx-grid__td--pinned\"\n                [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n                [ngClass]=\"col.cellClasses | igxCellStyles:rowData[col.field]:rowData:col.field\"\n                [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n                [column]=\"col\"\n                [formatter]=\"col.formatter\"\n                [row]=\"this\"\n                [lastPinned]=\"col.isLastPinned\"\n                [style.min-height.px]=\"grid.rowHeight || 32\"\n                [rowData]=\"rowData\"\n                [style.min-width.px]=\"col.width\"\n                [style.flex-basis.px]=\"col.width\"\n                [width]=\"col.getCellWidth()\"\n                [visibleColumnIndex]=\"col.visibleIndex\"\n                [value]=\"rowData[col.field]\"\n                [cellTemplate]=\"col.bodyTemplate\" #treeCell>\n            </igx-grid-cell>\n            </ng-template>\n        <ng-template #treeCellTemplate>\n            <igx-tree-grid-cell\n                class=\"igx-grid__td igx-grid__td--fw igx-grid__td--tree-cell igx-grid__td--pinned\"\n                [class.igx-grid__td--number]=\"col.dataType === 'number' && col.visibleIndex !== 0\"\n                [ngClass]=\"col.cellClasses | igxCellStyles:rowData[col.field]:rowData:col.field\"\n                [level]=\"treeRow.level\"\n                [expanded]=\"treeRow.expanded\"\n                [showIndicator]=\"showIndicator\"\n                [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n                [column]=\"col\"\n                [formatter]=\"col.formatter\"\n                [row]=\"this\"\n                [lastPinned]=\"col.isLastPinned\"\n                [style.min-height.px]=\"grid.rowHeight || 32\"\n                [rowData]=\"rowData\"\n                [style.min-width.px]=\"col.width\"\n                [style.flex-basis.px]=\"col.width\"\n                [width]=\"col.getCellWidth()\"\n                [visibleColumnIndex]=\"col.visibleIndex\"\n                [value]=\"rowData[col.field]\"\n                [isLoading]=\"isLoading\"\n                [cellTemplate]=\"col.bodyTemplate\" #treeCell>\n            </igx-tree-grid-cell>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 ? treeCellTemplate : cellTemplate\"></ng-container>\n    </ng-template>\n</ng-container>\n<ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\" [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth' [igxForSizePropName]=\"'calcWidth'\" [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n    <ng-template #cellTemplate>\n        <igx-grid-cell\n            class=\"igx-grid__td igx-grid__td--fw\"\n            [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n            [ngClass]=\"col.cellClasses | igxCellStyles:rowData[col.field]:rowData:col.field\"\n            [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n            [column]=\"col\"\n            [formatter]=\"col.formatter\"\n            [row]=\"this\"\n            [style.min-height.px]=\"grid.rowHeight || 32\"\n            [rowData]=\"rowData\"\n            [style.min-width.px]=\"col.width\"\n            [style.flex-basis.px]=\"col.width\"\n            [width]=\"col.getCellWidth()\"\n            [visibleColumnIndex]=\"col.visibleIndex\"\n            [value]=\"rowData[col.field]\"\n            [cellTemplate]=\"col.bodyTemplate\" #treeCell>\n        </igx-grid-cell>\n    </ng-template>\n    <ng-template #treeCellTemplate>\n        <igx-tree-grid-cell\n            class=\"igx-grid__td igx-grid__td--fw igx-grid__td--tree-cell\"\n            [class.igx-grid__td--number]=\"col.dataType === 'number' && col.visibleIndex !== 0\"\n            [ngClass]=\"col.cellClasses | igxCellStyles:rowData[col.field]:rowData:col.field\"\n            [level]=\"treeRow.level\"\n            [expanded]=\"treeRow.expanded\"\n            [showIndicator]=\"showIndicator\"\n            [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n            [column]=\"col\"\n            [formatter]=\"col.formatter\"\n            [row]=\"this\"\n            [style.min-height.px]=\"grid.rowHeight || 32\"\n            [rowData]=\"rowData\"\n            [style.min-width.px]=\"col.width\"\n            [style.flex-basis.px]=\"col.width\"\n            [width]=\"col.getCellWidth()\"\n            [visibleColumnIndex]=\"col.visibleIndex\"\n            [value]=\"rowData[col.field]\"\n            [isLoading]=\"isLoading\"\n            [cellTemplate]=\"col.bodyTemplate\" #treeCell>\n        </igx-tree-grid-cell>\n    </ng-template>\n    <ng-container *ngTemplateOutlet=\"col.visibleIndex === 0 ? treeCellTemplate : cellTemplate\"></ng-container>\n</ng-template>\n",
                    providers: [{ provide: IgxRowComponent, useExisting: forwardRef(function () { return IgxTreeGridRowComponent; }) }]
                }] }
    ];
    /** @nocollapse */
    IgxTreeGridRowComponent.ctorParameters = function () { return [
        { type: GridBaseAPIService },
        { type: IgxGridCRUDService },
        { type: IgxGridSelectionService },
        { type: IgxSelectionAPIService },
        { type: ElementRef },
        { type: ChangeDetectorRef }
    ]; };
    IgxTreeGridRowComponent.propDecorators = {
        cells: [{ type: ViewChildren, args: ['treeCell',] }],
        treeRow: [{ type: Input }],
        expanded: [{ type: HostBinding, args: ['attr.aria-expanded',] }]
    };
    return IgxTreeGridRowComponent;
}(IgxRowComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxTreeGridHierarchizingPipe = /** @class */ (function () {
    function IgxTreeGridHierarchizingPipe(gridAPI) {
        this.gridAPI = (/** @type {?} */ (gridAPI));
    }
    /**
     * @param {?} collection
     * @param {?} primaryKey
     * @param {?} foreignKey
     * @param {?} childDataKey
     * @param {?} id
     * @param {?} pipeTrigger
     * @return {?}
     */
    IgxTreeGridHierarchizingPipe.prototype.transform = /**
     * @param {?} collection
     * @param {?} primaryKey
     * @param {?} foreignKey
     * @param {?} childDataKey
     * @param {?} id
     * @param {?} pipeTrigger
     * @return {?}
     */
    function (collection, primaryKey, foreignKey, childDataKey, id, pipeTrigger) {
        /** @type {?} */
        var grid = this.gridAPI.grid;
        /** @type {?} */
        var hierarchicalRecords = [];
        /** @type {?} */
        var treeGridRecordsMap = new Map();
        /** @type {?} */
        var flatData = [];
        if (primaryKey && foreignKey) {
            hierarchicalRecords = this.hierarchizeFlatData(id, collection, primaryKey, foreignKey, treeGridRecordsMap, flatData);
        }
        else if (childDataKey) {
            hierarchicalRecords = this.hierarchizeRecursive(id, collection, primaryKey, childDataKey, undefined, flatData, 0, treeGridRecordsMap);
        }
        grid.flatData = flatData;
        grid.records = treeGridRecordsMap;
        grid.rootRecords = hierarchicalRecords;
        return hierarchicalRecords;
    };
    /**
     * @private
     * @param {?} primaryKey
     * @param {?} rowData
     * @return {?}
     */
    IgxTreeGridHierarchizingPipe.prototype.getRowID = /**
     * @private
     * @param {?} primaryKey
     * @param {?} rowData
     * @return {?}
     */
    function (primaryKey, rowData) {
        return primaryKey ? rowData[primaryKey] : rowData;
    };
    /**
     * @private
     * @param {?} id
     * @param {?} collection
     * @param {?} primaryKey
     * @param {?} foreignKey
     * @param {?} map
     * @param {?} flatData
     * @return {?}
     */
    IgxTreeGridHierarchizingPipe.prototype.hierarchizeFlatData = /**
     * @private
     * @param {?} id
     * @param {?} collection
     * @param {?} primaryKey
     * @param {?} foreignKey
     * @param {?} map
     * @param {?} flatData
     * @return {?}
     */
    function (id, collection, primaryKey, foreignKey, map$$1, flatData) {
        var _this = this;
        /** @type {?} */
        var result = [];
        /** @type {?} */
        var missingParentRecords = [];
        collection.forEach(function (row) {
            /** @type {?} */
            var record = {
                rowID: _this.getRowID(primaryKey, row),
                data: row,
                children: []
            };
            /** @type {?} */
            var parent = map$$1.get(row[foreignKey]);
            if (parent) {
                record.parent = parent;
                parent.children.push(record);
            }
            else {
                missingParentRecords.push(record);
            }
            map$$1.set(row[primaryKey], record);
        });
        missingParentRecords.forEach(function (record) {
            /** @type {?} */
            var parent = map$$1.get(record.data[foreignKey]);
            if (parent) {
                record.parent = parent;
                parent.children.push(record);
            }
            else {
                result.push(record);
            }
        });
        this.setIndentationLevels(id, result, 0, flatData);
        return result;
    };
    /**
     * @private
     * @param {?} id
     * @param {?} collection
     * @param {?} indentationLevel
     * @param {?} flatData
     * @return {?}
     */
    IgxTreeGridHierarchizingPipe.prototype.setIndentationLevels = /**
     * @private
     * @param {?} id
     * @param {?} collection
     * @param {?} indentationLevel
     * @param {?} flatData
     * @return {?}
     */
    function (id, collection, indentationLevel, flatData) {
        for (var i = 0; i < collection.length; i++) {
            /** @type {?} */
            var record = collection[i];
            record.level = indentationLevel;
            record.expanded = this.gridAPI.get_row_expansion_state(record);
            flatData.push(record.data);
            if (record.children && record.children.length > 0) {
                this.setIndentationLevels(id, record.children, indentationLevel + 1, flatData);
            }
        }
    };
    /**
     * @private
     * @param {?} id
     * @param {?} collection
     * @param {?} primaryKey
     * @param {?} childDataKey
     * @param {?} parent
     * @param {?} flatData
     * @param {?} indentationLevel
     * @param {?} map
     * @return {?}
     */
    IgxTreeGridHierarchizingPipe.prototype.hierarchizeRecursive = /**
     * @private
     * @param {?} id
     * @param {?} collection
     * @param {?} primaryKey
     * @param {?} childDataKey
     * @param {?} parent
     * @param {?} flatData
     * @param {?} indentationLevel
     * @param {?} map
     * @return {?}
     */
    function (id, collection, primaryKey, childDataKey, parent, flatData, indentationLevel, map$$1) {
        /** @type {?} */
        var result = [];
        for (var i = 0; i < collection.length; i++) {
            /** @type {?} */
            var item = collection[i];
            /** @type {?} */
            var record = {
                rowID: this.getRowID(primaryKey, item),
                data: item,
                parent: parent,
                level: indentationLevel
            };
            record.expanded = this.gridAPI.get_row_expansion_state(record);
            flatData.push(item);
            map$$1.set(record.rowID, record);
            record.children = item[childDataKey] ?
                this.hierarchizeRecursive(id, item[childDataKey], primaryKey, childDataKey, record, flatData, indentationLevel + 1, map$$1) :
                undefined;
            result.push(record);
        }
        return result;
    };
    IgxTreeGridHierarchizingPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'treeGridHierarchizing',
                    pure: true
                },] }
    ];
    /** @nocollapse */
    IgxTreeGridHierarchizingPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };
    return IgxTreeGridHierarchizingPipe;
}());
/**
 * @hidden
 */
var IgxTreeGridFlatteningPipe = /** @class */ (function () {
    function IgxTreeGridFlatteningPipe(gridAPI) {
        this.gridAPI = (/** @type {?} */ (gridAPI));
    }
    /**
     * @param {?} collection
     * @param {?} id
     * @param {?} expandedLevels
     * @param {?} expandedStates
     * @param {?} pipeTrigger
     * @return {?}
     */
    IgxTreeGridFlatteningPipe.prototype.transform = /**
     * @param {?} collection
     * @param {?} id
     * @param {?} expandedLevels
     * @param {?} expandedStates
     * @param {?} pipeTrigger
     * @return {?}
     */
    function (collection, id, expandedLevels, expandedStates, pipeTrigger) {
        /** @type {?} */
        var grid = this.gridAPI.grid;
        /** @type {?} */
        var data = [];
        grid.processedRootRecords = collection;
        grid.processedRecords = new Map();
        this.getFlatDataRecursive(collection, data, expandedLevels, expandedStates, id, true);
        grid.processedExpandedFlatData = data.map(function (r) { return r.data; });
        return data;
    };
    /**
     * @private
     * @param {?} collection
     * @param {?} data
     * @param {?} expandedLevels
     * @param {?} expandedStates
     * @param {?} gridID
     * @param {?} parentExpanded
     * @return {?}
     */
    IgxTreeGridFlatteningPipe.prototype.getFlatDataRecursive = /**
     * @private
     * @param {?} collection
     * @param {?} data
     * @param {?} expandedLevels
     * @param {?} expandedStates
     * @param {?} gridID
     * @param {?} parentExpanded
     * @return {?}
     */
    function (collection, data, expandedLevels, expandedStates, gridID, parentExpanded) {
        if (!collection || !collection.length) {
            return;
        }
        /** @type {?} */
        var grid = this.gridAPI.grid;
        for (var i = 0; i < collection.length; i++) {
            /** @type {?} */
            var hierarchicalRecord = collection[i];
            if (parentExpanded) {
                data.push(hierarchicalRecord);
            }
            hierarchicalRecord.expanded = this.gridAPI.get_row_expansion_state(hierarchicalRecord);
            this.updateNonProcessedRecordExpansion(grid, hierarchicalRecord);
            grid.processedRecords.set(hierarchicalRecord.rowID, hierarchicalRecord);
            this.getFlatDataRecursive(hierarchicalRecord.children, data, expandedLevels, expandedStates, gridID, parentExpanded && hierarchicalRecord.expanded);
        }
    };
    /**
     * @private
     * @param {?} grid
     * @param {?} record
     * @return {?}
     */
    IgxTreeGridFlatteningPipe.prototype.updateNonProcessedRecordExpansion = /**
     * @private
     * @param {?} grid
     * @param {?} record
     * @return {?}
     */
    function (grid, record) {
        /** @type {?} */
        var rec = grid.records.get(record.rowID);
        rec.expanded = record.expanded;
    };
    IgxTreeGridFlatteningPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'treeGridFlattening',
                    pure: true
                },] }
    ];
    /** @nocollapse */
    IgxTreeGridFlatteningPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };
    return IgxTreeGridFlatteningPipe;
}());
/**
 * @hidden
 */
var IgxTreeGridSortingPipe = /** @class */ (function () {
    function IgxTreeGridSortingPipe(gridAPI) {
        this.gridAPI = (/** @type {?} */ (gridAPI));
    }
    /**
     * @param {?} hierarchicalData
     * @param {?} expressions
     * @param {?} id
     * @param {?} pipeTrigger
     * @return {?}
     */
    IgxTreeGridSortingPipe.prototype.transform = /**
     * @param {?} hierarchicalData
     * @param {?} expressions
     * @param {?} id
     * @param {?} pipeTrigger
     * @return {?}
     */
    function (hierarchicalData, expressions, id, pipeTrigger) {
        /** @type {?} */
        var grid = this.gridAPI.grid;
        /** @type {?} */
        var result;
        if (!expressions.length) {
            result = hierarchicalData;
        }
        else {
            result = DataUtil.treeGridSort(hierarchicalData, expressions);
        }
        /** @type {?} */
        var filteredSortedData = [];
        this.flattenTreeGridRecords(result, filteredSortedData);
        grid.filteredSortedData = filteredSortedData;
        return result;
    };
    /**
     * @private
     * @param {?} records
     * @param {?} flatData
     * @return {?}
     */
    IgxTreeGridSortingPipe.prototype.flattenTreeGridRecords = /**
     * @private
     * @param {?} records
     * @param {?} flatData
     * @return {?}
     */
    function (records, flatData) {
        var e_1, _a;
        if (records && records.length) {
            try {
                for (var records_1 = __values(records), records_1_1 = records_1.next(); !records_1_1.done; records_1_1 = records_1.next()) {
                    var record = records_1_1.value;
                    flatData.push(record.data);
                    this.flattenTreeGridRecords(record.children, flatData);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (records_1_1 && !records_1_1.done && (_a = records_1.return)) _a.call(records_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
    };
    IgxTreeGridSortingPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'treeGridSorting',
                    pure: true
                },] }
    ];
    /** @nocollapse */
    IgxTreeGridSortingPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };
    return IgxTreeGridSortingPipe;
}());
/**
 * @hidden
 */
var IgxTreeGridPagingPipe = /** @class */ (function () {
    function IgxTreeGridPagingPipe(gridAPI) {
        this.gridAPI = (/** @type {?} */ (gridAPI));
    }
    /**
     * @param {?} collection
     * @param {?=} page
     * @param {?=} perPage
     * @param {?=} id
     * @param {?=} pipeTrigger
     * @return {?}
     */
    IgxTreeGridPagingPipe.prototype.transform = /**
     * @param {?} collection
     * @param {?=} page
     * @param {?=} perPage
     * @param {?=} id
     * @param {?=} pipeTrigger
     * @return {?}
     */
    function (collection, page, perPage, id, pipeTrigger) {
        if (page === void 0) { page = 0; }
        if (perPage === void 0) { perPage = 15; }
        /** @type {?} */
        var grid = this.gridAPI.grid;
        if (!grid.paging) {
            return collection;
        }
        /** @type {?} */
        var len = collection.length;
        /** @type {?} */
        var totalPages = Math.ceil(len / perPage);
        /** @type {?} */
        var state$$1 = {
            index: (totalPages > 0 && page >= totalPages) ? totalPages - 1 : page,
            recordsPerPage: perPage
        };
        /** @type {?} */
        var result = DataUtil.page(cloneArray(collection), state$$1);
        grid.pagingState = state$$1;
        ((/** @type {?} */ (grid)))._page = state$$1.index;
        return result;
    };
    IgxTreeGridPagingPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'treeGridPaging',
                    pure: true
                },] }
    ];
    /** @nocollapse */
    IgxTreeGridPagingPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };
    return IgxTreeGridPagingPipe;
}());
/**
 * @hidden
 */
var IgxTreeGridTransactionPipe = /** @class */ (function () {
    function IgxTreeGridTransactionPipe(gridAPI) {
        this.gridAPI = (/** @type {?} */ (gridAPI));
    }
    /**
     * @param {?} collection
     * @param {?} id
     * @param {?} pipeTrigger
     * @return {?}
     */
    IgxTreeGridTransactionPipe.prototype.transform = /**
     * @param {?} collection
     * @param {?} id
     * @param {?} pipeTrigger
     * @return {?}
     */
    function (collection, id, pipeTrigger) {
        /** @type {?} */
        var grid = this.gridAPI.grid;
        if (collection && grid.transactions.enabled) {
            /** @type {?} */
            var aggregatedChanges = grid.transactions.getAggregatedChanges(true);
            if (aggregatedChanges.length > 0) {
                /** @type {?} */
                var primaryKey = grid.primaryKey;
                if (!primaryKey) {
                    return collection;
                }
                /** @type {?} */
                var foreignKey = grid.foreignKey;
                /** @type {?} */
                var childDataKey = grid.childDataKey;
                if (foreignKey) {
                    /** @type {?} */
                    var flatDataClone = cloneArray(collection);
                    return DataUtil.mergeTransactions(flatDataClone, aggregatedChanges, grid.primaryKey);
                }
                else if (childDataKey) {
                    /** @type {?} */
                    var hierarchicalDataClone = cloneHierarchicalArray(collection, childDataKey);
                    return DataUtil.mergeHierarchicalTransactions(hierarchicalDataClone, aggregatedChanges, childDataKey, grid.primaryKey);
                }
            }
        }
        return collection;
    };
    IgxTreeGridTransactionPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'treeGridTransaction',
                    pure: true
                },] }
    ];
    /** @nocollapse */
    IgxTreeGridTransactionPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };
    return IgxTreeGridTransactionPipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxTreeGridCellComponent = /** @class */ (function (_super) {
    __extends(IgxTreeGridCellComponent, _super);
    function IgxTreeGridCellComponent(selectionService, crudService, gridAPI, selection, cdr, element, zone, document) {
        var _this = _super.call(this, selectionService, crudService, gridAPI, selection, cdr, element, zone) || this;
        _this.zone = zone;
        _this.document = document;
        /**
         * @hidden
         */
        _this.expanded = false;
        /**
         * @hidden
         */
        _this.level = 0;
        /**
         * @hidden
         */
        _this.showIndicator = false;
        _this.treeGridAPI = (/** @type {?} */ (gridAPI));
        return _this;
    }
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTreeGridCellComponent.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxTreeGridCellComponent.prototype.toggle = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.stopPropagation();
        this.treeGridAPI.trigger_row_expansion_toggle(this.row.treeRow, !this.row.expanded, event, this.visibleColumnIndex);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTreeGridCellComponent.prototype.onIndicatorFocus = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.gridAPI.submit_value();
        this.nativeElement.focus();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxTreeGridCellComponent.prototype.onLoadingDblClick = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.stopPropagation();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} range
     * @return {?}
     */
    IgxTreeGridCellComponent.prototype.calculateSizeToFit = /**
     * @hidden
     * @param {?} range
     * @return {?}
     */
    function (range) {
        /** @type {?} */
        var indicatorWidth = this.indicator.nativeElement.getBoundingClientRect().width;
        /** @type {?} */
        var indicatorStyle = this.document.defaultView.getComputedStyle(this.indicator.nativeElement);
        /** @type {?} */
        var indicatorMargin = parseFloat(indicatorStyle.marginRight);
        /** @type {?} */
        var leftPadding = 0;
        if (this.indentationDiv) {
            /** @type {?} */
            var indentationStyle = this.document.defaultView.getComputedStyle(this.indentationDiv.nativeElement);
            leftPadding = parseFloat(indentationStyle.paddingLeft);
        }
        /** @type {?} */
        var largestWidth = Math.max.apply(Math, __spread(Array.from(this.nativeElement.children)
            .map(function (child) { return getNodeSizeViaRange(range, child); })));
        return largestWidth + indicatorWidth + indicatorMargin + leftPadding;
    };
    IgxTreeGridCellComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'igx-tree-grid-cell',
                    template: "<ng-template #defaultCell>\n    <div igxTextHighlight [cssClass]=\"highlightClass\" [activeCssClass]=\"activeHighlightClass\" [groupName]=\"gridID\"\n        [value]=\"formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal: grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value\"\n        [row]=\"rowData\" [column]=\"this.column.field\" [containerClass]=\"'igx-grid__td-text'\"\n        class=\"igx-grid__td-text\">{{ formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal:\n        grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value }}</div>\n</ng-template>\n<ng-template #inlineEditor  let-cell=\"cell\">\n    <ng-container *ngIf=\"column.dataType === 'string'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [(ngModel)]=\"editValue\" [igxFocus]=\"focused\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'number'\"> \n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [(ngModel)]=\"editValue\" [igxFocus]=\"focused\"  type=\"number\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'boolean'\">\n        <igx-checkbox (change)=\"editValue = $event.checked\" [value]=\"editValue\" [checked]=\"editValue\" [disableRipple]=\"true\"></igx-checkbox>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'date'\">\n        <igx-date-picker [style.width.%]=\"100\" [outlet]=\"grid.outletDirective\" mode=\"dropdown\" (onSelection)=\"editValue = $event\"\n        [locale]=\"grid.locale\" [value]=\"editValue\" [igxFocus]=\"focused\" [labelVisibility]=\"false\">\n    </igx-date-picker>\n    </ng-container>\n</ng-template>\n<ng-container *ngIf=\"!inEditMode\">\n    <ng-container *ngIf=\"level > 0\">\n        <div #indentationDiv class=\"igx-grid__tree-cell--padding-level-{{level}}\"></div>\n    </ng-container>\n    <div #indicator\n         *ngIf=\"!isLoading\"\n         class=\"igx-grid__tree-grouping-indicator\"\n         [ngStyle]=\"{'visibility': showIndicator ? 'visible' : 'hidden'}\"\n         (click)=\"toggle($event)\" (focus)=\"onIndicatorFocus()\" tabindex=\"-1\">\n        <igx-icon *ngIf=\"!expanded\" fontSet=\"material\">expand_more</igx-icon>\n        <igx-icon *ngIf=\"expanded\" fontSet=\"material\">expand_less</igx-icon>\n    </div>\n    <div *ngIf=\"isLoading\"\n         (dblclick)=\"onLoadingDblClick($event)\"\n         class=\"igx-grid__tree-loading-indicator\">\n        <ng-container *ngTemplateOutlet=\"grid.rowLoadingIndicatorTemplate ? grid.rowLoadingIndicatorTemplate : defaultLoadingIndicatorTemplate\">\n        </ng-container>\n    </div>\n    <ng-template #defaultLoadingIndicatorTemplate>\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </ng-template>\n</ng-container>\n<ng-container *ngTemplateOutlet=\"template; context: context\">\n</ng-container>\n"
                }] }
    ];
    /** @nocollapse */
    IgxTreeGridCellComponent.ctorParameters = function () { return [
        { type: IgxGridSelectionService },
        { type: IgxGridCRUDService },
        { type: GridBaseAPIService },
        { type: IgxSelectionAPIService },
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
    ]; };
    IgxTreeGridCellComponent.propDecorators = {
        expanded: [{ type: Input }],
        level: [{ type: Input }],
        showIndicator: [{ type: Input }],
        indicator: [{ type: ViewChild, args: ['indicator', { read: ElementRef },] }],
        indentationDiv: [{ type: ViewChild, args: ['indentationDiv', { read: ElementRef },] }],
        defaultContentElement: [{ type: ViewChild, args: ['defaultContentElement', { read: ElementRef },] }],
        isLoading: [{ type: Input }]
    };
    return IgxTreeGridCellComponent;
}(IgxGridCellComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxTreeGridSummaryPipe = /** @class */ (function () {
    function IgxTreeGridSummaryPipe(gridAPI) {
        this.gridAPI = (/** @type {?} */ (gridAPI));
    }
    /**
     * @param {?} flatData
     * @param {?} hasSummary
     * @param {?} summaryCalculationMode
     * @param {?} summaryPosition
     * @param {?} id
     * @param {?} pipeTrigger
     * @param {?} summaryPipeTrigger
     * @return {?}
     */
    IgxTreeGridSummaryPipe.prototype.transform = /**
     * @param {?} flatData
     * @param {?} hasSummary
     * @param {?} summaryCalculationMode
     * @param {?} summaryPosition
     * @param {?} id
     * @param {?} pipeTrigger
     * @param {?} summaryPipeTrigger
     * @return {?}
     */
    function (flatData, hasSummary, summaryCalculationMode, summaryPosition, id, pipeTrigger, summaryPipeTrigger) {
        /** @type {?} */
        var grid = this.gridAPI.grid;
        if (!flatData || !hasSummary || summaryCalculationMode === GridSummaryCalculationMode.rootLevelOnly) {
            return flatData;
        }
        return this.addSummaryRows(grid, flatData, summaryPosition);
    };
    /**
     * @private
     * @param {?} grid
     * @param {?} collection
     * @param {?} summaryPosition
     * @return {?}
     */
    IgxTreeGridSummaryPipe.prototype.addSummaryRows = /**
     * @private
     * @param {?} grid
     * @param {?} collection
     * @param {?} summaryPosition
     * @return {?}
     */
    function (grid, collection, summaryPosition) {
        /** @type {?} */
        var recordsWithSummary = [];
        /** @type {?} */
        var maxSummaryHeight = grid.summaryService.calcMaxSummaryHeight();
        for (var i = 0; i < collection.length; i++) {
            /** @type {?} */
            var record = collection[i];
            recordsWithSummary.push(record);
            /** @type {?} */
            var isExpanded = record.children && record.children.length > 0 && record.expanded;
            if (summaryPosition === GridSummaryPosition.bottom && !isExpanded) {
                /** @type {?} */
                var childRecord = record;
                /** @type {?} */
                var parent_1 = record.parent;
                while (parent_1) {
                    /** @type {?} */
                    var children = parent_1.children;
                    if (children[children.length - 1] === childRecord) {
                        /** @type {?} */
                        var childData = children.filter(function (r) { return !r.isFilteredOutParent; }).map(function (r) { return r.data; });
                        childData = this.removeDeletedRecord(grid, parent_1.rowID, childData);
                        /** @type {?} */
                        var summaries = grid.summaryService.calculateSummaries(parent_1.rowID, childData);
                        /** @type {?} */
                        var summaryRecord = {
                            summaries: summaries,
                            max: maxSummaryHeight,
                            cellIndentation: parent_1.level + 1
                        };
                        recordsWithSummary.push(summaryRecord);
                        childRecord = parent_1;
                        parent_1 = childRecord.parent;
                    }
                    else {
                        break;
                    }
                }
            }
            else if (summaryPosition === GridSummaryPosition.top && isExpanded) {
                /** @type {?} */
                var childData = record.children.filter(function (r) { return !r.isFilteredOutParent; }).map(function (r) { return r.data; });
                childData = this.removeDeletedRecord(grid, record.rowID, childData);
                /** @type {?} */
                var summaries = grid.summaryService.calculateSummaries(record.rowID, childData);
                /** @type {?} */
                var summaryRecord = {
                    summaries: summaries,
                    max: maxSummaryHeight,
                    cellIndentation: record.level + 1
                };
                recordsWithSummary.push(summaryRecord);
            }
        }
        return recordsWithSummary;
    };
    /**
     * @private
     * @param {?} grid
     * @param {?} rowId
     * @param {?} data
     * @return {?}
     */
    IgxTreeGridSummaryPipe.prototype.removeDeletedRecord = /**
     * @private
     * @param {?} grid
     * @param {?} rowId
     * @param {?} data
     * @return {?}
     */
    function (grid, rowId, data) {
        if (!grid.transactions.enabled || !grid.cascadeOnDelete) {
            return data;
        }
        /** @type {?} */
        var deletedRows = grid.transactions.getTransactionLog().filter(function (t) { return t.type === 'delete'; }).map(function (t) { return t.id; });
        /** @type {?} */
        var row = grid.records.get(rowId);
        if (!row && deletedRows.lenght === 0) {
            return [];
        }
        row = row.children ? row : row.parent;
        while (row) {
            rowId = row.rowID;
            if (deletedRows.indexOf(rowId) !== -1) {
                return [];
            }
            row = row.parent;
        }
        deletedRows.forEach(function (rowID) {
            /** @type {?} */
            var tempData = grid.primaryKey ? data.map(function (rec) { return rec[grid.primaryKey]; }) : data;
            /** @type {?} */
            var index = tempData.indexOf(rowID);
            if (index !== -1) {
                data.splice(index, 1);
            }
        });
        return data;
    };
    IgxTreeGridSummaryPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'treeGridSummary',
                    pure: true
                },] }
    ];
    /** @nocollapse */
    IgxTreeGridSummaryPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };
    return IgxTreeGridSummaryPipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxTreeGridModule = /** @class */ (function () {
    function IgxTreeGridModule() {
    }
    IgxTreeGridModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        IgxTreeGridComponent,
                        IgxTreeGridRowComponent,
                        IgxTreeGridCellComponent,
                        IgxTreeGridHierarchizingPipe,
                        IgxTreeGridFlatteningPipe,
                        IgxTreeGridSortingPipe,
                        IgxTreeGridFilteringPipe,
                        IgxTreeGridPagingPipe,
                        IgxTreeGridTransactionPipe,
                        IgxTreeGridSummaryPipe,
                        IgxRowLoadingIndicatorTemplateDirective
                    ],
                    exports: [
                        IgxTreeGridComponent,
                        IgxTreeGridRowComponent,
                        IgxTreeGridCellComponent,
                        IgxRowLoadingIndicatorTemplateDirective,
                        IgxGridCommonModule
                    ],
                    imports: [
                        CommonModule,
                        FormsModule,
                        IgxChipsModule,
                        IgxGridCommonModule
                    ]
                },] }
    ];
    return IgxTreeGridModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var  /**
 * @hidden
 */
IgxHierarchicalSelectionAPIService = /** @class */ (function (_super) {
    __extends(IgxHierarchicalSelectionAPIService, _super);
    function IgxHierarchicalSelectionAPIService() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.hSelection = new Map();
        return _this;
    }
    /**
     * @param {?} rootID
     * @param {?} parentID
     * @param {?} cell
     * @return {?}
     */
    IgxHierarchicalSelectionAPIService.prototype.add_sub_item = /**
     * @param {?} rootID
     * @param {?} parentID
     * @param {?} cell
     * @return {?}
     */
    function (rootID, parentID, cell) {
        /** @type {?} */
        var selItem = new Map();
        selItem.set(parentID, cell);
        this.hSelection.set(rootID, selItem);
    };
    /**
     * @param {?} rootID
     * @return {?}
     */
    IgxHierarchicalSelectionAPIService.prototype.get_sub_item = /**
     * @param {?} rootID
     * @return {?}
     */
    function (rootID) {
        /** @type {?} */
        var selItem;
        /** @type {?} */
        var sel = this.hSelection.get(rootID);
        if (sel) {
            selItem = {
                gridID: this.hSelection.get(rootID).keys().next().value,
                cell: this.hSelection.get(rootID).values().next().value
            };
        }
        return selItem;
    };
    /**
     * @param {?} rootID
     * @return {?}
     */
    IgxHierarchicalSelectionAPIService.prototype.clear_sub_item = /**
     * @param {?} rootID
     * @return {?}
     */
    function (rootID) {
        return this.hSelection.set(rootID, null);
    };
    return IgxHierarchicalSelectionAPIService;
}(IgxSelectionAPIService));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxHierarchicalGridNavigationService = /** @class */ (function (_super) {
    __extends(IgxHierarchicalGridNavigationService, _super);
    function IgxHierarchicalGridNavigationService() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @protected
     * @param {?=} visibleIndex
     * @param {?=} isSummary
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype.getCellSelector = /**
     * @protected
     * @param {?=} visibleIndex
     * @param {?=} isSummary
     * @return {?}
     */
    function (visibleIndex, isSummary) {
        if (isSummary === void 0) { isSummary = false; }
        return isSummary ? 'igx-grid-summary-cell' : 'igx-hierarchical-grid-cell';
    };
    /**
     * @protected
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype.getRowSelector = /**
     * @protected
     * @return {?}
     */
    function () {
        return 'igx-hierarchical-grid-row';
    };
    /**
     * @protected
     * @param {?} index
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype.getRowByIndex = /**
     * @protected
     * @param {?} index
     * @return {?}
     */
    function (index) {
        var _this = this;
        /** @type {?} */
        var selector = this.getRowSelector();
        /** @type {?} */
        var rows = Array.from(this.grid.nativeElement.querySelectorAll(selector + "[data-rowindex=\"" + index + "\"]"));
        /** @type {?} */
        var row;
        rows.forEach(function (r) {
            /** @type {?} */
            var parentGrid = _this.getClosestElemByTag(r, 'igx-hierarchical-grid');
            if (parentGrid && parentGrid.getAttribute('id') === _this.grid.id) {
                row = r;
            }
        });
        return row;
    };
    /**
     * @private
     * @param {?=} grid
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype.getChildContainer = /**
     * @private
     * @param {?=} grid
     * @return {?}
     */
    function (grid) {
        /** @type {?} */
        var currGrid = grid || this.grid;
        return currGrid.nativeElement.parentNode.parentNode.parentNode;
    };
    /**
     * @private
     * @param {?=} grid
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype.getChildGridRowContainer = /**
     * @private
     * @param {?=} grid
     * @return {?}
     */
    function (grid) {
        /** @type {?} */
        var currGrid = grid || this.grid;
        return currGrid.nativeElement.parentNode.parentNode;
    };
    /**
     * @private
     * @param {?} childGridID
     * @param {?} grid
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype.getChildGrid = /**
     * @private
     * @param {?} childGridID
     * @param {?} grid
     * @return {?}
     */
    function (childGridID, grid) {
        /** @type {?} */
        var cgrid = grid.hgridAPI.getChildGrids(true).filter(function (g) { return g.id === childGridID; })[0];
        return cgrid;
    };
    /**
     * @private
     * @param {?} grid
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype._isScrolledToBottom = /**
     * @private
     * @param {?} grid
     * @return {?}
     */
    function (grid) {
        /** @type {?} */
        var scrollTop = grid.verticalScrollContainer.getVerticalScroll().scrollTop;
        /** @type {?} */
        var scrollHeight = grid.verticalScrollContainer.getVerticalScroll().scrollHeight;
        return scrollHeight === 0 || Math.round(scrollTop + grid.verticalScrollContainer.igxForContainerSize) === scrollHeight;
    };
    /**
     * @private
     * @param {?} index
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype.getIsChildAtIndex = /**
     * @private
     * @param {?} index
     * @return {?}
     */
    function (index) {
        return this.grid.isChildGridRecord(this.grid.verticalScrollContainer.igxForOf[index]);
    };
    /**
     * @param {?} rowIndex
     * @param {?} visibleColumnIndex
     * @param {?=} isSummary
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype.getCellElementByVisibleIndex = /**
     * @param {?} rowIndex
     * @param {?} visibleColumnIndex
     * @param {?=} isSummary
     * @return {?}
     */
    function (rowIndex, visibleColumnIndex, isSummary) {
        if (isSummary === void 0) { isSummary = false; }
        /** @type {?} */
        var cellSelector = this.getCellSelector(visibleColumnIndex, isSummary);
        if (isSummary) {
            /** @type {?} */
            var summaryRow = this.grid.summariesRowList.toArray()[0].nativeElement;
            return summaryRow.querySelector(cellSelector + "[data-visibleIndex=\"" + visibleColumnIndex + "\"]");
        }
        /** @type {?} */
        var row = this.getRowByIndex(rowIndex);
        return row.querySelector(cellSelector + "[data-rowindex=\"" + rowIndex + "\"][data-visibleIndex=\"" + visibleColumnIndex + "\"]");
    };
    /**
     * @param {?} rowElement
     * @param {?} currentRowIndex
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype.navigateUp = /**
     * @param {?} rowElement
     * @param {?} currentRowIndex
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    function (rowElement, currentRowIndex, visibleColumnIndex) {
        var _this = this;
        /** @type {?} */
        var prevElem = rowElement.previousElementSibling;
        if (prevElem) {
            /** @type {?} */
            var nodeName = prevElem.children[0].nodeName.toLowerCase();
            /** @type {?} */
            var isElemChildGrid = nodeName.toLowerCase() === 'igx-child-grid-row';
            if (isElemChildGrid) {
                this.focusPrevChild(prevElem, visibleColumnIndex, this.grid);
            }
            else {
                if (this.grid.parent !== null) {
                    // currently navigating in child grid
                    this._navigateUpInChild(rowElement, currentRowIndex, visibleColumnIndex);
                }
                else {
                    _super.prototype.navigateUp.call(this, rowElement, currentRowIndex, visibleColumnIndex);
                }
            }
        }
        else if (currentRowIndex !== 0) {
            // handle scenario when prev item is child grid but is not yet in view
            /** @type {?} */
            var isPrevChildGrid = this.getIsChildAtIndex(currentRowIndex - 1);
            if (!isPrevChildGrid) {
                _super.prototype.navigateUp.call(this, rowElement, currentRowIndex, visibleColumnIndex);
            }
            else {
                this.scrollGrid(this.grid, -rowElement.offsetHeight, function () {
                    rowElement = _this.getRowByIndex(currentRowIndex);
                    _this.navigateUp(rowElement, currentRowIndex, visibleColumnIndex);
                });
            }
        }
        else if (this.grid.parent !== null &&
            currentRowIndex === 0) {
            // move to prev row in sibling layout or parent
            this.focusPrev(visibleColumnIndex);
        }
    };
    /**
     * @param {?} rowElement
     * @param {?} currentRowIndex
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype.navigateDown = /**
     * @param {?} rowElement
     * @param {?} currentRowIndex
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    function (rowElement, currentRowIndex, visibleColumnIndex) {
        /** @type {?} */
        var nextElem = rowElement.nextElementSibling;
        if (nextElem) {
            // next elem is in DOM
            /** @type {?} */
            var nodeName = nextElem.children[0].nodeName.toLowerCase();
            /** @type {?} */
            var isNextElemChildGrid = nodeName.toLowerCase() === 'igx-child-grid-row';
            if (isNextElemChildGrid) {
                this.focusNextChild(nextElem, visibleColumnIndex, this.grid);
            }
            else {
                if (this.grid.parent !== null) {
                    // currently navigating in child grid
                    this._navigateDownInChild(rowElement, currentRowIndex, visibleColumnIndex);
                }
                else {
                    _super.prototype.navigateDown.call(this, rowElement, currentRowIndex, visibleColumnIndex);
                }
            }
        }
        else if (currentRowIndex !== this.grid.verticalScrollContainer.igxForOf.length - 1) {
            // scroll next in view
            _super.prototype.navigateDown.call(this, rowElement, currentRowIndex, visibleColumnIndex);
        }
        else if (this.grid.parent !== null &&
            currentRowIndex === this.grid.verticalScrollContainer.igxForOf.length - 1) {
            // move to next row in sibling layout or in parent
            this.focusNext(visibleColumnIndex);
        }
    };
    /**
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype.navigateTop = /**
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    function (visibleColumnIndex) {
        var _this = this;
        if (this.grid.parent !== null) {
            // navigating in child
            /** @type {?} */
            var verticalScroll = this.grid.verticalScrollContainer.getVerticalScroll();
            /** @type {?} */
            var cellSelector_1 = this.getCellSelector(visibleColumnIndex);
            if (verticalScroll.scrollTop === 0) {
                this._focusScrollCellInView(visibleColumnIndex);
            }
            else {
                this.scrollGrid(this.grid, 'top', function () {
                    /** @type {?} */
                    var cells = _this.grid.nativeElement.querySelectorAll(cellSelector_1 + "[data-visibleIndex=\"" + visibleColumnIndex + "\"]");
                    if (cells.length > 0) {
                        _this._focusScrollCellInView(visibleColumnIndex);
                    }
                });
            }
        }
        else {
            _super.prototype.navigateTop.call(this, visibleColumnIndex);
        }
    };
    /**
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype.navigateBottom = /**
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    function (visibleColumnIndex) {
        var _this = this;
        // handle scenario where last index is child grid
        // in that case focus cell in last data row
        /** @type {?} */
        var lastIndex = this.grid.verticalScrollContainer.igxForOf.length - 1;
        if (this.getIsChildAtIndex(lastIndex)) {
            /** @type {?} */
            var targetIndex_1 = lastIndex - 1;
            /** @type {?} */
            var scrTopPosition = this.grid.verticalScrollContainer.getScrollForIndex(targetIndex_1, true);
            /** @type {?} */
            var verticalScroll = this.grid.verticalScrollContainer.getVerticalScroll();
            /** @type {?} */
            var cellSelector_2 = this.getCellSelector(visibleColumnIndex);
            if (verticalScroll.scrollTop === scrTopPosition) {
                /** @type {?} */
                var cells = this.getRowByIndex(targetIndex_1).querySelectorAll(cellSelector_2 + "[data-visibleIndex=\"" + visibleColumnIndex + "\"]");
                cells[cells.length - 1].focus();
            }
            else {
                this.scrollGrid(this.grid, scrTopPosition - verticalScroll.scrollTop, function () {
                    /** @type {?} */
                    var cells = _this.getRowByIndex(targetIndex_1).querySelectorAll(cellSelector_2 + "[data-visibleIndex=\"" + visibleColumnIndex + "\"]");
                    if (cells.length > 0) {
                        cells[cells.length - 1].focus();
                    }
                });
            }
        }
        else {
            _super.prototype.navigateBottom.call(this, visibleColumnIndex);
        }
    };
    /**
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype.goToLastCell = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // handle scenario where last index is child grid
        // in that case focus last cell in last data row
        /** @type {?} */
        var lastIndex = this.grid.verticalScrollContainer.igxForOf.length - 1;
        if (this.getIsChildAtIndex(lastIndex)) {
            /** @type {?} */
            var targetIndex_2 = lastIndex - 1;
            /** @type {?} */
            var scrTopPosition = this.grid.verticalScrollContainer.getScrollForIndex(targetIndex_2, true);
            /** @type {?} */
            var verticalScroll = this.grid.verticalScrollContainer.getVerticalScroll();
            if (verticalScroll.scrollTop === scrTopPosition) {
                this.onKeydownEnd(targetIndex_2);
            }
            else {
                this.scrollGrid(this.grid, scrTopPosition - verticalScroll.scrollTop, function () {
                    _this.onKeydownEnd(targetIndex_2);
                });
            }
        }
        else {
            _super.prototype.goToLastCell.call(this);
        }
    };
    /**
     * @param {?} rowIndex
     * @param {?=} isSummary
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype.onKeydownEnd = /**
     * @param {?} rowIndex
     * @param {?=} isSummary
     * @return {?}
     */
    function (rowIndex, isSummary) {
        var _this = this;
        if (isSummary === void 0) { isSummary = false; }
        if (this.grid.parent && !isSummary) {
            // handle scenario where last child row might not be in view
            // parent should scroll to child grid end
            /** @type {?} */
            var childContainer = this.grid.nativeElement.parentNode.parentNode;
            /** @type {?} */
            var diffBottom = childContainer.getBoundingClientRect().bottom - this.grid.rootGrid.nativeElement.getBoundingClientRect().bottom;
            /** @type {?} */
            var row = this.grid.getRowByIndex(rowIndex).element.nativeElement;
            /** @type {?} */
            var rowBottom = row.getBoundingClientRect().bottom;
            /** @type {?} */
            var rowIsVisible = rowBottom <= this.grid.rootGrid.tbody.nativeElement.getBoundingClientRect().bottom;
            /** @type {?} */
            var gridTop = this._getMaxTop(this.grid);
            /** @type {?} */
            var diffTop = row.getBoundingClientRect().bottom -
                row.offsetHeight - gridTop;
            /** @type {?} */
            var endIsVisible = diffBottom <= 0;
            /** @type {?} */
            var topVisible = diffTop >= 0;
            if (!endIsVisible && !rowIsVisible) {
                this.scrollGrid(this.grid.parent, diffBottom, function () { return _super.prototype.onKeydownEnd.call(_this, rowIndex); });
            }
            else if (!topVisible) {
                /** @type {?} */
                var scrGrid = this.grid.verticalScrollContainer.getVerticalScroll().scrollTop !== 0 ? this.grid :
                    this.getNextScrollable(this.grid).grid;
                /** @type {?} */
                var topGrid = scrGrid.tbody.nativeElement.getBoundingClientRect().top >
                    this.grid.rootGrid.tbody.nativeElement.getBoundingClientRect().top ? scrGrid : this.grid.rootGrid;
                this.scrollGrid(topGrid, diffTop, function () { return _super.prototype.onKeydownEnd.call(_this, rowIndex); });
            }
            else {
                _super.prototype.onKeydownEnd.call(this, rowIndex, isSummary);
            }
        }
        else {
            _super.prototype.onKeydownEnd.call(this, rowIndex, isSummary);
        }
    };
    /**
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype.goToFirstCell = /**
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var verticalScroll = this.grid.verticalScrollContainer.getVerticalScroll();
        /** @type {?} */
        var horizontalScroll = this.grid.dataRowList.first.virtDirRow.getHorizontalScroll();
        if (verticalScroll.scrollTop === 0 && this.grid.parent) {
            // scroll parent so that current child is in view
            if (!horizontalScroll.clientWidth || parseInt(horizontalScroll.scrollLeft, 10) <= 1 || this.grid.pinnedColumns.length) {
                this.navigateTop(0);
            }
            else {
                this.horizontalScroll(this.grid.dataRowList.first.index).scrollTo(0);
                this.grid.parentVirtDir.onChunkLoad
                    .pipe(first())
                    .subscribe(function () {
                    _this.navigateTop(0);
                });
            }
        }
        else {
            _super.prototype.goToFirstCell.call(this);
        }
    };
    /**
     * @param {?} currentRowEl
     * @param {?} rowIndex
     * @param {?} visibleColumnIndex
     * @param {?=} isSummaryRow
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype.performTab = /**
     * @param {?} currentRowEl
     * @param {?} rowIndex
     * @param {?} visibleColumnIndex
     * @param {?=} isSummaryRow
     * @return {?}
     */
    function (currentRowEl, rowIndex, visibleColumnIndex, isSummaryRow) {
        var _this = this;
        if (isSummaryRow === void 0) { isSummaryRow = false; }
        /** @type {?} */
        var summaryRows = this.grid.summariesRowList.toArray();
        /** @type {?} */
        var hasSummaries = summaryRows.length > 0;
        /** @type {?} */
        var isLastDataRow = rowIndex === this.grid.verticalScrollContainer.igxForOf.length - 1;
        /** @type {?} */
        var nextIsDataRow = this.grid.dataRowList.find(function (row) { return row.index === rowIndex + 1; });
        /** @type {?} */
        var isLastColumn = this.grid.unpinnedColumns[this.grid.unpinnedColumns.length - 1].visibleIndex === visibleColumnIndex;
        /** @type {?} */
        var isLastSummaryRow = hasSummaries && isSummaryRow;
        /** @type {?} */
        var nextIndex = rowIndex + 1;
        /** @type {?} */
        var virt = this.grid.verticalScrollContainer;
        /** @type {?} */
        var isNextChild = nextIndex <= virt.igxForOf.length - 1 &&
            this.grid.isChildGridRecord(virt.igxForOf[nextIndex]);
        if (!nextIsDataRow && !(isLastDataRow && hasSummaries) && isLastColumn && !isSummaryRow) {
            // navigating in child, next is not summary
            /** @type {?} */
            var childContainer = this.getChildGridRowContainer();
            /** @type {?} */
            var nextIsSiblingChild = this.grid.parent ? !!childContainer.nextElementSibling : false;
            if (nextIsSiblingChild) {
                this.focusNextChildDOMElem(childContainer, this.grid.parent);
            }
            else if (isNextChild) {
                /** @type {?} */
                var isInView = virt.state.startIndex + virt.state.chunkSize > nextIndex;
                if (!isInView) {
                    this.scrollGrid(this.grid, 'next', function () {
                        _this.focusNextChildDOMElem(currentRowEl, _this.grid);
                    });
                }
                else {
                    this.focusNextChildDOMElem(currentRowEl, this.grid);
                }
            }
            else {
                this.navigateDown(currentRowEl, rowIndex, 0);
            }
        }
        else if (isLastSummaryRow && isLastColumn && this.grid.parent) {
            // navigating in child summary, next is parent summary or next parent row
            /** @type {?} */
            var parent_1 = this.grid.parent;
            /** @type {?} */
            var parentHasSummary = parent_1.summariesRowList.toArray().length > 0;
            /** @type {?} */
            var parentRowIndex = parseInt(this.getClosestElemByTag(currentRowEl, 'igx-child-grid-row').parentNode.getAttribute('data-rowindex'), 10);
            /** @type {?} */
            var isLastRowInParent = parent_1.verticalScrollContainer.igxForOf.length - 1 === parentRowIndex;
            // check if next is sibling
            /** @type {?} */
            var childRowContainer = this.getChildGridRowContainer(this.grid);
            /** @type {?} */
            var nextIsSiblingChild = !!childRowContainer.nextElementSibling;
            if (isLastRowInParent && parentHasSummary && !nextIsSiblingChild) {
                // next is parent summary
                /** @type {?} */
                var parentSummary = parent_1.summariesRowList.toArray()[0].nativeElement;
                parent_1.navigation.focusNextRow(parentSummary, 0, this.grid.rootGrid, true);
            }
            else {
                // next is sibling or parent
                this.focusNext(0);
            }
        }
        else if (isLastDataRow && hasSummaries && isLastColumn && this.grid.parent) {
            // navigating in child rows, next is child grid's summary row
            this.focusNextRow(summaryRows[0].nativeElement, 0, this.grid.parent, true);
        }
        else {
            _super.prototype.performTab.call(this, currentRowEl, rowIndex, visibleColumnIndex, isSummaryRow);
        }
    };
    /**
     * @private
     * @param {?} currentRowEl
     * @param {?} grid
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype.focusNextChildDOMElem = /**
     * @private
     * @param {?} currentRowEl
     * @param {?} grid
     * @return {?}
     */
    function (currentRowEl, grid) {
        /** @type {?} */
        var gridElem = currentRowEl.nextElementSibling.querySelector('igx-hierarchical-grid');
        /** @type {?} */
        var childGridID = gridElem.getAttribute('id');
        /** @type {?} */
        var childGrid = this.getChildGrid(childGridID, grid);
        if (childGrid.allowFiltering && childGrid.filterMode === FilterMode.quickFilter) {
            childGrid.navigation.moveFocusToFilterCell(true);
            return;
        }
        this.focusNextChild(currentRowEl.nextElementSibling, 0, grid);
    };
    /**
     * @param {?} column
     * @param {?} eventArgs
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype.navigatePrevFilterCell = /**
     * @param {?} column
     * @param {?} eventArgs
     * @return {?}
     */
    function (column, eventArgs) {
        if (column.visibleIndex === 0 && this.grid.parent) {
            eventArgs.preventDefault();
            /** @type {?} */
            var targetGrid = this.grid.parent;
            /** @type {?} */
            var prevSiblingChild = this.getChildGridRowContainer().previousElementSibling;
            if (prevSiblingChild) {
                /** @type {?} */
                var gridElem = prevSiblingChild.querySelectorAll('igx-hierarchical-grid')[0];
                targetGrid = this.getChildGrid(gridElem.getAttribute('id'), this.grid.parent);
            }
            this.focusPrev(targetGrid.unpinnedColumns[targetGrid.unpinnedColumns.length - 1].visibleIndex);
        }
        else {
            _super.prototype.navigatePrevFilterCell.call(this, column, eventArgs);
        }
    };
    /**
     * @param {?} column
     * @param {?} eventArgs
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype.navigateNextFilterCell = /**
     * @param {?} column
     * @param {?} eventArgs
     * @return {?}
     */
    function (column, eventArgs) {
        /** @type {?} */
        var cols = this.grid.filteringService.unpinnedFilterableColumns;
        /** @type {?} */
        var nextFilterableIndex = cols.indexOf(column) + 1;
        if (nextFilterableIndex >= this.grid.filteringService.unpinnedFilterableColumns.length) {
            // next is not filter cell
            /** @type {?} */
            var dataRows = this.grid.rowList.toArray();
            /** @type {?} */
            var hasRows = dataRows.length !== 0;
            /** @type {?} */
            var summaryRows = this.grid.summariesRowList.toArray();
            /** @type {?} */
            var hasSummaries = summaryRows.length > 0 && summaryRows[0].summaryCells.length > 0;
            if (hasRows) {
                this.focusNextRow(dataRows[0].nativeElement, 0, this.grid, false);
            }
            else if (hasSummaries) {
                this.focusNextRow(summaryRows[0].nativeElement, 0, this.grid, true);
            }
            else {
                this.focusNext(0);
            }
            eventArgs.preventDefault();
        }
        else {
            _super.prototype.navigateNextFilterCell.call(this, column, eventArgs);
        }
    };
    /**
     * @param {?} currentRowEl
     * @param {?} rowIndex
     * @param {?} visibleColumnIndex
     * @param {?=} isSummary
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype.performShiftTabKey = /**
     * @param {?} currentRowEl
     * @param {?} rowIndex
     * @param {?} visibleColumnIndex
     * @param {?=} isSummary
     * @return {?}
     */
    function (currentRowEl, rowIndex, visibleColumnIndex, isSummary) {
        var _this = this;
        if (isSummary === void 0) { isSummary = false; }
        if (visibleColumnIndex === 0 && rowIndex === 0 && this.grid.parent && !isSummary) {
            if (this.grid.allowFiltering && this.grid.filterMode === FilterMode.quickFilter) {
                this.moveFocusToFilterCell();
            }
            else {
                /** @type {?} */
                var prevSiblingChild = this.getChildGridRowContainer().previousElementSibling;
                if (prevSiblingChild) {
                    /** @type {?} */
                    var gridElem = prevSiblingChild.querySelectorAll('igx-hierarchical-grid')[0];
                    this.performShiftTabIntoChild(gridElem, currentRowEl, rowIndex);
                }
                else {
                    this.navigateUp(currentRowEl, rowIndex, this.grid.parent.unpinnedColumns[this.grid.parent.unpinnedColumns.length - 1].visibleIndex);
                }
            }
        }
        else if (visibleColumnIndex === 0 && currentRowEl.previousElementSibling &&
            currentRowEl.previousElementSibling.children[0].tagName.toLowerCase() === 'igx-child-grid-row') {
            /** @type {?} */
            var gridElem = this.getLastGridElem(currentRowEl.previousElementSibling);
            this.performShiftTabIntoChild(gridElem, currentRowEl, rowIndex);
        }
        else if (visibleColumnIndex === 0 && isSummary) {
            /** @type {?} */
            var lastRowIndex_1 = this.grid.verticalScrollContainer.igxForOf.length - 1;
            if (lastRowIndex_1 === -1) {
                // no child data
                if (this.grid.allowFiltering && this.grid.filterMode === FilterMode.quickFilter) {
                    this.moveFocusToFilterCell();
                }
                else {
                    this.navigateUp(currentRowEl, rowIndex, this.grid.parent.unpinnedColumns[this.grid.parent.unpinnedColumns.length - 1].visibleIndex);
                }
            }
            else if (!this.getIsChildAtIndex(lastRowIndex_1)) {
                _super.prototype.goToLastCell.call(this);
            }
            else {
                /** @type {?} */
                var scrTopPosition = this.grid.verticalScrollContainer.getScrollForIndex(lastRowIndex_1, true);
                /** @type {?} */
                var verticalScroll = this.grid.verticalScrollContainer.getVerticalScroll();
                if (verticalScroll.scrollTop === scrTopPosition || isNaN(scrTopPosition)) {
                    /** @type {?} */
                    var closestChild = this.getLastGridElem(this.grid.getRowByIndex(lastRowIndex_1).nativeElement.parentElement);
                    this.performShiftTabIntoChild(closestChild, currentRowEl, rowIndex);
                }
                else {
                    this.scrollGrid(this.grid, scrTopPosition - verticalScroll.scrollTop, function () {
                        /** @type {?} */
                        var closestChild = _this.getLastGridElem(_this.grid.getRowByIndex(lastRowIndex_1).nativeElement.parentElement);
                        _this.performShiftTabIntoChild(closestChild, currentRowEl, rowIndex);
                    });
                }
            }
        }
        else {
            _super.prototype.performShiftTabKey.call(this, currentRowEl, rowIndex, visibleColumnIndex, isSummary);
        }
    };
    /**
     * @private
     * @param {?} trContainer
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype.getLastGridElem = /**
     * @private
     * @param {?} trContainer
     * @return {?}
     */
    function (trContainer) {
        /** @type {?} */
        var children = trContainer.children;
        /** @type {?} */
        var closestChild = children[children.length - 1].children[0].children[0];
        return closestChild;
    };
    /**
     * @private
     * @param {?} gridElem
     * @param {?} currentRowEl
     * @param {?} rowIndex
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype.performShiftTabIntoChild = /**
     * @private
     * @param {?} gridElem
     * @param {?} currentRowEl
     * @param {?} rowIndex
     * @return {?}
     */
    function (gridElem, currentRowEl, rowIndex) {
        /** @type {?} */
        var childGridID = gridElem.getAttribute('id');
        /** @type {?} */
        var childGrid = this.getChildGrid(childGridID, this.grid) || this.getChildGrid(childGridID, this.grid.parent);
        /** @type {?} */
        var lastIndex = childGrid.unpinnedColumns[childGrid.unpinnedColumns.length - 1].visibleIndex;
        /** @type {?} */
        var summaryRows = childGrid.summariesRowList.toArray();
        if (summaryRows.length > 0 && summaryRows[0].summaryCells.length > 0) {
            // move focus to last summary row cell
            /** @type {?} */
            var summaryRow = summaryRows[0].nativeElement;
            this.focusPrevRow(summaryRow, lastIndex, childGrid, true, true);
        }
        else if (childGrid.rowList.toArray().length === 0 &&
            childGrid.allowFiltering && childGrid.filterMode === FilterMode.quickFilter) {
            // move to filter cell
            childGrid.navigation.moveFocusToFilterCell();
        }
        else {
            // move to next cell
            this.navigateUp(currentRowEl, rowIndex, lastIndex);
        }
    };
    /**
     * @private
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype._focusScrollCellInView = /**
     * @private
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    function (visibleColumnIndex) {
        /** @type {?} */
        var cellSelector = this.getCellSelector(visibleColumnIndex);
        /** @type {?} */
        var cells = this.grid.nativeElement.querySelectorAll(cellSelector + "[data-visibleIndex=\"" + visibleColumnIndex + "\"]");
        /** @type {?} */
        var cell = cells[0];
        /** @type {?} */
        var childContainer = this.grid.nativeElement.parentNode.parentNode;
        /** @type {?} */
        var scrTop = this.grid.parent.verticalScrollContainer.getVerticalScroll().scrollTop;
        /** @type {?} */
        var dc = childContainer.parentNode.parentNode;
        /** @type {?} */
        var scrWith = parseInt(dc.style.top, 10);
        if (scrTop === 0 || scrWith === 0) {
            // cell is in view
            cell.focus({ preventScroll: true });
        }
        else {
            // scroll parent so that cell is in view
            this.scrollGrid(this.grid.parent, scrWith, function () { return cell.focus({ preventScroll: true }); });
        }
    };
    /**
     * @private
     * @param {?} elem
     * @param {?} visibleColumnIndex
     * @param {?} grid
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype.focusNextChild = /**
     * @private
     * @param {?} elem
     * @param {?} visibleColumnIndex
     * @param {?} grid
     * @return {?}
     */
    function (elem, visibleColumnIndex, grid) {
        var _this = this;
        /** @type {?} */
        var gridElem = elem.querySelector('igx-hierarchical-grid');
        /** @type {?} */
        var childGridID = gridElem.getAttribute('id');
        /** @type {?} */
        var childGrid = this.getChildGrid(childGridID, grid);
        if (childGrid.rowList.toArray().length === 0) {
            this.focusNext(visibleColumnIndex, childGrid);
            return;
        }
        // Update column index since the next child can have in general less columns than visibleColumnIndex value.
        /** @type {?} */
        var lastCellIndex = childGrid.unpinnedColumns[childGrid.unpinnedColumns.length - 1].visibleIndex;
        visibleColumnIndex = Math.min(lastCellIndex, visibleColumnIndex);
        if (childGrid.verticalScrollContainer.state.startIndex !== 0) {
            // scroll to top
            this.scrollGrid(childGrid, 'top', function () { return _this.focusNextRow(elem, visibleColumnIndex, childGrid); });
        }
        else {
            this.focusNextRow(elem, visibleColumnIndex, childGrid);
        }
    };
    /**
     * @private
     * @param {?} elem
     * @param {?} visibleColumnIndex
     * @param {?} grid
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype.focusPrevChild = /**
     * @private
     * @param {?} elem
     * @param {?} visibleColumnIndex
     * @param {?} grid
     * @return {?}
     */
    function (elem, visibleColumnIndex, grid) {
        var _this = this;
        /** @type {?} */
        var grids = [];
        /** @type {?} */
        var gridElems = Array.from(elem.querySelectorAll('igx-hierarchical-grid'));
        /** @type {?} */
        var childLevel = grid.childLayoutList.first.level;
        gridElems.forEach(function (hg) {
            /** @type {?} */
            var parentRow = _this.getClosestElemByTag(hg, 'igx-child-grid-row');
            if (parentRow && parseInt(parentRow.getAttribute('data-level'), 10) === childLevel) {
                grids.push(hg);
            }
        });
        /** @type {?} */
        var gridElem = grids[grids.length - 1];
        /** @type {?} */
        var childGridID = gridElem.getAttribute('id');
        /** @type {?} */
        var childGrid = this.getChildGrid(childGridID, grid);
        if (childGrid.rowList.toArray().length === 0) {
            this.focusPrev(visibleColumnIndex, childGrid);
            return;
        }
        // Update column index since the previous child can have in general less columns than visibleColumnIndex value.
        /** @type {?} */
        var lastCellIndex = childGrid.unpinnedColumns[childGrid.unpinnedColumns.length - 1].visibleIndex;
        visibleColumnIndex = Math.min(lastCellIndex, visibleColumnIndex);
        /** @type {?} */
        var isScrolledToBottom = this._isScrolledToBottom(childGrid);
        /** @type {?} */
        var lastIndex = childGrid.verticalScrollContainer.igxForOf.length - 1;
        if (!isScrolledToBottom) {
            // scroll to end
            this.scrollGrid(childGrid, 'bottom', function () { return _this.focusPrevChild(elem, visibleColumnIndex, grid); });
        }
        else {
            /** @type {?} */
            var lastRowInChild = childGrid.getRowByIndex(lastIndex);
            /** @type {?} */
            var isChildGrid = lastRowInChild.nativeElement.nodeName.toLowerCase() === 'igx-child-grid-row';
            if (isChildGrid) {
                this.focusPrevChild(lastRowInChild.nativeElement.parentNode, visibleColumnIndex, childGrid);
            }
            else {
                this.focusPrevRow(lastRowInChild.nativeElement, visibleColumnIndex, childGrid, true);
            }
        }
    };
    /**
     * @private
     * @param {?} visibleColumnIndex
     * @param {?=} grid
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype.focusPrev = /**
     * @private
     * @param {?} visibleColumnIndex
     * @param {?=} grid
     * @return {?}
     */
    function (visibleColumnIndex, grid) {
        var _this = this;
        /** @type {?} */
        var currGrid = grid || this.grid;
        /** @type {?} */
        var parentContainer = this.getChildContainer(currGrid);
        /** @type {?} */
        var childRowContainer = this.getChildGridRowContainer(currGrid);
        /** @type {?} */
        var prevIsSiblingChild = !!childRowContainer.previousElementSibling;
        /** @type {?} */
        var prev = childRowContainer.previousElementSibling || parentContainer.previousElementSibling;
        if (prev) {
            if (prevIsSiblingChild) {
                this.focusPrevChild(prev, visibleColumnIndex, currGrid.parent);
            }
            else {
                this.focusPrevRow(prev, visibleColumnIndex, currGrid.parent);
            }
        }
        else {
            this.scrollGrid(currGrid.parent, 'prev', function () {
                parentContainer = _this.getChildContainer(grid);
                childRowContainer = _this.getChildGridRowContainer(grid);
                prev = childRowContainer.previousElementSibling || parentContainer.previousElementSibling;
                if (prevIsSiblingChild) {
                    _this.focusPrevChild(prev, visibleColumnIndex, currGrid.parent);
                }
                else {
                    _this.focusPrevRow(prev, visibleColumnIndex, currGrid.parent);
                }
            });
        }
    };
    /**
     * @private
     * @param {?} grid
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype.getNextParentInfo = /**
     * @private
     * @param {?} grid
     * @return {?}
     */
    function (grid) {
        // find next parent that is not at bottom
        /** @type {?} */
        var currGrid = grid.parent;
        /** @type {?} */
        var nextElem = this.getChildContainer(grid).nextElementSibling;
        while (!nextElem && currGrid.parent !== null) {
            nextElem = this.getChildContainer(currGrid).nextElementSibling;
            currGrid = currGrid.parent;
        }
        return { grid: currGrid, nextElement: nextElem };
    };
    /**
     * @private
     * @param {?} grid
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype.getNextScrollable = /**
     * @private
     * @param {?} grid
     * @return {?}
     */
    function (grid) {
        /** @type {?} */
        var currGrid = grid.parent;
        if (!currGrid) {
            return { grid: grid, prev: null };
        }
        /** @type {?} */
        var nonScrollable = currGrid.verticalScrollContainer.getVerticalScroll().scrollTop === 0;
        /** @type {?} */
        var prev = grid;
        while (nonScrollable && currGrid.parent !== null) {
            prev = currGrid;
            currGrid = currGrid.parent;
            nonScrollable = currGrid.verticalScrollContainer.getVerticalScroll().scrollTop === 0;
        }
        return { grid: currGrid, prev: prev };
    };
    /**
     * @private
     * @param {?} visibleColumnIndex
     * @param {?=} grid
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype.focusNext = /**
     * @private
     * @param {?} visibleColumnIndex
     * @param {?=} grid
     * @return {?}
     */
    function (visibleColumnIndex, grid) {
        var _this = this;
        /** @type {?} */
        var currGrid = grid || this.grid;
        /** @type {?} */
        var parentInfo = this.getNextParentInfo(currGrid);
        /** @type {?} */
        var nextParentGrid = parentInfo.grid;
        /** @type {?} */
        var nextParentElem = parentInfo.nextElement;
        /** @type {?} */
        var childRowContainer = this.getChildGridRowContainer(currGrid);
        /** @type {?} */
        var nextIsSiblingChild = !!childRowContainer.nextElementSibling;
        /** @type {?} */
        var next = childRowContainer.nextElementSibling || nextParentElem;
        /** @type {?} */
        var verticalScroll = nextParentGrid.verticalScrollContainer.getVerticalScroll();
        if (next) {
            if (nextIsSiblingChild) {
                this.focusNextChild(next, visibleColumnIndex, nextParentGrid);
            }
            else {
                this.focusNextRow(next, visibleColumnIndex, grid || nextParentGrid);
            }
        }
        else if (verticalScroll.scrollTop !==
            verticalScroll.scrollHeight - nextParentGrid.verticalScrollContainer.igxForContainerSize) {
            this.scrollGrid(nextParentGrid, 'next', function () {
                nextParentElem = parentInfo.nextElement;
                childRowContainer = _this.getChildGridRowContainer();
                next = childRowContainer.nextElementSibling || nextParentElem;
                if (next && nextIsSiblingChild) {
                    _this.focusNextChild(next, visibleColumnIndex, nextParentGrid);
                }
                else if (next) {
                    _this.focusNextRow(next, visibleColumnIndex, grid || nextParentGrid);
                }
            });
        }
    };
    /**
     * @private
     * @param {?} grid
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype.getNextScrollableDown = /**
     * @private
     * @param {?} grid
     * @return {?}
     */
    function (grid) {
        /** @type {?} */
        var currGrid = grid.parent;
        if (!currGrid) {
            return { grid: grid, prev: null };
        }
        /** @type {?} */
        var scrollTop = currGrid.verticalScrollContainer.getVerticalScroll().scrollTop;
        /** @type {?} */
        var scrollHeight = currGrid.verticalScrollContainer.getVerticalScroll().scrollHeight;
        /** @type {?} */
        var nonScrollable = scrollHeight === 0 ||
            Math.round(scrollTop + currGrid.verticalScrollContainer.igxForContainerSize) === scrollHeight;
        /** @type {?} */
        var prev = grid;
        while (nonScrollable && currGrid.parent !== null) {
            prev = currGrid;
            currGrid = currGrid.parent;
            scrollTop = currGrid.verticalScrollContainer.getVerticalScroll().scrollTop;
            scrollHeight = currGrid.verticalScrollContainer.getVerticalScroll().scrollHeight;
            nonScrollable = scrollHeight === 0 ||
                Math.round(scrollTop + currGrid.verticalScrollContainer.igxForContainerSize) === scrollHeight;
        }
        return { grid: currGrid, prev: prev };
    };
    /**
     * @private
     * @param {?} grid
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype._getMinBottom = /**
     * @private
     * @param {?} grid
     * @return {?}
     */
    function (grid) {
        /** @type {?} */
        var currGrid = grid;
        /** @type {?} */
        var bottom = currGrid.tbody.nativeElement.getBoundingClientRect().bottom;
        while (currGrid.parent) {
            currGrid = currGrid.parent;
            bottom = Math.min(bottom, currGrid.tbody.nativeElement.getBoundingClientRect().bottom);
        }
        return bottom;
    };
    /**
     * @private
     * @param {?} grid
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype._getMaxTop = /**
     * @private
     * @param {?} grid
     * @return {?}
     */
    function (grid) {
        /** @type {?} */
        var currGrid = grid;
        /** @type {?} */
        var top = currGrid.tbody.nativeElement.getBoundingClientRect().top;
        while (currGrid.parent) {
            currGrid = currGrid.parent;
            top = Math.max(top, currGrid.tbody.nativeElement.getBoundingClientRect().top);
        }
        return top;
    };
    /**
     * @private
     * @param {?} elem
     * @param {?} visibleColumnIndex
     * @param {?} grid
     * @param {?=} isSummary
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype.focusNextRow = /**
     * @private
     * @param {?} elem
     * @param {?} visibleColumnIndex
     * @param {?} grid
     * @param {?=} isSummary
     * @return {?}
     */
    function (elem, visibleColumnIndex, grid, isSummary) {
        /** @type {?} */
        var cellSelector = this.getCellSelector(visibleColumnIndex, isSummary);
        if (grid.navigation.isColumnFullyVisible(visibleColumnIndex) && grid.navigation.isColumnLeftFullyVisible(visibleColumnIndex)) {
            /** @type {?} */
            var cell_1 = elem.querySelector(cellSelector + "[data-visibleIndex=\"" + visibleColumnIndex + "\"]");
            /** @type {?} */
            var closestScrollableGrid = this.getNextScrollableDown(grid).grid;
            // const diff = cell.getBoundingClientRect().bottom - grid.rootGrid.tbody.nativeElement.getBoundingClientRect().bottom;
            /** @type {?} */
            var gridBottom = this._getMinBottom(grid);
            /** @type {?} */
            var diff = cell_1.getBoundingClientRect().bottom - gridBottom;
            /** @type {?} */
            var inView = diff <= 0;
            /** @type {?} */
            var scrollTop = closestScrollableGrid.verticalScrollContainer.getVerticalScroll().scrollTop;
            /** @type {?} */
            var scrollHeight = closestScrollableGrid.verticalScrollContainer.getVerticalScroll().scrollHeight;
            /** @type {?} */
            var canScroll = !(scrollHeight === 0 ||
                Math.round(scrollTop + closestScrollableGrid.verticalScrollContainer.igxForContainerSize) === scrollHeight);
            if (!inView && canScroll) {
                this.scrollGrid(closestScrollableGrid, diff, function () { return cell_1.focus({ preventScroll: true }); });
            }
            else {
                cell_1.focus({ preventScroll: true });
            }
        }
        else {
            /** @type {?} */
            var cellElem = elem.querySelector("" + cellSelector);
            /** @type {?} */
            var rowIndex = parseInt(cellElem.getAttribute('data-rowindex'), 10);
            grid.navigation.performHorizontalScrollToCell(rowIndex, visibleColumnIndex);
        }
    };
    /**
     * @private
     * @param {?} elem
     * @param {?} visibleColumnIndex
     * @param {?} grid
     * @param {?=} inChild
     * @param {?=} isSummary
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype.focusPrevRow = /**
     * @private
     * @param {?} elem
     * @param {?} visibleColumnIndex
     * @param {?} grid
     * @param {?=} inChild
     * @param {?=} isSummary
     * @return {?}
     */
    function (elem, visibleColumnIndex, grid, inChild, isSummary) {
        var _this = this;
        if (grid.navigation.isColumnFullyVisible(visibleColumnIndex) && grid.navigation.isColumnLeftFullyVisible(visibleColumnIndex)) {
            /** @type {?} */
            var cellSelector_3 = this.getCellSelector(visibleColumnIndex, isSummary);
            /** @type {?} */
            var cells = elem.querySelectorAll(cellSelector_3 + "[data-visibleIndex=\"" + visibleColumnIndex + "\"]");
            /** @type {?} */
            var cell_2 = cells[cells.length - 1];
            /** @type {?} */
            var rIndex_1 = parseInt(elem.getAttribute('data-rowindex'), 10);
            /** @type {?} */
            var scrGrid = grid.verticalScrollContainer.getVerticalScroll().scrollTop !== 0 ? grid :
                this.getNextScrollable(grid).grid;
            /** @type {?} */
            var topGrid = scrGrid.tbody.nativeElement.getBoundingClientRect().top >
                grid.rootGrid.tbody.nativeElement.getBoundingClientRect().top ? scrGrid : grid.rootGrid;
            /** @type {?} */
            var gridTop = this._getMaxTop(grid);
            /** @type {?} */
            var scrTop = scrGrid.verticalScrollContainer.getVerticalScroll().scrollTop;
            /** @type {?} */
            var diff = cell_2.getBoundingClientRect().bottom -
                cell_2.offsetHeight - gridTop;
            if (scrTop !== 0 && diff < 0 && !inChild) {
                this.scrollGrid(scrGrid, diff, function () {
                    /** @type {?} */
                    var el = !isSummary ? grid.navigation.getRowByIndex(rIndex_1) : elem;
                    cell_2 = el.querySelectorAll(cellSelector_3 + "[data-visibleIndex=\"" + visibleColumnIndex + "\"]")[0];
                    cell_2.focus({ preventScroll: true });
                });
            }
            else if (diff < 0 && inChild) {
                this.scrollGrid(topGrid, diff, function () {
                    cell_2.focus({ preventScroll: true });
                });
            }
            else {
                cell_2.focus({ preventScroll: true });
            }
        }
        else {
            this.horizontalScrollGridToIndex(grid, visibleColumnIndex, function () {
                _this.focusPrevRow(elem, visibleColumnIndex, grid, inChild, isSummary);
            });
        }
    };
    /**
     * @private
     * @param {?} grid
     * @param {?} visibleColumnIndex
     * @param {?} callBackFunc
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype.horizontalScrollGridToIndex = /**
     * @private
     * @param {?} grid
     * @param {?} visibleColumnIndex
     * @param {?} callBackFunc
     * @return {?}
     */
    function (grid, visibleColumnIndex, callBackFunc) {
        /** @type {?} */
        var unpinnedIndex = this.getColumnUnpinnedIndex(visibleColumnIndex);
        grid.parentVirtDir.onChunkLoad
            .pipe(first())
            .subscribe(callBackFunc);
        grid.dataRowList.toArray()[0].virtDirRow.scrollTo(unpinnedIndex);
    };
    /**
     * @private
     * @param {?} grid
     * @param {?} target
     * @param {?} callBackFunc
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype.scrollGrid = /**
     * @private
     * @param {?} grid
     * @param {?} target
     * @param {?} callBackFunc
     * @return {?}
     */
    function (grid, target, callBackFunc) {
        grid.nativeElement.focus({ preventScroll: true });
        requestAnimationFrame(function () {
            if (typeof target === 'number') {
                grid.verticalScrollContainer.addScrollTop(target);
            }
            else {
                switch (target) {
                    case 'top':
                        grid.verticalScrollContainer.scrollTo(0);
                        break;
                    case 'bottom':
                        grid.verticalScrollContainer.scrollTo(grid.verticalScrollContainer.igxForOf.length - 1);
                        break;
                    case 'next':
                        grid.verticalScrollContainer.scrollNext();
                        break;
                    case 'prev':
                        grid.verticalScrollContainer.scrollPrev();
                        break;
                }
            }
            grid.verticalScrollContainer.onChunkLoad
                .pipe(first())
                .subscribe(callBackFunc);
        });
    };
    /**
     * @private
     * @param {?} rowElement
     * @param {?} currentRowIndex
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype._navigateUpInChild = /**
     * @private
     * @param {?} rowElement
     * @param {?} currentRowIndex
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    function (rowElement, currentRowIndex, visibleColumnIndex) {
        var _this = this;
        /** @type {?} */
        var prevElem = rowElement.previousElementSibling;
        /** @type {?} */
        var scrollable = this.getNextScrollable(this.grid);
        /** @type {?} */
        var grid = scrollable.grid;
        /** @type {?} */
        var scrTop = grid.verticalScrollContainer.getVerticalScroll().scrollTop;
        /** @type {?} */
        var containerTop = scrollable.prev.nativeElement.parentNode.parentNode.parentNode.parentNode;
        /** @type {?} */
        var top = parseInt(containerTop.style.top, 10);
        if (scrTop !== 0 && top < 0) {
            this.scrollGrid(grid, -prevElem.offsetHeight, function () { return _super.prototype.navigateUp.call(_this, rowElement, currentRowIndex, visibleColumnIndex); });
        }
        else {
            _super.prototype.navigateUp.call(this, rowElement, currentRowIndex, visibleColumnIndex);
        }
    };
    /**
     * @private
     * @param {?} rowElement
     * @param {?} currentRowIndex
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype._navigateDownInChild = /**
     * @private
     * @param {?} rowElement
     * @param {?} currentRowIndex
     * @param {?} visibleColumnIndex
     * @return {?}
     */
    function (rowElement, currentRowIndex, visibleColumnIndex) {
        var _this = this;
        /** @type {?} */
        var nextElem = rowElement.nextElementSibling;
        /** @type {?} */
        var childContainer = this.grid.nativeElement.parentNode.parentNode;
        /** @type {?} */
        var diff = childContainer.getBoundingClientRect().bottom - this.grid.rootGrid.nativeElement.getBoundingClientRect().bottom;
        /** @type {?} */
        var endIsVisible = diff < 0;
        /** @type {?} */
        var scrollable = this.getNextScrollableDown(this.grid);
        /** @type {?} */
        var grid = scrollable.grid;
        if (!endIsVisible) {
            this.scrollGrid(grid, nextElem.offsetHeight, function () { return _super.prototype.navigateDown.call(_this, rowElement, currentRowIndex, visibleColumnIndex); });
        }
        else {
            _super.prototype.navigateDown.call(this, rowElement, currentRowIndex, visibleColumnIndex);
        }
    };
    /**
     * @private
     * @param {?} sourceElem
     * @param {?} targetTag
     * @return {?}
     */
    IgxHierarchicalGridNavigationService.prototype.getClosestElemByTag = /**
     * @private
     * @param {?} sourceElem
     * @param {?} targetTag
     * @return {?}
     */
    function (sourceElem, targetTag) {
        /** @type {?} */
        var result = sourceElem;
        while (result !== null && result.nodeType === 1) {
            if (result.tagName.toLowerCase() === targetTag.toLowerCase()) {
                return result;
            }
            result = result.parentNode;
        }
        return null;
    };
    return IgxHierarchicalGridNavigationService;
}(IgxGridNavigationService));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var IgxHierarchicalTransactionServiceFactory = {
    provide: IgxGridTransaction,
    useFactory: hierarchicalTransactionServiceFactory
};
/**
 * @return {?}
 */
function hierarchicalTransactionServiceFactory() {
    return function () { return new IgxHierarchicalTransactionService(); };
}
/**
 * @abstract
 */
var IgxHierarchicalGridBaseComponent = /** @class */ (function (_super) {
    __extends(IgxHierarchicalGridBaseComponent, _super);
    function IgxHierarchicalGridBaseComponent(selectionService, crudService, gridAPI, selection, transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions) {
        var _this = _super.call(this, selectionService, crudService, gridAPI, selection, typeof transactionFactory === 'function' ? transactionFactory() : transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions) || this;
        _this.selectionService = selectionService;
        _this.transactionFactory = transactionFactory;
        _this.document = document;
        _this.overlayService = overlayService;
        _this.summaryService = summaryService;
        _this._displayDensityOptions = _displayDensityOptions;
        _this._expandChildren = false;
        _this.hgridAPI = (/** @type {?} */ (gridAPI));
        return _this;
    }
    Object.defineProperty(IgxHierarchicalGridBaseComponent.prototype, "maxLevelHeaderDepth", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            this._maxLevelHeaderDepth = this.columnList.reduce(function (acc, col) { return Math.max(acc, col.level); }, 0);
            return this._maxLevelHeaderDepth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxHierarchicalGridBaseComponent.prototype, "outlet", {
        /**
        * @hidden
        */
        get: /**
         * @hidden
         * @protected
         * @return {?}
         */
        function () {
            return this.rootGrid ? this.rootGrid.outletDirective : this.outletDirective;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} cols
     * @return {?}
     */
    IgxHierarchicalGridBaseComponent.prototype.createColumnsList = /**
     * @hidden
     * @param {?} cols
     * @return {?}
     */
    function (cols) {
        var _this = this;
        /** @type {?} */
        var columns = [];
        /** @type {?} */
        var topLevelCols = this.onlyTopLevel(cols);
        topLevelCols.forEach(function (col) {
            /** @type {?} */
            var ref = _this._createColumn(col);
            ref.changeDetectorRef.detectChanges();
            columns.push(ref.instance);
        });
        /** @type {?} */
        var result = flatten$1(columns);
        this.columnList.reset(result);
        this.columnList.notifyOnChanges();
    };
    /**
     * @protected
     * @param {?} col
     * @return {?}
     */
    IgxHierarchicalGridBaseComponent.prototype._createColumn = /**
     * @protected
     * @param {?} col
     * @return {?}
     */
    function (col) {
        /** @type {?} */
        var ref;
        if (col instanceof IgxColumnGroupComponent) {
            ref = this._createColGroupComponent(col);
        }
        else {
            ref = this._createColComponent(col);
        }
        return ref;
    };
    /**
     * @protected
     * @param {?} col
     * @return {?}
     */
    IgxHierarchicalGridBaseComponent.prototype._createColGroupComponent = /**
     * @protected
     * @param {?} col
     * @return {?}
     */
    function (col) {
        var _this = this;
        /** @type {?} */
        var factoryGroup = this.resolver.resolveComponentFactory(IgxColumnGroupComponent);
        /** @type {?} */
        var ref = this.viewRef.createComponent(factoryGroup, null, this.viewRef.injector);
        ref.changeDetectorRef.detectChanges();
        factoryGroup.inputs.forEach(function (input) {
            /** @type {?} */
            var propName = input.propName;
            ((/** @type {?} */ (ref.instance)))[propName] = ((/** @type {?} */ (col)))[propName];
        });
        if (col.children.length > 0) {
            /** @type {?} */
            var newChildren_1 = [];
            col.children.forEach(function (child) {
                /** @type {?} */
                var newCol = _this._createColumn(child).instance;
                newCol.parent = ref.instance;
                newChildren_1.push(newCol);
            });
            ((/** @type {?} */ (ref.instance))).children.reset(newChildren_1);
            ((/** @type {?} */ (ref.instance))).children.notifyOnChanges();
        }
        ((/** @type {?} */ (ref.instance))).grid = this;
        return ref;
    };
    /**
     * @protected
     * @param {?} col
     * @return {?}
     */
    IgxHierarchicalGridBaseComponent.prototype._createColComponent = /**
     * @protected
     * @param {?} col
     * @return {?}
     */
    function (col) {
        /** @type {?} */
        var factoryColumn = this.resolver.resolveComponentFactory(IgxColumnComponent);
        /** @type {?} */
        var ref = this.viewRef.createComponent(factoryColumn, null, this.viewRef.injector);
        factoryColumn.inputs.forEach(function (input) {
            /** @type {?} */
            var propName = input.propName;
            if (!(((/** @type {?} */ (col)))[propName] instanceof IgxSummaryOperand)) {
                ((/** @type {?} */ (ref.instance)))[propName] = ((/** @type {?} */ (col)))[propName];
            }
            else {
                ((/** @type {?} */ (ref.instance)))[propName] = col[propName].constructor;
            }
        });
        ((/** @type {?} */ (ref.instance))).grid = this;
        return ref;
    };
    /**
     * @protected
     * @param {?} rowIslandID
     * @return {?}
     */
    IgxHierarchicalGridBaseComponent.prototype.getGridsForIsland = /**
     * @protected
     * @param {?} rowIslandID
     * @return {?}
     */
    function (rowIslandID) {
        return this.hgridAPI.getChildGridsForRowIsland(rowIslandID);
    };
    /**
     * @protected
     * @param {?} path
     * @return {?}
     */
    IgxHierarchicalGridBaseComponent.prototype.getChildGrid = /**
     * @protected
     * @param {?} path
     * @return {?}
     */
    function (path) {
        if (!path) {
            return;
        }
        return this.hgridAPI.getChildGrid(path);
    };
    /** @nocollapse */
    IgxHierarchicalGridBaseComponent.ctorParameters = function () { return [
        { type: IgxGridSelectionService },
        { type: IgxGridCRUDService },
        { type: GridBaseAPIService },
        { type: IgxHierarchicalSelectionAPIService },
        { type: undefined, decorators: [{ type: Inject, args: [IgxGridTransaction,] }] },
        { type: ElementRef },
        { type: NgZone },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: ChangeDetectorRef },
        { type: ComponentFactoryResolver },
        { type: IterableDiffers },
        { type: ViewContainerRef },
        { type: IgxHierarchicalGridNavigationService },
        { type: IgxFilteringService },
        { type: IgxOverlayService, decorators: [{ type: Inject, args: [IgxOverlayService,] }] },
        { type: IgxGridSummaryService },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
    ]; };
    IgxHierarchicalGridBaseComponent.propDecorators = {
        expandChildren: [{ type: Input }],
        dragIndicatorIconBase: [{ type: ViewChild, args: ['dragIndicatorIconBase', { read: TemplateRef },] }]
    };
    return IgxHierarchicalGridBaseComponent;
}(IgxGridBaseComponent));
/**
 * @param {?} arr
 * @return {?}
 */
function flatten$1(arr) {
    /** @type {?} */
    var result = [];
    arr.forEach(function (el) {
        result.push(el);
        if (el.children) {
            result = result.concat(flatten$1(el.children.toArray()));
        }
    });
    return result;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxHierarchicalGridAPIService = /** @class */ (function (_super) {
    __extends(IgxHierarchicalGridAPIService, _super);
    function IgxHierarchicalGridAPIService() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.childRowIslands = new Map();
        _this.childGrids = new Map();
        return _this;
    }
    /**
     * @param {?} rowIsland
     * @return {?}
     */
    IgxHierarchicalGridAPIService.prototype.registerChildRowIsland = /**
     * @param {?} rowIsland
     * @return {?}
     */
    function (rowIsland) {
        this.childRowIslands.set(rowIsland.key, rowIsland);
        this.destroyMap.set(rowIsland.key, new Subject());
    };
    /**
     * @param {?} key
     * @return {?}
     */
    IgxHierarchicalGridAPIService.prototype.getChildRowIsland = /**
     * @param {?} key
     * @return {?}
     */
    function (key) {
        return this.childRowIslands.get(key);
    };
    /**
     * @param {?} path
     * @return {?}
     */
    IgxHierarchicalGridAPIService.prototype.getChildGrid = /**
     * @param {?} path
     * @return {?}
     */
    function (path) {
        /** @type {?} */
        var currPath = path;
        /** @type {?} */
        var grid;
        /** @type {?} */
        var pathElem = currPath.shift();
        /** @type {?} */
        var childrenForLayout = this.childGrids.get(pathElem.rowIslandKey);
        if (childrenForLayout) {
            /** @type {?} */
            var childGrid = childrenForLayout.get(pathElem.rowID);
            if (currPath.length === 0) {
                grid = childGrid;
            }
            else {
                grid = childGrid.hgridAPI.getChildGrid(currPath);
            }
        }
        return grid;
    };
    /**
     * @param {?=} inDepth
     * @return {?}
     */
    IgxHierarchicalGridAPIService.prototype.getChildGrids = /**
     * @param {?=} inDepth
     * @return {?}
     */
    function (inDepth) {
        /** @type {?} */
        var allChildren = [];
        this.childGrids.forEach(function (layoutMap) {
            layoutMap.forEach(function (grid) {
                allChildren.push(grid);
                if (inDepth) {
                    /** @type {?} */
                    var children = grid.hgridAPI.getChildGrids(inDepth);
                    children.forEach(function (item) {
                        allChildren.push(item);
                    });
                }
            });
        });
        return allChildren;
    };
    /**
     * @param {?} childGrid
     * @return {?}
     */
    IgxHierarchicalGridAPIService.prototype.getParentRowId = /**
     * @param {?} childGrid
     * @return {?}
     */
    function (childGrid) {
        /** @type {?} */
        var rowID;
        this.childGrids.forEach(function (layoutMap) {
            layoutMap.forEach(function (grid, key) {
                if (grid === childGrid) {
                    rowID = key;
                    return;
                }
            });
        });
        return rowID;
    };
    /**
     * @param {?} parentRowID
     * @param {?} rowIslandKey
     * @param {?} grid
     * @return {?}
     */
    IgxHierarchicalGridAPIService.prototype.registerChildGrid = /**
     * @param {?} parentRowID
     * @param {?} rowIslandKey
     * @param {?} grid
     * @return {?}
     */
    function (parentRowID, rowIslandKey, grid) {
        /** @type {?} */
        var childrenForLayout = this.childGrids.get(rowIslandKey);
        if (!childrenForLayout) {
            this.childGrids.set(rowIslandKey, new Map());
            childrenForLayout = this.childGrids.get(rowIslandKey);
        }
        childrenForLayout.set(parentRowID, grid);
    };
    /**
     * @param {?} rowIslandKey
     * @return {?}
     */
    IgxHierarchicalGridAPIService.prototype.getChildGridsForRowIsland = /**
     * @param {?} rowIslandKey
     * @return {?}
     */
    function (rowIslandKey) {
        /** @type {?} */
        var childrenForLayout = this.childGrids.get(rowIslandKey);
        /** @type {?} */
        var children = [];
        if (childrenForLayout) {
            childrenForLayout.forEach(function (child) {
                children.push(child);
            });
        }
        return children;
    };
    /**
     * @param {?} rowIslandKey
     * @param {?} rowID
     * @return {?}
     */
    IgxHierarchicalGridAPIService.prototype.getChildGridByID = /**
     * @param {?} rowIslandKey
     * @param {?} rowID
     * @return {?}
     */
    function (rowIslandKey, rowID) {
        /** @type {?} */
        var childrenForLayout = this.childGrids.get(rowIslandKey);
        return childrenForLayout.get(rowID);
    };
    return IgxHierarchicalGridAPIService;
}(GridBaseAPIService));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxRowIslandAPIService = /** @class */ (function () {
    function IgxRowIslandAPIService() {
        this.change = new Subject();
        this.state = new Map();
        this.destroyMap = new Map();
        this.childRowIslands = new Map();
        this.childGrids = new Map();
    }
    /**
     * @param {?} rowIsland
     * @return {?}
     */
    IgxRowIslandAPIService.prototype.register = /**
     * @param {?} rowIsland
     * @return {?}
     */
    function (rowIsland) {
        this.state.set(rowIsland.id, rowIsland);
        this.destroyMap.set(rowIsland.id, new Subject());
    };
    /**
     * @param {?} rowIsland
     * @return {?}
     */
    IgxRowIslandAPIService.prototype.unsubscribe = /**
     * @param {?} rowIsland
     * @return {?}
     */
    function (rowIsland) {
        this.state.delete(rowIsland.id);
    };
    /**
     * @param {?} id
     * @return {?}
     */
    IgxRowIslandAPIService.prototype.get = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
        return this.state.get(id);
    };
    /**
     * @param {?} id
     * @return {?}
     */
    IgxRowIslandAPIService.prototype.unset = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
        this.state.delete(id);
        this.destroyMap.delete(id);
    };
    /**
     * @param {?} oldId
     * @param {?} newId
     * @return {?}
     */
    IgxRowIslandAPIService.prototype.reset = /**
     * @param {?} oldId
     * @param {?} newId
     * @return {?}
     */
    function (oldId, newId) {
        /** @type {?} */
        var destroy = this.destroyMap.get(oldId);
        /** @type {?} */
        var rowIsland = this.get(oldId);
        this.unset(oldId);
        if (rowIsland) {
            this.state.set(newId, rowIsland);
        }
        if (destroy) {
            this.destroyMap.set(newId, destroy);
        }
    };
    /**
     * @param {?} rowIsland
     * @return {?}
     */
    IgxRowIslandAPIService.prototype.registerChildRowIsland = /**
     * @param {?} rowIsland
     * @return {?}
     */
    function (rowIsland) {
        this.childRowIslands.set(rowIsland.key, rowIsland);
        this.destroyMap.set(rowIsland.key, new Subject());
    };
    /**
     * @param {?} rowIsland
     * @return {?}
     */
    IgxRowIslandAPIService.prototype.unsetChildRowIsland = /**
     * @param {?} rowIsland
     * @return {?}
     */
    function (rowIsland) {
        this.childRowIslands.delete(rowIsland.key);
        this.destroyMap.delete(rowIsland.key);
    };
    /**
     * @param {?} rowIslandKey
     * @return {?}
     */
    IgxRowIslandAPIService.prototype.getChildRowIsland = /**
     * @param {?} rowIslandKey
     * @return {?}
     */
    function (rowIslandKey) {
        return this.childRowIslands.get(rowIslandKey);
    };
    /**
     * @param {?} parentRowID
     * @param {?} grid
     * @return {?}
     */
    IgxRowIslandAPIService.prototype.registerChildGrid = /**
     * @param {?} parentRowID
     * @param {?} grid
     * @return {?}
     */
    function (parentRowID, grid) {
        this.childGrids.set(parentRowID, grid);
    };
    /**
     * @param {?=} inDepth
     * @return {?}
     */
    IgxRowIslandAPIService.prototype.getChildGrids = /**
     * @param {?=} inDepth
     * @return {?}
     */
    function (inDepth) {
        /** @type {?} */
        var allChildren = [];
        this.childGrids.forEach(function (grid) {
            allChildren.push(grid);
        });
        if (inDepth) {
            this.childRowIslands.forEach(function (layout) {
                allChildren = allChildren.concat(layout.rowIslandAPI.getChildGrids(inDepth));
            });
        }
        return allChildren;
    };
    /**
     * @param {?} rowID
     * @return {?}
     */
    IgxRowIslandAPIService.prototype.getChildGridByID = /**
     * @param {?} rowID
     * @return {?}
     */
    function (rowID) {
        return this.childGrids.get(rowID);
    };
    return IgxRowIslandAPIService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxRowIslandComponent = /** @class */ (function (_super) {
    __extends(IgxRowIslandComponent, _super);
    function IgxRowIslandComponent(selectionService, crudService, gridAPI, selection, transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions, rowIslandAPI) {
        var _this = _super.call(this, selectionService, crudService, gridAPI, selection, typeof transactionFactory === 'function' ? transactionFactory() : transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions) || this;
        _this.selectionService = selectionService;
        _this.transactionFactory = transactionFactory;
        _this.document = document;
        _this.overlayService = overlayService;
        _this.summaryService = summaryService;
        _this._displayDensityOptions = _displayDensityOptions;
        _this.rowIslandAPI = rowIslandAPI;
        /**
         * @hidden
         */
        _this.children = new QueryList();
        /**
         * @hidden
         */
        _this.childColumns = new QueryList();
        /**
         * @hidden
         */
        _this.onLayoutChange = new EventEmitter();
        /**
         * Event emmited when a grid is being created based on this row island.
         * ```html
         * <igx-hierarchical-grid [data]="Data" [autoGenerate]="true">
         *      <igx-row-island [key]="'childData'" (onGridCreated)="gridCreated($event)" #rowIsland>
         *          <!-- ... -->
         *      </igx-row-island>
         * </igx-hierarchical-grid>
         * ```
         * \@memberof IgxRowIslandComponent
         */
        _this.onGridCreated = new EventEmitter();
        /**
         * @hidden
         */
        _this.initialChanges = [];
        /**
         * @hidden
         */
        _this.rootGrid = null;
        _this.layout_id = "igx-row-island-";
        _this.isInit = false;
        _this.hgridAPI = (/** @type {?} */ (gridAPI));
        return _this;
    }
    Object.defineProperty(IgxRowIslandComponent.prototype, "expandChildren", {
        /**
         * Gets if all immediate children of the grids for this `IgxRowIslandComponent` have been set to be expanded/collapsed.
         * ```typescript
         * const expanded = this.rowIsland.expandChildren;
         * ```
         * @memberof IgxRowIslandComponent
         */
        get: /**
         * Gets if all immediate children of the grids for this `IgxRowIslandComponent` have been set to be expanded/collapsed.
         * ```typescript
         * const expanded = this.rowIsland.expandChildren;
         * ```
         * \@memberof IgxRowIslandComponent
         * @return {?}
         */
        function () {
            return this._expandChildren;
        },
        /**
         * Sets if all immediate children of the grids for this `IgxRowIslandComponent` should be expanded/collapsed.
         * ```html
         * <igx-hierarchical-grid [data]="Data" [autoGenerate]="true">
         *      <igx-row-island [key]="'childData'" [expandChildren]="true" #rowIsland>
         *          <!-- ... -->
         *      </igx-row-island>
         * </igx-hierarchical-grid>
         * ```
         * @memberof IgxRowIslandComponent
         */
        set: /**
         * Sets if all immediate children of the grids for this `IgxRowIslandComponent` should be expanded/collapsed.
         * ```html
         * <igx-hierarchical-grid [data]="Data" [autoGenerate]="true">
         *      <igx-row-island [key]="'childData'" [expandChildren]="true" #rowIsland>
         *          <!-- ... -->
         *      </igx-row-island>
         * </igx-hierarchical-grid>
         * ```
         * \@memberof IgxRowIslandComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._expandChildren = value;
            this.rowIslandAPI.getChildGrids().forEach(function (grid) {
                if (document.body.contains(grid.nativeElement)) {
                    // Detect changes right away if the grid is visible
                    grid.expandChildren = value;
                    grid.markForCheck();
                }
                else {
                    // Else defer the detection on changes when the grid gets into view for performance.
                    grid.updateOnRender = true;
                }
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxRowIslandComponent.prototype, "id", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            /** @type {?} */
            var pId = this.parentId ? this.parentId.substring(this.parentId.indexOf(this.layout_id) + this.layout_id.length) + '-' : '';
            return this.layout_id + pId + this.key;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxRowIslandComponent.prototype, "parentId", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.parentIsland ? this.parentIsland.id : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxRowIslandComponent.prototype, "level", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            /** @type {?} */
            var ptr = this.parentIsland;
            /** @type {?} */
            var lvl = 0;
            while (ptr) {
                lvl++;
                ptr = ptr.parentIsland;
            }
            return lvl + 1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxRowIslandComponent.prototype, "transactions", {
        /**
         * Get transactions service for the children grid components.
         * @experimental @hidden
         */
        get: /**
         * Get transactions service for the children grid components.
         * \@experimental \@hidden
         * @return {?}
         */
        function () {
            /** @type {?} */
            var grids = this.rowIslandAPI.getChildGrids();
            return grids.length ? grids[0].transactions : this._transactions;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxRowIslandComponent.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxRowIslandComponent.prototype.ngAfterContentInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        this.children.reset(this.children.toArray().slice(1));
        this.children.forEach(function (child) {
            child.parentIsland = _this;
        });
        /** @type {?} */
        var nestedColumns = this.children.map(function (layout) { return layout.columnList.toArray(); });
        /** @type {?} */
        var colsArray = [].concat.apply([], nestedColumns);
        /** @type {?} */
        var topCols = this.columnList.filter(function (item) {
            return colsArray.indexOf(item) === -1;
        });
        this.childColumns.reset(topCols);
        this.columnList.changes.pipe(takeUntil(this.destroy$)).subscribe(function () { _this.updateColumnList(); });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxRowIslandComponent.prototype.ngAfterViewInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.rowIslandAPI.register(this);
        if (this.parentIsland) {
            this.parentIsland.rowIslandAPI.registerChildRowIsland(this);
        }
        else {
            this.rootGrid.hgridAPI.registerChildRowIsland(this);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} changes
     * @return {?}
     */
    IgxRowIslandComponent.prototype.ngOnChanges = /**
     * @hidden
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        this.onLayoutChange.emit(changes);
        if (!this.isInit) {
            this.initialChanges.push(changes);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxRowIslandComponent.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        // Override the base destroy because we don't have rendered anything to use removeEventListener on
        this.destroy$.next(true);
        this.destroy$.complete();
        this.rowIslandAPI.unset(this.id);
        if (this.parentIsland) {
            this.parentIsland.rowIslandAPI.unsetChildRowIsland(this);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxRowIslandComponent.prototype.reflow = /**
     * @hidden
     * @return {?}
     */
    function () { };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxRowIslandComponent.prototype.calculateGridHeight = /**
     * @hidden
     * @return {?}
     */
    function () { };
    /**
     * @protected
     * @return {?}
     */
    IgxRowIslandComponent.prototype.updateColumnList = /**
     * @protected
     * @return {?}
     */
    function () {
        var _this = this;
        /** @type {?} */
        var nestedColumns = this.children.map(function (layout) { return layout.columnList.toArray(); });
        /** @type {?} */
        var colsArray = [].concat.apply([], nestedColumns);
        /** @type {?} */
        var topCols = this.columnList.filter(function (item) {
            if (colsArray.indexOf(item) === -1) {
                /* Reset the default width of the columns that come into this row island,
                because the root catches them first during the detectChanges() and sets their defaultWidth. */
                item.defaultWidth = undefined;
                return true;
            }
            return false;
        });
        this.childColumns.reset(topCols);
        if (this.parentIsland) {
            this.parentIsland.columnList.notifyOnChanges();
        }
        else {
            this.rootGrid.columnList.notifyOnChanges();
        }
        this.rowIslandAPI.getChildGrids().forEach(function (grid) {
            grid.createColumnsList(_this.childColumns.toArray());
            if (!document.body.contains(grid.nativeElement)) {
                grid.updateOnRender = true;
            }
        });
    };
    IgxRowIslandComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'igx-row-island',
                    template: "",
                    providers: [IgxRowIslandAPIService]
                }] }
    ];
    /** @nocollapse */
    IgxRowIslandComponent.ctorParameters = function () { return [
        { type: IgxGridSelectionService },
        { type: IgxGridCRUDService },
        { type: GridBaseAPIService },
        { type: IgxHierarchicalSelectionAPIService },
        { type: undefined, decorators: [{ type: Inject, args: [IgxGridTransaction,] }] },
        { type: ElementRef },
        { type: NgZone },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: ChangeDetectorRef },
        { type: ComponentFactoryResolver },
        { type: IterableDiffers },
        { type: ViewContainerRef },
        { type: IgxHierarchicalGridNavigationService },
        { type: IgxFilteringService },
        { type: IgxOverlayService, decorators: [{ type: Inject, args: [IgxOverlayService,] }] },
        { type: IgxGridSummaryService },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] },
        { type: IgxRowIslandAPIService }
    ]; };
    IgxRowIslandComponent.propDecorators = {
        key: [{ type: Input }],
        expandChildren: [{ type: Input }],
        children: [{ type: ContentChildren, args: [IgxRowIslandComponent, { read: IgxRowIslandComponent, descendants: false },] }],
        childColumns: [{ type: ContentChildren, args: [IgxColumnComponent, { read: IgxColumnComponent, descendants: false },] }],
        onLayoutChange: [{ type: Output }],
        onGridCreated: [{ type: Output }]
    };
    return IgxRowIslandComponent;
}(IgxHierarchicalGridBaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxChildGridRowComponent = /** @class */ (function () {
    function IgxChildGridRowComponent(gridAPI, selectionAPI, element, cdr) {
        this.gridAPI = gridAPI;
        this.selectionAPI = selectionAPI;
        this.element = element;
        this.cdr = cdr;
        /**
         * Returns whether the row is expanded.
         * ```typescript
         * const RowExpanded = this.grid1.rowList.first.expanded;
         * ```
         */
        this.expanded = false;
        /**
         *  The data passed to the row component.
         *
         * ```typescript
         * // get the row data for the first selected row
         * let selectedRowData = this.grid.selectedRows[0].rowData;
         * ```
         */
        this.rowData = [];
        /**
         * @hidden
         */
        this.tabindex = 0;
        /**
         * @hidden
         */
        this.role = 'row';
    }
    Object.defineProperty(IgxChildGridRowComponent.prototype, "parentHasScroll", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return !this.parentGrid.verticalScrollContainer.dc.instance.notVirtual;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxChildGridRowComponent.prototype, "parentGrid", {
        /**
         * Get a reference to the grid that contains the selected row.
         *
         * ```typescript
         * handleRowSelection(event) {
         *  // the grid on which the onRowSelectionChange event was triggered
         *  const grid = event.row.grid;
         * }
         * ```
         *
         * ```html
         *  <igx-grid
         *    [data]="data"
         *    (onRowSelectionChange)="handleRowSelection($event)">
         *  </igx-grid>
         * ```
         */
        // TODO: Refactor
        get: /**
         * Get a reference to the grid that contains the selected row.
         *
         * ```typescript
         * handleRowSelection(event) {
         *  // the grid on which the onRowSelectionChange event was triggered
         *  const grid = event.row.grid;
         * }
         * ```
         *
         * ```html
         *  <igx-grid
         *    [data]="data"
         *    (onRowSelectionChange)="handleRowSelection($event)">
         *  </igx-grid>
         * ```
         * @return {?}
         */
        // TODO: Refactor
        function () {
            return this.gridAPI.grid;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxChildGridRowComponent.prototype, "level", {
        get: /**
         * @return {?}
         */
        function () {
            return this.layout.level;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxChildGridRowComponent.prototype, "nativeElement", {
        /**
         * The native DOM element representing the row. Could be null in certain environments.
         *
         * ```typescript
         * // get the nativeElement of the second selected row
         * let selectedRowNativeElement = this.grid.selectedRows[1].nativeElement;
         * ```
         */
        get: /**
         * The native DOM element representing the row. Could be null in certain environments.
         *
         * ```typescript
         * // get the nativeElement of the second selected row
         * let selectedRowNativeElement = this.grid.selectedRows[1].nativeElement;
         * ```
         * @return {?}
         */
        function () {
            return this.element.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxChildGridRowComponent.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        // setting child data only once on init
        // due to context change issues when moving cached views containing hierarchical child grids
        this.hGrid.data = this.rowData.childGridsData[this.layout.key];
        this.layout.onLayoutChange.subscribe(function (ch) {
            _this._handleLayoutChanges(ch);
        });
        /** @type {?} */
        var changes = this.layout.initialChanges;
        changes.forEach(function (change) {
            _this._handleLayoutChanges(change);
        });
        this.hGrid.parent = this.parentGrid;
        this.hGrid.parentIsland = this.layout;
        this.hGrid.childRow = this;
        this.layout.onGridCreated.emit({
            owner: this.layout,
            parentID: this.rowData.rowID,
            grid: this.hGrid
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxChildGridRowComponent.prototype.ngAfterViewInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        this.hGrid.childLayoutList = this.layout.children;
        if (this.layout.childColumns.length > 0 && !this.hGrid.autoGenerate) {
            this.hGrid.createColumnsList(this.layout.childColumns.toArray());
        }
        /** @type {?} */
        var layouts = this.hGrid.childLayoutList.toArray();
        layouts.forEach(function (l) { return _this.hGrid.hgridAPI.registerChildRowIsland(l); });
        this.parentGrid.hgridAPI.registerChildGrid(this.rowData.rowID, this.layout.key, this.hGrid);
        this.layout.rowIslandAPI.registerChildGrid(this.rowData.rowID, this.hGrid);
        this.hGrid.cdr.detectChanges();
    };
    /**
     * @private
     * @param {?} changes
     * @return {?}
     */
    IgxChildGridRowComponent.prototype._handleLayoutChanges = /**
     * @private
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        for (var change in changes) {
            if (changes.hasOwnProperty(change)) {
                this.hGrid[change] = changes[change].currentValue;
            }
        }
    };
    IgxChildGridRowComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-child-grid-row',
                    template: "<div class=\"igx-grid__hierarchical-indent\" [ngClass]=\"{'igx-grid__hierarchical-indent--scroll': parentHasScroll}\">\n    <igx-hierarchical-grid #hgrid></igx-hierarchical-grid>\n</div>\n"
                }] }
    ];
    /** @nocollapse */
    IgxChildGridRowComponent.ctorParameters = function () { return [
        { type: GridBaseAPIService },
        { type: IgxSelectionAPIService },
        { type: ElementRef },
        { type: ChangeDetectorRef }
    ]; };
    IgxChildGridRowComponent.propDecorators = {
        layout: [{ type: Input }],
        parentGridID: [{ type: Input }],
        rowData: [{ type: Input }],
        index: [{ type: Input }],
        hGrid: [{ type: ViewChild, args: ['hgrid',] }],
        tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
        role: [{ type: HostBinding, args: ['attr.role',] }],
        level: [{ type: HostBinding, args: ['attr.data-level',] }]
    };
    return IgxChildGridRowComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var NEXT_ID$o = 0;
var IgxHierarchicalGridComponent = /** @class */ (function (_super) {
    __extends(IgxHierarchicalGridComponent, _super);
    function IgxHierarchicalGridComponent(selectionService, crudService, colResizingService, gridAPI, selection, transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions) {
        var _this = _super.call(this, selectionService, crudService, gridAPI, selection, typeof transactionFactory === 'function' ? transactionFactory() : transactionFactory, elementRef, zone, document, cdr, resolver, differs, viewRef, navigation, filteringService, overlayService, summaryService, _displayDensityOptions) || this;
        _this.selectionService = selectionService;
        _this.colResizingService = colResizingService;
        _this.transactionFactory = transactionFactory;
        _this.document = document;
        _this.overlayService = overlayService;
        _this.summaryService = summaryService;
        _this._displayDensityOptions = _displayDensityOptions;
        /**
         * The custom template, if any, that should be used when rendering the row drag indicator icon
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.dragIndicatorIconTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-grid #grid>
         *      ...
         *      <ng-template igxDragIndicatorIcon>
         *          <igx-icon fontSet="material">info</igx-icon>
         *      </ng-template>
         *  </igx-grid>
         * ```
         */
        _this.dragIndicatorIconTemplate = null;
        /**
         * @hidden
         */
        _this.childLayoutKeys = [];
        /**
         * @hidden
         */
        _this.highlightedRowID = null;
        /**
         * @hidden
         */
        _this.updateOnRender = false;
        /**
         * @hidden
         */
        _this.parent = null;
        _this._hierarchicalState = [];
        _this._filteredData = null;
        _this.h_id = "igx-hierarchical-grid-" + NEXT_ID$o++;
        _this.childGridTemplates = new Map();
        _this.scrollTop = 0;
        _this.scrollLeft = 0;
        _this.hgridAPI = (/** @type {?} */ (gridAPI));
        return _this;
    }
    Object.defineProperty(IgxHierarchicalGridComponent.prototype, "id", {
        /**
         * Sets the value of the `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-hierarchical-grid [id]="'igx-hgrid-1'" [data]="Data" [autoGenerate]="true"></igx-hierarchical-grid>
         * ```
         * @memberof IgxHierarchicalGridComponent
         */
        get: /**
         * Sets the value of the `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-hierarchical-grid [id]="'igx-hgrid-1'" [data]="Data" [autoGenerate]="true"></igx-hierarchical-grid>
         * ```
         * \@memberof IgxHierarchicalGridComponent
         * @return {?}
         */
        function () {
            return this.h_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxHierarchicalGridComponent.prototype, "data", {
        /**
         * Returns an array of data set to the `IgxHierarchicalGridComponent`.
         * ```typescript
         * let filteredData = this.grid.filteredData;
         * ```
         * @memberof IgxHierarchicalGridComponent
         */
        get: /**
         * Returns an array of data set to the `IgxHierarchicalGridComponent`.
         * ```typescript
         * let filteredData = this.grid.filteredData;
         * ```
         * \@memberof IgxHierarchicalGridComponent
         * @return {?}
         */
        function () {
            return this._data;
        },
        /**
         * An @Input property that lets you fill the `IgxHierarchicalGridComponent` with an array of data.
         * ```html
         * <igx-hierarchical-grid [data]="Data" [autoGenerate]="true"></igx-hierarchical-grid>
         * ```
         * @memberof IgxHierarchicalGridComponent
         */
        set: /**
         * An \@Input property that lets you fill the `IgxHierarchicalGridComponent` with an array of data.
         * ```html
         * <igx-hierarchical-grid [data]="Data" [autoGenerate]="true"></igx-hierarchical-grid>
         * ```
         * \@memberof IgxHierarchicalGridComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var _this = this;
            this._data = value;
            if (this.parent) {
                this.calculateGridHeight();
            }
            this.summaryService.clearSummaryCache();
            if (this.shouldGenerate) {
                this.setupColumns();
                this.reflow();
            }
            this.cdr.markForCheck();
            if (this.parent && (this.height === null || this.height.indexOf('%') !== -1)) {
                // If the height will change based on how much data there is, recalculate sizes in igxForOf.
                requestAnimationFrame(function () {
                    _this.updateParentSizes();
                });
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxHierarchicalGridComponent.prototype, "hierarchicalState", {
        /**
        * Sets the state of the `IgxHierarchicalGridComponent` containing which rows are expanded.
        * ```typescript
        * this.gridState = [{ rowID: 1 }, { rowID: 4}];
        * ```
        * ```html
        * <igx-hierarchical-grid [primaryKey]="'ID'" [data]="Data" [autoGenerate]="false" [hierarchicalState]="hgridState">
        *      <igx-column field="ID"  [dataType]='number'></igx-column>
        *      <igx-column field="Product"  [dataType]='string'></igx-column>
        *      <igx-column field="Description"  [dataType]='string'></igx-column>
        * </igx-hierarchical-grid>
        * ```
        * @memberof IgxHierarchicalGridComponent
        */
        get: /**
         * Sets the state of the `IgxHierarchicalGridComponent` containing which rows are expanded.
         * ```typescript
         * this.gridState = [{ rowID: 1 }, { rowID: 4}];
         * ```
         * ```html
         * <igx-hierarchical-grid [primaryKey]="'ID'" [data]="Data" [autoGenerate]="false" [hierarchicalState]="hgridState">
         *      <igx-column field="ID"  [dataType]='number'></igx-column>
         *      <igx-column field="Product"  [dataType]='string'></igx-column>
         *      <igx-column field="Description"  [dataType]='string'></igx-column>
         * </igx-hierarchical-grid>
         * ```
         * \@memberof IgxHierarchicalGridComponent
         * @return {?}
         */
        function () {
            return this._hierarchicalState;
        },
        set: /**
         * @param {?} val
         * @return {?}
         */
        function (val) {
            var _this = this;
            this._hierarchicalState = val;
            if (this.parent) {
                requestAnimationFrame(function () {
                    _this.updateParentSizes();
                });
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxHierarchicalGridComponent.prototype, "filteredData", {
        /**
         * Returns an array of objects containing the filtered data in the `IgxHierarchicalGridComponent`.
         * ```typescript
         * let filteredData = this.grid.filteredData;
         * ```
         * @memberof IgxHierarchicalGridComponent
         */
        get: /**
         * Returns an array of objects containing the filtered data in the `IgxHierarchicalGridComponent`.
         * ```typescript
         * let filteredData = this.grid.filteredData;
         * ```
         * \@memberof IgxHierarchicalGridComponent
         * @return {?}
         */
        function () {
            return this._filteredData;
        },
        /**
         * Sets an array of objects containing the filtered data in the `IgxHierarchicalGridComponent`.
         * ```typescript
         * this.grid.filteredData = [{
         *       ID: 1,
         *       Name: "A"
         * }];
         * ```
         * @memberof IgxHierarchicalGridComponent
         */
        set: /**
         * Sets an array of objects containing the filtered data in the `IgxHierarchicalGridComponent`.
         * ```typescript
         * this.grid.filteredData = [{
         *       ID: 1,
         *       Name: "A"
         * }];
         * ```
         * \@memberof IgxHierarchicalGridComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._filteredData = value;
            if (this.rowSelectable) {
                this.updateHeaderCheckboxStatusOnFilter(this._filteredData);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxHierarchicalGridComponent.prototype, "expandChildren", {
        /**
         * Gets if all immediate children of the `IgxHierarchicalGridComponent` previously have been set to be expanded/collapsed.
         * If previously set and some rows have been manually expanded/collapsed it will still return the last set value.
         * ```typescript
         * const expanded = this.grid.expandChildren;
         * ```
         * @memberof IgxHierarchicalGridComponent
         */
        get: /**
         * Gets if all immediate children of the `IgxHierarchicalGridComponent` previously have been set to be expanded/collapsed.
         * If previously set and some rows have been manually expanded/collapsed it will still return the last set value.
         * ```typescript
         * const expanded = this.grid.expandChildren;
         * ```
         * \@memberof IgxHierarchicalGridComponent
         * @return {?}
         */
        function () {
            return this._expandChildren;
        },
        /**
         * Sets if all immediate children of the `IgxHierarchicalGridComponent` should be expanded/collapsed.
         * Defult value is false.
         * ```html
         * <igx-hierarchical-grid [id]="'igx-grid-1'" [data]="Data" [autoGenerate]="true" [expandChildren]="true"></igx-hierarchical-grid>
         * ```
         * @memberof IgxHierarchicalGridComponent
         */
        set: /**
         * Sets if all immediate children of the `IgxHierarchicalGridComponent` should be expanded/collapsed.
         * Defult value is false.
         * ```html
         * <igx-hierarchical-grid [id]="'igx-grid-1'" [data]="Data" [autoGenerate]="true" [expandChildren]="true"></igx-hierarchical-grid>
         * ```
         * \@memberof IgxHierarchicalGridComponent
         * @param {?} value
         * @return {?}
         */
        function (value) {
            var _this = this;
            this._expandChildren = value;
            if (value && this.data) {
                this.hierarchicalState = this.data.map(function (rec) {
                    return { rowID: _this.primaryKey ? rec[_this.primaryKey] : rec };
                });
            }
            else if (this.data) {
                this.hierarchicalState = [];
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxHierarchicalGridComponent.prototype, "foreignKey", {
        /**
         * Gets the unique identifier of the parent row. It may be a `string` or `number` if `primaryKey` of the
         * parent grid is set or an object reference of the parent record otherwise.
         * ```typescript
         * const foreignKey = this.grid.foreignKey;
         * ```
         * @memberof IgxHierarchicalGridComponent
         */
        get: /**
         * Gets the unique identifier of the parent row. It may be a `string` or `number` if `primaryKey` of the
         * parent grid is set or an object reference of the parent record otherwise.
         * ```typescript
         * const foreignKey = this.grid.foreignKey;
         * ```
         * \@memberof IgxHierarchicalGridComponent
         * @return {?}
         */
        function () {
            if (!this.parent) {
                return null;
            }
            return this.parent.hgridAPI.getParentRowId(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxHierarchicalGridComponent.prototype, "hasExpandableChildren", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return !!this.childLayoutKeys.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxHierarchicalGridComponent.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        this._transactions = this.parentIsland ? this.parentIsland.transactions : this._transactions;
        _super.prototype.ngOnInit.call(this);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxHierarchicalGridComponent.prototype.ngAfterViewInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        _super.prototype.ngAfterViewInit.call(this);
        this.verticalScrollContainer.getVerticalScroll().addEventListener('scroll', this.hg_verticalScrollHandler.bind(this));
        this.parentVirtDir.getHorizontalScroll().addEventListener('scroll', this.hg_horizontalScrollHandler.bind(this));
        if (this.expandChildren && this.data && this.hierarchicalState.length !== this.data.length) {
            this.hierarchicalState = this.data.map(function (rec) {
                return { rowID: _this.primaryKey ? rec[_this.primaryKey] : rec };
            });
        }
        this.verticalScrollContainer.onBeforeViewDestroyed.pipe(takeUntil(this.destroy$)).subscribe(function (view) {
            /** @type {?} */
            var rowData = view.context.$implicit;
            if (_this.isChildGridRecord(rowData)) {
                /** @type {?} */
                var cachedData = _this.childGridTemplates.get(rowData.rowID);
                if (cachedData) {
                    /** @type {?} */
                    var tmlpOutlet = cachedData.owner;
                    tmlpOutlet._viewContainerRef.detach(0);
                }
            }
        });
        if (this.parent) {
            this._displayDensity = this.rootGrid._displayDensity;
            this.rootGrid.onDensityChanged.pipe(takeUntil(this.destroy$)).subscribe(function () {
                requestAnimationFrame(function () {
                    _this._displayDensity = _this.rootGrid._displayDensity;
                    if (document.body.contains(_this.nativeElement)) {
                        _this.reflow();
                    }
                    else {
                        _this.updateOnRender = true;
                    }
                });
            });
            this.childLayoutKeys = this.parentIsland.children.map(function (item) { return item.key; });
        }
        else {
            this.childLayoutKeys = this.childLayoutList.map(function (item) { return item.key; });
            this.cdr.detectChanges();
        }
        this.toolbarCustomContentTemplates = this.parentIsland ?
            this.parentIsland.toolbarCustomContentTemplates :
            this.toolbarCustomContentTemplates;
    };
    Object.defineProperty(IgxHierarchicalGridComponent.prototype, "outletDirective", {
        get: /**
         * @return {?}
         */
        function () {
            return this.rootGrid._outletDirective;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxHierarchicalGridComponent.prototype, "parentRowOutletDirective", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this === this.rootGrid ? null : this.rootGrid.rowEditingOutletDirective;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxHierarchicalGridComponent.prototype.ngAfterContentInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.updateColumnList(false);
        _super.prototype.ngAfterContentInit.call(this);
    };
    /**
     * @protected
     * @param {?} change
     * @return {?}
     */
    IgxHierarchicalGridComponent.prototype.onColumnsChanged = /**
     * @protected
     * @param {?} change
     * @return {?}
     */
    function (change) {
        this.updateColumnList();
        _super.prototype.onColumnsChanged.call(this, change);
    };
    /**
     * @private
     * @param {?=} recalcColSizes
     * @return {?}
     */
    IgxHierarchicalGridComponent.prototype.updateColumnList = /**
     * @private
     * @param {?=} recalcColSizes
     * @return {?}
     */
    function (recalcColSizes) {
        var _this = this;
        if (recalcColSizes === void 0) { recalcColSizes = true; }
        /** @type {?} */
        var childLayouts = this.parent ? this.childLayoutList : this.allLayoutList;
        /** @type {?} */
        var nestedColumns = childLayouts.map(function (layout) {
            if (!layout.rootGrid && !_this.parent) {
                // If the layout doesn't have rootGrid set and this is the root, set it
                layout.rootGrid = _this;
            }
            return layout.columnList.toArray();
        });
        /** @type {?} */
        var colsArray = [].concat.apply([], nestedColumns);
        /** @type {?} */
        var colLength = this.columnList.length;
        if (colsArray.length > 0) {
            /** @type {?} */
            var topCols = this.columnList.filter(function (item) {
                return colsArray.indexOf(item) === -1;
            });
            this.columnList.reset(topCols);
            if (recalcColSizes && this.columnList.length !== colLength) {
                this.calculateGridSizes();
            }
        }
    };
    /**
     * @return {?}
     */
    IgxHierarchicalGridComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (!this.parent) {
            this.hgridAPI.getChildGrids(true).forEach(function (grid) {
                if (!grid.childRow.cdr.destroyed) {
                    grid.childRow.cdr.destroy();
                }
            });
        }
        _super.prototype.ngOnDestroy.call(this);
    };
    Object.defineProperty(IgxHierarchicalGridComponent.prototype, "template", {
        /**
        * @hidden
        */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            if (this.filteredData && this.filteredData.length === 0) {
                return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyFilteredGridTemplate;
            }
            if (this.isLoading && (!this.data || this.dataLength === 0)) {
                return this.loadingGridTemplate ? this.loadingGridTemplate : this.loadingGridDefaultTemplate;
            }
            if (this.dataLength === 0) {
                return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyGridDefaultTemplate;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     * Gets the combined width of the columns that are specific to the enabled grid features. They are fixed.
     * TODO: Remove for Angular 8. Calling parent class getter using super is not supported for now.
     */
    /**
     * @hidden
     * Gets the combined width of the columns that are specific to the enabled grid features. They are fixed.
     * TODO: Remove for Angular 8. Calling parent class getter using super is not supported for now.
     * @return {?}
     */
    IgxHierarchicalGridComponent.prototype.getFeatureColumnsWidth = /**
     * @hidden
     * Gets the combined width of the columns that are specific to the enabled grid features. They are fixed.
     * TODO: Remove for Angular 8. Calling parent class getter using super is not supported for now.
     * @return {?}
     */
    function () {
        /** @type {?} */
        var width = _super.prototype.getFeatureColumnsWidth.call(this);
        if (this.hasExpandableChildren) {
            width += this.headerHierarchyExpander.nativeElement.clientWidth || this.getDefaultExpanderWidth();
        }
        return width;
    };
    /**
     * @private
     * @return {?}
     */
    IgxHierarchicalGridComponent.prototype.getDefaultExpanderWidth = /**
     * @private
     * @return {?}
     */
    function () {
        switch (this.displayDensity) {
            case DisplayDensity.cosy:
                return 57;
            case DisplayDensity.compact:
                return 49;
            default:
                return 72;
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} rowData
     * @return {?}
     */
    IgxHierarchicalGridComponent.prototype.isRowHighlighted = /**
     * @hidden
     * @param {?} rowData
     * @return {?}
     */
    function (rowData) {
        return this.highlightedRowID === rowData.rowID;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} record
     * @return {?}
     */
    IgxHierarchicalGridComponent.prototype.isHierarchicalRecord = /**
     * @hidden
     * @param {?} record
     * @return {?}
     */
    function (record) {
        return this.childLayoutList.length !== 0 && record[this.childLayoutList.first.key];
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} record
     * @return {?}
     */
    IgxHierarchicalGridComponent.prototype.isChildGridRecord = /**
     * @hidden
     * @param {?} record
     * @return {?}
     */
    function (record) {
        // Can be null when there is defined layout but no child data was found
        return record.childGridsData !== undefined;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} index
     * @param {?} rec
     * @return {?}
     */
    IgxHierarchicalGridComponent.prototype.trackChanges = /**
     * @hidden
     * @param {?} index
     * @param {?} rec
     * @return {?}
     */
    function (index, rec) {
        if (rec.childGridsData !== undefined) {
            // if is child rec
            return rec.rowID;
        }
        return rec;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} rowData
     * @return {?}
     */
    IgxHierarchicalGridComponent.prototype.getContext = /**
     * @hidden
     * @param {?} rowData
     * @return {?}
     */
    function (rowData) {
        if (this.isChildGridRecord(rowData)) {
            /** @type {?} */
            var cachedData = this.childGridTemplates.get(rowData.rowID);
            if (cachedData) {
                /** @type {?} */
                var view = cachedData.view;
                /** @type {?} */
                var tmlpOutlet = cachedData.owner;
                return {
                    $implicit: rowData,
                    moveView: view,
                    owner: tmlpOutlet,
                    index: this.verticalScrollContainer.igxForOf.indexOf(rowData)
                };
            }
            else {
                /** @type {?} */
                var rowID = this.primaryKey ? rowData.rowID : this.data.indexOf(rowData.rowID);
                // child rows contain unique grids, hence should have unique templates
                return {
                    $implicit: rowData,
                    templateID: 'childRow-' + rowID,
                    index: this.verticalScrollContainer.igxForOf.indexOf(rowData)
                };
            }
        }
        else {
            return {
                $implicit: rowData,
                templateID: 'dataRow',
                index: this.verticalScrollContainer.igxForOf.indexOf(rowData)
            };
        }
    };
    Object.defineProperty(IgxHierarchicalGridComponent.prototype, "rootGrid", {
        /**
         * @hidden
        */
        get: /**
         * @hidden
         * @template THIS
         * @this {THIS}
         * @return {THIS}
         */
        function () {
            /** @type {?} */
            var currGrid = (/** @type {?} */ (this));
            while (currGrid.parent) {
                currGrid = currGrid.parent;
            }
            return currGrid;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
    */
    /**
     * @hidden
     * @protected
     * @param {?} collection
     * @param {?=} cb
     * @return {?}
     */
    IgxHierarchicalGridComponent.prototype.initColumns = /**
     * @hidden
     * @protected
     * @param {?} collection
     * @param {?=} cb
     * @return {?}
     */
    function (collection, cb) {
        if (cb === void 0) { cb = null; }
        if (this.hasColumnLayouts) {
            // invalid configuration - hierarchical grid should not allow column layouts
            // remove column layouts
            /** @type {?} */
            var nonColumnLayoutColumns = this.columnList.filter(function (col) { return !col.columnLayout && !(col.parent && col.parent.columnLayout); });
            this.columnList.reset(nonColumnLayoutColumns);
        }
        _super.prototype.initColumns.call(this, collection, cb);
    };
    /**
     * @hidden
     * Gets the visible content height that includes header + tbody + footer.
     * For hierarchical child grid it may be scrolled and not fully visible.
     */
    /**
     * @hidden
     * Gets the visible content height that includes header + tbody + footer.
     * For hierarchical child grid it may be scrolled and not fully visible.
     * @return {?}
     */
    IgxHierarchicalGridComponent.prototype.getVisibleContentHeight = /**
     * @hidden
     * Gets the visible content height that includes header + tbody + footer.
     * For hierarchical child grid it may be scrolled and not fully visible.
     * @return {?}
     */
    function () {
        /** @type {?} */
        var height = _super.prototype.getVisibleContentHeight.call(this);
        if (this.parent) {
            /** @type {?} */
            var rootHeight = this.rootGrid.getVisibleContentHeight();
            /** @type {?} */
            var topDiff = this.nativeElement.getBoundingClientRect().top - this.rootGrid.nativeElement.getBoundingClientRect().top;
            height = rootHeight - topDiff > height ? height : rootHeight - topDiff;
        }
        return height;
    };
    /**
     * @hidden
    */
    /**
     * @hidden
     * @return {?}
     */
    IgxHierarchicalGridComponent.prototype.collapseAllRows = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.hierarchicalState = [];
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} record
     * @return {?}
     */
    IgxHierarchicalGridComponent.prototype.isExpanded = /**
     * @hidden
     * @param {?} record
     * @return {?}
     */
    function (record) {
        var _this = this;
        /** @type {?} */
        var inState;
        if (record.childGridsData !== undefined) {
            inState = !!this.hierarchicalState.find(function (v) { return v.rowID === record.rowID; });
        }
        else {
            inState = !!this.hierarchicalState.find(function (v) {
                return _this.primaryKey ? v.rowID === record[_this.primaryKey] : v.rowID === record;
            });
        }
        return inState && this.childLayoutList.length !== 0;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} args
     * @return {?}
     */
    IgxHierarchicalGridComponent.prototype.viewCreatedHandler = /**
     * @hidden
     * @param {?} args
     * @return {?}
     */
    function (args) {
        if (this.isChildGridRecord(args.context.$implicit)) {
            /** @type {?} */
            var key = args.context.$implicit.rowID;
            this.childGridTemplates.set(key, args);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} args
     * @return {?}
     */
    IgxHierarchicalGridComponent.prototype.viewMovedHandler = /**
     * @hidden
     * @param {?} args
     * @return {?}
     */
    function (args) {
        var _this = this;
        if (this.isChildGridRecord(args.context.$implicit)) {
            // view was moved, update owner in cache
            /** @type {?} */
            var key = args.context.$implicit.rowID;
            /** @type {?} */
            var cachedData = this.childGridTemplates.get(key);
            cachedData.owner = args.owner;
            this.childLayoutList.forEach(function (layout) {
                /** @type {?} */
                var relatedGrid = _this.hgridAPI.getChildGridByID(layout.key, args.context.$implicit.rowID);
                if (relatedGrid && relatedGrid.updateOnRender) {
                    // Detect changes if `expandChildren` has changed when the grid wasn't visible. This is for performance reasons.
                    relatedGrid.reflow();
                    relatedGrid.updateOnRender = false;
                }
            });
            /** @type {?} */
            var childGrids = this.getChildGrids(true);
            childGrids.forEach(function (grid) {
                grid.updateScrollPosition();
            });
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxHierarchicalGridComponent.prototype.updateScrollPosition = /**
     * @hidden
     * @return {?}
     */
    function () {
        /** @type {?} */
        var vScr = this.verticalScrollContainer.getVerticalScroll();
        /** @type {?} */
        var hScr = this.parentVirtDir.getHorizontalScroll();
        if (vScr) {
            vScr.scrollTop = this.scrollTop;
        }
        if (hScr) {
            hScr.scrollLeft = this.scrollLeft;
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxHierarchicalGridComponent.prototype.getPossibleColumnWidth = /**
     * @hidden
     * @return {?}
     */
    function () {
        /** @type {?} */
        var computedWidth = this.calcWidth || parseInt(this.document.defaultView.getComputedStyle(this.nativeElement).getPropertyValue('width'), 10);
        computedWidth -= this.headerHierarchyExpander.nativeElement.clientWidth;
        return _super.prototype.getPossibleColumnWidth.call(this, computedWidth);
    };
    /**
     * @protected
     * @param {?=} inDeph
     * @return {?}
     */
    IgxHierarchicalGridComponent.prototype.getChildGrids = /**
     * @protected
     * @param {?=} inDeph
     * @return {?}
     */
    function (inDeph) {
        return this.hgridAPI.getChildGrids(inDeph);
    };
    /**
     * @protected
     * @param {?} data
     * @return {?}
     */
    IgxHierarchicalGridComponent.prototype.generateDataFields = /**
     * @protected
     * @param {?} data
     * @return {?}
     */
    function (data) {
        var _this = this;
        return _super.prototype.generateDataFields.call(this, data).filter(function (field) {
            /** @type {?} */
            var layoutsList = _this.parentIsland ? _this.parentIsland.children : _this.childLayoutList;
            /** @type {?} */
            var keys = layoutsList.map(function (item) { return item.key; });
            return keys.indexOf(field) === -1;
        });
    };
    /**
     * @protected
     * @return {?}
     */
    IgxHierarchicalGridComponent.prototype._calculateGridBodyHeight = /**
     * @protected
     * @return {?}
     */
    function () {
        if (!this.parent || !this.isPercentHeight) {
            return _super.prototype._calculateGridBodyHeight.call(this);
        }
        /** @type {?} */
        var bodyHeight = this.defaultTargetBodyHeight;
        return bodyHeight > 0 ? bodyHeight : null;
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    IgxHierarchicalGridComponent.prototype.hg_verticalScrollHandler = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.scrollTop = event.target.scrollTop;
    };
    /**
     * @return {?}
     */
    IgxHierarchicalGridComponent.prototype.onContainerScroll = /**
     * @return {?}
     */
    function () {
        this.hideOverlays();
    };
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    IgxHierarchicalGridComponent.prototype.hg_horizontalScrollHandler = /**
     * @private
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.scrollLeft = event.target.scrollLeft;
    };
    /**
     * @private
     * @return {?}
     */
    IgxHierarchicalGridComponent.prototype.updateParentSizes = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var currGrid = this.parent;
        while (currGrid) {
            /** @type {?} */
            var hadScrollbar = currGrid.hasVerticalSroll();
            /** @type {?} */
            var virt = currGrid.verticalScrollContainer;
            virt.recalcUpdateSizes();
            /** @type {?} */
            var offset = parseInt(virt.dc.instance._viewContainer.element.nativeElement.style.top, 10);
            /** @type {?} */
            var scr = virt.getVerticalScroll();
            scr.scrollTop = virt.getScrollForIndex(virt.state.startIndex) - offset;
            if (hadScrollbar !== currGrid.hasVerticalSroll()) {
                // If after recalculations the grid should show vertical scrollbar it should also reflow.
                currGrid.reflow();
            }
            currGrid = currGrid.parent;
        }
    };
    IgxHierarchicalGridComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-hierarchical-grid',
                    template: "<igx-grid-toolbar role=\"rowgroup\" [style.width.px]=\"outerWidth\" *ngIf=\"showToolbar\" [gridID]=\"id\" [displayDensity]=\"displayDensity\" #toolbar>\n</igx-grid-toolbar>\n\n<ng-template #defaultPager let-api>\n    <button [disabled]=\"api.isFirstPage\" (click)=\"api.paginate(0)\" igxButton=\"icon\" igxRipple igxRippleCentered=\"true\">\n        <igx-icon fontSet=\"material\">first_page</igx-icon>\n    </button>\n    <button [disabled]=\"api.isFirstPage\" (click)=\"api.previousPage()\" igxButton=\"icon\" igxRipple igxRippleCentered=\"true\">\n        <igx-icon fontSet=\"material\">chevron_left</igx-icon>\n    </button>\n    <span>{{ api.page + 1 }} of {{ api.totalPages }}</span>\n    <button [disabled]=\"api.isLastPage\" (click)=\"api.nextPage()\" igxRipple igxRippleCentered=\"true\" igxButton=\"icon\">\n        <igx-icon fontSet=\"material\">chevron_right</igx-icon>\n    </button>\n        <button [disabled]=\"api.isLastPage\" (click)=\"api.paginate(api.totalPages - 1)\" igxButton=\"icon\" igxRipple igxRippleCentered=\"true\">\n        <igx-icon fontSet=\"material\">last_page</igx-icon>\n    </button>\n    <select style=\"margin-left: 1rem;\" (change)=\"api.perPage = $event.target.value\">\n            <option [value]=\"val\" [selected]=\"api.perPage == val\" *ngFor=\"let val of [5, 10, 15, 25, 50, 100, 500]\">{{ val }}</option>\n    </select>\n</ng-template>\n\n<div class=\"igx-grid__thead\">\n    <div class=\"igx-grid__thead-wrapper\"  role=\"rowgroup\" [style.width.px]='calcWidth + 1' #theadRow>\n        <div class=\"igx-grid__tr\" role=\"row\" [style.width.px]='calcWidth + 1'>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"left\" class=\"igx-grid__scroll-on-drag-left\"></span>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"left\" class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n                <div class=\"igx-grid__hierarchical-expander igx-grid__hierarchical-expander--header\" #headerHierarchyExpander [hidden]='!hasExpandableChildren'[ngClass]=\"{\n                    'igx-grid__hierarchical-expander--push': filteringService.isFilterRowVisible,\n                    'igx-grid__hierarchical-expander--no-border': rowSelectable || rowDraggable\n                }\">\n                    <igx-icon role=\"button\" fontSet=\"material\" [isActive]='hierarchicalState.length > 0 && hasExpandableChildren' (click)=\"collapseAllRows()\">unfold_less</igx-icon>\n                </div>\n                <ng-container *ngIf=\"rowDraggable\">\n                    <div class=\"igx-grid__drag-indicator\" [ngClass]=\"{\n                        'igx-grid__drag-indicator--header': !rowSelectable\n                    }\" #headerDragContainer>\n                        <div style=\"visibility: hidden;\">\n                            <ng-container *ngTemplateOutlet=\"this.dragIndicatorIconTemplate ? this.dragIndicatorIconTemplate : this.dragIndicatorIconBase\"></ng-container>\n                        </div>\n                    </div>\n                </ng-container>\n                <ng-container *ngIf=\"showRowCheckboxes\">\n                    <div class=\"igx-grid__cbx-selection\" #headerCheckboxContainer [ngClass]=\"{\n                        'igx-grid__cbx-selection--push': filteringService.isFilterRowVisible\n                    }\">\n                        <igx-checkbox [checked]=\"allRowsSelected\" (change)=\"onHeaderCheckboxClick($event, filteredData)\" disableRipple=\"true\" [aria-label]=\"headerCheckboxAriaLabel\" #headerCheckbox></igx-checkbox>\n                    </div>\n                </ng-container>\n            <ng-container *ngIf=\"pinnedColumns.length > 0\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width.px]=\"getHeaderGroupWidth(col)\" [style.flex-basis.px]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n            <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\" [igxForScrollOrientation]=\"'horizontal'\" [igxForScrollContainer]=\"parentVirtDir\"\n                [igxForContainerSize]='unpinnedWidth' [igxForTrackBy]='trackColumnChanges'  [igxForSizePropName]='\"calcWidth\"' #headerContainer>\n                <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width.px]=\"getHeaderGroupWidth(col)\" [style.flex-basis.px]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n            </ng-template>\n        </div>\n        <igx-grid-filtering-row #filteringRow [style.width.px]='calcWidth' *ngIf=\"filteringService.isFilterRowVisible\" [column]=\"filteringService.filteredColumn\"></igx-grid-filtering-row>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div class=\"igx-grid__thead-thumb\" [hidden]='!hasVerticalSroll()' [style.width.px]=\"scrollWidth\"></div>\n</div>\n\n<div igxGridBody class=\"igx-grid__tbody\">\n    <div class=\"igx-grid__tbody-content\" (onDragStop)=\"selectionService.dragMode = $event\" (onDragScroll)=\"dragScroll($event)\" [igxGridDragSelect]=\"selectionService.dragMode\" role=\"rowgroup\" [style.height.px]='calcHeight' [style.width.px]='calcWidth + 1' #tbody (scroll)='scrollHandler($event)'>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"left\" class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"left\" class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n        <ng-template igxGridFor let-rowData [igxGridForOf]=\"data\n        | gridTransaction:id:pipeTrigger\n        | gridFiltering:filteringExpressionsTree:id:pipeTrigger\n        | gridSort:sortingExpressions:id:pipeTrigger\n        | gridHierarchicalPaging:page:perPage:id:pipeTrigger\n        | gridHierarchical:hierarchicalState:id:primaryKey:childLayoutKeys:pipeTrigger\"\n        let-rowIndex=\"index\" [igxForScrollOrientation]=\"'vertical'\"  [igxForScrollContainer]='verticalScroll'\n        [igxForContainerSize]='calcHeight' [igxForItemSize]=\"rowHeight\" [igxForTrackBy]='trackChanges' #verticalScrollContainer (onChunkPreload)=\"dataLoading($event)\">\n                <ng-template\n                [igxTemplateOutlet]='(isHierarchicalRecord(rowData) ? hierarchical_record_template : (isChildGridRecord(rowData) && isExpanded(rowData) ? child_record_template : hierarchical_record_template))'\n                [igxTemplateOutletContext]='getContext(rowData)'\n                (onViewCreated)='viewCreatedHandler($event)'\n                (onViewMoved)='viewMovedHandler($event)'\n                (onCachedViewLoaded)='cachedViewLoaded($event)'\n                ></ng-template>\n            <!-- <ng-container *igxTemplateOutlet=\"(isHierarchicalRecord(rowData) ? hierarchical_record_template : (isChildGridRecord(rowData) && isExpanded(rowData) ? child_record_template : hierarchical_record_template)); context: getContext(rowData)\"></ng-container> -->\n        </ng-template>\n        <ng-template #hierarchical_record_template let-rowIndex=\"index\" let-rowData>\n            <igx-hierarchical-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [rowData]=\"rowData\" #row>\n            </igx-hierarchical-grid-row>\n        </ng-template>\n        <ng-template #child_record_template let-rowIndex=\"index\" let-rowData>\n            <div style=\"overflow:auto;width: 100%;\" [attr.data-rowindex]='rowIndex' (scroll)='onContainerScroll()' [ngClass]=\"{\n                'igx-grid__tr-container': true,\n                'igx-grid__tr--highlighted':isRowHighlighted(rowData)\n            }\">\n                    <igx-child-grid-row *ngFor=\"let layout of childLayoutList\" [parentGridID]=\"id\" [index]=\"rowIndex\" [rowData]=\"rowData\" [layout]='layout' #row>\n                    </igx-child-grid-row>\n            </div>\n        </ng-template>\n        <ng-template #summary_template let-rowIndex=\"index\" let-rowData>\n            <igx-grid-summary-row [gridID]=\"id\" [summaries]=\"rowData.summaries\" [index]=\"rowIndex\" class=\"igx-grid__summaries--body\" #summaryRow>\n            </igx-grid-summary-row>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"template\"></ng-container>\n        <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n        <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"parentVirtDir\" [attr.droppable]=\"true\" id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div [hidden]='!hasVerticalSroll()' class=\"igx-grid__tbody-scrollbar\" [style.width.px]=\"scrollWidth\" [style.height.px]='calcHeight'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #verticalScrollHolder ></ng-template>\n    </div>\n</div>\n\n\n<div class=\"igx-grid__tfoot\" role=\"rowgroup\" [style.height.px]='summariesHeight' #tfoot>\n    <igx-grid-summary-row [style.width.px]='calcWidth' [style.height.px]='summariesHeight'\n        *ngIf=\"hasSummarizedColumns && rootSummariesEnabled\"\n        [gridID]=\"id\"\n        [summaries]=\"id | igxGridSummaryDataPipe:summaryService.retriggerRootPipe\"\n        [indentation]=\"hasExpandableChildren ? 1 : 0\"\n        [index]=\"0\"\n        class=\"igx-grid__summaries\"\n        #summaryRow>\n    </igx-grid-summary-row>\n    <div class=\"igx-grid__tfoot-thumb\" [hidden]='!hasVerticalSroll()' [style.height.px]='summariesHeight' [style.width.px]=\"scrollWidth\"></div>\n</div>\n\n<div class=\"igx-grid__scroll\" [style.height]=\"'18px'\" #scr [hidden]=\"unpinnedWidth - totalWidth >= 0\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]='pinnedWidth' [hidden]=\"pinnedWidth === 0\"></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]='unpinnedWidth'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #scrollContainer>\n        </ng-template>\n    </div>\n</div>\n\n<div class=\"igx-paginator igx-grid-paginator\" *ngIf=\"paging && totalRecords\" #paginator>\n    <ng-container *ngTemplateOutlet=\"paginationTemplate ? paginationTemplate : defaultPager; context: { $implicit: this }\">\n    </ng-container>\n</div>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyFilteredGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultLoadingGrid>\n    <div class=\"igx-grid__loading\">\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n</ng-template>\n\n\n<div *ngIf=\"rowEditable\" igxToggle>\n    <div [className]=\"bannerClass\">\n        <ng-container *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: endEdit.bind(this) }\"></ng-container>\n    </div>\n</div>\n<ng-template #defaultRowEditText>\n    You have {{ rowChangesCount }} changes in this row\n</ng-template>\n<ng-template #defaultRowEditActions>\n    <button igxButton igxRowEditTabStop (click)=\"endEdit(false, $event)\">Cancel</button>\n    <button igxButton igxRowEditTabStop (click)=\"endEdit(true, $event)\">Done</button>\n</ng-template>\n<ng-template #defaultRowEditTemplate>\n    <div class=\"igx-banner__message\">\n        <span class=\"igx-banner__text\">\n            <ng-container *ngTemplateOutlet=\"rowEditText ? rowEditText : defaultRowEditText; context: { $implicit: rowChangesCount }\"></ng-container>\n        </span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <ng-container *ngTemplateOutlet=\"rowEditActions ? rowEditActions : defaultRowEditActions; context: { $implicit: endEdit.bind(this) }\"></ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #dragIndicatorIconBase>\n    <igx-icon fontSet=\"material\">drag_indicator</igx-icon>\n</ng-template>\n\n<igx-grid-column-resizer *ngIf=\"colResizingService.showResizer\"></igx-grid-column-resizer>\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet></div>\n",
                    providers: [
                        IgxGridSelectionService,
                        IgxGridCRUDService,
                        { provide: GridBaseAPIService, useClass: IgxHierarchicalGridAPIService },
                        { provide: IgxGridBaseComponent, useExisting: forwardRef(function () { return IgxHierarchicalGridComponent; }) },
                        IgxGridSummaryService,
                        IgxFilteringService,
                        IgxHierarchicalGridNavigationService,
                        IgxForOfSyncService
                    ]
                }] }
    ];
    /** @nocollapse */
    IgxHierarchicalGridComponent.ctorParameters = function () { return [
        { type: IgxGridSelectionService },
        { type: IgxGridCRUDService },
        { type: IgxColumnResizingService },
        { type: GridBaseAPIService },
        { type: IgxHierarchicalSelectionAPIService },
        { type: undefined, decorators: [{ type: Inject, args: [IgxGridTransaction,] }] },
        { type: ElementRef },
        { type: NgZone },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: ChangeDetectorRef },
        { type: ComponentFactoryResolver },
        { type: IterableDiffers },
        { type: ViewContainerRef },
        { type: IgxHierarchicalGridNavigationService },
        { type: IgxFilteringService },
        { type: IgxOverlayService, decorators: [{ type: Inject, args: [IgxOverlayService,] }] },
        { type: IgxGridSummaryService },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DisplayDensityToken,] }] }
    ]; };
    IgxHierarchicalGridComponent.propDecorators = {
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        data: [{ type: Input }],
        hierarchicalState: [{ type: Input }],
        expandChildren: [{ type: Input }],
        childLayoutList: [{ type: ContentChildren, args: [IgxRowIslandComponent, { read: IgxRowIslandComponent, descendants: false },] }],
        allLayoutList: [{ type: ContentChildren, args: [IgxRowIslandComponent, { read: IgxRowIslandComponent, descendants: true },] }],
        dragIndicatorIconTemplate: [{ type: ContentChild, args: [IgxDragIndicatorIconDirective, { read: TemplateRef },] }],
        hierarchicalRecordTemplate: [{ type: ViewChild, args: ['hierarchical_record_template', { read: TemplateRef },] }],
        childTemplate: [{ type: ViewChild, args: ['child_record_template', { read: TemplateRef },] }],
        headerHierarchyExpander: [{ type: ViewChild, args: ['headerHierarchyExpander', { read: ElementRef },] }],
        templateOutlets: [{ type: ViewChildren, args: [IgxTemplateOutletDirective, { read: IgxTemplateOutletDirective },] }],
        hierarchicalRows: [{ type: ViewChildren, args: [IgxChildGridRowComponent, { read: IgxChildGridRowComponent },] }]
    };
    return IgxHierarchicalGridComponent;
}(IgxHierarchicalGridBaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxHierarchicalGridCellComponent = /** @class */ (function (_super) {
    __extends(IgxHierarchicalGridCellComponent, _super);
    function IgxHierarchicalGridCellComponent(selectionService, crudService, gridAPI, selection, cdr, helement, zone) {
        var _this = _super.call(this, selectionService, crudService, gridAPI, selection, cdr, helement, zone) || this;
        _this.selectionService = selectionService;
        _this.crudService = crudService;
        _this.gridAPI = gridAPI;
        _this.selection = selection;
        _this.cdr = cdr;
        _this.helement = helement;
        _this.zone = zone;
        _this.hSelection = (/** @type {?} */ (selection));
        return _this;
    }
    /**
     * @return {?}
     */
    IgxHierarchicalGridCellComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
        this._rootGrid = this._getRootGrid();
    };
    /**
     * @private
     * @return {?}
     */
    IgxHierarchicalGridCellComponent.prototype._getRootGrid = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var currGrid = this.grid;
        while (currGrid.parent) {
            currGrid = currGrid.parent;
        }
        return currGrid;
    };
    // TODO: Extend the new selection service to avoid complete traversal
    // TODO: Extend the new selection service to avoid complete traversal
    /**
     * @return {?}
     */
    IgxHierarchicalGridCellComponent.prototype._clearAllHighlights = 
    // TODO: Extend the new selection service to avoid complete traversal
    /**
     * @return {?}
     */
    function () {
        __spread([this._rootGrid], this._rootGrid.getChildGrids(true)).forEach(function (grid) {
            grid.selectionService.clear();
            grid.selectionService.activeElement = null;
            grid.nativeElement.classList.remove('igx-grid__tr--highlighted');
            grid.highlightedRowID = null;
            grid.cdr.markForCheck();
        });
    };
    /**
     * @return {?}
     */
    IgxHierarchicalGridCellComponent.prototype._updateCellSelectionStatus = /**
     * @return {?}
     */
    function () {
        this._clearAllHighlights();
        /** @type {?} */
        var currentElement = this.grid.nativeElement;
        /** @type {?} */
        var parentGrid = this.grid;
        /** @type {?} */
        var childGrid;
        // add highligh to the current grid
        if (this._rootGrid.id !== currentElement.id) {
            currentElement.classList.add('igx-grid__tr--highlighted');
        }
        // add highligh to the current grid
        while (this._rootGrid.id !== parentGrid.id) {
            childGrid = parentGrid;
            parentGrid = parentGrid.parent;
            /** @type {?} */
            var parentRowID = parentGrid.hgridAPI.getParentRowId(childGrid);
            parentGrid.highlightedRowID = parentRowID;
        }
        _super.prototype._updateCellSelectionStatus.call(this);
    };
    // TODO: Refactor
    // TODO: Refactor
    /**
     * @param {?} event
     * @return {?}
     */
    IgxHierarchicalGridCellComponent.prototype.dispatchEvent = 
    // TODO: Refactor
    /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        /** @type {?} */
        var key = event.key.toLowerCase();
        if (event.altKey) {
            /** @type {?} */
            var grid = this.gridAPI.grid;
            /** @type {?} */
            var state$$1 = this.gridAPI.grid.hierarchicalState;
            /** @type {?} */
            var collapse = this.row.expanded && (key === 'left' || key === 'arrowleft' || key === 'up' || key === 'arrowup');
            /** @type {?} */
            var expand = !this.row.expanded && (key === 'right' || key === 'arrowright' || key === 'down' || key === 'arrowdown');
            if (collapse) {
                grid.hierarchicalState = state$$1.filter(function (v) {
                    return v.rowID !== _this.row.rowID;
                });
            }
            else if (expand) {
                state$$1.push({ rowID: this.row.rowID });
                grid.hierarchicalState = __spread(state$$1);
            }
            if (expand || collapse) {
                /** @type {?} */
                var rowID = this.cellID.rowID;
                grid.cdr.detectChanges();
                this.persistFocusedCell(rowID);
            }
            return;
        }
        _super.prototype.dispatchEvent.call(this, event);
    };
    /**
     * @protected
     * @param {?} rowID
     * @return {?}
     */
    IgxHierarchicalGridCellComponent.prototype.persistFocusedCell = /**
     * @protected
     * @param {?} rowID
     * @return {?}
     */
    function (rowID) {
        var _this = this;
        requestAnimationFrame(function () {
            // TODO: Test it out
            /** @type {?} */
            var cell = _this.gridAPI.get_cell_by_key(rowID, _this.column.field);
            if (cell) {
                cell.nativeElement.focus();
            }
        });
    };
    IgxHierarchicalGridCellComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-hierarchical-grid-cell',
                    template: "<ng-template #defaultCell>\n    <div igxTextHighlight [cssClass]=\"highlightClass\" [activeCssClass]=\"activeHighlightClass\" [groupName]=\"gridID\"\n        [value]=\"formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal: grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value\"\n        [row]=\"rowData\" [column]=\"this.column.field\" [containerClass]=\"'igx-grid__td-text'\"\n        class=\"igx-grid__td-text\">{{ formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal:\n        grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value }}</div>\n</ng-template>\n<ng-template #inlineEditor let-cell=\"cell\">\n    <ng-container *ngIf=\"column.dataType === 'string'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [value]=\"editValue\" (input)=\"editValue = $event.target.value\" [igxFocus]=\"focused\" />\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'number'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [value]=\"editValue\" (input)=\"editValue = $event.target.value\" [igxFocus]=\"focused\" type=\"number\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'boolean'\">\n        <igx-checkbox (change)=\"editValue = $event.checked\" [value]=\"editValue\" [checked]=\"editValue\"\n            [igxFocus]=\"focused\" [disableRipple]=\"true\"></igx-checkbox>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'date'\">\n        <igx-date-picker [style.width.%]=\"100\" [outlet]=\"grid.outletDirective\" mode=\"dropdown\" (onSelection)=\"editValue = $event\"\n            [locale]=\"grid.locale\" [value]=\"editValue\" [igxFocus]=\"focused\" [labelVisibility]=\"false\">\n        </igx-date-picker>\n    </ng-container>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"template; context: context\">\n</ng-container>\n"
                }] }
    ];
    /** @nocollapse */
    IgxHierarchicalGridCellComponent.ctorParameters = function () { return [
        { type: IgxGridSelectionService },
        { type: IgxGridCRUDService },
        { type: GridBaseAPIService },
        { type: IgxHierarchicalSelectionAPIService },
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone }
    ]; };
    IgxHierarchicalGridCellComponent.propDecorators = {
        dispatchEvent: [{ type: HostListener, args: ['keydown', ['$event'],] }]
    };
    return IgxHierarchicalGridCellComponent;
}(IgxGridCellComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxHierarchicalRowComponent = /** @class */ (function (_super) {
    __extends(IgxHierarchicalRowComponent, _super);
    function IgxHierarchicalRowComponent(gridAPI, crudService, selectionService, hselection, element, cdr) {
        var _this = _super.call(this, gridAPI, crudService, selectionService, hselection, element, cdr) || this;
        _this.gridAPI = gridAPI;
        _this.crudService = crudService;
        _this.selectionService = selectionService;
        _this.hselection = hselection;
        _this.element = element;
        _this.cdr = cdr;
        /**
         * @hidden
         */
        _this.tabindex = 0;
        return _this;
    }
    Object.defineProperty(IgxHierarchicalRowComponent.prototype, "expanded", {
        /**
     * Returns whether the row is expanded.
     * ```typescript
     * const RowExpanded = this.grid1.rowList.first.expanded;
     * ```
     */
        get: /**
         * Returns whether the row is expanded.
         * ```typescript
         * const RowExpanded = this.grid1.rowList.first.expanded;
         * ```
         * @return {?}
         */
        function () {
            return this.grid.isExpanded(this.rowData);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxHierarchicalRowComponent.prototype, "hasChildren", {
        get: /**
         * @return {?}
         */
        function () {
            return !!this.grid.childLayoutKeys.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxHierarchicalRowComponent.prototype, "highlighted", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.grid && this.grid.highlightedRowID === this.rowID;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Toggles the hierarchical row.
     * ```typescript
     * this.grid1.rowList.first.toggle()
     * ```
     */
    /**
     * Toggles the hierarchical row.
     * ```typescript
     * this.grid1.rowList.first.toggle()
     * ```
     * @return {?}
     */
    IgxHierarchicalRowComponent.prototype.toggle = /**
     * Toggles the hierarchical row.
     * ```typescript
     * this.grid1.rowList.first.toggle()
     * ```
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.added) {
            return;
        }
        /** @type {?} */
        var grid = this.gridAPI.grid;
        /** @type {?} */
        var state$$1 = this.gridAPI.grid.hierarchicalState;
        if (!this.expanded) {
            state$$1.push({ rowID: this.rowID });
            grid.hierarchicalState = __spread(state$$1);
        }
        else {
            grid.hierarchicalState = state$$1.filter(function (v) {
                return v.rowID !== _this.rowID;
            });
        }
        grid.cdr.detectChanges();
        requestAnimationFrame(function () {
            grid.reflow();
        });
    };
    IgxHierarchicalRowComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    selector: 'igx-hierarchical-grid-row',
                    template: "<div (click)=\"toggle()\" class=\"igx-grid__hierarchical-expander\" [tabIndex]=\"tabindex\" *ngIf=\"hasChildren\" #expander>\n    <igx-icon *ngIf=\"!expanded\" [isActive]='!added' fontSet=\"material\">expand_more</igx-icon>\n    <igx-icon *ngIf=\"expanded\" [isActive]='!added' fontSet=\"material\">expand_less</igx-icon>\n</div>\n<ng-container *ngIf=\"rowDraggable\">\n    <div [class]=\"resolveDragIndicatorClasses\" [igxRowDrag]=\"this\">\n            <ng-container *ngTemplateOutlet=\"this.grid.dragIndicatorIconTemplate ? this.grid.dragIndicatorIconTemplate : this.grid.dragIndicatorIconBase\"></ng-container>\n    </div>\n</ng-container>\n<ng-container *ngIf=\"rowSelectable\">\n        <div class=\"igx-grid__cbx-selection\">\n            <igx-checkbox [checked]=\"isSelected\" (change)=\"onCheckboxClick($event)\" disableRipple=\"true\" [disableTransitions]=\"grid.disableTransitions\" [aria-label]=\"rowCheckboxAriaLabel\"></igx-checkbox>\n        </div>\n</ng-container>\n\n<ng-container *ngIf=\"pinnedColumns.length > 0\">\n    <igx-hierarchical-grid-cell *ngFor=\"let col of pinnedColumns | igxNotGrouped\"\n        class=\"igx-grid__td igx-grid__td--fw igx-grid__td--pinned\"\n        [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n        [ngClass]=\"col.cellClasses | igxCellStyles:rowData[col.field]:rowData:col.field\"\n        [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n        [column]=\"col\"\n        [formatter]=\"col.formatter\"\n        [row]=\"this\"\n        [lastPinned]=\"col.isLastPinned\"\n        [style.min-height.px]=\"grid.rowHeight || 32\"\n        [rowData]=\"rowData\"\n        [style.min-width.px]=\"col.width\"\n        [style.flex-basis.px]=\"col.width\"\n        [width]=\"col.getCellWidth()\"\n        [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"rowData[col.field]\"\n        [cellTemplate]=\"col.bodyTemplate\">\n    </igx-hierarchical-grid-cell>\n</ng-container>\n\n<ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxNotGrouped\" [igxForScrollContainer]=\"grid.parentVirtDir\" let-colIndex=\"index\" [igxForSizePropName]='\"calcWidth\"' [igxForScrollOrientation]=\"'horizontal'\" [igxForContainerSize]='grid.unpinnedWidth' [igxForTrackBy]='grid.trackColumnChanges' #igxDirRef>\n    <igx-hierarchical-grid-cell\n        class=\"igx-grid__td igx-grid__td--fw\"\n        [class.igx-grid__td--number]=\"col.dataType === 'number'\"\n        [ngClass]=\"col.cellClasses | igxCellStyles:rowData[col.field]:rowData:col.field\"\n        [editMode]=\"col.editable && crudService.isInEditMode(index, col.index)\"\n        [column]=\"col\"\n        [formatter]=\"col.formatter\"\n        [row]=\"this\"\n        [style.min-height.px]=\"grid.rowHeight || 32\"\n        [rowData]=\"rowData\"\n        [style.min-width.px]=\"col.width\"\n        [style.flex-basis.px]=\"col.width\"\n        [width]=\"col.getCellWidth()\"\n        [visibleColumnIndex]=\"col.visibleIndex\"\n        [value]=\"rowData[col.field]\"\n        [cellTemplate]=\"col.bodyTemplate\">\n    </igx-hierarchical-grid-cell>\n</ng-template>\n\n",
                    providers: [{ provide: IgxRowComponent, useExisting: forwardRef(function () { return IgxHierarchicalRowComponent; }) }]
                }] }
    ];
    /** @nocollapse */
    IgxHierarchicalRowComponent.ctorParameters = function () { return [
        { type: GridBaseAPIService },
        { type: IgxGridCRUDService },
        { type: IgxGridSelectionService },
        { type: IgxHierarchicalSelectionAPIService },
        { type: ElementRef },
        { type: ChangeDetectorRef }
    ]; };
    IgxHierarchicalRowComponent.propDecorators = {
        cells: [{ type: ViewChildren, args: [forwardRef(function () { return IgxHierarchicalGridCellComponent; }), { read: IgxHierarchicalGridCellComponent },] }],
        expander: [{ type: ViewChild, args: ['expander', { read: ElementRef },] }],
        tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
        expanded: [{ type: HostBinding, args: ['class.igx-grid__tr--expanded',] }],
        highlighted: [{ type: HostBinding, args: ['class.igx-grid__tr--highlighted',] }]
    };
    return IgxHierarchicalRowComponent;
}(IgxRowComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxGridHierarchicalPipe = /** @class */ (function () {
    function IgxGridHierarchicalPipe(gridAPI) {
        this.gridAPI = gridAPI;
    }
    /**
     * @param {?} collection
     * @param {?=} state
     * @param {?=} id
     * @param {?=} primaryKey
     * @param {?=} childKeys
     * @param {?=} pipeTrigger
     * @return {?}
     */
    IgxGridHierarchicalPipe.prototype.transform = /**
     * @param {?} collection
     * @param {?=} state
     * @param {?=} id
     * @param {?=} primaryKey
     * @param {?=} childKeys
     * @param {?=} pipeTrigger
     * @return {?}
     */
    function (collection, state$$1, id, primaryKey, childKeys, pipeTrigger) {
        if (state$$1 === void 0) { state$$1 = []; }
        if (childKeys.length === 0) {
            return collection;
        }
        /** @type {?} */
        var grid = this.gridAPI.grid;
        /** @type {?} */
        var result = this.addHierarchy(grid, cloneArray(collection), state$$1, primaryKey, childKeys);
        return result;
    };
    /**
     * @template T
     * @param {?} grid
     * @param {?} data
     * @param {?} state
     * @param {?} primaryKey
     * @param {?} childKeys
     * @return {?}
     */
    IgxGridHierarchicalPipe.prototype.addHierarchy = /**
     * @template T
     * @param {?} grid
     * @param {?} data
     * @param {?} state
     * @param {?} primaryKey
     * @param {?} childKeys
     * @return {?}
     */
    function (grid, data, state$$1, primaryKey, childKeys) {
        /** @type {?} */
        var result = [];
        data.forEach(function (v) {
            result.push(v);
            /** @type {?} */
            var childGridsData = {};
            childKeys.forEach(function (childKey) {
                /** @type {?} */
                var childData = v[childKey] ? v[childKey] : null;
                childGridsData[childKey] = childData;
            });
            if (grid.isExpanded(v)) {
                result.push({ rowID: primaryKey ? v[primaryKey] : v, childGridsData: childGridsData });
            }
        });
        return result;
    };
    IgxGridHierarchicalPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'gridHierarchical',
                    pure: true
                },] }
    ];
    /** @nocollapse */
    IgxGridHierarchicalPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };
    return IgxGridHierarchicalPipe;
}());
/**
 * @hidden
 */
var IgxGridHierarchicalPagingPipe = /** @class */ (function () {
    function IgxGridHierarchicalPagingPipe(gridAPI) {
        this.gridAPI = gridAPI;
    }
    /**
     * @param {?} collection
     * @param {?=} page
     * @param {?=} perPage
     * @param {?=} id
     * @param {?=} pipeTrigger
     * @return {?}
     */
    IgxGridHierarchicalPagingPipe.prototype.transform = /**
     * @param {?} collection
     * @param {?=} page
     * @param {?=} perPage
     * @param {?=} id
     * @param {?=} pipeTrigger
     * @return {?}
     */
    function (collection, page, perPage, id, pipeTrigger) {
        if (page === void 0) { page = 0; }
        if (perPage === void 0) { perPage = 15; }
        if (!this.gridAPI.grid.paging) {
            return collection;
        }
        /** @type {?} */
        var state$$1 = {
            index: page,
            recordsPerPage: perPage
        };
        /** @type {?} */
        var result = DataUtil.page(cloneArray(collection), state$$1);
        this.gridAPI.grid.pagingState = state$$1;
        return result;
    };
    IgxGridHierarchicalPagingPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'gridHierarchicalPaging',
                    pure: true
                },] }
    ];
    /** @nocollapse */
    IgxGridHierarchicalPagingPipe.ctorParameters = function () { return [
        { type: GridBaseAPIService }
    ]; };
    return IgxGridHierarchicalPagingPipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxHierarchicalGridModule = /** @class */ (function () {
    function IgxHierarchicalGridModule() {
    }
    IgxHierarchicalGridModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        IgxHierarchicalGridComponent,
                        IgxHierarchicalRowComponent,
                        IgxRowIslandComponent,
                        IgxChildGridRowComponent,
                        IgxHierarchicalGridCellComponent,
                        IgxGridHierarchicalPipe,
                        IgxGridHierarchicalPagingPipe
                    ],
                    exports: [
                        IgxGridModule,
                        IgxHierarchicalGridComponent,
                        IgxHierarchicalRowComponent,
                        IgxHierarchicalGridCellComponent,
                        IgxRowIslandComponent,
                        IgxChildGridRowComponent
                    ],
                    imports: [
                        CommonModule,
                        FormsModule,
                        IgxChipsModule,
                        IgxGridModule
                    ],
                    providers: [
                        IgxRowIslandAPIService,
                        IgxHierarchicalSelectionAPIService
                    ]
                },] }
    ];
    return IgxHierarchicalGridModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * IgxActionIcon is a container for the action nav icon of the IgxNavbar.
 */
var IgxActionIconDirective = /** @class */ (function () {
    function IgxActionIconDirective() {
    }
    IgxActionIconDirective.decorators = [
        { type: Directive, args: [{
                    // tslint:disable-next-line:directive-selector
                    selector: 'igx-action-icon'
                },] }
    ];
    return IgxActionIconDirective;
}());
/** @type {?} */
var NEXT_ID$p = 0;
/**
 * **Ignite UI for Angular Navbar** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/navbar.html)
 *
 * The Ignite UI Navbar is most commonly used to provide an app header with a hamburger menu and navigation
 * state such as a "Go Back" button. It also supports other actions represented by icons.
 *
 * Example:
 * ```html
 * <igx-navbar title="Sample App" actionButtonIcon="menu">
 *   <igx-icon>search</igx-icon>
 *   <igx-icon>favorite</igx-icon>
 *   <igx-icon>more_vert</igx-icon>
 * </igx-navbar>
 * ```
 */
var IgxNavbarComponent = /** @class */ (function () {
    function IgxNavbarComponent() {
        this.isVisible = true;
        /**
         * An \@Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-navbar [id]="'igx-navbar-12'" title="Sample App" actionButtonIcon="menu">
         * ```
         */
        this.id = "igx-navbar-" + NEXT_ID$p++;
        /**
         * The event that will be thrown when the action is executed,
         * provides reference to the `IgxNavbar` component as argument
         * ```typescript
         * public actionExc(event){
         *    alert("Action Execute!");
         * }
         * //..
         * ```
         * ```html
         * <igx-navbar (onAction)="actionExc($event)" title="Sample App" actionButtonIcon="menu">
         * ```
         */
        this.onAction = new EventEmitter();
        /**
         * An \@Input property that sets the titleId of the `IgxNavbarComponent`. If not set it will be automatically generated.
         * ```html
         * <igx-navbar [titleId]="'igx-navbar-7'" title="Sample App" actionButtonIcon="menu">
         * ```
         */
        this.titleId = "igx-navbar-" + IgxNavbarComponent.NEXT_ID++;
    }
    Object.defineProperty(IgxNavbarComponent.prototype, "isActionButtonVisible", {
        /**
         *Returns whether the `IgxNavbarComponent` action button is visible, true/false.
         *```typescript
         *@ViewChild("MyChild")
         *public navBar: IgxNavbarComponent;
         *ngAfterViewInit(){
         *    let actionButtonVisibile = this.navBar.isActionButtonVisible;
         *}
         *```
         */
        get: /**
         * Returns whether the `IgxNavbarComponent` action button is visible, true/false.
         * ```typescript
         * \@ViewChild("MyChild")
         * public navBar: IgxNavbarComponent;
         * ngAfterViewInit(){
         *    let actionButtonVisibile = this.navBar.isActionButtonVisible;
         * }
         * ```
         * @return {?}
         */
        function () {
            if (this.actionIconTemplate || !this.actionButtonIcon) {
                return false;
            }
            return this.isVisible;
        },
        /**
         *Sets whether the action button of the `IgxNavbarComponent` is visible.
         *```html
         *<igx-navbar [title]="currentView" [isActionButtonVisible]="'false'"></igx-navbar>
         *```
         */
        set: /**
         * Sets whether the action button of the `IgxNavbarComponent` is visible.
         * ```html
         * <igx-navbar [title]="currentView" [isActionButtonVisible]="'false'"></igx-navbar>
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.isVisible = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxNavbarComponent.prototype._triggerAction = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.onAction.emit(this);
    };
    IgxNavbarComponent.NEXT_ID = 1;
    IgxNavbarComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-navbar',
                    template: "<nav class=\"igx-navbar\" role=\"navigation\" [attr.aria-labelledby]=\"titleId\">\n    <div class=\"igx-navbar__left\">\n        <igx-icon (click)=\"_triggerAction()\" fontSet=\"material\" *ngIf=\"isActionButtonVisible\">{{actionButtonIcon}}</igx-icon>\n        <ng-content select=\"igx-action-icon\"></ng-content>\n        <h1 class=\"igx-navbar__title\" [attr.id]=\"titleId\">{{ title }}</h1>\n    </div>\n    <div class=\"igx-navbar__right\">\n        <ng-content></ng-content>\n    </div>\n</nav>\n",
                    styles: ["\n        :host {\n            display: block;\n        }\n    "]
                }] }
    ];
    IgxNavbarComponent.propDecorators = {
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        isActionButtonVisible: [{ type: Input }],
        actionButtonIcon: [{ type: Input }],
        title: [{ type: Input }],
        onAction: [{ type: Output }],
        titleId: [{ type: Input }],
        actionIconTemplate: [{ type: ContentChild, args: [IgxActionIconDirective, { read: IgxActionIconDirective },] }]
    };
    return IgxNavbarComponent;
}());
/**
 * @hidden
 */
var IgxNavbarModule = /** @class */ (function () {
    function IgxNavbarModule() {
    }
    IgxNavbarModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxNavbarComponent, IgxActionIconDirective],
                    exports: [IgxNavbarComponent, IgxActionIconDirective],
                    imports: [IgxButtonModule, IgxIconModule, CommonModule]
                },] }
    ];
    return IgxNavbarModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxNavDrawerItemDirective = /** @class */ (function () {
    function IgxNavDrawerItemDirective() {
        /**
         * @hidden
         */
        this.active = false;
        /**
         * @hidden
         */
        this.isHeader = false;
        /**
         * @hidden
         */
        this.activeClass = 'igx-nav-drawer__item--active';
    }
    Object.defineProperty(IgxNavDrawerItemDirective.prototype, "defaultCSS", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return !this.active && !this.isHeader;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavDrawerItemDirective.prototype, "currentCSS", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.active && !this.isHeader;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavDrawerItemDirective.prototype, "headerCSS", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.isHeader;
        },
        enumerable: true,
        configurable: true
    });
    IgxNavDrawerItemDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxDrawerItem]',
                    exportAs: 'igxDrawerItem'
                },] }
    ];
    IgxNavDrawerItemDirective.propDecorators = {
        active: [{ type: Input, args: ['active',] }],
        isHeader: [{ type: Input, args: ['isHeader',] }],
        defaultCSS: [{ type: HostBinding, args: ['class.igx-nav-drawer__item',] }],
        currentCSS: [{ type: HostBinding, args: ['class.igx-nav-drawer__item--active',] }],
        headerCSS: [{ type: HostBinding, args: ['class.igx-nav-drawer__item--header',] }]
    };
    return IgxNavDrawerItemDirective;
}());
var IgxNavDrawerTemplateDirective = /** @class */ (function () {
    function IgxNavDrawerTemplateDirective(template) {
        this.template = template;
    }
    IgxNavDrawerTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxDrawer]'
                },] }
    ];
    /** @nocollapse */
    IgxNavDrawerTemplateDirective.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return IgxNavDrawerTemplateDirective;
}());
var IgxNavDrawerMiniTemplateDirective = /** @class */ (function () {
    function IgxNavDrawerMiniTemplateDirective(template) {
        this.template = template;
    }
    IgxNavDrawerMiniTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxDrawerMini]'
                },] }
    ];
    /** @nocollapse */
    IgxNavDrawerMiniTemplateDirective.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return IgxNavDrawerMiniTemplateDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var NEXT_ID$q = 0;
/**
 * **Ignite UI for Angular Navigation Drawer** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/navdrawer.html)
 *
 * The Ignite UI Navigation Drawer is a collapsible side navigation container commonly used in combination with the Navbar.
 *
 * Example:
 * ```html
 * <igx-nav-drawer id="navigation" [isOpen]="true">
 *   <ng-template igxDrawer>
 *     <nav>
 *       <span igxDrawerItem [isHeader]="true">Email</span>
 *       <span igxDrawerItem igxRipple>Inbox</span>
 *       <span igxDrawerItem igxRipple>Deleted</span>
 *       <span igxDrawerItem igxRipple>Sent</span>
 *     </nav>
 *   </ng-template>
 * </igx-nav-drawer>
 * ```
 */
var IgxNavigationDrawerComponent = /** @class */ (function () {
    function IgxNavigationDrawerComponent(elementRef, _state, renderer, _touchManager) {
        var _this = this;
        this.elementRef = elementRef;
        this._state = _state;
        this.renderer = renderer;
        this._touchManager = _touchManager;
        this.cssClass = 'igx-nav-drawer';
        /**
         * ID of the component
         *
         * ```typescript
         * // get
         * let myNavDrawerId = this.navdrawer.id;
         * ```
         *
         * ```html
         * <!--set-->
         *  <igx-nav-drawer id='navdrawer'></igx-nav-drawer>
         * ```
         */
        this.id = "igx-nav-drawer-" + NEXT_ID$q++;
        /**
         * Position of the Navigation Drawer. Can be "left"(default) or "right".
         *
         * ```typescript
         * // get
         * let myNavDrawerPosition = this.navdrawer.position;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [position]="'left'"></igx-nav-drawer>
         * ```
         */
        this.position = 'left';
        /**
         * Enables the use of touch gestures to manipulate the drawer:
         * - swipe/pan from edge to open, swipe-toggle and pan-drag.
         *
         * ```typescript
         * // get
         * let gesturesEnabled = this.navdrawer.enableGestures;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [enableGestures]='true'></igx-nav-drawer>
         * ```
         */
        this.enableGestures = true;
        /**
         * State of the drawer.
         *
         * ```typescript
         * // get
         * let navDrawerIsOpen = this.navdrawer.isOpen;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [isOpen]='false'></igx-nav-drawer>
         * ```
         */
        this.isOpen = false;
        /**
         * When pinned the drawer is relatively positioned instead of sitting above content.
         * May require additional layout styling.
         *
         * ```typescript
         * // get
         * let navDrawerIsPinned = this.navdrawer.pin;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [pin]='false'></igx-nav-drawer>
         * ```
         */
        this.pin = false;
        /**
         * Minimum device width required for automatic pin to be toggled.
         * Default is 1024, can be set to a falsy value to disable this behavior.
         *
         * ```typescript
         * // get
         * let navDrawerPinTreshold = this.navdrawer.pinThreshold;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [pinTreshold]='1024'></igx-nav-drawer>
         * ```
         */
        this.pinThreshold = 1024;
        /**
         * Width of the drawer in its open state. Defaults to "280px".
         *
         * ```typescript
         * // get
         * let navDrawerWidth = this.navdrawer.width;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [width]="'228px'"></igx-nav-drawer>
         * ```
         */
        this.width = '280px';
        /**
         * Width of the drawer in its mini state. Defaults to 60px.
         *
         * ```typescript
         * // get
         * let navDrawerMiniWidth = this.navdrawer.miniWidth;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [miniWidth]="'34px'"></igx-nav-drawer>
         * ```
         */
        this.miniWidth = '60px';
        /**
         * Pinned state change output for two-way binding.
         *
         * ```html
         * <igx-nav-drawer [(pin)]='isPinned'></igx-nav-drawer>
         * ```
         */
        this.pinChange = new EventEmitter(true);
        /**
         * Event fired as the Navigation Drawer is about to open.
         *
         * ```html
         *  <igx-nav-drawer (opening)='onOpening()'></igx-nav-drawer>
         * ```
         */
        this.opening = new EventEmitter();
        /**
         * Event fired when the Navigation Drawer has opened.
         *
         * ```html
         * <igx-nav-drawer (opened)='onOpened()'></igx-nav-drawer>
         * ```
         */
        this.opened = new EventEmitter();
        /**
         * Event fired as the Navigation Drawer is about to close.
         *
         * ```html
         * <igx-nav-drawer (closing)='onClosing()'></igx-nav-drawer>
         * ```
         */
        this.closing = new EventEmitter();
        /**
         * Event fired when the Navigation Drawer has closed.
         *
         * ```html
         * <igx-nav-drawer (closed)='onClosed()'></igx-nav-drawer>
         * ```
         */
        this.closed = new EventEmitter();
        this._gesturesAttached = false;
        this._widthCache = { width: null, miniWidth: null, windowWidth: null };
        this.css = {
            drawer: 'igx-nav-drawer__aside',
            mini: 'igx-nav-drawer__aside--mini',
            overlay: 'igx-nav-drawer__overlay',
            styleDummy: 'igx-nav-drawer__style-dummy'
        };
        /**
         * Pan animation properties
         */
        this._panning = false;
        this._maxEdgeZone = 50;
        this.checkPinThreshold = function (evt) {
            /** @type {?} */
            var windowWidth;
            if (_this.pinThreshold) {
                windowWidth = _this.getWindowWidth();
                if (evt && _this._widthCache.windowWidth === windowWidth) {
                    return;
                }
                _this._widthCache.windowWidth = windowWidth;
                if (!_this.pin && windowWidth >= _this.pinThreshold) {
                    _this.pin = true;
                    _this.pinChange.emit(true);
                }
                else if (_this.pin && windowWidth < _this.pinThreshold) {
                    _this.pin = false;
                    _this.pinChange.emit(false);
                }
            }
        };
        this.swipe = function (evt) {
            // TODO: Could also force input type: http://stackoverflow.com/a/27108052
            if (!_this.enableGestures || evt.pointerType !== 'touch') {
                return;
            }
            // HammerJS swipe is horizontal-only by default, don't check deltaY
            /** @type {?} */
            var deltaX;
            /** @type {?} */
            var startPosition;
            if (_this.position === 'right') {
                // when on the right use inverse of deltaX
                deltaX = -evt.deltaX;
                startPosition = _this.getWindowWidth() - (evt.center.x + evt.distance);
            }
            else {
                deltaX = evt.deltaX;
                startPosition = evt.center.x - evt.distance;
            }
            // only accept closing swipe (ignoring minEdgeZone) when the drawer is expanded:
            if ((_this.isOpen && deltaX < 0) ||
                // positive deltaX from the edge:
                (deltaX > 0 && startPosition < _this.maxEdgeZone)) {
                _this.toggle();
            }
        };
        this.panstart = function (evt) {
            if (!_this.enableGestures || _this.pin || evt.pointerType !== 'touch') {
                return;
            }
            /** @type {?} */
            var startPosition = _this.position === 'right' ? _this.getWindowWidth() - (evt.center.x + evt.distance)
                : evt.center.x - evt.distance;
            // cache width during animation, flag to allow further handling
            if (_this.isOpen || (startPosition < _this.maxEdgeZone)) {
                _this._panning = true;
                _this._panStartWidth = _this.getExpectedWidth(!_this.isOpen);
                _this._panLimit = _this.getExpectedWidth(_this.isOpen);
                _this.renderer.setElementClass(_this.overlay, 'panning', true);
                _this.renderer.setElementClass(_this.drawer, 'panning', true);
            }
        };
        this.pan = function (evt) {
            // TODO: input.deltaX = prevDelta.x + (center.x - offset.x);
            // get actual delta (not total session one) from event?
            // pan WILL also fire after a full swipe, only resize on flag
            if (!_this._panning) {
                return;
            }
            /** @type {?} */
            var right = _this.position === 'right';
            // when on the right use inverse of deltaX
            /** @type {?} */
            var deltaX = right ? -evt.deltaX : evt.deltaX;
            /** @type {?} */
            var visibleWidth;
            /** @type {?} */
            var newX;
            /** @type {?} */
            var percent;
            visibleWidth = _this._panStartWidth + deltaX;
            if (_this.isOpen && deltaX < 0) {
                // when visibleWidth hits limit - stop animating
                if (visibleWidth <= _this._panLimit) {
                    return;
                }
                if (_this.hasAnimateWidth) {
                    percent = (visibleWidth - _this._panLimit) / (_this._panStartWidth - _this._panLimit);
                    newX = visibleWidth;
                }
                else {
                    percent = visibleWidth / _this._panStartWidth;
                    newX = evt.deltaX;
                }
                _this.setXSize(newX, percent.toPrecision(2));
            }
            else if (!_this.isOpen && deltaX > 0) {
                // when visibleWidth hits limit - stop animating
                if (visibleWidth >= _this._panLimit) {
                    return;
                }
                if (_this.hasAnimateWidth) {
                    percent = (visibleWidth - _this._panStartWidth) / (_this._panLimit - _this._panStartWidth);
                    newX = visibleWidth;
                }
                else {
                    percent = visibleWidth / _this._panLimit;
                    newX = (_this._panLimit - visibleWidth) * (right ? 1 : -1);
                }
                _this.setXSize(newX, percent.toPrecision(2));
            }
        };
        this.panEnd = function (evt) {
            if (_this._panning) {
                /** @type {?} */
                var deltaX = _this.position === 'right' ? -evt.deltaX : evt.deltaX;
                /** @type {?} */
                var visibleWidth = _this._panStartWidth + deltaX;
                _this.resetPan();
                // check if pan brought the drawer to 50%
                if (_this.isOpen && visibleWidth <= _this._panStartWidth / 2) {
                    _this.close();
                }
                else if (!_this.isOpen && visibleWidth >= _this._panLimit / 2) {
                    _this.open();
                }
                _this._panStartWidth = null;
            }
        };
        this.toggleOpenedEvent = function (evt) {
            _this.elementRef.nativeElement.removeEventListener('transitionend', _this.toggleOpenedEvent, false);
            _this.opened.emit();
        };
        this.toggleClosedEvent = function (evt) {
            _this.elementRef.nativeElement.removeEventListener('transitionend', _this.toggleClosedEvent, false);
            _this.closed.emit();
        };
    }
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "element", {
        /**
         * Returns nativeElement of the component.
         *
         * @hidden
         */
        get: /**
         * Returns nativeElement of the component.
         *
         * @hidden
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "template", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            if (this.miniTemplate && !this.isOpen) {
                return this.miniTemplate.template;
            }
            else if (this.contentTemplate) {
                return this.contentTemplate.template;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "miniTemplate", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._miniTemplate;
        },
        /**
         * @hidden
         */
        set: /**
         * @hidden
         * @param {?} v
         * @return {?}
         */
        function (v) {
            if (!this.isOpen) {
                this.setDrawerWidth(v ? this.miniWidth : '');
            }
            this._miniTemplate = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "flexWidth", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            if (!this.pin) {
                return '0px';
            }
            if (this.isOpen) {
                return this.width;
            }
            if (this.miniTemplate && this.miniWidth) {
                return this.miniWidth;
            }
            return '0px';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "isPinnedRight", {
        /** @hidden */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.pin && this.position === 'right' ? '1' : '0';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "drawer", {
        /**
          * @hidden
          */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._drawer.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "overlay", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._overlay.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "styleDummy", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._styleDummy.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "hasAnimateWidth", {
        /**
         * Property to decide whether to change width or translate the drawer from pan gesture.
         *
         * @hidden
         */
        get: /**
         * Property to decide whether to change width or translate the drawer from pan gesture.
         *
         * @hidden
         * @return {?}
         */
        function () {
            return this.pin || !!this.miniTemplate;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "maxEdgeZone", {
        /**
         * Used for touch gestures (swipe and pan).
         * Defaults to 50 (in px) and is extended to at least 110% of the mini template width if available.
         *
         * @hidden
         */
        get: /**
         * Used for touch gestures (swipe and pan).
         * Defaults to 50 (in px) and is extended to at least 110% of the mini template width if available.
         *
         * @hidden
         * @return {?}
         */
        function () {
            return this._maxEdgeZone;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "expectedWidth", {
        /**
         * Gets the Drawer width for specific state.
         * Will attempt to evaluate requested state and cache.
         *
         *
         * @hidden
         */
        get: /**
         * Gets the Drawer width for specific state.
         * Will attempt to evaluate requested state and cache.
         *
         *
         * @hidden
         * @return {?}
         */
        function () {
            return this.getExpectedWidth(false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "expectedMiniWidth", {
        /**
         * Get the Drawer mini width for specific state.
         * Will attempt to evaluate requested state and cache.
         *
         * @hidden
         */
        get: /**
         * Get the Drawer mini width for specific state.
         * Will attempt to evaluate requested state and cache.
         *
         * @hidden
         * @return {?}
         */
        function () {
            return this.getExpectedWidth(true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "touchManager", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._touchManager;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "state", {
        /**
         * Exposes optional navigation service
         *
         * @hidden
         */
        get: /**
         * Exposes optional navigation service
         *
         * @hidden
         * @return {?}
         */
        function () {
            return this._state;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        // DOM and @Input()-s initialized
        if (this._state) {
            this._state.add(this.id, this);
        }
        if (this.isOpen) {
            this.setDrawerWidth(this.width);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.ngAfterContentInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        // wait for template and ng-content to be ready
        this.updateEdgeZone();
        this.checkPinThreshold();
        this.ensureEvents();
        // TODO: apply platform-safe Ruler from http://plnkr.co/edit/81nWDyreYMzkunihfRgX?p=preview
        // (https://github.com/angular/angular/issues/6515), blocked by https://github.com/angular/angular/issues/6904
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        this._touchManager.destroy();
        if (this._state) {
            this._state.remove(this.id);
        }
        if (this._resizeObserver) {
            this._resizeObserver.unsubscribe();
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} changes
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.ngOnChanges = /**
     * @hidden
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        // simple settings can come from attribute set (rather than binding), make sure boolean props are converted
        if (changes.enableGestures && changes.enableGestures.currentValue !== undefined) {
            this.enableGestures = !!(this.enableGestures && this.enableGestures.toString() === 'true');
            this.ensureEvents();
        }
        if (changes.pin && changes.pin.currentValue !== undefined) {
            this.pin = !!(this.pin && this.pin.toString() === 'true');
            if (this.pin) {
                this._touchManager.destroy();
                this._gesturesAttached = false;
            }
            else {
                this.ensureEvents();
            }
        }
        if (changes.pinThreshold) {
            if (this.pinThreshold) {
                this.ensureEvents();
                this.checkPinThreshold();
            }
        }
        if (changes.width && this.isOpen) {
            this.setDrawerWidth(changes.width.currentValue);
        }
        if (changes.miniWidth) {
            if (!this.isOpen) {
                this.setDrawerWidth(changes.miniWidth.currentValue);
            }
            this.updateEdgeZone();
        }
    };
    /**
     * Toggle the open state of the Navigation Drawer.
     *
     * ```typescript
     * this.navdrawer.toggle();
     * ```
     */
    /**
     * Toggle the open state of the Navigation Drawer.
     *
     * ```typescript
     * this.navdrawer.toggle();
     * ```
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.toggle = /**
     * Toggle the open state of the Navigation Drawer.
     *
     * ```typescript
     * this.navdrawer.toggle();
     * ```
     * @return {?}
     */
    function () {
        if (this.isOpen) {
            this.close();
        }
        else {
            this.open();
        }
    };
    /**
     * Open the Navigation Drawer. Has no effect if already opened.
     *
     * ```typescript
     * this.navdrawer.open();
     * ```
     */
    /**
     * Open the Navigation Drawer. Has no effect if already opened.
     *
     * ```typescript
     * this.navdrawer.open();
     * ```
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.open = /**
     * Open the Navigation Drawer. Has no effect if already opened.
     *
     * ```typescript
     * this.navdrawer.open();
     * ```
     * @return {?}
     */
    function () {
        if (this._panning) {
            this.resetPan();
        }
        if (this.isOpen) {
            return;
        }
        this.opening.emit();
        this.isOpen = true;
        // TODO: Switch to animate API when available
        // var animationCss = this.animate.css();
        //     animationCss
        //         .setStyles({'width':'50px'}, {'width':'400px'})
        //         .start(this.elementRef.nativeElement)
        //         .onComplete(() => animationCss.setToStyles({'width':'auto'}).start(this.elementRef.nativeElement));
        this.elementRef.nativeElement.addEventListener('transitionend', this.toggleOpenedEvent, false);
        this.setDrawerWidth(this.width);
    };
    /**
     * Close the Navigation Drawer. Has no effect if already closed.
     *
     * ```typescript
     * this.navdrawer.close();
     * ```
     */
    /**
     * Close the Navigation Drawer. Has no effect if already closed.
     *
     * ```typescript
     * this.navdrawer.close();
     * ```
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.close = /**
     * Close the Navigation Drawer. Has no effect if already closed.
     *
     * ```typescript
     * this.navdrawer.close();
     * ```
     * @return {?}
     */
    function () {
        if (this._panning) {
            this.resetPan();
        }
        if (!this.isOpen) {
            return;
        }
        this.closing.emit();
        this.isOpen = false;
        this.setDrawerWidth(this.miniTemplate ? this.miniWidth : '');
        this.elementRef.nativeElement.addEventListener('transitionend', this.toggleClosedEvent, false);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} value
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.set_maxEdgeZone = /**
     * @hidden
     * @protected
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this._maxEdgeZone = value;
    };
    /**
     * Get the Drawer width for specific state. Will attempt to evaluate requested state and cache.
     *
     * @hidden
     * @param [mini] - Request mini width instead
     */
    /**
     * Get the Drawer width for specific state. Will attempt to evaluate requested state and cache.
     *
     * @hidden
     * @protected
     * @param {?=} mini
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.getExpectedWidth = /**
     * Get the Drawer width for specific state. Will attempt to evaluate requested state and cache.
     *
     * @hidden
     * @protected
     * @param {?=} mini
     * @return {?}
     */
    function (mini) {
        if (mini) {
            if (!this.miniTemplate) {
                return 0;
            }
            if (this.miniWidth) {
                return parseFloat(this.miniWidth);
            }
            else {
                // if (!this.isOpen) { // This WON'T work due to transition timings...
                //     return this.elementRef.nativeElement.children[1].offsetWidth;
                // } else {
                if (this._widthCache.miniWidth === null) {
                    // force class for width calc. TODO?
                    this.renderer.setElementClass(this.styleDummy, this.css.drawer, true);
                    this.renderer.setElementClass(this.styleDummy, this.css.mini, true);
                    this._widthCache.miniWidth = this.styleDummy.offsetWidth;
                    this.renderer.setElementClass(this.styleDummy, this.css.drawer, false);
                    this.renderer.setElementClass(this.styleDummy, this.css.mini, false);
                }
                return this._widthCache.miniWidth;
            }
        }
        else {
            if (this.width) {
                return parseFloat(this.width);
            }
            else {
                if (this._widthCache.width === null) {
                    // force class for width calc. TODO?
                    this.renderer.setElementClass(this.styleDummy, this.css.drawer, true);
                    this._widthCache.width = this.styleDummy.offsetWidth;
                    this.renderer.setElementClass(this.styleDummy, this.css.drawer, false);
                }
                return this._widthCache.width;
            }
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.getWindowWidth = /**
     * @private
     * @return {?}
     */
    function () {
        return (window.innerWidth > 0) ? window.innerWidth : screen.width;
    };
    /**
     * Sets the drawer width.
     */
    /**
     * Sets the drawer width.
     * @private
     * @param {?} width
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.setDrawerWidth = /**
     * Sets the drawer width.
     * @private
     * @param {?} width
     * @return {?}
     */
    function (width) {
        var _this = this;
        window.requestAnimationFrame(function () {
            if (_this.drawer) {
                _this.renderer.setElementStyle(_this.drawer, 'width', width);
            }
        });
    };
    /**
     * Get current Drawer width.
     */
    /**
     * Get current Drawer width.
     * @private
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.getDrawerWidth = /**
     * Get current Drawer width.
     * @private
     * @return {?}
     */
    function () {
        return this.drawer.offsetWidth;
    };
    /**
     * @private
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.ensureEvents = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        // set listeners for swipe/pan only if needed, but just once
        if (this.enableGestures && !this.pin && !this._gesturesAttached) {
            // Built-in manager handler(L20887) causes endless loop and max stack exception.
            // https://github.com/angular/angular/issues/6993
            // Use ours for now (until beta.10):
            // this.renderer.listen(document, "swipe", this.swipe);
            this._touchManager.addGlobalEventListener('document', 'swipe', this.swipe);
            this._gesturesAttached = true;
            // this.renderer.listen(document, "panstart", this.panstart);
            // this.renderer.listen(document, "pan", this.pan);
            this._touchManager.addGlobalEventListener('document', 'panstart', this.panstart);
            this._touchManager.addGlobalEventListener('document', 'panmove', this.pan);
            this._touchManager.addGlobalEventListener('document', 'panend', this.panEnd);
        }
        if (!this._resizeObserver) {
            this._resizeObserver = fromEvent(window, 'resize').pipe(debounce(function () { return interval(150); }))
                .subscribe(function (value) {
                _this.checkPinThreshold(value);
            });
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.updateEdgeZone = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var maxValue;
        if (this.miniTemplate) {
            maxValue = Math.max(this._maxEdgeZone, this.getExpectedWidth(true) * 1.1);
            this.set_maxEdgeZone(maxValue);
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.resetPan = /**
     * @private
     * @return {?}
     */
    function () {
        this._panning = false;
        /* styles fail to apply when set on parent due to extra attributes, prob ng bug */
        this.renderer.setElementClass(this.overlay, 'panning', false);
        this.renderer.setElementClass(this.drawer, 'panning', false);
        this.setXSize(0, '');
    };
    /**
     * Sets the absolute position or width in case the drawer doesn't change position.
     * @param x the number pixels to translate on the X axis or the width to set. 0 width will clear the style instead.
     * @param opacity optional value to apply to the overlay
     */
    /**
     * Sets the absolute position or width in case the drawer doesn't change position.
     * @private
     * @param {?} x the number pixels to translate on the X axis or the width to set. 0 width will clear the style instead.
     * @param {?=} opacity optional value to apply to the overlay
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.setXSize = /**
     * Sets the absolute position or width in case the drawer doesn't change position.
     * @private
     * @param {?} x the number pixels to translate on the X axis or the width to set. 0 width will clear the style instead.
     * @param {?=} opacity optional value to apply to the overlay
     * @return {?}
     */
    function (x, opacity) {
        var _this = this;
        // Angular polyfills patches window.requestAnimationFrame, but switch to DomAdapter API (TODO)
        window.requestAnimationFrame(function () {
            if (_this.hasAnimateWidth) {
                _this.renderer.setElementStyle(_this.drawer, 'width', x ? Math.abs(x) + 'px' : '');
            }
            else {
                _this.renderer.setElementStyle(_this.drawer, 'transform', x ? 'translate3d(' + x + 'px,0,0)' : '');
                _this.renderer.setElementStyle(_this.drawer, '-webkit-transform', x ? 'translate3d(' + x + 'px,0,0)' : '');
            }
            if (opacity !== undefined) {
                _this.renderer.setElementStyle(_this.overlay, 'opacity', opacity);
            }
        });
    };
    IgxNavigationDrawerComponent.decorators = [
        { type: Component, args: [{
                    providers: [HammerGesturesManager],
                    selector: 'igx-nav-drawer',
                    template: "<ng-template #defaultItemsTemplate>\n    <div igxDrawerItem [isHeader]=\"true\">Navigation Drawer</div>\n    <div igxDrawerItem> Start by adding</div>\n    <div igxDrawerItem> <code>&lt;ng-template igxDrawer&gt;</code> </div>\n    <div igxDrawerItem> And some items inside </div>\n    <div igxDrawerItem> Style with igxDrawerItem </div>\n    <div igxDrawerItem> and igxRipple directives</div>\n</ng-template>\n\n<div [hidden]=\"pin\"\n    class=\"igx-nav-drawer__overlay\"\n    [class.igx-nav-drawer__overlay--hidden]=\"!isOpen\"\n    (click)=\"close()\" #overlay>\n</div>\n<aside role=\"navigation\"\n    class=\"igx-nav-drawer__aside\"\n    [class.igx-nav-drawer__aside--collapsed]=\"!miniTemplate && !isOpen\"\n    [class.igx-nav-drawer__aside--mini]=\"miniTemplate && !isOpen\"\n    [class.igx-nav-drawer__aside--normal]=\"!miniTemplate || isOpen\"\n    [class.igx-nav-drawer__aside--pinned]=\"pin\"\n    [class.igx-nav-drawer__aside--right]=\"position == 'right'\" #aside>\n\n    <ng-container *ngTemplateOutlet=\"template || defaultItemsTemplate\"></ng-container>\n</aside>\n<div class=\"igx-nav-drawer__style-dummy\" #dummy></div>\n",
                    styles: ["\n        :host {\n            display: block;\n            height: 100%;\n        }\n    "]
                }] }
    ];
    /** @nocollapse */
    IgxNavigationDrawerComponent.ctorParameters = function () { return [
        { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
        { type: IgxNavigationService, decorators: [{ type: Optional }] },
        { type: Renderer },
        { type: HammerGesturesManager }
    ]; };
    IgxNavigationDrawerComponent.propDecorators = {
        cssClass: [{ type: HostBinding, args: ['class',] }],
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        position: [{ type: Input }],
        enableGestures: [{ type: Input }],
        isOpen: [{ type: Input }],
        pin: [{ type: Input }],
        pinThreshold: [{ type: Input }],
        width: [{ type: Input }],
        miniWidth: [{ type: Input }],
        pinChange: [{ type: Output }],
        opening: [{ type: Output }],
        opened: [{ type: Output }],
        closing: [{ type: Output }],
        closed: [{ type: Output }],
        miniTemplate: [{ type: ContentChild, args: [IgxNavDrawerMiniTemplateDirective, { read: IgxNavDrawerMiniTemplateDirective },] }],
        contentTemplate: [{ type: ContentChild, args: [IgxNavDrawerTemplateDirective, { read: IgxNavDrawerTemplateDirective },] }],
        flexWidth: [{ type: HostBinding, args: ['style.flexBasis',] }],
        isPinnedRight: [{ type: HostBinding, args: ['style.order',] }],
        _drawer: [{ type: ViewChild, args: ['aside',] }],
        _overlay: [{ type: ViewChild, args: ['overlay',] }],
        _styleDummy: [{ type: ViewChild, args: ['dummy',] }]
    };
    return IgxNavigationDrawerComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxNavigationDrawerModule = /** @class */ (function () {
    function IgxNavigationDrawerModule() {
    }
    IgxNavigationDrawerModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        IgxNavigationDrawerComponent,
                        IgxNavDrawerItemDirective,
                        IgxNavDrawerMiniTemplateDirective,
                        IgxNavDrawerTemplateDirective
                    ],
                    exports: [
                        IgxNavigationDrawerComponent,
                        IgxNavDrawerItemDirective,
                        IgxNavDrawerMiniTemplateDirective,
                        IgxNavDrawerTemplateDirective
                    ],
                    imports: [CommonModule]
                },] }
    ];
    return IgxNavigationDrawerModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
var SliderType = {
    /**
     * Slider with single thumb.
     */
    SLIDER: 0,
    /**
     *  Range slider with multiple thumbs, that can mark the range.
     */
    RANGE: 1,
};
SliderType[SliderType.SLIDER] = 'SLIDER';
SliderType[SliderType.RANGE] = 'RANGE';
/** @enum {number} */
var SliderHandle = {
    FROM: 0,
    TO: 1,
};
SliderHandle[SliderHandle.FROM] = 'FROM';
SliderHandle[SliderHandle.TO] = 'TO';
/** @type {?} */
var noop$5 = function () {
};
/** @type {?} */
var NEXT_ID$r = 0;
/**
 * **Ignite UI for Angular Slider** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/slider.html)
 *
 * The Ignite UI Slider allows selection in a given range by moving the thumb along the track. The track
 * can be defined as continuous or stepped, and you can choose between single and range slider types.
 *
 * Example:
 * ```html
 * <igx-slider id="slider"
 *            [minValue]="0" [maxValue]="100"
 *            [isContinuous]=true [(ngModel)]="volume">
 * </igx-slider>
 * ```
 */
var IgxSliderComponent = /** @class */ (function () {
    function IgxSliderComponent(renderer) {
        this.renderer = renderer;
        /**
         * An \@Input property that sets the value of the `id` attribute.
         * If not provided it will be automatically generated.
         * ```html
         * <igx-slider [id]="'igx-slider-32'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
         * ```
         */
        this.id = "igx-slider-" + NEXT_ID$r++;
        /**
         * An \@Input property that marks the `IgxSliderComponent` as continuous.
         * By default is considered that the `IgxSliderComponent` is discrete.
         * Discrete `IgxSliderComponent` does not have ticks and does not shows bubble labels for values.
         * ```html
         * <igx-slider #slider [isContinuous]="'true'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
         * ```
         */
        this.isContinuous = false;
        /**
         * An \@Input property that sets the type of the `IgxSliderComponent`. The slider can be SliderType.SLIDER(default) or SliderType.RANGE.
         * ```typescript
         * sliderType: SliderType = SliderType.RANGE;
         * //...
         * ```
         * ```html
         * <igx-slider #slider2 [type]="sliderType" [(ngModel)]="rangeValue" [minValue]="0" [maxValue]="100">
         * ```
         */
        this.type = SliderType.SLIDER;
        /**
         * An \@Input property that sets the duration visibility of thumbs labels. The default value is 750 milliseconds.
         * ```html
         * <igx-slider #slider [thumbLabelVisibilityDuration]="3000" [(ngModel)]="task.percentCompleted" [step]="5">
         * ```
         */
        this.thumbLabelVisibilityDuration = 750;
        /**
         * An \@Input property that sets the incremental/decremental step of the value when dragging the thumb.
         * The default step is 1, and step should not be less or equal than 0.
         * ```html
         * <igx-slider #slider [(ngModel)]="task.percentCompleted" [step]="5">
         * ```
         */
        this.step = 1;
        /**
         * This event is emitted when user has stopped interacting the thumb and value is changed.
         * ```typescript
         * public change(event){
         *    alert("The value has been changed!");
         * }
         * ```
         * ```html
         * <igx-slider (onValueChange)="change($event)" #slider [(ngModel)]="task.percentCompleted" [step]="5">
         * ```
         */
        this.onValueChange = new EventEmitter();
        /**
         * @hidden
         */
        this.isActiveLabel = false;
        this.activeHandle = SliderHandle.TO;
        // Measures & Coordinates
        this.width = 0;
        this.xOffset = 0;
        this.xPointer = 0;
        this.pPointer = 0;
        // Limit handle travel zone
        this.pMin = 0;
        this.pMax = 1;
        // From/upperValue in percent values
        this.hasViewInit = false;
        this._minValue = 0;
        this._maxValue = 100;
        this._onChangeCallback = noop$5;
        this._onTouchedCallback = noop$5;
    }
    Object.defineProperty(IgxSliderComponent.prototype, "isRange", {
        /**
         *Returns whether the `IgxSliderComponent` type is RANGE.
         *```typescript
         *@ViewChild("slider")
         *public slider: IgxSliderComponent;
         *ngAfterViewInit(){
         *    let sliderRange = this.slider.isRange;
         *}
         * ```
         */
        get: /**
         * Returns whether the `IgxSliderComponent` type is RANGE.
         * ```typescript
         * \@ViewChild("slider")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *    let sliderRange = this.slider.isRange;
         * }
         * ```
         * @return {?}
         */
        function () {
            /** @type {?} */
            var isRange = this.type === SliderType.RANGE;
            return isRange;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "maxValue", {
        /**
         * Returns the maximum value for the `IgxSliderComponent`.
         * ```typescript
         *@ViewChild("slider")
         *public slider: IgxSliderComponent;
         *ngAfterViewInit(){
         *    let sliderMax = this.slider.maxValue;
         *}
         * ```
         */
        get: /**
         * Returns the maximum value for the `IgxSliderComponent`.
         * ```typescript
         * \@ViewChild("slider")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *    let sliderMax = this.slider.maxValue;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this._maxValue;
        },
        /**
         * Sets the maximal value for the `IgxSliderComponent`.
         * The default maximum value is 100.
         * ```html
         * <igx-slider [type]="sliderType" [minValue]="56" [maxValue]="256">
         * ```
         */
        set: /**
         * Sets the maximal value for the `IgxSliderComponent`.
         * The default maximum value is 100.
         * ```html
         * <igx-slider [type]="sliderType" [minValue]="56" [maxValue]="256">
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value <= this._minValue) {
                this._maxValue = this._minValue + 1;
            }
            else {
                this._maxValue = value;
            }
            if (this._trackUpperBound) {
                this._upperBound = this._maxValue;
            }
            this.invalidateValue();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "minValue", {
        /**
         *Returns the minimal value of the `IgxSliderComponent`.
         *```typescript
         *@ViewChild("slider2")
         *public slider: IgxSliderComponent;
         *ngAfterViewInit(){
         *    let sliderMin = this.slider.minValue;
         *}
         *```
         */
        get: /**
         * Returns the minimal value of the `IgxSliderComponent`.
         * ```typescript
         * \@ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *    let sliderMin = this.slider.minValue;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this._minValue;
        },
        /**
         * Sets the minimal value for the `IgxSliderComponent`.
         * The default minimal value is 0.
         * ```html
         * <igx-slider [type]="sliderType" [minValue]="56" [maxValue]="100">
         * ```
         */
        set: /**
         * Sets the minimal value for the `IgxSliderComponent`.
         * The default minimal value is 0.
         * ```html
         * <igx-slider [type]="sliderType" [minValue]="56" [maxValue]="100">
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value >= this.maxValue) {
                this._minValue = this.maxValue - 1;
            }
            else {
                this._minValue = value;
            }
            if (this._trackLowerBound) {
                this._lowerBound = this._minValue;
            }
            this.invalidateValue();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "lowerBound", {
        /**
         * Returns the lower boundary of the `IgxSliderComponent`.
         *```typescript
         *@ViewChild("slider")
         *public slider: IgxSliderComponent;
         *ngAfterViewInit(){
         *    let sliderLowBound = this.slider.lowerBound;
         *}
         *```
         */
        get: /**
         * Returns the lower boundary of the `IgxSliderComponent`.
         * ```typescript
         * \@ViewChild("slider")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *    let sliderLowBound = this.slider.lowerBound;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this._lowerBound;
        },
        /**
         * Sets the lower boundary of the `IgxSliderComponent`.
         * If not set is the same as min value.
         * ```html
         * <igx-slider [step]="5" [lowerBound]="20">
         * ```
         */
        set: /**
         * Sets the lower boundary of the `IgxSliderComponent`.
         * If not set is the same as min value.
         * ```html
         * <igx-slider [step]="5" [lowerBound]="20">
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._trackLowerBound) {
                this._trackLowerBound = false;
            }
            if (value >= this.upperBound) {
                this._lowerBound = this.minValue;
                return;
            }
            this._lowerBound = this.valueInRange(value, this.minValue, this.maxValue);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "upperBound", {
        /**
         * Returns the upper boundary of the `IgxSliderComponent`.
         * ```typescript
         *@ViewChild("slider")
         *public slider: IgxSliderComponent;
         *ngAfterViewInit(){
         *    let sliderUpBound = this.slider.upperBound;
         *}
         * ```
         */
        get: /**
         * Returns the upper boundary of the `IgxSliderComponent`.
         * ```typescript
         * \@ViewChild("slider")
         * public slider: IgxSliderComponent;
         * ngAfterViewInit(){
         *    let sliderUpBound = this.slider.upperBound;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this._upperBound;
        },
        /**
         * Sets the upper boundary of the `IgxSliderComponent`.
         * If not set is the same as max value.
         * ```html
         * <igx-slider [step]="5" [upperBound]="20">
         * ```
         */
        set: /**
         * Sets the upper boundary of the `IgxSliderComponent`.
         * If not set is the same as max value.
         * ```html
         * <igx-slider [step]="5" [upperBound]="20">
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._trackUpperBound) {
                this._trackUpperBound = false;
            }
            if (value <= this.lowerBound) {
                this._upperBound = this.maxValue;
                return;
            }
            this._upperBound = this.valueInRange(value, this.minValue, this.maxValue);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "lowerValue", {
        /**
         * Returns the lower value of the `IgxSliderComponent`.
         * ```typescript
         * @ViewChild("slider")
         * public slider: IgxSliderComponent;
         * public lowValue(event){
         *    let sliderLowValue = this.slider.lowerValue;
         *}
         *```
         */
        get: /**
         * Returns the lower value of the `IgxSliderComponent`.
         * ```typescript
         * \@ViewChild("slider")
         * public slider: IgxSliderComponent;
         * public lowValue(event){
         *    let sliderLowValue = this.slider.lowerValue;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this._lowerValue;
        },
        /**
         *Sets the lower value of the `IgxSliderComponent`.
         *```typescript
         *@ViewChild("slider2")
         *public slider: IgxSliderComponent;
         *public lowValue(event){
         *    this.slider.lowerValue = 120;
         *}
         *```
         */
        set: /**
         * Sets the lower value of the `IgxSliderComponent`.
         * ```typescript
         * \@ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * public lowValue(event){
         *    this.slider.lowerValue = 120;
         * }
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            value = this.valueInRange(value, this.lowerBound, this.upperBound);
            if (this.isRange && value > this.upperValue) {
                return;
            }
            this._lowerValue = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "upperValue", {
        /**
         *Returns the upper value of the `IgxSliderComponent`.
         *```typescript
         *@ViewChild("slider2")
         *public slider: IgxSliderComponent;
         *public upperValue(event){
         *    let upperValue = this.slider.upperValue;
         *}
         *```
         */
        get: /**
         * Returns the upper value of the `IgxSliderComponent`.
         * ```typescript
         * \@ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * public upperValue(event){
         *    let upperValue = this.slider.upperValue;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this._upperValue;
        },
        /**
         *Sets the upper value of the `IgxSliderComponent`.
         *```typescript
         *@ViewChild("slider2")
         *public slider: IgxSliderComponent;
         *public upperValue(event){
         *    this.slider.upperValue = 120;
         *}
         *```
         */
        set: /**
         * Sets the upper value of the `IgxSliderComponent`.
         * ```typescript
         * \@ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * public upperValue(event){
         *    this.slider.upperValue = 120;
         * }
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            value = this.valueInRange(value, this.lowerBound, this.upperBound);
            if (this.isRange && value < this.lowerValue) {
                return;
            }
            this._upperValue = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSliderComponent.prototype, "value", {
        /**
         * Returns the slider value. If the slider is of type SLIDER the returned value is number.
         * If the slider type is RANGE the returned value is object containing lower and upper properties for the values.
         *```typescript
         *@ViewChild("slider2")
         *public slider: IgxSliderComponent;
         *public sliderValue(event){
         *    let sliderVal = this.slider.value;
         *}
         *```
         */
        get: /**
         * Returns the slider value. If the slider is of type SLIDER the returned value is number.
         * If the slider type is RANGE the returned value is object containing lower and upper properties for the values.
         * ```typescript
         * \@ViewChild("slider2")
         * public slider: IgxSliderComponent;
         * public sliderValue(event){
         *    let sliderVal = this.slider.value;
         * }
         * ```
         * @return {?}
         */
        function () {
            if (this.isRange) {
                return {
                    lower: this.snapValueToStep(this.lowerValue),
                    upper: this.snapValueToStep(this.upperValue)
                };
            }
            else {
                /** @type {?} */
                var val = this.snapValueToStep(this.upperValue);
                return val;
            }
        },
        /**
         * Sets the slider value.
         * If the slider is of type SLIDER the argument is number. By default if no value is set the default value is
         * same as lower upper bound.
         * If the slider type is RANGE the the argument is object containing lower and upper properties for the values.
         * By default if no value is set the default value is for lower value it is the same as lower bound and if no
         * value is set for the upper value it is the same as the upper bound.
         * ```typescript
         *rangeValue = {
         *   lower: 30,
         *   upper: 60
         *};
         * ```
         * ```html
         * <igx-slider [type]="sliderType" [(ngModel)]="rangeValue" [minValue]="56" [maxValue]="256">
         * ```
         */
        set: /**
         * Sets the slider value.
         * If the slider is of type SLIDER the argument is number. By default if no value is set the default value is
         * same as lower upper bound.
         * If the slider type is RANGE the the argument is object containing lower and upper properties for the values.
         * By default if no value is set the default value is for lower value it is the same as lower bound and if no
         * value is set for the upper value it is the same as the upper bound.
         * ```typescript
         * rangeValue = {
         *   lower: 30,
         *   upper: 60
         * };
         * ```
         * ```html
         * <igx-slider [type]="sliderType" [(ngModel)]="rangeValue" [minValue]="56" [maxValue]="256">
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (!this.isRange) {
                this.upperValue = this.snapValueToStep((/** @type {?} */ (value)));
            }
            else {
                this.upperValue =
                    this.snapValueToStep(((/** @type {?} */ (value))) == null ? null : ((/** @type {?} */ (value))).upper);
                this.lowerValue =
                    this.snapValueToStep(((/** @type {?} */ (value))) == null ? null : ((/** @type {?} */ (value))).lower);
            }
            this._onChangeCallback(this.value);
            if (this.hasViewInit) {
                this.positionHandlesAndUpdateTrack();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxSliderComponent.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (this.lowerBound === undefined) {
            this.lowerBound = this.minValue;
            this._trackLowerBound = true;
        }
        if (this.upperBound === undefined) {
            this.upperBound = this.maxValue;
            this._trackUpperBound = true;
        }
        if (this.isRange) {
            if (Number.isNaN(((/** @type {?} */ (this.value))).lower)) {
                this.value = {
                    lower: this.lowerBound,
                    upper: ((/** @type {?} */ (this.value))).upper
                };
            }
            if (Number.isNaN(((/** @type {?} */ (this.value))).upper)) {
                this.value = {
                    lower: ((/** @type {?} */ (this.value))).lower,
                    upper: this.upperBound
                };
            }
        }
        else {
            if (Number.isNaN((/** @type {?} */ (this.value)))) {
                this.value = this.lowerBound;
            }
        }
        this.pMin = this.valueToFraction(this.lowerBound) || 0;
        this.pMax = this.valueToFraction(this.upperBound) || 1;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxSliderComponent.prototype.ngAfterViewInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.hasViewInit = true;
        this.positionHandlesAndUpdateTrack();
        this.setTickInterval();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    IgxSliderComponent.prototype.writeValue = /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.value = value;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    IgxSliderComponent.prototype.registerOnChange = /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._onChangeCallback = fn;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    IgxSliderComponent.prototype.registerOnTouched = /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._onTouchedCallback = fn;
    };
    /** @hidden */
    /**
     * @hidden
     * @return {?}
     */
    IgxSliderComponent.prototype.getEditElement = /**
     * @hidden
     * @return {?}
     */
    function () {
        return this.isRange ? this.thumbFrom.nativeElement : this.thumbTo.nativeElement;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxSliderComponent.prototype.showThumbsLabels = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (this.disabled) {
            return;
        }
        if (this.isContinuous) {
            return;
        }
        if (this.timer !== null) {
            clearInterval(this.timer);
        }
        this.isActiveLabel = true;
    };
    /**
     *
     * @hidden
     */
    /**
     *
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    IgxSliderComponent.prototype.onFocus = /**
     *
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        if (this.isRange && $event.target === this.thumbFrom.nativeElement) {
            this.activeHandle = SliderHandle.FROM;
        }
        if ($event.target === this.thumbTo.nativeElement) {
            this.activeHandle = SliderHandle.TO;
        }
        this.toggleThumbLabel();
    };
    /**
     *
     * @hidden
     */
    /**
     *
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    IgxSliderComponent.prototype.onPanEnd = /**
     *
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        this.hideThumbsLabels();
        this.emitValueChanged(null);
    };
    /**
     *
     * @hidden
     */
    /**
     *
     * @hidden
     * @return {?}
     */
    IgxSliderComponent.prototype.hideThumbLabelsOnBlur = /**
     *
     * @hidden
     * @return {?}
     */
    function () {
        if (this.timer !== null) {
            clearInterval(this.timer);
        }
        this.isActiveLabel = false;
    };
    /**
     *
     * @hidden
     */
    /**
     *
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    IgxSliderComponent.prototype.onKeyDown = /**
     *
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        if (this.disabled) {
            return true;
        }
        /** @type {?} */
        var incrementSign;
        if ($event.key.endsWith('Left')) {
            incrementSign = -1;
        }
        else if ($event.key.endsWith('Right')) {
            incrementSign = 1;
        }
        else {
            return;
        }
        /** @type {?} */
        var value = this.value;
        if (this.isRange) {
            if (this.activeHandle === SliderHandle.FROM) {
                /** @type {?} */
                var newLower = ((/** @type {?} */ (this.value))).lower + incrementSign * this.step;
                if (newLower >= ((/** @type {?} */ (this.value))).upper) {
                    this.thumbTo.nativeElement.focus();
                    return;
                }
                this.value = {
                    lower: newLower,
                    upper: ((/** @type {?} */ (this.value))).upper
                };
            }
            else {
                /** @type {?} */
                var newUpper = ((/** @type {?} */ (this.value))).upper + incrementSign * this.step;
                if (newUpper <= ((/** @type {?} */ (this.value))).lower) {
                    this.thumbFrom.nativeElement.focus();
                    return;
                }
                this.value = {
                    lower: ((/** @type {?} */ (this.value))).lower,
                    upper: ((/** @type {?} */ (this.value))).upper + incrementSign * this.step
                };
            }
        }
        else {
            this.value = (/** @type {?} */ (this.value)) + incrementSign * this.step;
        }
        if (this.hasValueChanged(value)) {
            this.emitValueChanged(value);
        }
        this.showThumbsLabels();
    };
    /**
     *
     * @hidden
     */
    /**
     *
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    IgxSliderComponent.prototype.onTap = /**
     *
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        /** @type {?} */
        var value = this.value;
        this.update($event);
        if (this.hasValueChanged(value)) {
            this.emitValueChanged(value);
        }
    };
    /**
     *
     * @hidden
     */
    /**
     *
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    IgxSliderComponent.prototype.update = /**
     *
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        if (this.disabled) {
            return;
        }
        if ($event.type === 'tap') {
            this.toggleThumbLabel();
        }
        // Set width and offset first
        this.setSliderWidth();
        this.setSliderOffset();
        // Then get pointer coordinates
        this.setPointerPosition($event);
        this.setPointerPercent();
        // Find the closest handle if dual slider
        if (this.isRange) {
            this.closestHandle();
        }
        // Update To/From Values
        this.setValues();
        // this.printInfo();
        // Finally do positionHandlesAndUpdateTrack the DOM
        // based on data values
        this.positionHandlesAndUpdateTrack();
        this._onTouchedCallback();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxSliderComponent.prototype.hideThumbsLabels = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.disabled) {
            return;
        }
        if (this.isContinuous) {
            return;
        }
        this.timer = setTimeout(function () { return _this.isActiveLabel = false; }, this.thumbLabelVisibilityDuration);
    };
    /**
     * @private
     * @param {?} value
     * @param {?=} min
     * @param {?=} max
     * @return {?}
     */
    IgxSliderComponent.prototype.valueInRange = /**
     * @private
     * @param {?} value
     * @param {?=} min
     * @param {?=} max
     * @return {?}
     */
    function (value, min, max) {
        if (min === void 0) { min = 0; }
        if (max === void 0) { max = 100; }
        return Math.max(Math.min(value, max), min);
    };
    /**
     * @private
     * @return {?}
     */
    IgxSliderComponent.prototype.invalidateValue = /**
     * @private
     * @return {?}
     */
    function () {
        if (!this.isRange) {
            if (this.value >= this._lowerBound && this.value <= this._upperBound) {
                this.positionHandlesAndUpdateTrack();
            }
            else if (this.value < this._lowerBound) {
                this.value = this._lowerBound;
            }
            else if (this.value > this._upperBound) {
                this.value = this._upperBound;
            }
        }
        else {
            /** @type {?} */
            var value = (/** @type {?} */ (this.value));
            if (value.lower >= this._lowerBound && value.lower <= this._upperBound) {
                this.positionHandlesAndUpdateTrack();
            }
            else if (value.lower < this._lowerBound) {
                this.value = {
                    lower: this._lowerBound,
                    upper: value.upper
                };
            }
            else if (value.lower > this._upperBound) {
                this.value = {
                    lower: value.lower,
                    upper: this._upperBound
                };
            }
            if (value.upper >= this._lowerBound && value.upper <= this._upperBound) {
                this.positionHandlesAndUpdateTrack();
            }
            else if (value.upper < this._lowerBound) {
                this.value = {
                    lower: this._lowerBound,
                    upper: value.upper
                };
            }
            else if (value.upper > this._upperBound) {
                this.value = {
                    lower: value.lower,
                    upper: this._upperBound
                };
            }
        }
    };
    /**
     * @private
     * @param {?} color
     * @param {?} interval
     * @return {?}
     */
    IgxSliderComponent.prototype.generateTickMarks = /**
     * @private
     * @param {?} color
     * @param {?} interval
     * @return {?}
     */
    function (color, interval$$1) {
        return "repeating-linear-gradient(\n            " + 'to left' + ",\n            " + color + ",\n            " + color + " 1.5px,\n            transparent 1.5px,\n            transparent " + interval$$1 + "%\n        ), repeating-linear-gradient(\n            " + 'to right' + ",\n            " + color + ",\n            " + color + " 1.5px,\n            transparent 1.5px,\n            transparent " + interval$$1 + "%\n        )";
    };
    /**
     * @private
     * @return {?}
     */
    IgxSliderComponent.prototype.toggleThumbLabel = /**
     * @private
     * @return {?}
     */
    function () {
        this.showThumbsLabels();
        this.hideThumbsLabels();
    };
    /**
     * @private
     * @return {?}
     */
    IgxSliderComponent.prototype.getSliderOffset = /**
     * @private
     * @return {?}
     */
    function () {
        return this.xOffset;
    };
    /**
     * @private
     * @param {?} num
     * @return {?}
     */
    IgxSliderComponent.prototype.toFixed = /**
     * @private
     * @param {?} num
     * @return {?}
     */
    function (num) {
        num = parseFloat(num.toFixed(20));
        return num;
    };
    /**
     * @private
     * @param {?} handle
     * @param {?} position
     * @return {?}
     */
    IgxSliderComponent.prototype.positionHandle = /**
     * @private
     * @param {?} handle
     * @param {?} position
     * @return {?}
     */
    function (handle, position) {
        handle.nativeElement.style.left = this.valueToFraction(position) * 100 + "%";
    };
    /**
     * @private
     * @return {?}
     */
    IgxSliderComponent.prototype.positionHandlesAndUpdateTrack = /**
     * @private
     * @return {?}
     */
    function () {
        if (!this.isRange) {
            this.positionHandle(this.thumbTo, (/** @type {?} */ (this.value)));
        }
        else {
            this.positionHandle(this.thumbTo, ((/** @type {?} */ (this.value))).upper);
            this.positionHandle(this.thumbFrom, ((/** @type {?} */ (this.value))).lower);
        }
        this.updateTrack();
    };
    /**
     * @private
     * @return {?}
     */
    IgxSliderComponent.prototype.closestHandle = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var fromOffset = this.thumbFrom.nativeElement.offsetLeft + this.thumbFrom.nativeElement.offsetWidth / 2;
        /** @type {?} */
        var toOffset = this.thumbTo.nativeElement.offsetLeft + this.thumbTo.nativeElement.offsetWidth / 2;
        /** @type {?} */
        var match = this.closestTo(this.xPointer, [fromOffset, toOffset]);
        if (match === toOffset) {
            this.thumbTo.nativeElement.focus();
        }
        else if (match === fromOffset) {
            this.thumbFrom.nativeElement.focus();
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxSliderComponent.prototype.setTickInterval = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.isContinuous) {
            return;
        }
        /** @type {?} */
        var interval$$1 = this.step > 1 ? this.step : null;
        this.renderer.setStyle(this.ticks.nativeElement, 'background', this.generateTickMarks('white', interval$$1));
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    IgxSliderComponent.prototype.snapValueToStep = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var valueModStep = (value - this.minValue) % this.step;
        /** @type {?} */
        var snapValue = value - valueModStep;
        if (Math.abs(valueModStep) * 2 >= this.step) {
            snapValue += (valueModStep > 0) ? this.step : (-this.step);
        }
        return parseFloat(snapValue.toFixed(20));
    };
    /**
     * @private
     * @param {?} goal
     * @param {?} positions
     * @return {?}
     */
    IgxSliderComponent.prototype.closestTo = /**
     * @private
     * @param {?} goal
     * @param {?} positions
     * @return {?}
     */
    function (goal, positions) {
        return positions.reduce(function (previous, current) {
            return (Math.abs(goal - current) < Math.abs(goal - previous) ? current : previous);
        });
    };
    // Set Values for To/From based on active handle
    // Set Values for To/From based on active handle
    /**
     * @private
     * @return {?}
     */
    IgxSliderComponent.prototype.setValues = 
    // Set Values for To/From based on active handle
    /**
     * @private
     * @return {?}
     */
    function () {
        if (this.activeHandle === SliderHandle.TO) {
            if (this.isRange) {
                this.value = {
                    lower: ((/** @type {?} */ (this.value))).lower,
                    upper: this.fractionToValue(this.pPointer)
                };
            }
            else {
                this.value = this.fractionToValue(this.pPointer);
            }
        }
        if (this.activeHandle === SliderHandle.FROM) {
            this.value = {
                lower: this.fractionToValue(this.pPointer),
                upper: ((/** @type {?} */ (this.value))).upper
            };
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxSliderComponent.prototype.setSliderWidth = /**
     * @private
     * @return {?}
     */
    function () {
        this.width = this.slider.nativeElement.offsetWidth;
    };
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    IgxSliderComponent.prototype.setPointerPosition = /**
     * @private
     * @param {?} e
     * @return {?}
     */
    function (e) {
        this.xPointer = e.center.x - this.getSliderOffset();
    };
    /**
     * @private
     * @return {?}
     */
    IgxSliderComponent.prototype.setSliderOffset = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var rect = this.slider.nativeElement.getBoundingClientRect();
        this.xOffset = rect.left;
    };
    /**
     * @private
     * @return {?}
     */
    IgxSliderComponent.prototype.setPointerPercent = /**
     * @private
     * @return {?}
     */
    function () {
        this.pPointer = this.valueInRange(this.toFixed(this.xPointer / this.width), this.pMin, this.pMax);
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    IgxSliderComponent.prototype.valueToFraction = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return this.valueInRange((value - this.minValue) / (this.maxValue - this.minValue), this.pMin, this.pMax);
    };
    /**
     * @private
     * @param {?} fraction
     * @return {?}
     */
    IgxSliderComponent.prototype.fractionToValue = /**
     * @private
     * @param {?} fraction
     * @return {?}
     */
    function (fraction) {
        /** @type {?} */
        var max = this.maxValue;
        /** @type {?} */
        var min = this.minValue;
        return (max - min) * fraction + min;
    };
    /**
     * @private
     * @return {?}
     */
    IgxSliderComponent.prototype.updateTrack = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var fromPosition = this.valueToFraction(this.lowerValue);
        /** @type {?} */
        var toPosition = this.valueToFraction(this.upperValue);
        /** @type {?} */
        var positionGap = (this.valueToFraction(this.upperValue) - this.valueToFraction(this.lowerValue));
        if (!this.isRange) {
            this.track.nativeElement.style.transform = "scaleX(" + toPosition + ")";
        }
        if (this.isRange) {
            this.track.nativeElement.style.transform = "scaleX(" + 1 + ")";
            this.track.nativeElement.style.left = fromPosition * 100 + "%";
            this.track.nativeElement.style.width = positionGap * 100 + "%";
        }
    };
    /**
     * @private
     * @param {?} oldValue
     * @return {?}
     */
    IgxSliderComponent.prototype.hasValueChanged = /**
     * @private
     * @param {?} oldValue
     * @return {?}
     */
    function (oldValue) {
        /** @type {?} */
        var isSliderWithDifferentValue = !this.isRange && oldValue !== this.value;
        /** @type {?} */
        var isRangeWithOneDifferentValue = this.isRange &&
            (((/** @type {?} */ (oldValue))).lower !== ((/** @type {?} */ (this.value))).lower ||
                ((/** @type {?} */ (oldValue))).upper !== ((/** @type {?} */ (this.value))).upper);
        return isSliderWithDifferentValue || isRangeWithOneDifferentValue;
    };
    /**
     * @private
     * @param {?} oldValue
     * @return {?}
     */
    IgxSliderComponent.prototype.emitValueChanged = /**
     * @private
     * @param {?} oldValue
     * @return {?}
     */
    function (oldValue) {
        this.onValueChange.emit({ oldValue: oldValue, value: this.value });
    };
    IgxSliderComponent.decorators = [
        { type: Component, args: [{
                    providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: IgxSliderComponent, multi: true }],
                    selector: 'igx-slider',
                    template: "<div class=\"igx-slider\" [class.igx-slider--disabled]=\"disabled\" #slider (panstart)=\"showThumbsLabels()\" (panend)=\"onPanEnd($event)\"\n    (pan)=\"update($event)\" (tap)=\"onTap($event)\">\n    <div class=\"igx-slider__track\">\n        <div #track class=\"igx-slider__track-fill\"></div>\n        <div #ticks class=\"igx-slider__track-ticks\"></div>\n    </div>\n    <div class=\"igx-slider__thumbs\">\n        <div (keydown)=\"onKeyDown($event);\" (keyup)=\"hideThumbsLabels()\" (blur)=\"hideThumbLabelsOnBlur()\" (focus)=\"onFocus($event);\"\n            *ngIf=\"isRange\" class=\"igx-slider__thumb-from\" tabindex=\"1\" [ngClass]=\"{ 'igx-slider__thumb-from--active': isActiveLabel }\"\n            #thumbFrom>\n            <span class=\"label\">{{ lowerValue}}</span>\n            <span class=\"dot\"></span>\n        </div>\n        <div (keydown)=\"onKeyDown($event);\" (keyup)=\"hideThumbsLabels()\" (blur)=\"hideThumbLabelsOnBlur()\" (focus)=\"onFocus($event);\"\n            class=\"igx-slider__thumb-to\" tabindex=\"1\" [ngClass]=\"{ 'igx-slider__thumb-to--active': isActiveLabel }\" #thumbTo>\n            <span *ngIf=\"isRange\" class=\"label\">{{ upperValue}}</span>\n            <span *ngIf=\"!isRange\" class=\"label\">{{ value }}</span>\n            <span class=\"dot\"></span>\n        </div>\n    </div>\n</div>\n",
                    styles: ["\n        :host {\n            display: block;\n        }\n    "]
                }] }
    ];
    /** @nocollapse */
    IgxSliderComponent.ctorParameters = function () { return [
        { type: Renderer2 }
    ]; };
    IgxSliderComponent.propDecorators = {
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        disabled: [{ type: Input }],
        isContinuous: [{ type: Input }],
        type: [{ type: Input }],
        thumbLabelVisibilityDuration: [{ type: Input }],
        step: [{ type: Input }],
        onValueChange: [{ type: Output }],
        slider: [{ type: ViewChild, args: ['slider',] }],
        track: [{ type: ViewChild, args: ['track',] }],
        ticks: [{ type: ViewChild, args: ['ticks',] }],
        thumbFrom: [{ type: ViewChild, args: ['thumbFrom',] }],
        thumbTo: [{ type: ViewChild, args: ['thumbTo',] }],
        maxValue: [{ type: Input }],
        minValue: [{ type: Input }],
        lowerBound: [{ type: Input }],
        upperBound: [{ type: Input }],
        value: [{ type: Input }]
    };
    return IgxSliderComponent;
}());
/**
 * @hidden
 */
var IgxSliderModule = /** @class */ (function () {
    function IgxSliderModule() {
    }
    IgxSliderModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxSliderComponent],
                    exports: [IgxSliderComponent],
                    imports: [CommonModule]
                },] }
    ];
    return IgxSliderModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var NEXT_ID$s = 0;
/**
 * **Ignite UI for Angular Snackbar** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/snackbar.html)
 *
 * The Ignite UI Snack Bar provides feedback about an operation with a single-line message, which can
 * include a link to an action such as Undo.
 *
 * Example:
 * ```html
 * <button (click)="snackbar.show()">Send message</button>
 * <div>
 *   <igx-snackbar #snackbar message="Message sent">
 *   </igx-snackbar>
 * </div>
 * ```
 */
var IgxSnackbarComponent = /** @class */ (function () {
    function IgxSnackbarComponent(zone) {
        this.zone = zone;
        /**
         * Sets/gets the `id` of the snackbar.
         * If not set, the `id` of the first snackbar component  will be `"igx-snackbar-0"`;
         * ```html
         * <igx-snackbar id = "Snackbar1"></igx-snackbar>
         * ```
         * ```typescript
         * let snackbarId = this.snackbar.id;
         * ```
         * \@memberof IgxSnackbarComponent
         */
        this.id = "igx-snackbar-" + NEXT_ID$s++;
        /**
         * Enables/Disables the visibility of the snackbar.
         * If not set, the `isVisible` attribute will have value `false`.
         * ```html
         * <igx-snackbar [isVisible] = "true"></igx-snackbar>
         * ```
         * ```typescript
         * let isVisible =  this.snackbar.isVisible;
         * ```
         */
        this.isVisible = false;
        /**
         * Sets/gets if the snackbar will be automatically hidden after the `displayTime` is over.
         * Default value is `true`.
         * ```html
         * <igx-snackbar [autoHide] = "false"></igx-snackbar>
         * ```
         * ```typescript
         * let autoHide =  this.snackbar.autoHide;
         * ```
         */
        this.autoHide = true;
        /**
         * Sets/gets the duration of time(in milliseconds) in which the snackbar will be visible after it is being shown.
         * Default value is 4000.
         * ```html
         * <igx-snackbar [displayTime] = "2000"></igx-snackbar>
         * ```
         * ```typescript
         * let displayTime = this.snackbar.displayTime;
         * ```
         */
        this.displayTime = 4000;
        /**
         * An event that will be emitted when the action is executed.
         * Provides reference to the `IgxSnackbarComponent` as an argument.
         * ```html
         * <igx-snackbar (onAction) = "onAction($event)"></igx-snackbar>
         * ```
         */
        this.onAction = new EventEmitter();
        /**
         * An event that will be emitted when the snackbar animation starts.
         * Provides reference to the `AnimationEvent` interface as an argument.
         * ```html
         * <igx-snackbar (animationStarted) = "animationStarted($event)"></igx-snackbar>
         * ```
         */
        this.animationStarted = new EventEmitter();
        /**
         * An event that will be emitted when the snackbar animation ends.
         * Provides reference to the `AnimationEvent` interface as an argument.
         * ```html
         * <igx-snackbar (animationDone) = "animationDone($event)"></igx-snackbar>
         * ```
         */
        this.animationDone = new EventEmitter();
    }
    /**
     * Shows the snackbar and hides it after the `displayTime` is over if `autoHide` is set to `true`.
     * ```typescript
     * this.snackbar.show();
     * ```
     */
    /**
     * Shows the snackbar and hides it after the `displayTime` is over if `autoHide` is set to `true`.
     * ```typescript
     * this.snackbar.show();
     * ```
     * @return {?}
     */
    IgxSnackbarComponent.prototype.show = /**
     * Shows the snackbar and hides it after the `displayTime` is over if `autoHide` is set to `true`.
     * ```typescript
     * this.snackbar.show();
     * ```
     * @return {?}
     */
    function () {
        var _this = this;
        clearTimeout(this.timeoutId);
        setTimeout(this.timeoutId);
        this.isVisible = true;
        if (this.autoHide) {
            this.timeoutId = setTimeout(function () {
                _this.hide();
            }, this.displayTime);
        }
    };
    /**
     * Hides the snackbar.
     * ```typescript
     * this.snackbar.hide();
     * ```
     */
    /**
     * Hides the snackbar.
     * ```typescript
     * this.snackbar.hide();
     * ```
     * @return {?}
     */
    IgxSnackbarComponent.prototype.hide = /**
     * Hides the snackbar.
     * ```typescript
     * this.snackbar.hide();
     * ```
     * @return {?}
     */
    function () {
        this.isVisible = false;
        clearTimeout(this.timeoutId);
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxSnackbarComponent.prototype.triggerAction = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.onAction.emit(this);
    };
    /**
     *@hidden
     * @memberof IgxSnackbarComponent
     */
    /**
     * @hidden
     * \@memberof IgxSnackbarComponent
     * @param {?} evt
     * @return {?}
     */
    IgxSnackbarComponent.prototype.snackbarAnimationStarted = /**
     * @hidden
     * \@memberof IgxSnackbarComponent
     * @param {?} evt
     * @return {?}
     */
    function (evt) {
        if (evt.fromState === 'void') {
            this.animationStarted.emit(evt);
        }
    };
    /**
     *@hidden
     * @memberof IgxSnackbarComponent
     */
    /**
     * @hidden
     * \@memberof IgxSnackbarComponent
     * @param {?} evt
     * @return {?}
     */
    IgxSnackbarComponent.prototype.snackbarAnimationDone = /**
     * @hidden
     * \@memberof IgxSnackbarComponent
     * @param {?} evt
     * @return {?}
     */
    function (evt) {
        if (evt.fromState === 'show') {
            this.animationDone.emit(evt);
        }
    };
    IgxSnackbarComponent.decorators = [
        { type: Component, args: [{
                    animations: [
                        trigger('slideInOut', [
                            transition('void => *', [
                                useAnimation(slideInBottom, {
                                    params: {
                                        duration: '.35s',
                                        easing: 'cubic-bezier(0.0, 0.0, 0.2, 1)',
                                        fromPosition: 'translateY(100%)',
                                        toPosition: 'translateY(0)'
                                    }
                                })
                            ]),
                            transition('* => void', [
                                useAnimation(slideOutBottom, {
                                    params: {
                                        duration: '.2s',
                                        easing: 'cubic-bezier(0.4, 0.0, 1, 1)',
                                        fromPosition: 'translateY(0)',
                                        toOpacity: 1,
                                        toPosition: 'translateY(100%)'
                                    }
                                })
                            ])
                        ]),
                        trigger('fadeInOut', [
                            transition('void => *', [
                                useAnimation(fadeIn, {
                                    params: {
                                        duration: '.35s',
                                        easing: 'ease-out'
                                    }
                                })
                            ]),
                            transition('* => void', [
                                useAnimation(fadeOut, {
                                    params: {
                                        duration: '.2s',
                                        easing: 'ease-out'
                                    }
                                })
                            ])
                        ])
                    ],
                    selector: 'igx-snackbar',
                    template: "<div class=\"igx-snackbar\" *ngIf=\"isVisible\" (@slideInOut.start)=\"snackbarAnimationStarted($event)\" (@slideInOut.done)=\"snackbarAnimationDone($event)\"\n    [@slideInOut]=\"isVisible\">\n    <div class=\"igx-snackbar__message\" [@fadeInOut]=\"isVisible\">\n        {{ message }}\n        <ng-content></ng-content>\n    </div>\n    <button class=\"igx-snackbar__button\" igxRipple=\"white\" *ngIf=\"actionText\" [@fadeInOut] (click)=\"triggerAction()\">\n        {{ actionText }}\n    </button>\n</div>\n",
                    styles: ["\n        :host {\n            display: block;\n        }\n    "]
                }] }
    ];
    /** @nocollapse */
    IgxSnackbarComponent.ctorParameters = function () { return [
        { type: NgZone }
    ]; };
    IgxSnackbarComponent.propDecorators = {
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        message: [{ type: Input }],
        isVisible: [{ type: Input }],
        autoHide: [{ type: Input }],
        displayTime: [{ type: Input }],
        actionText: [{ type: Input }],
        onAction: [{ type: Output }],
        animationStarted: [{ type: Output }],
        animationDone: [{ type: Output }]
    };
    return IgxSnackbarComponent;
}());
/**
 * @hidden
 */
var IgxSnackbarModule = /** @class */ (function () {
    function IgxSnackbarModule() {
    }
    IgxSnackbarModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxSnackbarComponent],
                    exports: [IgxSnackbarComponent],
                    imports: [CommonModule]
                },] }
    ];
    return IgxSnackbarModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var SwitchLabelPosition = {
    BEFORE: 'before',
    AFTER: 'after',
};
/** @type {?} */
var noop$6 = function () { };
/** @type {?} */
var nextId$3 = 0;
/**
 * **Ignite UI for Angular Switch** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/switch.html)
 *
 * The Ignite UI Switch lets the user toggle between on/off or true/false states.
 *
 * Example:
 * ```html
 * <igx-switch [checked]="true">
 *   Simple switch
 * </igx-switch>
 * ```
 */
var IgxSwitchComponent = /** @class */ (function () {
    function IgxSwitchComponent() {
        /**
         * Sets/gets the `id` of the switch component.
         * If not set, the `id` of the first switch component will be `"igx-switch-0"`.
         * ```html
         * <igx-switch id="my-first-switch"></igx-switch>
         * ```
         * ```typescript
         * let switchId =  this.switch.id;
         * ```
         * \@memberof IgxSwitchComponent
         */
        this.id = "igx-switch-" + nextId$3++;
        /**
         * Sets/gets the id of the `label` element in the switch component.
         * If not set, the label of the first switch component will have value `"igx-switch-0-label"`.
         * ```html
         * <igx-switch labelId="Label1"></igx-switch>
         * ```
         * ```typescript
         * let labelId =  this.switch.labelId;
         * ```
         * \@memberof IgxSwitchComponent
         */
        this.labelId = this.id + "-label";
        /**
         * Sets/gets the value of the `tabindex` attribute.
         * ```html
         * <igx-switch [tabindex]="1"></igx-switch>
         * ```
         * ```typescript
         * let tabIndex =  this.switch.tabindex;
         * ```
         * \@memberof IgxSwitchComponent
         */
        this.tabindex = null;
        /**
         * Sets/gets the position of the `label` in the switch component.
         * If not set, `labelPosition` will have value `"after"`.
         * ```html
         * <igx-switch labelPosition="before"></igx-switch>
         * ```
         * ```typescript
         * let labelPosition =  this.switch.labelPosition;
         * ```
         * \@memberof IgxSwitchComponent
         */
        this.labelPosition = 'after';
        /**
         * Enables/Disables the ripple effect
         * If not set, `disableRipple` will have value `false`.
         * ```html
         * <igx-switch [disableRipple]="true"></igx-switch>
         * ```
         * ```typescript
         * let isRippleDisabled = this.switch.disableRipple;
         * ```
         * \@memberof IgxSwitchComponent
         */
        this.disableRipple = false;
        /**
         * Sets/gets whether switch is required.
         * If not set, `required` will have value `false`.
         * ```html
         * <igx-switch [required]="true"></igx-switch>
         * ```
         * ```typescript
         * let isRequired = this.switch.required;
         * ```
         * \@memberof IgxSwitchComponent
         */
        this.required = false;
        /**
         * Sets/gets the `aria-labelledBy` attribute.
         * If not set, the  value of `aria-labelledBy` will be equal to the value of `labelId` attribute.
         * ```html
         * <igx-switch aria-labelledby = "Label1"></igx-switch>
         * ```
         * ```typescript
         * let ariaLabelledBy = this.switch.ariaLabelledBy;
         * ```
         * \@memberof IgxSwitchComponent
         */
        this.ariaLabelledBy = this.labelId;
        /**
         * Sets/gets the value of the `aria-label` attribute.
         * ```html
         * <igx-switch aria-label="Label1"></igx-switch>
         * ```
         * ```typescript
         * let ariaLabel =  this.switch.ariaLabel;
         * ```
         * \@memberof IgxSwitchComponent
         */
        this.ariaLabel = null;
        /**
         * An event that is emitted after the switch state is changed.
         * Provides references to the `IgxSwitchComponent` and the `checked` property as event arguments.
         * \@memberof IgxSwitchComponent
         */
        this.change = new EventEmitter();
        /**
         * @hidden
         * \@memberof IgxSwitchComponent
         */
        this._onTouchedCallback = noop$6;
        /**
         * @hidden
         * \@memberof IgxSwitchComponent
         */
        this._onChangeCallback = noop$6;
        /**
         * Returns the class of the switch component.
         * ```typescript
         * let switchClass = this.switch.cssClass;
         * ```
         * \@memberof IgxSwitchComponent
         */
        this.cssClass = 'igx-switch';
        /**
         * Sets/gets whether the switch is on or off.
         * Default value is 'false'.
         * ```html
         *  <igx-switch [checked] = "true"></igx-switch>
         * ```
         * ```typescript
         * let isChecked =  this.switch.checked;
         * ```
         * \@memberof IgxSwitchComponent
         */
        this.checked = false;
        /**
         * Sets/gets the `disabled` attribute.
         * Default value is `false`.
         * ```html
         * <igx-switch [disabled] = "true"><igx-switch>
         * ```
         * ```typescript
         * let isDisabled =  this.switch.disabled;
         * ```
         * \@memberof IgxSwitchComponent
         */
        this.disabled = false;
        /**
         * Sets/gets whether the switch component is on focus.
         * Default value is `false`.
         * ```typescript
         * this.switch.focused = true;
         * ```
         * ```typescript
         * let isFocused =  this.switch.focused;
         * ```
         * \@memberof IgxSwitchComponent
         */
        this.focused = false;
        /**
         * @hidden
         */
        this.inputId = this.id + "-input";
    }
    /**
     * Toggles the checked state of the switch.
     * ```typescript
     * this.switch.toggle();
     * ```
     * @memberof IgxSwitchComponent
     */
    /**
     * Toggles the checked state of the switch.
     * ```typescript
     * this.switch.toggle();
     * ```
     * \@memberof IgxSwitchComponent
     * @return {?}
     */
    IgxSwitchComponent.prototype.toggle = /**
     * Toggles the checked state of the switch.
     * ```typescript
     * this.switch.toggle();
     * ```
     * \@memberof IgxSwitchComponent
     * @return {?}
     */
    function () {
        if (this.disabled) {
            return;
        }
        this.checked = !this.checked;
        this.focused = false;
        this.change.emit({ checked: this.checked, switch: this });
        this._onChangeCallback(this.checked);
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxSwitchComponent.prototype._onSwitchChange = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.stopPropagation();
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxSwitchComponent.prototype._onSwitchClick = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.stopPropagation();
        this.toggle();
        if (isIE()) {
            this.nativeCheckbox.nativeElement.blur();
        }
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxSwitchComponent.prototype._onLabelClick = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.toggle();
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxSwitchComponent.prototype.onFocus = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.focused = true;
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxSwitchComponent.prototype.onBlur = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.focused = false;
        this._onTouchedCallback();
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    IgxSwitchComponent.prototype.writeValue = /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this._value = value;
        this.checked = !!this._value;
    };
    /** @hidden */
    /**
     * @hidden
     * @return {?}
     */
    IgxSwitchComponent.prototype.getEditElement = /**
     * @hidden
     * @return {?}
     */
    function () {
        return this.nativeCheckbox.nativeElement;
    };
    Object.defineProperty(IgxSwitchComponent.prototype, "labelClass", {
        /**
         *@hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            switch (this.labelPosition) {
                case SwitchLabelPosition.BEFORE:
                    return this.cssClass + "__label--before";
                case SwitchLabelPosition.AFTER:
                default:
                    return this.cssClass + "__label";
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    IgxSwitchComponent.prototype.registerOnChange = /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._onChangeCallback = fn; };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    IgxSwitchComponent.prototype.registerOnTouched = /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._onTouchedCallback = fn; };
    IgxSwitchComponent.decorators = [
        { type: Component, args: [{
                    providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: IgxSwitchComponent, multi: true }],
                    selector: 'igx-switch',
                    template: "<input #checkbox class=\"igx-switch__input\" type=\"checkbox\"\n    [id]=\"inputId\"\n    [name]=\"name\"\n    [value]=\"value\"\n    [tabindex]=\"tabindex\"\n    [disabled]=\"disabled\"\n    [checked]=\"checked\"\n    [required]=\"required\"\n    [attr.aria-checked]=\"checked\"\n    [attr.aria-labelledby]=\"ariaLabelledBy\"\n    [attr.aria-label]=\"ariaLabel\"\n    (change)=\"_onSwitchChange($event)\"\n    (click)=\"_onSwitchClick($event)\"\n    (focus)=\"onFocus($event)\"\n    (blur)=\"onBlur($event)\" />\n\n<label #label class =\"igx-switch__composite\" [for]=\"inputId\"\n    igxRipple\n    igxRippleTarget=\".igx-switch__ripple\"\n    [igxRippleDisabled]=\"disableRipple\"\n    [igxRippleCentered]=\"true\"\n    [igxRippleDuration]=\"300\">\n    <div class=\"igx-switch__composite-thumb\">\n        <div class=\"igx-switch__ripple\"></div>\n    </div>\n</label>\n\n<span #placeholderLabel role=\"label\"\n    [class]=\"labelClass\"\n    [id]=\"labelId\"\n    (click)=\"_onLabelClick($event)\">\n    <ng-content></ng-content>\n</span>\n"
                }] }
    ];
    IgxSwitchComponent.propDecorators = {
        nativeCheckbox: [{ type: ViewChild, args: ['checkbox',] }],
        nativeLabel: [{ type: ViewChild, args: ['label',] }],
        placeholderLabel: [{ type: ViewChild, args: ['placeholderLabel',] }],
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        labelId: [{ type: Input }],
        value: [{ type: Input }],
        name: [{ type: Input }],
        tabindex: [{ type: Input }],
        labelPosition: [{ type: Input }],
        disableRipple: [{ type: Input }],
        required: [{ type: Input }],
        ariaLabelledBy: [{ type: Input, args: ['aria-labelledby',] }],
        ariaLabel: [{ type: Input, args: ['aria-label',] }],
        change: [{ type: Output }],
        cssClass: [{ type: HostBinding, args: ['class.igx-switch',] }],
        checked: [{ type: HostBinding, args: ['class.igx-switch--checked',] }, { type: Input }],
        disabled: [{ type: HostBinding, args: ['class.igx-switch--disabled',] }, { type: Input }],
        focused: [{ type: HostBinding, args: ['class.igx-switch--focused',] }]
    };
    return IgxSwitchComponent;
}());
/** @type {?} */
var IGX_SWITCH_REQUIRED_VALIDATOR = {
    provide: NG_VALIDATORS,
    useExisting: forwardRef(function () { return IgxSwitchRequiredDirective; }),
    multi: true
};
/* tslint:disable directive-selector */
var IgxSwitchRequiredDirective = /** @class */ (function (_super) {
    __extends(IgxSwitchRequiredDirective, _super);
    function IgxSwitchRequiredDirective() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    IgxSwitchRequiredDirective.decorators = [
        { type: Directive, args: [{
                    selector: "igx-switch[required][formControlName],\n    igx-switch[required][formControl],\n    igx-switch[required][ngModel]",
                    providers: [IGX_SWITCH_REQUIRED_VALIDATOR]
                },] }
    ];
    return IgxSwitchRequiredDirective;
}(CheckboxRequiredValidator));
/**
 * @hidden
 */
var IgxSwitchModule = /** @class */ (function () {
    function IgxSwitchModule() {
    }
    IgxSwitchModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxSwitchComponent, IgxSwitchRequiredDirective],
                    exports: [IgxSwitchComponent, IgxSwitchRequiredDirective],
                    imports: [IgxRippleModule]
                },] }
    ];
    return IgxSwitchModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var NEXT_ID$t = 0;
var IgxTabTemplateDirective = /** @class */ (function () {
    function IgxTabTemplateDirective(template) {
        this.template = template;
    }
    IgxTabTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxTab]'
                },] }
    ];
    /** @nocollapse */
    IgxTabTemplateDirective.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return IgxTabTemplateDirective;
}());
/**
 * **Ignite UI for Angular Tab Bar** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/tabbar.html)
 *
 * The Ignite UI Tab Bar enables the user to navigate among a number of content panels displayed in a single view.
 *
 * Example:
 * ```html
 * <igx-bottom-nav>
 *   <igx-tab-panel label="Tab 1">Tab 1 Content</igx-tab-panel>
 *   <igx-tab-panel label="Tab 2">Tab 2 Content</igx-tab-panel>
 *   <igx-tab-panel label="Tab 3">Tab 3 Content</igx-tab-panel>
 * </igx-bottom-nav>
 * ```
 */
var IgxBottomNavComponent = /** @class */ (function () {
    function IgxBottomNavComponent(_element) {
        this._element = _element;
        /**
         * Sets/gets the `id` of the tab bar.
         * If not set, the `id` of the first tab bar component will be `"igx-bottom-nav-0"`.
         * ```html
         * <igx-bottom-nav id = "my-first-tab-bar"></igx-bottom-nav>
         * ```
         * ```typescript
         * let tabBarId =  this.tabBar.id;
         * ```
         * \@memberof IgxBottomNavComponent
         */
        this.id = "igx-bottom-nav-" + NEXT_ID$t++;
        /**
         * Emits an event when a new tab is selected.
         * Provides references to the `IgxTabComponent` and `IgxTabPanelComponent` as event arguments.
         * ```html
         * <igx-bottom-nav (onTableSelected) = "onTabSelected($event)"><igx-bottom-nav>
         * ```
         * \@memberof IgxBottomNavComponent
         */
        this.onTabSelected = new EventEmitter();
        /**
         * Emits an event when a tab is deselected.
         * Provides references to the `IgxTabComponent` and `IgxTabPanelComponent` as event arguments.
         * ```html
         * <igx-bottom-nav (onTabDeselected) = "onTabDeselected($event)"><igx-bottom-nav>
         * ```
         * \@memberof IgxBottomNavComponent
         */
        this.onTabDeselected = new EventEmitter();
        /**
         * Gets the `index` of selected tab/panel in the respective collection.
         * ```typescript
         * let index =  this.tabBar.selectedIndex;
         * ```
         * \@memberof IgxBottomNavComponent
         */
        this.selectedIndex = -1;
        /**
         * @hidden
         */
        this._itemStyle = 'igx-bottom-nav';
    }
    Object.defineProperty(IgxBottomNavComponent.prototype, "itemStyle", {
        /**
         * Gets the `itemStyle` of the tab bar.
         * ```typescript
         * let itemStyle =  this.tabBar.itemStyle;
         * ```
         * @memberof IgxBottomNavComponent
         */
        get: /**
         * Gets the `itemStyle` of the tab bar.
         * ```typescript
         * let itemStyle =  this.tabBar.itemStyle;
         * ```
         * \@memberof IgxBottomNavComponent
         * @return {?}
         */
        function () {
            return this._itemStyle;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxBottomNavComponent.prototype, "selectedTab", {
        /**
         * Gets the selected tab in the tab bar.
         * ```typescript
         * let tab =  this.tabBar.selectedTab;
         * ```
         * @memberof IgxBottomNavComponent
         */
        get: /**
         * Gets the selected tab in the tab bar.
         * ```typescript
         * let tab =  this.tabBar.selectedTab;
         * ```
         * \@memberof IgxBottomNavComponent
         * @return {?}
         */
        function () {
            if (this.tabs && this.selectedIndex !== undefined) {
                return this.tabs.toArray()[this.selectedIndex];
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxBottomNavComponent.prototype.ngAfterViewInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        // initial selection
        setTimeout(function () {
            if (_this.selectedIndex === -1) {
                /** @type {?} */
                var selectablePanels = _this.panels.filter(function (p) { return !p.disabled; });
                /** @type {?} */
                var panel = selectablePanels[0];
                if (panel) {
                    panel.select();
                }
            }
        }, 0);
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @param {?} args
     * @return {?}
     */
    IgxBottomNavComponent.prototype._selectedPanelHandler = /**
     * @hidden
     * @param {?} args
     * @return {?}
     */
    function (args) {
        var _this = this;
        this.selectedIndex = args.panel.index;
        this.panels.forEach(function (p) {
            if (p.index !== _this.selectedIndex) {
                _this._deselectPanel(p);
            }
        });
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @private
     * @param {?} panel
     * @return {?}
     */
    IgxBottomNavComponent.prototype._deselectPanel = /**
     * @hidden
     * @private
     * @param {?} panel
     * @return {?}
     */
    function (panel) {
        // Cannot deselect the selected tab - this will mean that there will be not selected tab left
        if (panel.disabled || this.selectedTab.index === panel.index) {
            return;
        }
        panel.isSelected = false;
        this.onTabDeselected.emit({ tab: this.tabs[panel.index], panel: panel });
    };
    IgxBottomNavComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-bottom-nav',
                    template: "<div>\n    <ng-content></ng-content>\n</div>\n<div #tablist class=\"{{itemStyle}}__menu {{itemStyle}}__menu--bottom\" role=\"tablist\" aria-orientation=\"horizontal\">\n    <igx-tab *ngFor=\"let panel of panels\" [id]=\"'igx-tab-' + panel.index\" [attr.aria-label]=\"panel.label\" [attr.aria-disabled]=\"panel.disabled\"\n        [attr.aria-selected]=\"panel.isSelected\" [attr.aria-controls]=\"'igx-tab-panel-'+ panel.index\" [ngClass]=\"{\n                 'igx-bottom-nav__menu-item': !panel.isSelected && !panel.disabled,\n                 'igx-bottom-nav__menu-item--selected': panel.isSelected,\n                 'igx-bottom-nav__menu-item--disabled': panel.disabled\n             }\" [relatedPanel]=\"panel\" (click)=\"panel.select()\" role=\"tab\">\n    </igx-tab>\n</div>\n",
                    styles: ["\n        :host {\n            display: block;\n        }\n    "]
                }] }
    ];
    /** @nocollapse */
    IgxBottomNavComponent.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    IgxBottomNavComponent.propDecorators = {
        tabs: [{ type: ViewChildren, args: [forwardRef(function () { return IgxTabComponent; }),] }],
        panels: [{ type: ContentChildren, args: [forwardRef(function () { return IgxTabPanelComponent; }),] }],
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        onTabSelected: [{ type: Output }],
        onTabDeselected: [{ type: Output }],
        _selectedPanelHandler: [{ type: HostListener, args: ['onTabSelected', ['$event'],] }]
    };
    return IgxBottomNavComponent;
}());
// ================================= IgxTabPanelComponent ======================================
var IgxTabPanelComponent = /** @class */ (function () {
    function IgxTabPanelComponent(_tabBar, _element) {
        this._tabBar = _tabBar;
        this._element = _element;
        /**
         * @hidden
         */
        this._itemStyle = 'igx-tab-panel';
        /**
         * Gets the role of the tab panel.
         * ```typescript
         * let tabPanelRole = this.tabPanel.role;
         * ```
         * \@memberof IgxTabPanelComponent
         */
        this.role = 'tabpanel';
        /**
         * Sets/gets whether a tab panel is selected.
         * ```typescript
         * this.tabPanel.isSelected = true;
         * ```
         * ```typescript
         * let isSelected =  this.tabPanelIsSelected;
         * ```
         * \@memberof IgxTabPanelComponent
         */
        this.isSelected = false;
    }
    Object.defineProperty(IgxTabPanelComponent.prototype, "styleClass", {
        /**
         * Gets whether a tab panel will have `igx-bottom-nav__panel` class.
         * ```typescript
         * let styleClass = this.tabPanel.styleClass;
         * ```
         * @memberof IgxTabPanelComponent
         */
        get: /**
         * Gets whether a tab panel will have `igx-bottom-nav__panel` class.
         * ```typescript
         * let styleClass = this.tabPanel.styleClass;
         * ```
         * \@memberof IgxTabPanelComponent
         * @return {?}
         */
        function () {
            return (!this.isSelected);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTabPanelComponent.prototype, "itemStyle", {
        /**
         * Gets the `itemStyle` of the tab panel.
         * ```typescript
         * let itemStyle = this.tabPanel.itemStyle;
         * ```
         * @memberof IgxTabPanelComponent
         */
        get: /**
         * Gets the `itemStyle` of the tab panel.
         * ```typescript
         * let itemStyle = this.tabPanel.itemStyle;
         * ```
         * \@memberof IgxTabPanelComponent
         * @return {?}
         */
        function () {
            return this._itemStyle;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTabPanelComponent.prototype, "relatedTab", {
        /**
         * Gets the tab associated with the panel.
         * ```typescript
         * let tab = this.tabPanel.relatedTab;
         * ```
         * @memberof IgxTabPanelComponent
         */
        get: /**
         * Gets the tab associated with the panel.
         * ```typescript
         * let tab = this.tabPanel.relatedTab;
         * ```
         * \@memberof IgxTabPanelComponent
         * @return {?}
         */
        function () {
            if (this._tabBar.tabs) {
                return this._tabBar.tabs.toArray()[this.index];
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTabPanelComponent.prototype, "index", {
        /**
         * Gets the index of a panel in the panels collection.
         * ```typescript
         * let panelIndex =  this.tabPanel.index
         * ```
         * @memberof IgxTabPanelComponent
         */
        get: /**
         * Gets the index of a panel in the panels collection.
         * ```typescript
         * let panelIndex =  this.tabPanel.index
         * ```
         * \@memberof IgxTabPanelComponent
         * @return {?}
         */
        function () {
            if (this._tabBar.panels) {
                return this._tabBar.panels.toArray().indexOf(this);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTabPanelComponent.prototype, "customTabTemplate", {
        /**
         * Gets the tab template.
         * ```typescript
         * let tabTemplate = this.tabPanel.customTabTemplate
         * ```
         * @memberof IgxTabPanelComponent
         */
        get: /**
         * Gets the tab template.
         * ```typescript
         * let tabTemplate = this.tabPanel.customTabTemplate
         * ```
         * \@memberof IgxTabPanelComponent
         * @return {?}
         */
        function () {
            return this._tabTemplate;
        },
        /**
         * Sets the tab template.
         * ```typescript
         * this.tabPanel.customTabTemplate(tabTemplate);
         * ```
         * @memberof IgxTabPanelComponent
         */
        set: /**
         * Sets the tab template.
         * ```typescript
         * this.tabPanel.customTabTemplate(tabTemplate);
         * ```
         * \@memberof IgxTabPanelComponent
         * @param {?} template
         * @return {?}
         */
        function (template) {
            this._tabTemplate = template;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTabPanelComponent.prototype.ngAfterContentInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (this.tabTemplate) {
            this._tabTemplate = this.tabTemplate.template;
        }
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTabPanelComponent.prototype.ngAfterViewChecked = /**
     * @hidden
     * @return {?}
     */
    function () {
        this._element.nativeElement.setAttribute('aria-labelledby', "igx-tab-" + this.index);
        this._element.nativeElement.setAttribute('id', "igx-bottom-nav__panel-" + this.index);
    };
    /**
     * Selects the current tab and the tab panel.
     * ```typescript
     * this.tabPanel.select();
     * ```
     * @memberof IgxTabPanelComponent
     */
    /**
     * Selects the current tab and the tab panel.
     * ```typescript
     * this.tabPanel.select();
     * ```
     * \@memberof IgxTabPanelComponent
     * @return {?}
     */
    IgxTabPanelComponent.prototype.select = /**
     * Selects the current tab and the tab panel.
     * ```typescript
     * this.tabPanel.select();
     * ```
     * \@memberof IgxTabPanelComponent
     * @return {?}
     */
    function () {
        if (this.disabled || this._tabBar.selectedIndex === this.index) {
            return;
        }
        this.isSelected = true;
        this._tabBar.onTabSelected.emit({ tab: this._tabBar.tabs.toArray()[this.index], panel: this });
    };
    IgxTabPanelComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-tab-panel',
                    template: "<ng-content></ng-content>\n"
                }] }
    ];
    /** @nocollapse */
    IgxTabPanelComponent.ctorParameters = function () { return [
        { type: IgxBottomNavComponent },
        { type: ElementRef }
    ]; };
    IgxTabPanelComponent.propDecorators = {
        label: [{ type: Input }],
        icon: [{ type: Input }],
        disabled: [{ type: Input }],
        role: [{ type: HostBinding, args: ['attr.role',] }],
        styleClass: [{ type: HostBinding, args: ['class.igx-bottom-nav__panel',] }],
        isSelected: [{ type: HostBinding, args: ['class.igx-bottom-nav__panel--selected',] }],
        tabTemplate: [{ type: ContentChild, args: [IgxTabTemplateDirective, { read: IgxTabTemplateDirective },] }]
    };
    return IgxTabPanelComponent;
}());
// ======================================= IgxTabComponent ==========================================
var IgxTabComponent = /** @class */ (function () {
    function IgxTabComponent(_tabBar, _element) {
        this._tabBar = _tabBar;
        this._element = _element;
        /**
         * Gets the `role` attribute.
         * ```typescript
         * let tabRole = this.tab.role;
         * ```
         * \@memberof IgxTabComponent
         */
        this.role = 'tab';
        /**
         * @hidden
         */
        this._changesCount = 0; // changes and updates accordingly applied to the tab.
    }
    Object.defineProperty(IgxTabComponent.prototype, "changesCount", {
        /**
         * Gets the changes and updates accordingly applied to the tab.
         *
         * @memberof IgxTabComponent
         */
        get: 
        // changes and updates accordingly applied to the tab.
        /**
         * Gets the changes and updates accordingly applied to the tab.
         *
         * \@memberof IgxTabComponent
         * @return {?}
         */
        function () {
            return this._changesCount;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTabComponent.prototype, "disabled", {
        /**
         * Gets whether the tab is disabled.
         * ```typescript
         * let isDisabled = this.tab.disabled;
         * ```
         * @memberof IgxTabComponent
         */
        get: /**
         * Gets whether the tab is disabled.
         * ```typescript
         * let isDisabled = this.tab.disabled;
         * ```
         * \@memberof IgxTabComponent
         * @return {?}
         */
        function () {
            /** @type {?} */
            var panel = this.relatedPanel;
            if (panel) {
                return panel.disabled;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTabComponent.prototype, "isSelected", {
        /**
         * Gets whether the tab is selected.
         * ```typescript
         * let isSelected  = this.tab.isSelected;
         * ```
         * @memberof IgxTabComponent
         */
        get: /**
         * Gets whether the tab is selected.
         * ```typescript
         * let isSelected  = this.tab.isSelected;
         * ```
         * \@memberof IgxTabComponent
         * @return {?}
         */
        function () {
            /** @type {?} */
            var panel = this.relatedPanel;
            if (panel) {
                return panel.isSelected;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTabComponent.prototype, "index", {
        /**
         * Gets the `index` of the tab.
         * ```typescript
         * let tabIndex = this.tab.index;
         * ```
         * @memberof IgxTabComponent
         */
        get: /**
         * Gets the `index` of the tab.
         * ```typescript
         * let tabIndex = this.tab.index;
         * ```
         * \@memberof IgxTabComponent
         * @return {?}
         */
        function () {
            return this._tabBar.tabs.toArray().indexOf(this);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Selects the current tab and the associated panel.
     * ```typescript
     * this.tab.select();
     * ```
     * @memberof IgxTabComponent
     */
    /**
     * Selects the current tab and the associated panel.
     * ```typescript
     * this.tab.select();
     * ```
     * \@memberof IgxTabComponent
     * @return {?}
     */
    IgxTabComponent.prototype.select = /**
     * Selects the current tab and the associated panel.
     * ```typescript
     * this.tab.select();
     * ```
     * \@memberof IgxTabComponent
     * @return {?}
     */
    function () {
        this.relatedPanel.select();
    };
    IgxTabComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-tab',
                    template: "<ng-template #defaultTabTemplate>\n    <div *ngIf=\"relatedPanel.icon\" class=\"tab-icon\">\n        <igx-icon fontSet=\"material\">{{relatedPanel.icon}}</igx-icon>\n        <igx-badge [value]=\"changesCount\" [hidden]=\"changesCount === 0\"></igx-badge>\n    </div>\n    <div *ngIf=\"relatedPanel.label\" ngClass=\"tab-label\">{{relatedPanel.label}}</div>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"relatedPanel.customTabTemplate ? relatedPanel.customTabTemplate : defaultTabTemplate; context: { $implicit: relatedPanel }\">\n</ng-container>"
                }] }
    ];
    /** @nocollapse */
    IgxTabComponent.ctorParameters = function () { return [
        { type: IgxBottomNavComponent },
        { type: ElementRef }
    ]; };
    IgxTabComponent.propDecorators = {
        role: [{ type: HostBinding, args: ['attr.role',] }],
        relatedPanel: [{ type: Input }]
    };
    return IgxTabComponent;
}());
/**
 * @hidden
 */
var IgxBottomNavModule = /** @class */ (function () {
    function IgxBottomNavModule() {
    }
    IgxBottomNavModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxBottomNavComponent, IgxTabPanelComponent, IgxTabComponent, IgxTabTemplateDirective],
                    exports: [IgxBottomNavComponent, IgxTabPanelComponent, IgxTabComponent, IgxTabTemplateDirective],
                    imports: [CommonModule, IgxBadgeModule, IgxIconModule]
                },] }
    ];
    return IgxBottomNavModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 * @abstract
 */
var  /**
 * @hidden
 * @abstract
 */
IgxTabsBase = /** @class */ (function () {
    function IgxTabsBase() {
    }
    // TODO: Define event arg interface!
    /**
     * @param {?} element
     * @param {?} scrollRight
     * @return {?}
     */
    IgxTabsBase.prototype.scrollElement = 
    // TODO: Define event arg interface!
    /**
     * @param {?} element
     * @param {?} scrollRight
     * @return {?}
     */
    function (element, scrollRight) { };
    return IgxTabsBase;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var ButtonStyle = {
    VISIBLE: 'visible',
    HIDDEN: 'hidden',
    NOT_DISPLAYED: 'not_displayed',
};
var IgxRightButtonStyleDirective = /** @class */ (function () {
    function IgxRightButtonStyleDirective(tabs) {
        this.tabs = tabs;
    }
    Object.defineProperty(IgxRightButtonStyleDirective.prototype, "visibleCSS", {
        get: /**
         * @return {?}
         */
        function () {
            return (this.getRightButtonStyle() === ButtonStyle.VISIBLE) ? true : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxRightButtonStyleDirective.prototype, "hiddenCSS", {
        get: /**
         * @return {?}
         */
        function () {
            return (this.getRightButtonStyle() === ButtonStyle.HIDDEN) ? true : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxRightButtonStyleDirective.prototype, "notDisplayedCSS", {
        get: /**
         * @return {?}
         */
        function () {
            return (this.getRightButtonStyle() === ButtonStyle.NOT_DISPLAYED) ? true : false;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @return {?}
     */
    IgxRightButtonStyleDirective.prototype.getRightButtonStyle = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var viewPortWidth = this.tabs.viewPort.nativeElement.offsetWidth;
        // We use this hacky way to get the width of the itemsContainer,
        // because there is inconsistency in IE we cannot use offsetWidth or scrollOffset.
        /** @type {?} */
        var itemsContainerChildrenCount = this.tabs.itemsContainer.nativeElement.children.length;
        /** @type {?} */
        var itemsContainerWidth = 0;
        if (itemsContainerChildrenCount > 1) {
            /** @type {?} */
            var lastTab = this.tabs.itemsContainer.nativeElement.children[itemsContainerChildrenCount - 2];
            itemsContainerWidth = lastTab.offsetLeft + lastTab.offsetWidth;
        }
        /** @type {?} */
        var headerContainerWidth = this.tabs.headerContainer.nativeElement.offsetWidth;
        /** @type {?} */
        var offset = this.tabs.offset;
        /** @type {?} */
        var total = offset + viewPortWidth;
        // Fix for IE 11, a difference is accumulated from the widths calculations.
        if (itemsContainerWidth - headerContainerWidth <= 1 && offset === 0) {
            return ButtonStyle.NOT_DISPLAYED;
        }
        if (itemsContainerWidth > total) {
            return ButtonStyle.VISIBLE;
        }
        else {
            return ButtonStyle.HIDDEN;
        }
    };
    IgxRightButtonStyleDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxRightButtonStyle]'
                },] }
    ];
    /** @nocollapse */
    IgxRightButtonStyleDirective.ctorParameters = function () { return [
        { type: IgxTabsBase }
    ]; };
    IgxRightButtonStyleDirective.propDecorators = {
        visibleCSS: [{ type: HostBinding, args: ['class.igx-tabs__header-button',] }],
        hiddenCSS: [{ type: HostBinding, args: ['class.igx-tabs__header-button--hidden',] }],
        notDisplayedCSS: [{ type: HostBinding, args: ['class.igx-tabs__header-button--none',] }]
    };
    return IgxRightButtonStyleDirective;
}());
var IgxLeftButtonStyleDirective = /** @class */ (function () {
    function IgxLeftButtonStyleDirective(tabs) {
        this.tabs = tabs;
    }
    Object.defineProperty(IgxLeftButtonStyleDirective.prototype, "visibleCSS", {
        get: /**
         * @return {?}
         */
        function () {
            return (this.getLeftButtonStyle() === ButtonStyle.VISIBLE) ? true : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxLeftButtonStyleDirective.prototype, "hiddenCSS", {
        get: /**
         * @return {?}
         */
        function () {
            return (this.getLeftButtonStyle() === ButtonStyle.HIDDEN) ? true : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxLeftButtonStyleDirective.prototype, "notDisplayedCSS", {
        get: /**
         * @return {?}
         */
        function () {
            return (this.getLeftButtonStyle() === ButtonStyle.NOT_DISPLAYED) ? true : false;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @return {?}
     */
    IgxLeftButtonStyleDirective.prototype.getLeftButtonStyle = /**
     * @private
     * @return {?}
     */
    function () {
        // We use this hacky way to get the width of the itemsContainer,
        // because there is inconsistency in IE we cannot use offsetWidth or scrollOffset.
        /** @type {?} */
        var itemsContainerChildrenCount = this.tabs.itemsContainer.nativeElement.children.length;
        /** @type {?} */
        var itemsContainerWidth = 0;
        if (itemsContainerChildrenCount > 1) {
            /** @type {?} */
            var lastTab = this.tabs.itemsContainer.nativeElement.children[itemsContainerChildrenCount - 2];
            itemsContainerWidth = lastTab.offsetLeft + lastTab.offsetWidth;
        }
        /** @type {?} */
        var headerContainerWidth = this.tabs.headerContainer.nativeElement.offsetWidth;
        /** @type {?} */
        var offset = this.tabs.offset;
        if (offset === 0) {
            // Fix for IE 11, a difference is accumulated from the widths calculations.
            if (itemsContainerWidth - headerContainerWidth <= 1) {
                return ButtonStyle.NOT_DISPLAYED;
            }
            return ButtonStyle.HIDDEN;
        }
        else {
            return ButtonStyle.VISIBLE;
        }
    };
    IgxLeftButtonStyleDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxLeftButtonStyle]'
                },] }
    ];
    /** @nocollapse */
    IgxLeftButtonStyleDirective.ctorParameters = function () { return [
        { type: IgxTabsBase }
    ]; };
    IgxLeftButtonStyleDirective.propDecorators = {
        visibleCSS: [{ type: HostBinding, args: ['class.igx-tabs__header-button',] }],
        hiddenCSS: [{ type: HostBinding, args: ['class.igx-tabs__header-button--hidden',] }],
        notDisplayedCSS: [{ type: HostBinding, args: ['class.igx-tabs__header-button--none',] }]
    };
    return IgxLeftButtonStyleDirective;
}());
var IgxTabItemTemplateDirective = /** @class */ (function () {
    function IgxTabItemTemplateDirective(template) {
        this.template = template;
    }
    IgxTabItemTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxTab]'
                },] }
    ];
    /** @nocollapse */
    IgxTabItemTemplateDirective.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return IgxTabItemTemplateDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxTabsGroupComponent = /** @class */ (function () {
    function IgxTabsGroupComponent(_tabs, _element) {
        this._tabs = _tabs;
        this._element = _element;
        /**
         * An \@Input property that allows you to enable/disable the `IgxTabGroupComponent`.
         * ```html
         * <igx-tabs-group label="Tab 2  Lorem ipsum dolor sit" icon="home" [disabled]="true">
         * ```
         */
        this.disabled = false;
        this.isSelected = false;
        /**
         * @hidden
         */
        this.role = 'tabpanel';
        /**
         * @hidden
         */
        this.styleClass = true;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    IgxTabsGroupComponent.prototype.onResize = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.isSelected) {
            this.transformContentAnimation(0);
        }
    };
    Object.defineProperty(IgxTabsGroupComponent.prototype, "relatedTab", {
        /**
         * An accessor that returns the `IgxTabItemComponent` component.
         * ```typescript
         * @ViewChild("MyTabsGroup")
         * public tab: IgxTabsGroupComponent;
         * ngAfterViewInIt(){
         *    let tabComponent = this.tab.relatedTab;
         * }
         * ```
         */
        get: /**
         * An accessor that returns the `IgxTabItemComponent` component.
         * ```typescript
         * \@ViewChild("MyTabsGroup")
         * public tab: IgxTabsGroupComponent;
         * ngAfterViewInIt(){
         *    let tabComponent = this.tab.relatedTab;
         * }
         * ```
         * @return {?}
         */
        function () {
            if (this._tabs.tabs) {
                return (/** @type {?} */ (this._tabs.tabs.toArray()[this.index]));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTabsGroupComponent.prototype, "index", {
        /**
         * An accessor that returns the value of the index of the `IgxTabsGroupComponent`.
         * ```typescript
         * @ViewChild("MyTabsGroup")
         * public tab: IgxTabsGroupComponent;
         * ngAfterViewInIt(){
         *    let tabIndex = this.tab.index;
         * }
         * ```
         */
        get: /**
         * An accessor that returns the value of the index of the `IgxTabsGroupComponent`.
         * ```typescript
         * \@ViewChild("MyTabsGroup")
         * public tab: IgxTabsGroupComponent;
         * ngAfterViewInIt(){
         *    let tabIndex = this.tab.index;
         * }
         * ```
         * @return {?}
         */
        function () {
            if (this._tabs.groups) {
                return this._tabs.groups.toArray().indexOf(this);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTabsGroupComponent.prototype, "customTabTemplate", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._tabTemplate;
        },
        /**
         *@hidden
         */
        set: /**
         * @hidden
         * @param {?} template
         * @return {?}
         */
        function (template) {
            this._tabTemplate = template;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTabsGroupComponent.prototype.ngAfterContentInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (this.tabTemplate) {
            this._tabTemplate = this.tabTemplate.template;
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTabsGroupComponent.prototype.ngAfterViewChecked = /**
     * @hidden
     * @return {?}
     */
    function () {
        this._element.nativeElement.setAttribute('aria-labelledby', "igx-tab-item-" + this.index);
        this._element.nativeElement.setAttribute('id', "igx-tabs__group-" + this.index);
        if (this.isSelected) {
            /** @type {?} */
            var tabItem = this.relatedTab.nativeTabItem.nativeElement;
            this.transformContentAnimation(0);
            this.transformIndicatorAnimation(tabItem);
        }
    };
    /**
     * A method that sets the focus on a tab.
     * @memberof {@link IgxTabsGroupComponent}
     *```typescript
     *@ViewChild("MyChild")
     *public tab : IgxTabsGroupComponent;
     *ngAfterViewInit(){
     *    this.tab.select();
     *}
     *```
     * @param focusDelay A number representing the expected delay.
     */
    /**
     * A method that sets the focus on a tab.
     * \@memberof {\@link IgxTabsGroupComponent}
     * ```typescript
     * \@ViewChild("MyChild")
     * public tab : IgxTabsGroupComponent;
     * ngAfterViewInit(){
     *    this.tab.select();
     * }
     * ```
     * @param {?=} focusDelay A number representing the expected delay.
     * @return {?}
     */
    IgxTabsGroupComponent.prototype.select = /**
     * A method that sets the focus on a tab.
     * \@memberof {\@link IgxTabsGroupComponent}
     * ```typescript
     * \@ViewChild("MyChild")
     * public tab : IgxTabsGroupComponent;
     * ngAfterViewInit(){
     *    this.tab.select();
     * }
     * ```
     * @param {?=} focusDelay A number representing the expected delay.
     * @return {?}
     */
    function (focusDelay) {
        var _this = this;
        if (focusDelay === void 0) { focusDelay = 200; }
        if (this.disabled || this.isSelected) {
            return;
        }
        this.isSelected = true;
        this.relatedTab.tabindex = 0;
        if (focusDelay !== 0) {
            setTimeout(function () {
                _this.relatedTab.nativeTabItem.nativeElement.focus();
            }, focusDelay);
        }
        this.handleSelection();
        this._tabs.onTabItemSelected.emit({ tab: this._tabs.tabs.toArray()[this.index], group: this });
    };
    /**
     * @private
     * @return {?}
     */
    IgxTabsGroupComponent.prototype.handleSelection = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var tabElement = this.relatedTab.nativeTabItem.nativeElement;
        // Scroll to the left
        if (tabElement.offsetLeft < this._tabs.offset) {
            this._tabs.scrollElement(tabElement, false);
        }
        // Scroll to the right
        /** @type {?} */
        var viewPortOffsetWidth = this._tabs.viewPort.nativeElement.offsetWidth;
        /** @type {?} */
        var delta = (tabElement.offsetLeft + tabElement.offsetWidth) - (viewPortOffsetWidth + this._tabs.offset);
        // Fix for IE 11, a difference is accumulated from the widths calculations
        if (delta > 1) {
            this._tabs.scrollElement(tabElement, true);
        }
        this.transformContentAnimation(0.2);
        this.transformIndicatorAnimation(tabElement);
    };
    /**
     * @private
     * @param {?} duration
     * @return {?}
     */
    IgxTabsGroupComponent.prototype.transformContentAnimation = /**
     * @private
     * @param {?} duration
     * @return {?}
     */
    function (duration) {
        /** @type {?} */
        var contentOffset = this._tabs.tabsContainer.nativeElement.offsetWidth * this.index;
        this._tabs.contentsContainer.nativeElement.style.transitionDuration = duration + "s";
        this._tabs.contentsContainer.nativeElement.style.transform = "translate(" + -contentOffset + "px)";
    };
    /**
     * @private
     * @param {?} element
     * @return {?}
     */
    IgxTabsGroupComponent.prototype.transformIndicatorAnimation = /**
     * @private
     * @param {?} element
     * @return {?}
     */
    function (element) {
        this._tabs.selectedIndicator.nativeElement.style.width = element.offsetWidth + "px";
        this._tabs.selectedIndicator.nativeElement.style.transform = "translate(" + element.offsetLeft + "px)";
    };
    IgxTabsGroupComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-tabs-group',
                    template: "<ng-content *ngIf=\"isSelected\"></ng-content>\n"
                }] }
    ];
    /** @nocollapse */
    IgxTabsGroupComponent.ctorParameters = function () { return [
        { type: IgxTabsBase },
        { type: ElementRef }
    ]; };
    IgxTabsGroupComponent.propDecorators = {
        disabled: [{ type: Input }],
        icon: [{ type: Input }],
        label: [{ type: Input }],
        tabTemplate: [{ type: ContentChild, args: [IgxTabItemTemplateDirective, { read: IgxTabItemTemplateDirective },] }],
        role: [{ type: HostBinding, args: ['attr.role',] }],
        styleClass: [{ type: HostBinding, args: ['class.igx-tabs__group',] }],
        onResize: [{ type: HostListener, args: ['window:resize', ['$event'],] }]
    };
    return IgxTabsGroupComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxTabItemComponent = /** @class */ (function () {
    function IgxTabItemComponent(_tabs, _element) {
        this._tabs = _tabs;
        this._element = _element;
        this._changesCount = 0; // changes and updates accordingly applied to the tab.
        /**
         * @hidden
         */
        this.role = 'tab';
        this._nativeTabItem = _element;
    }
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxTabItemComponent.prototype.onClick = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.select();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxTabItemComponent.prototype.onResize = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.isSelected) {
            this._tabs.selectedIndicator.nativeElement.style.width = this.nativeTabItem.nativeElement.offsetWidth + "px";
            this._tabs.selectedIndicator.nativeElement.style.transform = "translate(" + this.nativeTabItem.nativeElement.offsetLeft + "px)";
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxTabItemComponent.prototype.onKeydownArrowRight = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onKeyDown(false);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxTabItemComponent.prototype.onKeydownArrowLeft = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onKeyDown(true);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxTabItemComponent.prototype.onKeydownHome = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        this.onKeyDown(false, 0);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxTabItemComponent.prototype.onKeydownEnd = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        this.onKeyDown(false, this._tabs.tabs.toArray().length - 1);
    };
    Object.defineProperty(IgxTabItemComponent.prototype, "changesCount", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._changesCount;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTabItemComponent.prototype, "nativeTabItem", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._nativeTabItem;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTabItemComponent.prototype, "disabled", {
        /**
        * 	Gets whether the tab is disabled.
        * ```
        * const disabledItem = this.myTabComponent.tabs.first.disabled;
        * ```
        */
        get: /**
         * 	Gets whether the tab is disabled.
         * ```
         * const disabledItem = this.myTabComponent.tabs.first.disabled;
         * ```
         * @return {?}
         */
        function () {
            /** @type {?} */
            var group = this.relatedGroup;
            if (group) {
                return group.disabled;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTabItemComponent.prototype, "isSelected", {
        /**
         * Gets whether the tab is selected.
         * ```typescript
         * const selectedItem = this.myTabComponent.tabs.first.isSelected;
         * ```
         */
        get: /**
         * Gets whether the tab is selected.
         * ```typescript
         * const selectedItem = this.myTabComponent.tabs.first.isSelected;
         * ```
         * @return {?}
         */
        function () {
            /** @type {?} */
            var group = this.relatedGroup;
            if (group) {
                return group.isSelected;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTabItemComponent.prototype, "index", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._tabs.tabs.toArray().indexOf(this);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?=} focusDelay
     * @return {?}
     */
    IgxTabItemComponent.prototype.select = /**
     * @hidden
     * @param {?=} focusDelay
     * @return {?}
     */
    function (focusDelay) {
        if (focusDelay === void 0) { focusDelay = 200; }
        this.relatedGroup.select(focusDelay);
    };
    /**
     * @private
     * @param {?} isLeftArrow
     * @param {?=} index
     * @return {?}
     */
    IgxTabItemComponent.prototype.onKeyDown = /**
     * @private
     * @param {?} isLeftArrow
     * @param {?=} index
     * @return {?}
     */
    function (isLeftArrow, index) {
        if (index === void 0) { index = null; }
        /** @type {?} */
        var tabsArray = this._tabs.tabs.toArray();
        if (index === null) {
            index = (isLeftArrow)
                ? (this._tabs.selectedIndex === 0) ? tabsArray.length - 1 : this._tabs.selectedIndex - 1
                : (this._tabs.selectedIndex === tabsArray.length - 1) ? 0 : this._tabs.selectedIndex + 1;
        }
        /** @type {?} */
        var tab = tabsArray[index];
        tab.select(200);
    };
    IgxTabItemComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-tab-item',
                    template: "<ng-template #defaultTabTemplate>\n    <div *ngIf=\"relatedGroup.icon\" class=\"igx-tabs__header-menu-item-icon\">\n        <igx-icon fontSet=\"material\">{{relatedGroup.icon}}</igx-icon>\n        <igx-badge [value]=\"changesCount\" [hidden]=\"changesCount === 0\"></igx-badge>\n    </div>\n    <div *ngIf=\"relatedGroup.label\" ngClass=\"igx-tabs__item-label\">{{relatedGroup.label}}</div>\n</ng-template>\n<ng-container\n    *ngTemplateOutlet=\"relatedGroup.customTabTemplate ? relatedGroup.customTabTemplate : defaultTabTemplate; context: { $implicit: relatedGroup }\">\n</ng-container>"
                }] }
    ];
    /** @nocollapse */
    IgxTabItemComponent.ctorParameters = function () { return [
        { type: IgxTabsBase },
        { type: ElementRef }
    ]; };
    IgxTabItemComponent.propDecorators = {
        relatedGroup: [{ type: Input }],
        role: [{ type: HostBinding, args: ['attr.role',] }],
        tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
        onClick: [{ type: HostListener, args: ['click', ['$event'],] }],
        onResize: [{ type: HostListener, args: ['window:resize', ['$event'],] }],
        onKeydownArrowRight: [{ type: HostListener, args: ['keydown.arrowright', ['$event'],] }],
        onKeydownArrowLeft: [{ type: HostListener, args: ['keydown.arrowleft', ['$event'],] }],
        onKeydownHome: [{ type: HostListener, args: ['keydown.home', ['$event'],] }],
        onKeydownEnd: [{ type: HostListener, args: ['keydown.end', ['$event'],] }]
    };
    return IgxTabItemComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {string} */
var TabsType = {
    FIXED: 'fixed',
    CONTENTFIT: 'contentfit',
};
var IgxTabsComponent = /** @class */ (function () {
    function IgxTabsComponent(_element) {
        this._element = _element;
        /**
         * Defines the tab header sizing mode. You can choose between `contentfit` or `fixed`.
         * By default the header sizing mode is `contentfit`.
         * ```html
         * <igx-tabs tabsType="fixed">
         *     <igx-tabs-group label="HOME">Home</igx-tabs-group>
         * </igx-tabs>
         * ```
         */
        this.tabsType = 'contentfit';
        /**
         * @hidden
         */
        this.class = '';
        /**
         * Emitted when a tab item is deselected.
         * ```html
         * <igx-tabs (onTabItemDeselected)="itemDeselected($event)">
         *      <igx-tabs-group label="Tab 1">This is Tab 1 content.</igx-tabs-group>
         *      <igx-tabs-group label="Tab 2">This is Tab 2 content.</igx-tabs-group>
         * </igx-tabs>
         * ```
         * ```typescript
         * itemDeselected(e){
         *      const tabGroup = e.group;
         *      const tabItem = e.tab;
         * }
         * ```
         */
        this.onTabItemDeselected = new EventEmitter();
        /**
         * Emitted when a tab item is selected.
         * ```html
         * <igx-tabs (onTabItemSelected)="itemSelected($event)">
         *      <igx-tabs-group label="Tab 1">This is Tab 1 content.</igx-tabs-group>
         *      <igx-tabs-group label="Tab 2">This is Tab 2 content.</igx-tabs-group>
         * </igx-tabs>
         * ```
         * ```typescript
         * itemSelected(e){
         *      const tabGroup = e.group;
         *      const tabItem = e.tab;
         * }
         * ```
         */
        this.onTabItemSelected = new EventEmitter();
        /**
         * @hidden
         */
        this.offset = 0;
        this._selectedIndex = 0;
    }
    Object.defineProperty(IgxTabsComponent.prototype, "selectedIndex", {
        /**
        * An @Input property that sets the value of the `selectedIndex`.
        * Default value is 0.
        * ```html
        * <igx-tabs selectedIndex="1">
        * ```
        */
        get: /**
         * An \@Input property that sets the value of the `selectedIndex`.
         * Default value is 0.
         * ```html
         * <igx-tabs selectedIndex="1">
         * ```
         * @return {?}
         */
        function () {
            return this._selectedIndex;
        },
        set: /**
         * @param {?} index
         * @return {?}
         */
        function (index) {
            this._selectedIndex = index;
            this.setSelectedGroup();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTabsComponent.prototype, "cssClass", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            /** @type {?} */
            var defaultStyle = "igx-tabs";
            /** @type {?} */
            var fixedStyle = "igx-tabs--fixed";
            /** @type {?} */
            var iconStyle = "igx-tabs--icons";
            /** @type {?} */
            var iconLabelFound = this.groups.find(function (group) { return group.icon != null && group.label != null; });
            /** @type {?} */
            var css;
            switch (TabsType[this.tabsType.toUpperCase()]) {
                case TabsType.FIXED: {
                    css = fixedStyle;
                    break;
                }
                default: {
                    css = defaultStyle;
                    break;
                }
            }
            // Layout fix for items with icons
            if (iconLabelFound !== undefined) {
                css = css + " " + iconStyle;
            }
            return css + " " + this.class;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} args
     * @return {?}
     */
    IgxTabsComponent.prototype.selectedGroupHandler = /**
     * @hidden
     * @param {?} args
     * @return {?}
     */
    function (args) {
        var _this = this;
        /** @type {?} */
        var prevSelectedIndex = this.selectedIndex;
        if (prevSelectedIndex !== -1 && this.groups.toArray()[prevSelectedIndex] !== undefined) {
            this.onTabItemDeselected.emit({
                tab: this.groups.toArray()[prevSelectedIndex].relatedTab,
                group: this.groups.toArray()[prevSelectedIndex]
            });
        }
        this.selectedIndex = args.group.index;
        this.groups.forEach(function (p) {
            if (p.index !== _this.selectedIndex) {
                _this.deselectGroup(p);
            }
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxTabsComponent.prototype.scrollLeft = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.scroll(false);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxTabsComponent.prototype.scrollRight = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.scroll(true);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} element
     * @param {?} scrollRight
     * @return {?}
     */
    IgxTabsComponent.prototype.scrollElement = /**
     * @hidden
     * @param {?} element
     * @param {?} scrollRight
     * @return {?}
     */
    function (element, scrollRight) {
        /** @type {?} */
        var viewPortWidth = this.viewPort.nativeElement.offsetWidth;
        this.offset = (scrollRight) ? element.offsetWidth + element.offsetLeft - viewPortWidth : element.offsetLeft;
        this.itemsContainer.nativeElement.style.transform = "translate(" + -this.offset + "px)";
    };
    Object.defineProperty(IgxTabsComponent.prototype, "selectedTabItem", {
        /**
         * Gets the selected `IgxTabItemComponent`.
         * ```
         * const selectedItem = this.myTabComponent.selectedTabItem;
         * ```
         */
        get: /**
         * Gets the selected `IgxTabItemComponent`.
         * ```
         * const selectedItem = this.myTabComponent.selectedTabItem;
         * ```
         * @return {?}
         */
        function () {
            if (this.tabs && this.selectedIndex !== undefined) {
                return this.tabs.toArray()[this.selectedIndex];
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTabsComponent.prototype.ngAfterViewInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        requestAnimationFrame(function () {
            _this.setSelectedGroup();
        });
        this._groupChanges$ = this.groups.changes.subscribe(function () {
            _this.resetSelectionOnCollectionChanged();
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTabsComponent.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (this._groupChanges$) {
            this._groupChanges$.unsubscribe();
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxTabsComponent.prototype.setSelectedGroup = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        requestAnimationFrame(function () {
            if (_this.selectedIndex <= 0 || _this.selectedIndex >= _this.groups.length) {
                // if nothing is selected - select the first tabs group
                _this.selectGroupByIndex(0);
            }
            else {
                _this.selectGroupByIndex(_this.selectedIndex);
            }
        });
    };
    /**
     * @private
     * @return {?}
     */
    IgxTabsComponent.prototype.resetSelectionOnCollectionChanged = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        setTimeout(function () {
            if (_this.groups.toArray()[_this.selectedIndex] !== undefined) {
                // persist the selected index and applied it to the new collection
                _this.selectGroupByIndex(_this.selectedIndex);
            }
            else {
                if (_this.selectedIndex >= _this.groups.length) {
                    // in case the selected index is no longer valid, select the last group in the new collection
                    _this.selectGroupByIndex(_this.groups.length - 1);
                }
            }
        }, 0);
    };
    /**
     * @private
     * @param {?} selectedIndex
     * @return {?}
     */
    IgxTabsComponent.prototype.selectGroupByIndex = /**
     * @private
     * @param {?} selectedIndex
     * @return {?}
     */
    function (selectedIndex) {
        /** @type {?} */
        var selectableGroups = this.groups.filter(function (selectableGroup) { return !selectableGroup.disabled; });
        /** @type {?} */
        var group = selectableGroups[selectedIndex];
        if (group) {
            group.select(0);
        }
    };
    /**
     * @private
     * @param {?} group
     * @return {?}
     */
    IgxTabsComponent.prototype.deselectGroup = /**
     * @private
     * @param {?} group
     * @return {?}
     */
    function (group) {
        // Cannot deselect the selected tab - this will mean that there will be not selected tab left
        if (group.disabled || this.selectedTabItem.index === group.index) {
            return;
        }
        group.isSelected = false;
        group.relatedTab.tabindex = -1;
    };
    /**
     * @private
     * @param {?} scrollRight
     * @return {?}
     */
    IgxTabsComponent.prototype.scroll = /**
     * @private
     * @param {?} scrollRight
     * @return {?}
     */
    function (scrollRight) {
        var e_1, _a;
        /** @type {?} */
        var tabsArray = this.tabs.toArray();
        try {
            for (var tabsArray_1 = __values(tabsArray), tabsArray_1_1 = tabsArray_1.next(); !tabsArray_1_1.done; tabsArray_1_1 = tabsArray_1.next()) {
                var tab = tabsArray_1_1.value;
                /** @type {?} */
                var element = tab.nativeTabItem.nativeElement;
                if (scrollRight) {
                    if (element.offsetWidth + element.offsetLeft > this.viewPort.nativeElement.offsetWidth + this.offset) {
                        this.scrollElement(element, scrollRight);
                        break;
                    }
                }
                else {
                    if (element.offsetWidth + element.offsetLeft >= this.offset) {
                        this.scrollElement(element, scrollRight);
                        break;
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (tabsArray_1_1 && !tabsArray_1_1.done && (_a = tabsArray_1.return)) _a.call(tabsArray_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    IgxTabsComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-tabs',
                    template: "<!-- TODO Remove tab container from here -->\n<div #tabsContainer>\n    <div class=\"igx-tabs__header\" #headerContainer>\n        <button igxRipple class=\"igx-tabs__header-button\" igxButton=\"icon\" (click)=\"scrollLeft($event)\" igxLeftButtonStyle>\n            <igx-icon fontSet=\"material\">navigate_before</igx-icon>\n        </button>\n        <div class=\"igx-tabs__header-wrapper-fixed\" #viewPort>\n            <div #itemsContainer class=\"igx-tabs__header-wrapper-fluid\">\n                <igx-tab-item igxRipple *ngFor=\"let group of groups\" [id]=\"'igx-tab-item-' + group.index\" [attr.aria-label]=\"group.label\"\n                    [attr.aria-disabled]=\"group.disabled\" [attr.aria-selected]=\"group.isSelected\" [attr.aria-controls]=\"'igx-tab-item-group-'+ group.index\"\n                    [ngClass]=\"{\n                'igx-tabs__header-menu-item': !group.isSelected && !group.disabled,\n                'igx-tabs__header-menu-item--selected': group.isSelected,\n                'igx-tabs__header-menu-item--disabled': group.disabled }\" [relatedGroup]=\"group\" role=\"tab\">\n                </igx-tab-item>\n                <div #selectedIndicator *ngIf=\"groups.length > 0\" class=\"igx-tabs__header-menu-item-indicator\"></div>\n            </div>\n        </div>\n        <button igxRipple class=\"igx-tabs__header-button\" igxButton=\"icon\" (click)=\"scrollRight($event)\" igxRightButtonStyle>\n            <igx-icon fontSet=\"material\">navigate_next</igx-icon>\n        </button>\n    </div>\n    <div class=\"igx-tabs__content-fixed\">\n        <div #contentsContainer class=\"igx-tabs__content-fluid\">\n            <ng-content></ng-content>\n        </div>\n    </div>\n</div>",
                    providers: [{ provide: IgxTabsBase, useExisting: IgxTabsComponent }]
                }] }
    ];
    /** @nocollapse */
    IgxTabsComponent.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    IgxTabsComponent.propDecorators = {
        groups: [{ type: ContentChildren, args: [forwardRef(function () { return IgxTabsGroupComponent; }),] }],
        selectedIndex: [{ type: Input }],
        tabsType: [{ type: Input, args: ['tabsType',] }],
        class: [{ type: Input }],
        onTabItemDeselected: [{ type: Output }],
        onTabItemSelected: [{ type: Output }],
        contentsContainer: [{ type: ViewChild, args: ['contentsContainer',] }],
        headerContainer: [{ type: ViewChild, args: ['headerContainer',] }],
        itemsContainer: [{ type: ViewChild, args: ['itemsContainer',] }],
        selectedIndicator: [{ type: ViewChild, args: ['selectedIndicator',] }],
        tabsContainer: [{ type: ViewChild, args: ['tabsContainer',] }],
        viewPort: [{ type: ViewChild, args: ['viewPort',] }],
        tabs: [{ type: ViewChildren, args: [forwardRef(function () { return IgxTabItemComponent; }),] }],
        cssClass: [{ type: HostBinding, args: ['attr.class',] }],
        selectedGroupHandler: [{ type: HostListener, args: ['onTabItemSelected', ['$event'],] }]
    };
    return IgxTabsComponent;
}());
/**
 * @hidden
 */
var IgxTabsModule = /** @class */ (function () {
    function IgxTabsModule() {
    }
    IgxTabsModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxTabsComponent,
                        IgxTabsGroupComponent,
                        IgxTabItemComponent,
                        IgxTabItemTemplateDirective,
                        IgxRightButtonStyleDirective,
                        IgxLeftButtonStyleDirective],
                    exports: [IgxTabsComponent,
                        IgxTabsGroupComponent,
                        IgxTabItemComponent,
                        IgxTabItemTemplateDirective,
                        IgxRightButtonStyleDirective,
                        IgxLeftButtonStyleDirective],
                    imports: [CommonModule, IgxBadgeModule, IgxIconModule, IgxRippleModule]
                },] }
    ];
    return IgxTabsModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 * @type {?}
 */
var IGX_TIME_PICKER_COMPONENT = 'IgxTimePickerComponentToken';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxItemListDirective = /** @class */ (function () {
    function IgxItemListDirective(timePicker, elementRef) {
        this.timePicker = timePicker;
        this.elementRef = elementRef;
        this.tabindex = 0;
    }
    Object.defineProperty(IgxItemListDirective.prototype, "defaultCSS", {
        get: /**
         * @return {?}
         */
        function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxItemListDirective.prototype, "hourCSS", {
        get: /**
         * @return {?}
         */
        function () {
            return this.type === 'hourList';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxItemListDirective.prototype, "minuteCSS", {
        get: /**
         * @return {?}
         */
        function () {
            return this.type === 'minuteList';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxItemListDirective.prototype, "ampmCSS", {
        get: /**
         * @return {?}
         */
        function () {
            return this.type === 'ampmList';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    IgxItemListDirective.prototype.onFocus = /**
     * @return {?}
     */
    function () {
        this.isActive = true;
    };
    /**
     * @return {?}
     */
    IgxItemListDirective.prototype.onBlur = /**
     * @return {?}
     */
    function () {
        this.isActive = false;
    };
    /**
     * @private
     * @return {?}
     */
    IgxItemListDirective.prototype.nextItem = /**
     * @private
     * @return {?}
     */
    function () {
        switch (this.type) {
            case 'hourList': {
                this.timePicker.nextHour();
                break;
            }
            case 'minuteList': {
                this.timePicker.nextMinute();
                break;
            }
            case 'ampmList': {
                this.timePicker.nextAmPm();
                break;
            }
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxItemListDirective.prototype.prevItem = /**
     * @private
     * @return {?}
     */
    function () {
        switch (this.type) {
            case 'hourList': {
                this.timePicker.prevHour();
                break;
            }
            case 'minuteList': {
                this.timePicker.prevMinute();
                break;
            }
            case 'ampmList': {
                this.timePicker.prevAmPm();
                break;
            }
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxItemListDirective.prototype.onKeydownArrowDown = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        this.nextItem();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxItemListDirective.prototype.onKeydownArrowUp = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        this.prevItem();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxItemListDirective.prototype.onKeydownArrowRight = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        /** @type {?} */
        var listName = ((/** @type {?} */ (event.target))).className;
        if (listName.indexOf('hourList') !== -1) {
            this.timePicker.minuteList.nativeElement.focus();
        }
        else if (listName.indexOf('minuteList') !== -1 && this.timePicker._ampmItems.length !== 0) {
            this.timePicker.ampmList.nativeElement.focus();
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxItemListDirective.prototype.onKeydownArrowLeft = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        /** @type {?} */
        var listName = ((/** @type {?} */ (event.target))).className;
        if (listName.indexOf('minuteList') !== -1) {
            this.timePicker.hourList.nativeElement.focus();
        }
        else if (listName.indexOf('ampmList') !== -1) {
            this.timePicker.minuteList.nativeElement.focus();
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxItemListDirective.prototype.onKeydownEnter = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        if (this.timePicker.mode === InteractionMode.DropDown) {
            this.timePicker.hideOverlay();
            return;
        }
        this.timePicker.okButtonClick();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxItemListDirective.prototype.onKeydownEscape = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        this.timePicker.cancelButtonClick();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxItemListDirective.prototype.onHover = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.elementRef.nativeElement.focus();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxItemListDirective.prototype.onScroll = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        event.stopPropagation();
        if (event.deltaY > 0) {
            this.nextItem();
        }
        else if (event.deltaY < 0) {
            this.prevItem();
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxItemListDirective.prototype.onPanMove = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.deltaY < 0) {
            this.nextItem();
        }
        else if (event.deltaY > 0) {
            this.prevItem();
        }
    };
    IgxItemListDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxItemList]'
                },] }
    ];
    /** @nocollapse */
    IgxItemListDirective.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] },
        { type: ElementRef }
    ]; };
    IgxItemListDirective.propDecorators = {
        type: [{ type: Input, args: ['igxItemList',] }],
        tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
        defaultCSS: [{ type: HostBinding, args: ['class.igx-time-picker__column',] }],
        hourCSS: [{ type: HostBinding, args: ['class.igx-time-picker__hourList',] }],
        minuteCSS: [{ type: HostBinding, args: ['class.igx-time-picker__minuteList',] }],
        ampmCSS: [{ type: HostBinding, args: ['class.igx-time-picker__ampmList',] }],
        onFocus: [{ type: HostListener, args: ['focus',] }],
        onBlur: [{ type: HostListener, args: ['blur',] }],
        onKeydownArrowDown: [{ type: HostListener, args: ['keydown.arrowdown', ['$event'],] }],
        onKeydownArrowUp: [{ type: HostListener, args: ['keydown.arrowup', ['$event'],] }],
        onKeydownArrowRight: [{ type: HostListener, args: ['keydown.arrowright', ['$event'],] }],
        onKeydownArrowLeft: [{ type: HostListener, args: ['keydown.arrowleft', ['$event'],] }],
        onKeydownEnter: [{ type: HostListener, args: ['keydown.enter', ['$event'],] }],
        onKeydownEscape: [{ type: HostListener, args: ['keydown.escape', ['$event'],] }],
        onHover: [{ type: HostListener, args: ['mouseover',] }],
        onScroll: [{ type: HostListener, args: ['wheel', ['$event'],] }],
        onPanMove: [{ type: HostListener, args: ['panmove', ['$event'],] }]
    };
    return IgxItemListDirective;
}());
/**
 * @hidden
 */
var IgxHourItemDirective = /** @class */ (function () {
    function IgxHourItemDirective(timePicker, itemList) {
        this.timePicker = timePicker;
        this.itemList = itemList;
    }
    Object.defineProperty(IgxHourItemDirective.prototype, "defaultCSS", {
        get: /**
         * @return {?}
         */
        function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxHourItemDirective.prototype, "selectedCSS", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isSelectedHour;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxHourItemDirective.prototype, "activeCSS", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isSelectedHour && this.itemList.isActive;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxHourItemDirective.prototype, "isSelectedHour", {
        get: /**
         * @return {?}
         */
        function () {
            return this.timePicker.selectedHour === this.value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} item
     * @return {?}
     */
    IgxHourItemDirective.prototype.onClick = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (item !== '') {
            this.timePicker.scrollHourIntoView(item);
        }
    };
    IgxHourItemDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxHourItem]'
                },] }
    ];
    /** @nocollapse */
    IgxHourItemDirective.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] },
        { type: IgxItemListDirective }
    ]; };
    IgxHourItemDirective.propDecorators = {
        value: [{ type: Input, args: ['igxHourItem',] }],
        defaultCSS: [{ type: HostBinding, args: ['class.igx-time-picker__item',] }],
        selectedCSS: [{ type: HostBinding, args: ['class.igx-time-picker__item--selected',] }],
        activeCSS: [{ type: HostBinding, args: ['class.igx-time-picker__item--active',] }],
        onClick: [{ type: HostListener, args: ['click', ['value'],] }]
    };
    return IgxHourItemDirective;
}());
/**
 * @hidden
 */
var IgxMinuteItemDirective = /** @class */ (function () {
    function IgxMinuteItemDirective(timePicker, itemList) {
        this.timePicker = timePicker;
        this.itemList = itemList;
    }
    Object.defineProperty(IgxMinuteItemDirective.prototype, "defaultCSS", {
        get: /**
         * @return {?}
         */
        function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxMinuteItemDirective.prototype, "selectedCSS", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isSelectedMinute;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxMinuteItemDirective.prototype, "activeCSS", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isSelectedMinute && this.itemList.isActive;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxMinuteItemDirective.prototype, "isSelectedMinute", {
        get: /**
         * @return {?}
         */
        function () {
            return this.timePicker.selectedMinute === this.value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} item
     * @return {?}
     */
    IgxMinuteItemDirective.prototype.onClick = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (item !== '') {
            this.timePicker.scrollMinuteIntoView(item);
        }
    };
    IgxMinuteItemDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxMinuteItem]'
                },] }
    ];
    /** @nocollapse */
    IgxMinuteItemDirective.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] },
        { type: IgxItemListDirective }
    ]; };
    IgxMinuteItemDirective.propDecorators = {
        value: [{ type: Input, args: ['igxMinuteItem',] }],
        defaultCSS: [{ type: HostBinding, args: ['class.igx-time-picker__item',] }],
        selectedCSS: [{ type: HostBinding, args: ['class.igx-time-picker__item--selected',] }],
        activeCSS: [{ type: HostBinding, args: ['class.igx-time-picker__item--active',] }],
        onClick: [{ type: HostListener, args: ['click', ['value'],] }]
    };
    return IgxMinuteItemDirective;
}());
/**
 * @hidden
 */
var IgxAmPmItemDirective = /** @class */ (function () {
    function IgxAmPmItemDirective(timePicker, itemList) {
        this.timePicker = timePicker;
        this.itemList = itemList;
    }
    Object.defineProperty(IgxAmPmItemDirective.prototype, "defaultCSS", {
        get: /**
         * @return {?}
         */
        function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxAmPmItemDirective.prototype, "selectedCSS", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isSelectedAmPm;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxAmPmItemDirective.prototype, "activeCSS", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isSelectedAmPm && this.itemList.isActive;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxAmPmItemDirective.prototype, "isSelectedAmPm", {
        get: /**
         * @return {?}
         */
        function () {
            return this.timePicker.selectedAmPm === this.value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} item
     * @return {?}
     */
    IgxAmPmItemDirective.prototype.onClick = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (item !== '') {
            this.timePicker.scrollAmPmIntoView(item);
        }
    };
    IgxAmPmItemDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxAmPmItem]'
                },] }
    ];
    /** @nocollapse */
    IgxAmPmItemDirective.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] },
        { type: IgxItemListDirective }
    ]; };
    IgxAmPmItemDirective.propDecorators = {
        value: [{ type: Input, args: ['igxAmPmItem',] }],
        defaultCSS: [{ type: HostBinding, args: ['class.igx-time-picker__item',] }],
        selectedCSS: [{ type: HostBinding, args: ['class.igx-time-picker__item--selected',] }],
        activeCSS: [{ type: HostBinding, args: ['class.igx-time-picker__item--active',] }],
        onClick: [{ type: HostListener, args: ['click', ['value'],] }]
    };
    return IgxAmPmItemDirective;
}());
/**
 * This directive should be used to mark which ng-template will be used from IgxTimePicker when re-templating its input group.
 */
var IgxTimePickerTemplateDirective = /** @class */ (function () {
    function IgxTimePickerTemplateDirective(template) {
        this.template = template;
    }
    IgxTimePickerTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxTimePickerTemplate]'
                },] }
    ];
    /** @nocollapse */
    IgxTimePickerTemplateDirective.ctorParameters = function () { return [
        { type: TemplateRef }
    ]; };
    return IgxTimePickerTemplateDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Formats `IgxTimePickerComponent` display value according to the `format` property,
 * when the input element loses focus.
 *
 */
var TimeDisplayFormatPipe = /** @class */ (function () {
    function TimeDisplayFormatPipe(timePicker) {
        this.timePicker = timePicker;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    TimeDisplayFormatPipe.prototype.transform = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var maskAmPM = this.timePicker.parseMask();
        /** @type {?} */
        var mask = this.timePicker.parseMask(false);
        if (!value || value === mask || value === maskAmPM) {
            return '';
        }
        /** @type {?} */
        var sections = value.split(/[\s:]+/);
        /** @type {?} */
        var hour = sections[0];
        /** @type {?} */
        var minutes = sections[1];
        /** @type {?} */
        var amPM = sections[2];
        /** @type {?} */
        var format = this.timePicker.format;
        /** @type {?} */
        var prompt = this.timePicker.promptChar;
        /** @type {?} */
        var regExp = new RegExp(this.timePicker.promptChar, 'g');
        if (format.indexOf('hh') !== -1 || format.indexOf('HH') !== -1 && hour.indexOf(prompt) !== -1) {
            hour = hour === prompt + prompt ? '00' : hour.replace(regExp, '0');
        }
        if (format.indexOf('mm') !== -1 && minutes.indexOf(prompt) !== -1) {
            minutes = minutes === prompt + prompt ? '00' : minutes.replace(regExp, '0');
        }
        if (format.indexOf('hh') === -1 && format.indexOf('HH') === -1) {
            hour = hour.indexOf(prompt) !== -1 ? hour.replace(regExp, '') : hour;
            /** @type {?} */
            var hourVal = parseInt(hour, 10);
            hour = !hourVal ? '0' : hourVal < 10 && hourVal !== 0 ? hour.replace('0', '') : hour;
        }
        if (format.indexOf('mm') === -1) {
            minutes = minutes.indexOf(prompt) !== -1 ? minutes.replace(regExp, '') : minutes;
            /** @type {?} */
            var minutesVal = parseInt(minutes, 10);
            minutes = !minutesVal ? '0' : minutesVal < 10 && minutesVal !== 0 ? minutes.replace('0', '') : minutes;
        }
        if (format.indexOf('tt') !== -1 && (amPM !== 'AM' || amPM !== 'PM')) {
            amPM = amPM.indexOf('p') !== -1 || amPM.indexOf('P') !== -1 ? 'PM' : 'AM';
        }
        return amPM ? hour + ":" + minutes + " " + amPM : hour + ":" + minutes;
    };
    TimeDisplayFormatPipe.decorators = [
        { type: Pipe, args: [{ name: 'displayFormat' },] }
    ];
    /** @nocollapse */
    TimeDisplayFormatPipe.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] }
    ]; };
    return TimeDisplayFormatPipe;
}());
/**
 * Formats `IgxTimePickerComponent` display value according to the `format` property,
 * when the input element gets focus.
 *
 */
var TimeInputFormatPipe = /** @class */ (function () {
    function TimeInputFormatPipe(timePicker) {
        this.timePicker = timePicker;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    TimeInputFormatPipe.prototype.transform = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var prompt = this.timePicker.promptChar;
        /** @type {?} */
        var regExp = new RegExp(prompt, 'g');
        /** @type {?} */
        var mask;
        if (this.timePicker.cleared) {
            this.timePicker.cleared = false;
            mask = this.timePicker.parseMask(false);
        }
        else {
            mask = this.timePicker.parseMask();
        }
        if (!value || value === mask) {
            return mask;
        }
        /** @type {?} */
        var sections = value.split(/[\s:]+/);
        /** @type {?} */
        var hour = sections[0].replace(regExp, '');
        /** @type {?} */
        var minutes = sections[1].replace(regExp, '');
        /** @type {?} */
        var amPM = sections[2];
        /** @type {?} */
        var leadZeroHour = (parseInt(hour, 10) < 10 && !hour.startsWith('0')) || hour === '0';
        /** @type {?} */
        var leadZeroMinutes = (parseInt(minutes, 10) < 10 && !minutes.startsWith('0')) || minutes === '0';
        hour = leadZeroHour ? '0' + hour : hour;
        minutes = leadZeroMinutes ? '0' + minutes : minutes;
        return amPM ? hour + ":" + minutes + " " + amPM : hour + ":" + minutes;
    };
    TimeInputFormatPipe.decorators = [
        { type: Pipe, args: [{ name: 'inputFormat' },] }
    ];
    /** @nocollapse */
    TimeInputFormatPipe.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [IGX_TIME_PICKER_COMPONENT,] }] }
    ]; };
    return TimeInputFormatPipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var NEXT_ID$u = 0;
/** @type {?} */
var HOURS_POS = [0, 1, 2];
/** @type {?} */
var MINUTES_POS = [3, 4, 5];
/** @type {?} */
var AMPM_POS = [6, 7, 8];
/** @type {?} */
var ITEMS_COUNT = 7;
var TimePickerHammerConfig = /** @class */ (function (_super) {
    __extends(TimePickerHammerConfig, _super);
    function TimePickerHammerConfig() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.overrides = {
            pan: { direction: Hammer.DIRECTION_VERTICAL, threshold: 1 }
        };
        return _this;
    }
    TimePickerHammerConfig.decorators = [
        { type: Injectable }
    ];
    return TimePickerHammerConfig;
}(HammerGestureConfig));
var IgxTimePickerComponent = /** @class */ (function () {
    function IgxTimePickerComponent() {
        /**
         * An \@Input property that sets the value of the `id` attribute.
         * ```html
         * <igx-time-picker [id]="'igx-time-picker-5'" format="h:mm tt" ></igx-time-picker>
         * ```
         */
        this.id = "igx-time-picker-" + NEXT_ID$u++;
        /**
         * An \@Input property that allows you to disable the `igx-time-picker` component. By default `disabled` is set to false.
         * ```html
         * <igx-time-picker [disabled]="'true'" [vertical]="true" format="h:mm tt" ></igx-time-picker>
         * ```
         */
        this.disabled = false;
        /**
         * An \@Input property that gets/sets the delta by which hour and minute items would be changed <br>
         * when the user presses the Up/Down keys.
         * By default `itemsDelta` is set to `{hours: 1, minutes:1}`
         * ```html
         * <igx-time-picker [itemsDelta]="{hours:3, minutes:5}" id="time-picker"></igx-time-picker>
         * ```
         */
        this.itemsDelta = { hours: 1, minutes: 1 };
        /**
         * An \@Input property that determines the spin behavior. By default `isSpinLoop` is set to true.
         * The minutes and hour spinning will wrap around by default.
         * ```html
         * <igx-time-picker [isSpinLoop]="false" id="time-picker"></igx-time-picker>
         * ```
         */
        this.isSpinLoop = true;
        /**
         * An \@Input property that Gets/Sets the orientation of the `igxTimePicker`. By default `vertical` is set to false.
         * ```html
         * <igx-time-picker [vertical]="true" id="time-picker"></igx-time-picker>
         * ```
         */
        this.vertical = false;
        /**
         * Sets the character used to prompt the user for input.
         * Default value is "'-'".
         * ```html
         * <igx-time-picker [promptChar] = "'_'">
         * ```
         * \@memberof IgxTimePickerComponent
         */
        this.promptChar = '-';
        /**
         * An \@Input property that allows you to switch the interaction mode between
         * a dialog picker or dropdown with editable masked input.
         * Deafult is dialog picker.
         * ```html
         * public mode = InteractionMode.DROPDOWN;
         *  //..
         * <igx-time-picker [mode]="mode"></igx-time-picker>
         * ```
         * \@memberof IgxTimePickerComponent
         */
        this.mode = InteractionMode.Dialog;
        /**
         * Emitted when selection is made. The event contains the selected value. Returns {`oldValue`: `Date`, `newValue`: `Date`}.
         * ```typescript
         * \@ViewChild("toast")
         * private toast: IgxToastComponent;
         * public onValueChanged(timepicker){
         *    this.toast.show()
         * }
         * //...
         * ```
         * ```html
         * <igx-time-picker (onValueChanged)="onValueChanged($event)"></igx-time-picker>
         * <igx-toast #toast message="The value has been changed!"></igx-toast>
         * ```
         */
        this.onValueChanged = new EventEmitter();
        /**
         * Emitted when an invalid value is being set. Returns {`timePicker`: `any`, `currentValue`: `Date`, `setThroughUI`: `boolean`}
         * ```typescript
         * public min: string = "09:00";
         * public max: string = "18:00";
         * \@ViewChild("toast")
         * private toast: IgxToastComponent;
         * public onValidationFailed(timepicker){
         *    this.toast.show();
         * }
         * //...
         * ```
         * ```html
         * <igx-time-picker [minValue]="min" [maxValue]="max" (onValidationFailed)="onValidationFailed($event)"></igx-time-picker>
         * <igx-toast #toast message="Value must be between 09:00 and 18:00!"></igx-toast>
         * ```
         */
        this.onValidationFailed = new EventEmitter();
        /**
         * Emitted when a timePicker is being opened.
         * ```html
         * \@ViewChild("toast")
         * private toast: IgxToastComponent;
         * public onOpen(timepicker){
         *    this.toast.show();
         * }
         * //...
         * ```
         * ```html
         * <igx-time-picker [minValue]="min" [maxValue]="max" (onOpen)="onOpen($event)"></igx-time-picker>
         * <igx-toast #toast message="The time picker has been opened!"></igx-toast>
         * ```
         */
        this.onOpen = new EventEmitter();
        /**
         * Emitted when a timePicker is being closed.
         */
        this.onClose = new EventEmitter();
        /**
         * @hidden
         */
        this._hourItems = [];
        /**
         * @hidden
         */
        this._minuteItems = [];
        /**
         * @hidden
         */
        this._ampmItems = [];
        /**
         * @hidden
         */
        this.cleared = false;
        /**
         * @hidden
         */
        this.isNotEmpty = false;
        /**
         * @hidden
         */
        this.displayFormat = new TimeDisplayFormatPipe(this);
        /**
         * @hidden
         */
        this.inputFormat = new TimeInputFormatPipe(this);
        this._resourceStrings = CurrentResourceStrings.TimePickerResStrings;
        this._okButtonLabel = null;
        this._cancelButtonLabel = null;
        this._isHourListLoop = this.isSpinLoop;
        this._isMinuteListLoop = this.isSpinLoop;
        this._hourView = [];
        this._minuteView = [];
        this._ampmView = [];
        this._destroy$ = new Subject();
        this._onTouchedCallback = function () { };
        this._onChangeCallback = function () { };
    }
    Object.defineProperty(IgxTimePickerComponent.prototype, "value", {
        /**
         * An accessor that returns the value of `igx-time-picker` component.
         * ```html
         *@ViewChild("MyPick")
         *public pick: IgxTimePickerComponent;
         *ngAfterViewInit(){
         *    let pickSelect = this.pick.value;
         * }
         * ```
         */
        get: /**
         * An accessor that returns the value of `igx-time-picker` component.
         * ```html
         * \@ViewChild("MyPick")
         * public pick: IgxTimePickerComponent;
         * ngAfterViewInit(){
         *    let pickSelect = this.pick.value;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this._value;
        },
        /**
         * An accessor that allows you to set a time using the `value` input.
         * ```html
         *public date: Date = new Date(Date.now());
         *  //...
         *<igx-time-picker [value]="date" format="h:mm tt"></igx-time-picker>
         * ```
         */
        set: /**
         * An accessor that allows you to set a time using the `value` input.
         * ```html
         * public date: Date = new Date(Date.now());
         *  //...
         * <igx-time-picker [value]="date" format="h:mm tt"></igx-time-picker>
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._isValueValid(value)) {
                /** @type {?} */
                var oldVal = this._value;
                this._value = value;
                this._onChangeCallback(value);
                /** @type {?} */
                var dispVal = this._formatTime(this.value, this.format);
                if (this.mode === InteractionMode.DropDown && this._displayValue !== dispVal) {
                    this.displayValue = dispVal;
                }
                /** @type {?} */
                var args = {
                    oldValue: oldVal,
                    newValue: value
                };
                this.onValueChanged.emit(args);
            }
            else {
                /** @type {?} */
                var args = {
                    timePicker: this,
                    currentValue: value,
                    setThroughUI: false
                };
                this.onValidationFailed.emit(args);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTimePickerComponent.prototype, "resourceStrings", {
        /**
         * An accessor that returns the resource strings.
        */
        get: /**
         * An accessor that returns the resource strings.
         * @return {?}
         */
        function () {
            return this._resourceStrings;
        },
        /**
         * An accessor that sets the resource strings.
         * By default it uses EN resources.
        */
        set: /**
         * An accessor that sets the resource strings.
         * By default it uses EN resources.
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._resourceStrings = Object.assign({}, this._resourceStrings, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTimePickerComponent.prototype, "okButtonLabel", {
        /**
         * An accessor that returns the label of ok button.
        */
        get: /**
         * An accessor that returns the label of ok button.
         * @return {?}
         */
        function () {
            return this._okButtonLabel || this.resourceStrings.igx_time_picker_ok;
        },
        /**
         * An @Input property that renders OK button with custom text. By default `okButtonLabel` is set to OK.
         * ```html
         * <igx-time-picker okButtonLabel='SET' [value]="date" format="h:mm tt"></igx-time-picker>
         * ```
         */
        set: /**
         * An \@Input property that renders OK button with custom text. By default `okButtonLabel` is set to OK.
         * ```html
         * <igx-time-picker okButtonLabel='SET' [value]="date" format="h:mm tt"></igx-time-picker>
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._okButtonLabel = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTimePickerComponent.prototype, "cancelButtonLabel", {
        /**
        * An accessor that returns the label of cancel button.
        */
        get: /**
         * An accessor that returns the label of cancel button.
         * @return {?}
         */
        function () {
            return this._cancelButtonLabel || this.resourceStrings.igx_time_picker_cancel;
        },
        /**
         * An @Input property that renders cancel button with custom text.
         * By default `cancelButtonLabel` is set to Cancel.
         * ```html
         * <igx-time-picker cancelButtonLabel='Exit' [value]="date" format="h:mm tt"></igx-time-picker>
         * ```
         */
        set: /**
         * An \@Input property that renders cancel button with custom text.
         * By default `cancelButtonLabel` is set to Cancel.
         * ```html
         * <igx-time-picker cancelButtonLabel='Exit' [value]="date" format="h:mm tt"></igx-time-picker>
         * ```
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._cancelButtonLabel = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTimePickerComponent.prototype, "format", {
        /**
         * An @Input property that Gets/Sets format of time while `igxTimePicker` does not have focus. <br>
         * By default `format` is set to hh:mm tt. <br>
         * List of time-flags: <br>
         * `h` : hours field in 12-hours format without leading zero <br>
         * `hh` : hours field in 12-hours format with leading zero <br>
         * `H` : hours field in 24-hours format without leading zero <br>
         * `HH` : hours field in 24-hours format with leading zero <br>
         * `m` : minutes field without leading zero <br>
         * `mm` : minutes field with leading zero <br>
         * `tt` : 2 character string which represents AM/PM field <br>
         * ```html
         *<igx-time-picker format="HH:m" id="time-picker"></igx-time-picker>
         * ```
         */
        get: /**
         * An \@Input property that Gets/Sets format of time while `igxTimePicker` does not have focus. <br>
         * By default `format` is set to hh:mm tt. <br>
         * List of time-flags: <br>
         * `h` : hours field in 12-hours format without leading zero <br>
         * `hh` : hours field in 12-hours format with leading zero <br>
         * `H` : hours field in 24-hours format without leading zero <br>
         * `HH` : hours field in 24-hours format with leading zero <br>
         * `m` : minutes field without leading zero <br>
         * `mm` : minutes field with leading zero <br>
         * `tt` : 2 character string which represents AM/PM field <br>
         * ```html
         * <igx-time-picker format="HH:m" id="time-picker"></igx-time-picker>
         * ```
         * @return {?}
         */
        function () {
            return this._format || 'hh:mm tt';
        },
        set: /**
         * @param {?} formatValue
         * @return {?}
         */
        function (formatValue) {
            this._format = formatValue;
            this.mask = this._format.indexOf('tt') !== -1 ? '00:00 LL' : '00:00';
            if (this.displayValue) {
                this.displayValue = this._formatTime(this.value, this._format);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTimePickerComponent.prototype, "displayValue", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            if (this._displayValue === undefined) {
                return this._formatTime(this.value, this.format);
            }
            return this._displayValue;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._displayValue = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTimePickerComponent.prototype, "displayTime", {
        /**
         * Returns the current time formatted as string using the `format` option.
         * If there is no set time the return is an empty string.
         *```typescript
         *@ViewChild("MyChild")
         *private picker: IgxTimePickerComponent;
         *ngAfterViewInit(){
         *    let time = this.picker.displayTime;
         *}
         *```
         */
        get: /**
         * Returns the current time formatted as string using the `format` option.
         * If there is no set time the return is an empty string.
         * ```typescript
         * \@ViewChild("MyChild")
         * private picker: IgxTimePickerComponent;
         * ngAfterViewInit(){
         *    let time = this.picker.displayTime;
         * }
         * ```
         * @return {?}
         */
        function () {
            if (this.value) {
                return this._formatTime(this.value, this.format);
            }
            return '';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTimePickerComponent.prototype, "hourView", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._hourView;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTimePickerComponent.prototype, "minuteView", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._minuteView;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTimePickerComponent.prototype, "ampmView", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._ampmView;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTimePickerComponent.prototype, "showClearButton", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return (this.displayValue && this.displayValue !== this.parseMask(false)) || this.isNotEmpty;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTimePickerComponent.prototype, "validMinuteEntries", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            /** @type {?} */
            var minuteEntries = [];
            for (var i = 0; i < 60; i++) {
                minuteEntries.push(i);
            }
            return minuteEntries;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTimePickerComponent.prototype, "validHourEntries", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            /** @type {?} */
            var hourEntries = [];
            /** @type {?} */
            var index = this.format.indexOf('h') !== -1 ? 13 : 24;
            for (var i = 0; i < index; i++) {
                hourEntries.push(i);
            }
            return hourEntries;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTimePickerComponent.prototype, "template", {
        /**
         * Gets the input group template.
         * ```typescript
         * let template = this.template();
         * ```
         * @memberof IgxTimePickerComponent
         */
        get: /**
         * Gets the input group template.
         * ```typescript
         * let template = this.template();
         * ```
         * \@memberof IgxTimePickerComponent
         * @return {?}
         */
        function () {
            if (this.timePickerTemplateDirective) {
                return this.timePickerTemplateDirective.template;
            }
            return this.mode === InteractionMode.Dialog ? this.defaultTimePickerTemplate : this.dropdownInputTemplate;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTimePickerComponent.prototype, "context", {
        /**
         * Gets the context passed to the input group template.
         * @memberof IgxTimePickerComponent
         */
        get: /**
         * Gets the context passed to the input group template.
         * \@memberof IgxTimePickerComponent
         * @return {?}
         */
        function () {
            var _this = this;
            return {
                value: this.value,
                displayTime: this.displayTime,
                displayValue: this.displayValue,
                openDialog: function () { _this.openDialog(); }
            };
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTimePickerComponent.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        this._generateHours();
        this._generateMinutes();
        if (this.format.indexOf('tt') !== -1) {
            this._generateAmPm();
        }
        this._dropDownOverlaySettings = {
            modal: false,
            closeOnOutsideClick: true,
            scrollStrategy: new AbsoluteScrollStrategy(),
            positionStrategy: new AutoPositionStrategy()
        };
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTimePickerComponent.prototype.ngAfterViewInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.mode === InteractionMode.DropDown && this.input) {
            fromEvent(this.input.nativeElement, 'keydown').pipe(throttle(function () { return interval(0, animationFrameScheduler); }), takeUntil(this._destroy$)).subscribe(function (event) {
                if (event.key === "ArrowUp" /* UP_ARROW */ || event.key === "Up" /* UP_ARROW_IE */ ||
                    event.key === "ArrowDown" /* DOWN_ARROW */ || event.key === "Down" /* DOWN_ARROW_IE */) {
                    _this.spinOnEdit(event);
                }
            });
        }
        if (this.container && this.group) {
            this.container.nativeElement.style.width = this.group.element.nativeElement.getBoundingClientRect().width + 'px';
        }
        if (this.toggleRef) {
            this.toggleRef.onClosed.pipe(takeUntil(this._destroy$)).subscribe(function () {
                if (_this._input) {
                    _this._input.nativeElement.focus();
                }
                if (_this.mode === InteractionMode.DropDown) {
                    _this._onDropDownClosed();
                }
                _this.onClose.emit(_this);
            });
            this.toggleRef.onOpened.pipe(takeUntil(this._destroy$)).subscribe(function () {
                _this.onOpen.emit(_this);
            });
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTimePickerComponent.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        this._destroy$.next(true);
        this._destroy$.complete();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxTimePickerComponent.prototype.onKeydownSpace = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.openDialog();
        event.preventDefault();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTimePickerComponent.prototype.onAltArrowDown = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.openDialog();
    };
    /**
     * @private
     * @param {?} item
     * @param {?} items
     * @param {?} selectedItem
     * @param {?} isListLoop
     * @param {?} viewType
     * @return {?}
     */
    IgxTimePickerComponent.prototype._scrollItemIntoView = /**
     * @private
     * @param {?} item
     * @param {?} items
     * @param {?} selectedItem
     * @param {?} isListLoop
     * @param {?} viewType
     * @return {?}
     */
    function (item, items, selectedItem, isListLoop, viewType) {
        /** @type {?} */
        var itemIntoView;
        if (items) {
            /** @type {?} */
            var index = (item === 'AM' || item === 'PM') ? items.indexOf(item) : items.indexOf(parseInt(item, 10));
            /** @type {?} */
            var view = void 0;
            if (index !== -1) {
                if (isListLoop) {
                    if (index > 0) {
                        selectedItem = this._itemToString(items[index - 1], viewType);
                        itemIntoView = this._nextItem(items, selectedItem, isListLoop, viewType);
                    }
                    else {
                        selectedItem = this._itemToString(items[1], viewType);
                        itemIntoView = this._prevItem(items, selectedItem, isListLoop, viewType);
                    }
                }
                else {
                    view = items.slice(index - 3, index + 4);
                    selectedItem = this._itemToString(items[index], viewType);
                    itemIntoView = { selectedItem: selectedItem, view: view };
                }
                itemIntoView.view = this._viewToString(itemIntoView.view, viewType);
            }
        }
        return itemIntoView;
    };
    /**
     * @private
     * @param {?} view
     * @param {?} viewType
     * @return {?}
     */
    IgxTimePickerComponent.prototype._viewToString = /**
     * @private
     * @param {?} view
     * @param {?} viewType
     * @return {?}
     */
    function (view, viewType) {
        for (var i = 0; i < view.length; i++) {
            if (typeof (view[i]) !== 'string') {
                view[i] = this._itemToString(view[i], viewType);
            }
        }
        return view;
    };
    /**
     * @private
     * @param {?} item
     * @param {?} viewType
     * @return {?}
     */
    IgxTimePickerComponent.prototype._itemToString = /**
     * @private
     * @param {?} item
     * @param {?} viewType
     * @return {?}
     */
    function (item, viewType) {
        if (item === null) {
            item = '';
        }
        else if (viewType && typeof (item) !== 'string') {
            /** @type {?} */
            var leadZeroHour = (item < 10 && (this.format.indexOf('hh') !== -1 || this.format.indexOf('HH') !== -1));
            /** @type {?} */
            var leadZeroMinute = (item < 10 && this.format.indexOf('mm') !== -1);
            /** @type {?} */
            var leadZero = (viewType === 'hour') ? leadZeroHour : leadZeroMinute;
            item = (leadZero) ? '0' + item : "" + item;
        }
        return item;
    };
    /**
     * @private
     * @param {?} items
     * @param {?} selectedItem
     * @param {?} isListLoop
     * @param {?} viewType
     * @return {?}
     */
    IgxTimePickerComponent.prototype._prevItem = /**
     * @private
     * @param {?} items
     * @param {?} selectedItem
     * @param {?} isListLoop
     * @param {?} viewType
     * @return {?}
     */
    function (items, selectedItem, isListLoop, viewType) {
        /** @type {?} */
        var selectedIndex = items.indexOf(parseInt(selectedItem, 10));
        /** @type {?} */
        var itemsCount = items.length;
        /** @type {?} */
        var view;
        if (selectedIndex === -1) {
            view = items.slice(0, 7);
            selectedItem = items[3];
        }
        else if (isListLoop) {
            if (selectedIndex - 4 < 0) {
                view = items.slice(itemsCount - (4 - selectedIndex), itemsCount);
                view = view.concat(items.slice(0, selectedIndex + 3));
            }
            else if (selectedIndex + 4 > itemsCount) {
                view = items.slice(selectedIndex - 4, itemsCount);
                view = view.concat(items.slice(0, selectedIndex + 3 - itemsCount));
            }
            else {
                view = items.slice(selectedIndex - 4, selectedIndex + 3);
            }
            selectedItem = (selectedIndex === 0) ? items[itemsCount - 1] : items[selectedIndex - 1];
        }
        else if (selectedIndex > 3) {
            view = items.slice(selectedIndex - 4, selectedIndex + 3);
            selectedItem = items[selectedIndex - 1];
        }
        else if (selectedIndex === 3) {
            view = items.slice(0, 7);
        }
        view = this._viewToString(view, viewType);
        selectedItem = this._itemToString(selectedItem, viewType);
        return {
            selectedItem: selectedItem,
            view: view
        };
    };
    /**
     * @private
     * @param {?} items
     * @param {?} selectedItem
     * @param {?} isListLoop
     * @param {?} viewType
     * @return {?}
     */
    IgxTimePickerComponent.prototype._nextItem = /**
     * @private
     * @param {?} items
     * @param {?} selectedItem
     * @param {?} isListLoop
     * @param {?} viewType
     * @return {?}
     */
    function (items, selectedItem, isListLoop, viewType) {
        /** @type {?} */
        var selectedIndex = items.indexOf(parseInt(selectedItem, 10));
        /** @type {?} */
        var itemsCount = items.length;
        /** @type {?} */
        var view;
        if (selectedIndex === -1) {
            view = items.slice(0, 7);
            selectedItem = items[3];
        }
        else if (isListLoop) {
            if (selectedIndex < 2) {
                view = items.slice(itemsCount - (2 - selectedIndex), itemsCount);
                view = view.concat(items.slice(0, selectedIndex + 5));
            }
            else if (selectedIndex + 4 >= itemsCount) {
                view = items.slice(selectedIndex - 2, itemsCount);
                view = view.concat(items.slice(0, selectedIndex + 5 - itemsCount));
            }
            else {
                view = items.slice(selectedIndex - 2, selectedIndex + 5);
            }
            selectedItem = (selectedIndex === itemsCount - 1) ? items[0] : items[selectedIndex + 1];
        }
        else if (selectedIndex + 1 < itemsCount - 3) {
            view = items.slice(selectedIndex - 2, selectedIndex + 5);
            selectedItem = items[selectedIndex + 1];
        }
        else if (selectedIndex === itemsCount - 4) {
            view = items.slice(selectedIndex - 3, itemsCount);
        }
        view = this._viewToString(view, viewType);
        selectedItem = this._itemToString(selectedItem, viewType);
        return {
            selectedItem: selectedItem,
            view: view
        };
    };
    /**
     * @private
     * @param {?} value
     * @param {?} format
     * @return {?}
     */
    IgxTimePickerComponent.prototype._formatTime = /**
     * @private
     * @param {?} value
     * @param {?} format
     * @return {?}
     */
    function (value, format) {
        if (!value) {
            return '';
        }
        else {
            /** @type {?} */
            var hour = value.getHours();
            /** @type {?} */
            var minute = value.getMinutes();
            /** @type {?} */
            var formattedMinute = void 0;
            /** @type {?} */
            var formattedHour = void 0;
            /** @type {?} */
            var amPM = void 0;
            if (format.indexOf('h') !== -1) {
                amPM = (hour > 11) ? 'PM' : 'AM';
                if (hour > 12) {
                    hour -= 12;
                    formattedHour = hour < 10 && format.indexOf('hh') !== -1 ? '0' + hour : "" + hour;
                }
                else if (hour === 0) {
                    formattedHour = '12';
                }
                else if (hour < 10 && format.indexOf('hh') !== -1) {
                    formattedHour = '0' + hour;
                }
                else {
                    formattedHour = "" + hour;
                }
            }
            else {
                if (hour < 10 && format.indexOf('HH') !== -1) {
                    formattedHour = '0' + hour;
                }
                else {
                    formattedHour = "" + hour;
                }
            }
            formattedMinute = minute < 10 && format.indexOf('mm') !== -1 ? '0' + minute : "" + minute;
            return format.replace('hh', formattedHour).replace('h', formattedHour)
                .replace('HH', formattedHour).replace('H', formattedHour)
                .replace('mm', formattedMinute).replace('m', formattedMinute)
                .replace('tt', amPM);
        }
    };
    /**
     * @private
     * @param {?} start
     * @param {?} end
     * @return {?}
     */
    IgxTimePickerComponent.prototype._updateHourView = /**
     * @private
     * @param {?} start
     * @param {?} end
     * @return {?}
     */
    function (start, end) {
        this._hourView = this._viewToString(this._hourItems.slice(start, end), 'hour');
    };
    /**
     * @private
     * @param {?} start
     * @param {?} end
     * @return {?}
     */
    IgxTimePickerComponent.prototype._updateMinuteView = /**
     * @private
     * @param {?} start
     * @param {?} end
     * @return {?}
     */
    function (start, end) {
        this._minuteView = this._viewToString(this._minuteItems.slice(start, end), 'minute');
    };
    /**
     * @private
     * @param {?} start
     * @param {?} end
     * @return {?}
     */
    IgxTimePickerComponent.prototype._updateAmPmView = /**
     * @private
     * @param {?} start
     * @param {?} end
     * @return {?}
     */
    function (start, end) {
        this._ampmView = this._ampmItems.slice(start, end);
    };
    /**
     * @private
     * @param {?} items
     * @return {?}
     */
    IgxTimePickerComponent.prototype._addEmptyItems = /**
     * @private
     * @param {?} items
     * @return {?}
     */
    function (items) {
        for (var i = 0; i < 3; i++) {
            items.push(null);
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxTimePickerComponent.prototype._generateHours = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var hourItemsCount = 24;
        if (this.format.indexOf('h') !== -1) {
            hourItemsCount = 13;
        }
        hourItemsCount /= this.itemsDelta.hours;
        /** @type {?} */
        var i = this.format.indexOf('H') !== -1 ? 0 : 1;
        if (hourItemsCount < 7 || !this.isSpinLoop) {
            this._addEmptyItems(this._hourItems);
            this._isHourListLoop = false;
        }
        if (hourItemsCount > 1) {
            for (i; i < hourItemsCount; i++) {
                this._hourItems.push(i * this.itemsDelta.hours);
            }
        }
        else {
            this._hourItems.push(0);
        }
        if (hourItemsCount < 7 || !this.isSpinLoop) {
            this._addEmptyItems(this._hourItems);
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxTimePickerComponent.prototype._generateMinutes = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var minuteItemsCount = 60 / this.itemsDelta.minutes;
        if (minuteItemsCount < 7 || !this.isSpinLoop) {
            this._addEmptyItems(this._minuteItems);
            this._isMinuteListLoop = false;
        }
        for (var i = 0; i < minuteItemsCount; i++) {
            this._minuteItems.push(i * this.itemsDelta.minutes);
        }
        if (minuteItemsCount < 7 || !this.isSpinLoop) {
            this._addEmptyItems(this._minuteItems);
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxTimePickerComponent.prototype._generateAmPm = /**
     * @private
     * @return {?}
     */
    function () {
        this._addEmptyItems(this._ampmItems);
        this._ampmItems.push('AM');
        this._ampmItems.push('PM');
        this._addEmptyItems(this._ampmItems);
    };
    /**
     * @private
     * @return {?}
     */
    IgxTimePickerComponent.prototype._getSelectedTime = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var date = this.value ? new Date(this.value) : new Date();
        date.setHours(parseInt(this.selectedHour, 10));
        date.setMinutes(parseInt(this.selectedMinute, 10));
        date.setSeconds(0);
        if (this.selectedAmPm === 'PM' && this.selectedHour !== '12') {
            date.setHours(date.getHours() + 12);
        }
        if (this.selectedAmPm === 'AM' && this.selectedHour === '12') {
            date.setHours(0);
        }
        return date;
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    IgxTimePickerComponent.prototype._convertMinMaxValue = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var date = this.value ? new Date(this.value) : this._dateFromModel ? new Date(this._dateFromModel) : new Date();
        /** @type {?} */
        var sections = value.split(/[\s:]+/);
        date.setHours(parseInt(sections[0], 10));
        date.setMinutes(parseInt(sections[1], 10));
        date.setSeconds(0);
        if (sections[2] && sections[2] === 'PM' && sections[0] !== '12') {
            date.setHours(date.getHours() + 12);
        }
        if (sections[0] === '12' && sections[2] && sections[2] === 'AM') {
            date.setHours(0);
        }
        return date;
    };
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    IgxTimePickerComponent.prototype._isValueValid = /**
     * @private
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (this.maxValue && value > this._convertMinMaxValue(this.maxValue)) {
            return false;
        }
        else if (this.minValue && value < this._convertMinMaxValue(this.minValue)) {
            return false;
        }
        else {
            return true;
        }
    };
    /**
     * @private
     * @param {?} val
     * @return {?}
     */
    IgxTimePickerComponent.prototype._isEntryValid = /**
     * @private
     * @param {?} val
     * @return {?}
     */
    function (val) {
        /** @type {?} */
        var sections = val.split(/[\s:]+/);
        /** @type {?} */
        var re = new RegExp(this.promptChar, 'g');
        /** @type {?} */
        var hour = parseInt(sections[0].replace(re, ''), 10);
        /** @type {?} */
        var minutes = parseInt(sections[1].replace(re, ''), 10);
        return this.validHourEntries.indexOf(hour) !== -1 && this.validMinuteEntries.indexOf(minutes) !== -1;
    };
    /**
     * @private
     * @return {?}
     */
    IgxTimePickerComponent.prototype._getCursorPosition = /**
     * @private
     * @return {?}
     */
    function () {
        return this.input.nativeElement.selectionStart;
    };
    /**
     * @private
     * @param {?} start
     * @param {?=} end
     * @return {?}
     */
    IgxTimePickerComponent.prototype._setCursorPosition = /**
     * @private
     * @param {?} start
     * @param {?=} end
     * @return {?}
     */
    function (start, end) {
        if (end === void 0) { end = start; }
        this.input.nativeElement.setSelectionRange(start, end);
    };
    /**
     * @private
     * @return {?}
     */
    IgxTimePickerComponent.prototype._updateEditableInput = /**
     * @private
     * @return {?}
     */
    function () {
        if (this.mode === InteractionMode.DropDown) {
            this.displayValue = this._formatTime(this._getSelectedTime(), this.format);
        }
    };
    /**
     * @private
     * @param {?} currentVal
     * @param {?} minVal
     * @param {?} maxVal
     * @param {?} hDelta
     * @param {?} sign
     * @return {?}
     */
    IgxTimePickerComponent.prototype._spinHours = /**
     * @private
     * @param {?} currentVal
     * @param {?} minVal
     * @param {?} maxVal
     * @param {?} hDelta
     * @param {?} sign
     * @return {?}
     */
    function (currentVal, minVal, maxVal, hDelta, sign) {
        /** @type {?} */
        var oldVal = new Date(currentVal);
        currentVal.setMinutes(sign * hDelta);
        if (currentVal.getDate() !== oldVal.getDate() && this.isSpinLoop) {
            currentVal.setDate(oldVal.getDate());
        }
        /** @type {?} */
        var minutes = currentVal.getMinutes();
        if (currentVal.getTime() > maxVal.getTime()) {
            if (this.isSpinLoop) {
                minutes = minutes < minVal.getMinutes() ? 60 + minutes : minutes;
                minVal.setMinutes(sign * minutes);
                return minVal;
            }
            else {
                return oldVal;
            }
        }
        else if (currentVal.getTime() < minVal.getTime()) {
            if (this.isSpinLoop) {
                minutes = minutes <= maxVal.getMinutes() ? minutes : minutes - 60;
                maxVal.setMinutes(minutes);
                return maxVal;
            }
            else {
                return oldVal;
            }
        }
        else {
            return currentVal;
        }
    };
    /**
     * @private
     * @param {?} currentVal
     * @param {?} mDelta
     * @param {?} sign
     * @return {?}
     */
    IgxTimePickerComponent.prototype._spinMinutes = /**
     * @private
     * @param {?} currentVal
     * @param {?} mDelta
     * @param {?} sign
     * @return {?}
     */
    function (currentVal, mDelta, sign) {
        /** @type {?} */
        var minutes = currentVal.getMinutes() + (sign * mDelta);
        if (minutes < 0 || minutes >= 60) {
            minutes = this.isSpinLoop ? minutes - (sign * 60) : currentVal.getMinutes();
        }
        currentVal.setMinutes(minutes);
        return currentVal;
    };
    /**
     * @private
     * @return {?}
     */
    IgxTimePickerComponent.prototype._initializeContainer = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.value) {
            /** @type {?} */
            var formttedTime = this._formatTime(this.value, this.format);
            /** @type {?} */
            var sections = formttedTime.split(/[\s:]+/);
            this.selectedHour = sections[0];
            this.selectedMinute = sections[1];
            if (this._ampmItems !== null) {
                this.selectedAmPm = sections[2];
            }
        }
        if (this.selectedHour === undefined) {
            this.selectedHour = "" + this._hourItems[3];
        }
        if (this.selectedMinute === undefined) {
            this.selectedMinute = '0';
        }
        if (this.selectedAmPm === undefined && this._ampmItems !== null) {
            this.selectedAmPm = this._ampmItems[3];
        }
        this._prevSelectedHour = this.selectedHour;
        this._prevSelectedMinute = this.selectedMinute;
        this._prevSelectedAmPm = this.selectedAmPm;
        this._onTouchedCallback();
        this._updateHourView(0, ITEMS_COUNT);
        this._updateMinuteView(0, ITEMS_COUNT);
        this._updateAmPmView(0, ITEMS_COUNT);
        if (this.selectedHour) {
            this.scrollHourIntoView(this.selectedHour);
        }
        if (this.selectedMinute) {
            this.scrollMinuteIntoView(this.selectedMinute);
        }
        if (this.selectedAmPm) {
            this.scrollAmPmIntoView(this.selectedAmPm);
        }
        requestAnimationFrame(function () {
            _this.hourList.nativeElement.focus();
        });
    };
    /**
     * @private
     * @return {?}
     */
    IgxTimePickerComponent.prototype._closeDropDown = /**
     * @private
     * @return {?}
     */
    function () {
        this.toggleRef.close();
        this._onDropDownClosed();
    };
    /**
     * @private
     * @return {?}
     */
    IgxTimePickerComponent.prototype._onDropDownClosed = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var oldValue = this.value;
        /** @type {?} */
        var newVal = this._convertMinMaxValue(this.displayValue);
        if (this._isValueValid(newVal)) {
            if (!this.value || oldValue.getTime() !== newVal.getTime()) {
                this.value = newVal;
            }
        }
        else {
            this.displayValue = this.inputFormat.transform(this._formatTime(oldValue, this.format));
            /** @type {?} */
            var args = {
                timePicker: this,
                currentValue: newVal,
                setThroughUI: true
            };
            this.onValidationFailed.emit(args);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTimePickerComponent.prototype.getEditElement = /**
     * @hidden
     * @return {?}
     */
    function () {
        return this._input.nativeElement;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    IgxTimePickerComponent.prototype.writeValue = /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    function (value) {
        // use this flag to make sure that min/maxValue are checked (in _convertMinMaxValue() method)
        // against the real value when initializing the component and value is bound via ngModel
        this._dateFromModel = value;
        this.value = value;
        if (this.mode === InteractionMode.DropDown) {
            this.displayValue = this._formatTime(this.value, this.format);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    IgxTimePickerComponent.prototype.registerOnChange = /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._onChangeCallback = fn; };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    IgxTimePickerComponent.prototype.registerOnTouched = /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    function (fn) { this._onTouchedCallback = fn; };
    /**
     * opens the dialog.
     * ```html
     *<igx-time-picker #timePicker></igx-time-picker>
     * ```
     * ```typescript
     * @ViewChild('timePicker', { read: IgxTimePickerComponent }) picker: IgxTimePickerComponent;
     * picker.openDialog();
     * ```
     */
    /**
     * opens the dialog.
     * ```html
     * <igx-time-picker #timePicker></igx-time-picker>
     * ```
     * ```typescript
     * \@ViewChild('timePicker', { read: IgxTimePickerComponent }) picker: IgxTimePickerComponent;
     * picker.openDialog();
     * ```
     * @param {?=} timePicker
     * @return {?}
     */
    IgxTimePickerComponent.prototype.openDialog = /**
     * opens the dialog.
     * ```html
     * <igx-time-picker #timePicker></igx-time-picker>
     * ```
     * ```typescript
     * \@ViewChild('timePicker', { read: IgxTimePickerComponent }) picker: IgxTimePickerComponent;
     * picker.openDialog();
     * ```
     * @param {?=} timePicker
     * @return {?}
     */
    function (timePicker) {
        if (timePicker === void 0) { timePicker = this; }
        if (this.toggleRef.collapsed) {
            /** @type {?} */
            var settings = void 0;
            if (this.mode === InteractionMode.Dialog && this.overlaySettings) {
                settings = this.overlaySettings;
            }
            if (this.mode === InteractionMode.DropDown) {
                settings = this.overlaySettings || this._dropDownOverlaySettings;
                /** @type {?} */
                var posStrategy = settings.positionStrategy;
                if (this.group && posStrategy) {
                    posStrategy.settings.target = this.group.element.nativeElement;
                }
                else if (this.templateDropDownTarget && posStrategy) {
                    posStrategy.settings.target = this.templateDropDownTarget.nativeElement;
                }
                else if (!posStrategy || (posStrategy && !posStrategy.settings.target)) {
                    throw new Error('There is no target element for the dropdown to attach.' +
                        'Mark a DOM element with #dropDownTarget ref variable or provide correct overlay positionStrategy.');
                }
            }
            if (this.outlet) {
                settings.outlet = this.outlet;
            }
            this.toggleRef.open(settings);
            this._initializeContainer();
        }
        else if (this.mode === InteractionMode.DropDown) {
            this._closeDropDown();
        }
    };
    /**
     * Scrolls a hour item into view.
     * ```typescript
     *scrhintoView(picker) {
     *picker.scrollHourIntoView('2');
     *}
     * ```
     *```html
     *<igx-time-picker #picker format="h:mm tt" (onOpen)="scrhintoView(picker)"></igx-time-picker>
     *```
     *@param item to be scrolled in view.
     */
    /**
     * Scrolls a hour item into view.
     * ```typescript
     * scrhintoView(picker) {
     * picker.scrollHourIntoView('2');
     * }
     * ```
     * ```html
     * <igx-time-picker #picker format="h:mm tt" (onOpen)="scrhintoView(picker)"></igx-time-picker>
     * ```
     * @param {?} item to be scrolled in view.
     * @return {?}
     */
    IgxTimePickerComponent.prototype.scrollHourIntoView = /**
     * Scrolls a hour item into view.
     * ```typescript
     * scrhintoView(picker) {
     * picker.scrollHourIntoView('2');
     * }
     * ```
     * ```html
     * <igx-time-picker #picker format="h:mm tt" (onOpen)="scrhintoView(picker)"></igx-time-picker>
     * ```
     * @param {?} item to be scrolled in view.
     * @return {?}
     */
    function (item) {
        /** @type {?} */
        var hourIntoView = this._scrollItemIntoView(item, this._hourItems, this.selectedHour, this._isHourListLoop, 'hour');
        if (hourIntoView) {
            this._hourView = hourIntoView.view;
            this.selectedHour = hourIntoView.selectedItem;
            this._updateEditableInput();
        }
    };
    /**
     * Scrolls a minute item into view.
     * ```typescript
     *scrMintoView(picker) {
     *picker.scrollMinuteIntoView('3');
     *}
     * ```
     *```html
     *<igx-time-picker #picker format="h:mm tt" (onOpen)="scrMintoView(picker)"></igx-time-picker>
     *```
     * @param item to be scrolled in view.
     */
    /**
     * Scrolls a minute item into view.
     * ```typescript
     * scrMintoView(picker) {
     * picker.scrollMinuteIntoView('3');
     * }
     * ```
     * ```html
     * <igx-time-picker #picker format="h:mm tt" (onOpen)="scrMintoView(picker)"></igx-time-picker>
     * ```
     * @param {?} item to be scrolled in view.
     * @return {?}
     */
    IgxTimePickerComponent.prototype.scrollMinuteIntoView = /**
     * Scrolls a minute item into view.
     * ```typescript
     * scrMintoView(picker) {
     * picker.scrollMinuteIntoView('3');
     * }
     * ```
     * ```html
     * <igx-time-picker #picker format="h:mm tt" (onOpen)="scrMintoView(picker)"></igx-time-picker>
     * ```
     * @param {?} item to be scrolled in view.
     * @return {?}
     */
    function (item) {
        /** @type {?} */
        var minuteIntoView = this._scrollItemIntoView(item, this._minuteItems, this.selectedMinute, this._isMinuteListLoop, 'minute');
        if (minuteIntoView) {
            this._minuteView = minuteIntoView.view;
            this.selectedMinute = minuteIntoView.selectedItem;
            this._updateEditableInput();
        }
    };
    /**
     * Scrolls an ampm item into view.
     * ```typescript
     *scrAmPmIntoView(picker) {
     *picker.scrollAmPmIntoView('PM');
     *}
     * ```
     *```html
     *<igx-time-picker #picker format="h:mm tt" (onOpen)="scrAmPmIntoView(picker)"></igx-time-picker>
     *```
     * @param item to be scrolled in view.
     */
    /**
     * Scrolls an ampm item into view.
     * ```typescript
     * scrAmPmIntoView(picker) {
     * picker.scrollAmPmIntoView('PM');
     * }
     * ```
     * ```html
     * <igx-time-picker #picker format="h:mm tt" (onOpen)="scrAmPmIntoView(picker)"></igx-time-picker>
     * ```
     * @param {?} item to be scrolled in view.
     * @return {?}
     */
    IgxTimePickerComponent.prototype.scrollAmPmIntoView = /**
     * Scrolls an ampm item into view.
     * ```typescript
     * scrAmPmIntoView(picker) {
     * picker.scrollAmPmIntoView('PM');
     * }
     * ```
     * ```html
     * <igx-time-picker #picker format="h:mm tt" (onOpen)="scrAmPmIntoView(picker)"></igx-time-picker>
     * ```
     * @param {?} item to be scrolled in view.
     * @return {?}
     */
    function (item) {
        /** @type {?} */
        var ampmIntoView = this._scrollItemIntoView(item, this._ampmItems, this.selectedAmPm, false, null);
        if (ampmIntoView) {
            this._ampmView = ampmIntoView.view;
            this.selectedAmPm = ampmIntoView.selectedItem;
            this._updateEditableInput();
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTimePickerComponent.prototype.nextHour = /**
     * @hidden
     * @return {?}
     */
    function () {
        /** @type {?} */
        var nextHour = this._nextItem(this._hourItems, this.selectedHour, this._isHourListLoop, 'hour');
        this._hourView = nextHour.view;
        this.selectedHour = nextHour.selectedItem;
        this._updateEditableInput();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTimePickerComponent.prototype.prevHour = /**
     * @hidden
     * @return {?}
     */
    function () {
        /** @type {?} */
        var prevHour = this._prevItem(this._hourItems, this.selectedHour, this._isHourListLoop, 'hour');
        this._hourView = prevHour.view;
        this.selectedHour = prevHour.selectedItem;
        this._updateEditableInput();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTimePickerComponent.prototype.nextMinute = /**
     * @hidden
     * @return {?}
     */
    function () {
        /** @type {?} */
        var nextMinute = this._nextItem(this._minuteItems, this.selectedMinute, this._isMinuteListLoop, 'minute');
        this._minuteView = nextMinute.view;
        this.selectedMinute = nextMinute.selectedItem;
        this._updateEditableInput();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTimePickerComponent.prototype.prevMinute = /**
     * @hidden
     * @return {?}
     */
    function () {
        /** @type {?} */
        var prevMinute = this._prevItem(this._minuteItems, this.selectedMinute, this._isMinuteListLoop, 'minute');
        this._minuteView = prevMinute.view;
        this.selectedMinute = prevMinute.selectedItem;
        this._updateEditableInput();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTimePickerComponent.prototype.nextAmPm = /**
     * @hidden
     * @return {?}
     */
    function () {
        /** @type {?} */
        var selectedIndex = this._ampmItems.indexOf(this.selectedAmPm);
        if (selectedIndex + 1 < this._ampmItems.length - 3) {
            this._updateAmPmView(selectedIndex - 2, selectedIndex + 5);
            this.selectedAmPm = this._ampmItems[selectedIndex + 1];
            this._updateEditableInput();
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTimePickerComponent.prototype.prevAmPm = /**
     * @hidden
     * @return {?}
     */
    function () {
        /** @type {?} */
        var selectedIndex = this._ampmItems.indexOf(this.selectedAmPm);
        if (selectedIndex > 3) {
            this._updateAmPmView(selectedIndex - 4, selectedIndex + 3);
            this.selectedAmPm = this._ampmItems[selectedIndex - 1];
            this._updateEditableInput();
        }
    };
    /**
     * If current value is valid selects it, closes the dialog and returns true, otherwise returns false.
     * ```html
     * <igx-dialog class="igx-time-picker__dialog-popup" [rightButtonLabel]="okButtonLabel" (onRightButtonSelect)="okButtonClick()">
     * //..
     * </igx-dialog>
     * ```
     */
    /**
     * If current value is valid selects it, closes the dialog and returns true, otherwise returns false.
     * ```html
     * <igx-dialog class="igx-time-picker__dialog-popup" [rightButtonLabel]="okButtonLabel" (onRightButtonSelect)="okButtonClick()">
     * //..
     * </igx-dialog>
     * ```
     * @return {?}
     */
    IgxTimePickerComponent.prototype.okButtonClick = /**
     * If current value is valid selects it, closes the dialog and returns true, otherwise returns false.
     * ```html
     * <igx-dialog class="igx-time-picker__dialog-popup" [rightButtonLabel]="okButtonLabel" (onRightButtonSelect)="okButtonClick()">
     * //..
     * </igx-dialog>
     * ```
     * @return {?}
     */
    function () {
        /** @type {?} */
        var time = this._getSelectedTime();
        if (this._isValueValid(time)) {
            this.hideOverlay();
            this.value = time;
            return true;
        }
        else {
            /** @type {?} */
            var args = {
                timePicker: this,
                currentValue: time,
                setThroughUI: true
            };
            this.onValidationFailed.emit(args);
            return false;
        }
    };
    /**
     * Closes the dialog without selecting the current value.
     * ```html
     * <igx-dialog class="igx-time-picker__dialog-popup" [leftButtonLabel]="cancelButtonLabel" (onLeftButtonSelect)="cancelButtonClick()">
     * //...
     * </igx-dialog>
     * ```
     */
    /**
     * Closes the dialog without selecting the current value.
     * ```html
     * <igx-dialog class="igx-time-picker__dialog-popup" [leftButtonLabel]="cancelButtonLabel" (onLeftButtonSelect)="cancelButtonClick()">
     * //...
     * </igx-dialog>
     * ```
     * @return {?}
     */
    IgxTimePickerComponent.prototype.cancelButtonClick = /**
     * Closes the dialog without selecting the current value.
     * ```html
     * <igx-dialog class="igx-time-picker__dialog-popup" [leftButtonLabel]="cancelButtonLabel" (onLeftButtonSelect)="cancelButtonClick()">
     * //...
     * </igx-dialog>
     * ```
     * @return {?}
     */
    function () {
        this.hideOverlay();
        this.selectedHour = this._prevSelectedHour;
        this.selectedMinute = this._prevSelectedMinute;
        this.selectedAmPm = this._prevSelectedAmPm;
    };
    /**
     * Returns an array of the hours currently in view.
     *```html
     *@ViewChild("MyChild")
     *private picker: IgxTimePickerComponent;
     *ngAfterViewInit(){
     *    let hInView = this.picker.hoursInView;
     *}
     *```
     */
    /**
     * Returns an array of the hours currently in view.
     * ```html
     * \@ViewChild("MyChild")
     * private picker: IgxTimePickerComponent;
     * ngAfterViewInit(){
     *    let hInView = this.picker.hoursInView;
     * }
     * ```
     * @return {?}
     */
    IgxTimePickerComponent.prototype.hoursInView = /**
     * Returns an array of the hours currently in view.
     * ```html
     * \@ViewChild("MyChild")
     * private picker: IgxTimePickerComponent;
     * ngAfterViewInit(){
     *    let hInView = this.picker.hoursInView;
     * }
     * ```
     * @return {?}
     */
    function () {
        return this._hourView.filter(function (hour) { return hour !== ''; });
    };
    /**
     * Returns an array of the minutes currently in view.
     *```html
     *@ViewChild("MyChild")
     *private picker: IgxTimePickerComponent;
     *ngAfterViewInit(){
     *    let minInView = this.picker.minutesInView;
     *}
     *```
     */
    /**
     * Returns an array of the minutes currently in view.
     * ```html
     * \@ViewChild("MyChild")
     * private picker: IgxTimePickerComponent;
     * ngAfterViewInit(){
     *    let minInView = this.picker.minutesInView;
     * }
     * ```
     * @return {?}
     */
    IgxTimePickerComponent.prototype.minutesInView = /**
     * Returns an array of the minutes currently in view.
     * ```html
     * \@ViewChild("MyChild")
     * private picker: IgxTimePickerComponent;
     * ngAfterViewInit(){
     *    let minInView = this.picker.minutesInView;
     * }
     * ```
     * @return {?}
     */
    function () {
        return this._minuteView.filter(function (minute) { return minute !== ''; });
    };
    /**
     * Returns an array of the AM/PM currently in view.
     *```html
     *@ViewChild("MyChild")
     *private picker: IgxTimePickerComponent;
     *ngAfterViewInit(){
     *    let ApInView = this.picker.ampmInView;
     *}
     *```
     */
    /**
     * Returns an array of the AM/PM currently in view.
     * ```html
     * \@ViewChild("MyChild")
     * private picker: IgxTimePickerComponent;
     * ngAfterViewInit(){
     *    let ApInView = this.picker.ampmInView;
     * }
     * ```
     * @return {?}
     */
    IgxTimePickerComponent.prototype.ampmInView = /**
     * Returns an array of the AM/PM currently in view.
     * ```html
     * \@ViewChild("MyChild")
     * private picker: IgxTimePickerComponent;
     * ngAfterViewInit(){
     *    let ApInView = this.picker.ampmInView;
     * }
     * ```
     * @return {?}
     */
    function () {
        return this._ampmView.filter(function (ampm) { return ampm !== ''; });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTimePickerComponent.prototype.hideOverlay = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.toggleRef.close();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?=} preserveAmPm
     * @return {?}
     */
    IgxTimePickerComponent.prototype.parseMask = /**
     * @hidden
     * @param {?=} preserveAmPm
     * @return {?}
     */
    function (preserveAmPm) {
        if (preserveAmPm === void 0) { preserveAmPm = true; }
        /** @type {?} */
        var prompts = this.promptChar + this.promptChar;
        /** @type {?} */
        var amPm = preserveAmPm ? 'AM' : prompts;
        return this.format.indexOf('tt') !== -1 ? prompts + ":" + prompts + " " + amPm : prompts + ":" + prompts;
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTimePickerComponent.prototype.clear = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (this.toggleRef.collapsed) {
            this.cleared = true;
            this.isNotEmpty = false;
            /** @type {?} */
            var oldVal = new Date(this.value);
            this.displayValue = '';
            this.value.setHours(0, 0);
            if (oldVal.getTime() !== this.value.getTime()) {
                /** @type {?} */
                var args = {
                    oldValue: oldVal,
                    newValue: this.value
                };
                this.onValueChanged.emit(args);
            }
        }
        else {
            this.hideOverlay();
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxTimePickerComponent.prototype.onInput = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var val = event.target.value;
        /** @type {?} */
        var oldVal = new Date(this.value);
        this.isNotEmpty = val !== this.parseMask(false);
        // handle cases where all empty positions (promts) are filled and we want to update
        // timepicker own value property if it is a valid Date
        if (val.indexOf(this.promptChar) === -1) {
            if (this._isEntryValid(val)) {
                /** @type {?} */
                var newVal = this._convertMinMaxValue(val);
                if (oldVal.getTime() !== newVal.getTime()) {
                    this.value = newVal;
                }
            }
            else {
                /** @type {?} */
                var args = {
                    timePicker: this,
                    currentValue: val,
                    setThroughUI: false
                };
                this.onValidationFailed.emit(args);
            }
            // handle cases where the user deletes the display value (when pressing backspace or delete)
        }
        else if (!this.value || !val || val === this.parseMask(false)) {
            this.isNotEmpty = false;
            this.value.setHours(0, 0);
            this.displayValue = val;
            if (oldVal.getTime() !== this.value.getTime()) {
                /** @type {?} */
                var args = {
                    oldValue: oldVal,
                    newValue: this.value
                };
                this.onValueChanged.emit(args);
            }
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxTimePickerComponent.prototype.onFocus = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.isNotEmpty = event.target.value !== this.parseMask(false);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxTimePickerComponent.prototype.onBlur = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var value = event.target.value;
        this.isNotEmpty = value !== '';
        this.displayValue = value;
        if (value && value !== this.parseMask()) {
            if (this._isEntryValid(value)) {
                /** @type {?} */
                var newVal = this._convertMinMaxValue(value);
                if (!this.value || this.value.getTime() !== newVal.getTime()) {
                    this.value = newVal;
                }
            }
            else {
                /** @type {?} */
                var args = {
                    timePicker: this,
                    currentValue: value,
                    setThroughUI: false
                };
                this.onValidationFailed.emit(args);
            }
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxTimePickerComponent.prototype.spinOnEdit = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        event.preventDefault();
        /** @type {?} */
        var sign;
        /** @type {?} */
        var displayVal;
        /** @type {?} */
        var currentVal = new Date(this.value);
        /** @type {?} */
        var min = this.minValue ? this._convertMinMaxValue(this.minValue) : this._convertMinMaxValue('00:00');
        /** @type {?} */
        var max = this.maxValue ? this._convertMinMaxValue(this.maxValue) : this._convertMinMaxValue('24:00');
        /** @type {?} */
        var cursor = this._getCursorPosition();
        if (event.key) {
            /** @type {?} */
            var key = event.key;
            sign = key === "ArrowDown" /* DOWN_ARROW */ || key === "Down" /* DOWN_ARROW_IE */ ? -1 : 1;
        }
        if (event.deltaY) {
            sign = event.deltaY < 0 ? 1 : -1;
        }
        if (!this.displayValue) {
            this.value = min;
            displayVal = this._formatTime(this.value, this.format);
        }
        else {
            /** @type {?} */
            var hDelta = this.itemsDelta.hours * 60 + (sign * this.value.getMinutes());
            /** @type {?} */
            var mDelta = this.itemsDelta.minutes;
            /** @type {?} */
            var sections = this.displayValue.split(/[\s:]+/);
            if (HOURS_POS.indexOf(cursor) !== -1) {
                this.value = this._spinHours(currentVal, min, max, hDelta, sign);
            }
            if (MINUTES_POS.indexOf(cursor) !== -1) {
                this.value = this._spinMinutes(currentVal, mDelta, sign);
            }
            if (AMPM_POS.indexOf(cursor) !== -1 && this.format.indexOf('tt') !== -1) {
                sign = sections[2] && sections[2] === 'AM' ? 1 : -1;
                currentVal.setHours(currentVal.getHours() + (sign * 12));
                this.value = currentVal;
            }
            displayVal = this._formatTime(this.value, this.format);
        }
        // minor hack for preventing cursor jumping in IE
        this._displayValue = this.inputFormat.transform(displayVal);
        this.input.nativeElement.value = this._displayValue;
        this._setCursorPosition(cursor);
        requestAnimationFrame(function () {
            _this._setCursorPosition(cursor);
        });
    };
    IgxTimePickerComponent.decorators = [
        { type: Component, args: [{
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: IgxTimePickerComponent,
                            multi: true
                        },
                        {
                            provide: HAMMER_GESTURE_CONFIG,
                            useClass: TimePickerHammerConfig
                        },
                        {
                            provide: IGX_TIME_PICKER_COMPONENT,
                            useExisting: IgxTimePickerComponent
                        }
                    ],
                    selector: 'igx-time-picker',
                    template: "<ng-template #dropdownInputTemplate>\n    <igx-input-group #group>\n        <label igxLabel>Time</label>\n        <igx-prefix (click)=\"openDialog()\">\n            <igx-icon>access_time</igx-icon>\n        </igx-prefix>\n        <input #input type=\"text\" [igxMask]=\"mask\" igxInput [includeLiterals]=\"false\" [placeholder]=\"format\"\n            [displayValuePipe]=\"displayFormat\" [focusedValuePipe]=\"inputFormat\" [promptChar]=\"promptChar\"\n            [value]=\"displayValue\" (input)=\"onInput($event)\" (blur)=\"onBlur($event)\" (focus)=\"onFocus($event)\"\n            (wheel)=\"spinOnEdit($event)\" [disabled]=\"disabled\" />\n        <igx-suffix *ngIf=\"showClearButton\" igxRipple (click)=\"clear()\">\n            <igx-icon fontSet=\"material\">clear</igx-icon>\n        </igx-suffix>\n    </igx-input-group>\n</ng-template>\n<ng-template #defaultTimePickerTemplate>\n    <igx-input-group (click)=\"openDialog()\">\n        <igx-prefix>\n            <igx-icon>access_time</igx-icon>\n        </igx-prefix>\n        <label igxLabel>Time</label>\n        <input igxInput [value]=\"displayTime || ''\" [disabled]=\"disabled\" tabindex=\"0\" readonly />\n    </igx-input-group>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"template; context: context\"></ng-container>\n\n<div #container igxToggle class=\"igx-time-picker\"\n    [ngClass]=\"{'igx-time-picker--dropdown': mode === 'dropdown', 'igx-time-picker--vertical': vertical && mode === 'dialog'}\">\n    <div *ngIf=\"mode === 'dialog'\" class=\"igx-time-picker__header\">\n        <h5 class=\"igx-time-picker__header-ampm\">{{ selectedAmPm }}</h5>\n        <h2 class=\"igx-time-picker__header-hour\">\n            <span>{{ selectedHour }}</span>:<span>{{ selectedMinute }}</span>\n        </h2>\n    </div>\n    <div class=\"igx-time-picker__main\">\n        <div class=\"igx-time-picker__body\">\n            <div #hourList [igxItemList]=\"'hourList'\">\n                <span [igxHourItem]=\"hour\" *ngFor=\"let hour of hourView\">{{ hour }}</span>\n            </div>\n            <div #minuteList [igxItemList]=\"'minuteList'\">\n                <span [igxMinuteItem]=\"minute\" *ngFor=\"let minute of minuteView\">{{ minute }}</span>\n            </div>\n            <div #ampmList [igxItemList]=\"'ampmList'\">\n                <span [igxAmPmItem]=\"ampm\" *ngFor=\"let ampm of ampmView\">{{ ampm }}</span>\n            </div>\n        </div>\n        <div *ngIf=\"mode === 'dialog'\" class=\"igx-time-picker__buttons\">\n            <button *ngIf=\"cancelButtonLabel.length\" igxButton=\"flat\" (click)=\"cancelButtonClick()\">\n                {{cancelButtonLabel}}\n            </button>\n            <button *ngIf=\"okButtonLabel.length\" igxButton=\"flat\" (click)=\"okButtonClick()\">\n                {{okButtonLabel}}\n            </button>\n        </div>\n    </div>\n</div>",
                    styles: [":host {\n            display: block;\n        }"]
                }] }
    ];
    IgxTimePickerComponent.propDecorators = {
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        value: [{ type: Input }],
        disabled: [{ type: Input }],
        resourceStrings: [{ type: Input }],
        okButtonLabel: [{ type: Input }],
        cancelButtonLabel: [{ type: Input }],
        itemsDelta: [{ type: Input }],
        minValue: [{ type: Input }],
        maxValue: [{ type: Input }],
        isSpinLoop: [{ type: Input }],
        vertical: [{ type: Input }],
        format: [{ type: Input }],
        promptChar: [{ type: Input }],
        mode: [{ type: Input }],
        outlet: [{ type: Input }],
        overlaySettings: [{ type: Input }],
        onValueChanged: [{ type: Output }],
        onValidationFailed: [{ type: Output }],
        onOpen: [{ type: Output }],
        onClose: [{ type: Output }],
        hourList: [{ type: ViewChild, args: ['hourList',] }],
        minuteList: [{ type: ViewChild, args: ['minuteList',] }],
        ampmList: [{ type: ViewChild, args: ['ampmList',] }],
        defaultTimePickerTemplate: [{ type: ViewChild, args: ['defaultTimePickerTemplate', { read: TemplateRef },] }],
        timePickerTemplateDirective: [{ type: ContentChild, args: [IgxTimePickerTemplateDirective, { read: IgxTimePickerTemplateDirective },] }],
        _input: [{ type: ViewChild, args: [IgxInputDirective, { read: ElementRef },] }],
        container: [{ type: ViewChild, args: ['container',] }],
        toggleRef: [{ type: ViewChild, args: [IgxToggleDirective,] }],
        input: [{ type: ViewChild, args: ['input', { read: ElementRef },] }],
        group: [{ type: ViewChild, args: ['group', { read: IgxInputGroupComponent },] }],
        dropdownInputTemplate: [{ type: ViewChild, args: ['dropdownInputTemplate', { read: TemplateRef },] }],
        templateDropDownTarget: [{ type: ContentChild, args: ['dropDownTarget', { read: ElementRef },] }],
        onKeydownSpace: [{ type: HostListener, args: ['keydown.spacebar', ['$event'],] }, { type: HostListener, args: ['keydown.space', ['$event'],] }],
        onAltArrowDown: [{ type: HostListener, args: ['keydown.Alt.ArrowDown',] }]
    };
    return IgxTimePickerComponent;
}());
/**
 * @hidden
 */
var IgxTimePickerModule = /** @class */ (function () {
    function IgxTimePickerModule() {
    }
    IgxTimePickerModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        IgxTimePickerComponent,
                        IgxHourItemDirective,
                        IgxItemListDirective,
                        IgxMinuteItemDirective,
                        IgxAmPmItemDirective,
                        IgxTimePickerTemplateDirective,
                        TimeDisplayFormatPipe,
                        TimeInputFormatPipe
                    ],
                    exports: [
                        IgxTimePickerComponent,
                        IgxTimePickerTemplateDirective,
                        TimeDisplayFormatPipe,
                        TimeInputFormatPipe
                    ],
                    imports: [
                        CommonModule,
                        IgxInputGroupModule,
                        IgxIconModule,
                        IgxButtonModule,
                        IgxMaskModule,
                        IgxToggleModule
                    ],
                    providers: []
                },] }
    ];
    return IgxTimePickerModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
var NEXT_ID$v = 0;
/**
 * **Ignite UI for Angular Toast** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/toast.html)
 *
 * The Ignite UI Toast provides information and warning messages that are non-interactive and cannot
 * be dismissed by the user. Toasts can be displayed at the bottom, middle, or top of the page.
 *
 * Example:
 * ```html
 * <button (click)="toast.show()">Show notification</button>
 * <igx-toast #toast
 *           message="Notification displayed"
 *           displayTime="1000">
 * </igx-toast>
 * ```
 */
var IgxToastComponent = /** @class */ (function () {
    function IgxToastComponent(elementRef, navService) {
        this.elementRef = elementRef;
        this.navService = navService;
        /**
         * Returns a list of available CSS classes.
         * ```typescript
         * let toastClasses =  this.toast.CSS_CLASSES;
         * ```
         * \@memberof IgxToastComponent
         */
        this.CSS_CLASSES = {
            IGX_TOAST_BOTTOM: 'igx-toast--bottom',
            IGX_TOAST_MIDDLE: 'igx-toast--middle',
            IGX_TOAST_TOP: 'igx-toast--top'
        };
        /**
         * Sets/gets the `id` of the toast.
         * If not set, the `id` will have value `"igx-toast-0"`.
         * ```html
         * <igx-toast id = "my-first-toast"></igx-toast>
         * ```
         * ```typescript
         * let toastId = this.toast.id;
         * ```
         */
        this.id = "igx-toast-" + NEXT_ID$v++;
        /**
         * Emits an event prior the toast is shown.
         * Provides reference to the `IgxToastComponent` as event argument.
         * ```html
         * <igx-toast (onShowing) = "onShowing($event)"></igx-toast>
         * ```
         * \@memberof IgxToastComponent
         */
        this.onShowing = new EventEmitter();
        /**
         * Emits an event when the toast is shown.
         * Provides reference to the `IgxToastComponent` as event argument.
         * ```html
         * <igx-toast (onShown) = "onShown($event)"></igx-toast>
         * ```
         * \@memberof IgxToastComponent
         */
        this.onShown = new EventEmitter();
        /**
         * Emits an event prior the toast is hidden.
         * Provides reference to the `IgxToastComponent` as event argument.
         * ```html
         * <igx-toast (onHiding) = "onHiding($event)"></igx-toast>
         * ```
         * \@memberof IgxToastComponent
         */
        this.onHiding = new EventEmitter();
        /**
         *  Emits an event when the toast is hidden.
         *  Provides reference to the `IgxToastComponent` as event argument.
         * ```html
         * <igx-toast (onHidden) = "onHidden($event)"></igx-toast>
         * ```
         * \@memberof IgxToastComponent
         */
        this.onHidden = new EventEmitter();
        /**
         * Sets/gets the `role` attribute.
         * If not set, `role` will have value `"alert"`.
         * ```html
         * <igx-toast [role] = "'notify'"></igx-toast>
         * ```
         * ```typescript
         * let toastRole = this.toast.role;
         * ```
         * \@memberof IgxToastComponent
         */
        this.role = 'alert';
        /**
         * Sets/gets whether the toast will be hidden after the `displayTime` is over.
         * Default value is `true`.
         * ```html
         * <igx-toast [autoHide] = "false"></igx-toast>
         * ```
         * ```typescript
         * let autoHide = this.toast.autoHide;
         * ```
         * \@memberof IgxToastComponent
         */
        this.autoHide = true;
        /**
         * Sets/gets the duration of time span(in milliseconds) which the toast will be visible
         * after it is being shown.
         * Default value is `4000`.
         * ```html
         * <igx-toast [displayTime] = "2500"></igx-toast>
         * ```
         * ```typescript
         * let displayTime = this.toast.displayTime;
         * ```
         * \@memberof IgxToastComponent
         */
        this.displayTime = 4000;
        /**
         * Enables/Disables the visibility of the toast.
         * If not set, the `isVisible` attribute will have value `false`.
         * ```html
         * <igx-toast [isVisible] = "true"></igx-toast>
         * ```
         * ```typescript
         * let isVisible = this.toast.isVisible;
         * ```
         * \@memberof IgxToastComponent
         */
        this.isVisible = false;
        /**
         * Sets/gets the position of the toast.
         * If not set, the `position` attribute will have value `IgxToastPosition.Bottom`.
         * ```html
         * <igx-toast [position] = "top"></igx-toast>
         * ```
         * ```typescript
         * let toastPosition = this.toast.position;
         * ```
         * \@memberof IgxToastComponent
         */
        this.position = IgxToastPosition.Bottom;
    }
    Object.defineProperty(IgxToastComponent.prototype, "element", {
        /**
         * Gets the nativeElement of the toast.
         * ```typescript
         * let nativeElement = this.toast.element;
         * ```
         * @memberof IgxToastComponent
         */
        get: /**
         * Gets the nativeElement of the toast.
         * ```typescript
         * let nativeElement = this.toast.element;
         * ```
         * \@memberof IgxToastComponent
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Shows the toast.
     * If `autoHide` is enabled, the toast will hide after `displayTime` is over.
     * ```typescript
     * this.toast.show();
     * ```
     * @memberof IgxToastComponent
     */
    /**
     * Shows the toast.
     * If `autoHide` is enabled, the toast will hide after `displayTime` is over.
     * ```typescript
     * this.toast.show();
     * ```
     * \@memberof IgxToastComponent
     * @return {?}
     */
    IgxToastComponent.prototype.show = /**
     * Shows the toast.
     * If `autoHide` is enabled, the toast will hide after `displayTime` is over.
     * ```typescript
     * this.toast.show();
     * ```
     * \@memberof IgxToastComponent
     * @return {?}
     */
    function () {
        var _this = this;
        clearInterval(this.timeoutId);
        this.onShowing.emit(this);
        this.isVisible = true;
        if (this.autoHide) {
            this.timeoutId = setTimeout(function () {
                _this.hide();
            }, this.displayTime);
        }
        this.onShown.emit(this);
    };
    /**
     * Hides the toast.
     * ```typescript
     * this.toast.hide();
     * ```
     * @memberof IgxToastComponent
     */
    /**
     * Hides the toast.
     * ```typescript
     * this.toast.hide();
     * ```
     * \@memberof IgxToastComponent
     * @return {?}
     */
    IgxToastComponent.prototype.hide = /**
     * Hides the toast.
     * ```typescript
     * this.toast.hide();
     * ```
     * \@memberof IgxToastComponent
     * @return {?}
     */
    function () {
        this.onHiding.emit(this);
        this.isVisible = false;
        this.onHidden.emit(this);
        clearInterval(this.timeoutId);
    };
    /**
     * Wraps @show() method due @IToggleView interface implementation.
     * @hidden
     */
    /**
     * Wraps \@show() method due \@IToggleView interface implementation.
     * @hidden
     * @return {?}
     */
    IgxToastComponent.prototype.open = /**
     * Wraps \@show() method due \@IToggleView interface implementation.
     * @hidden
     * @return {?}
     */
    function () {
        this.show();
    };
    /**
     * Wraps @hide() method due @IToggleView interface implementation.
     * @hidden
     */
    /**
     * Wraps \@hide() method due \@IToggleView interface implementation.
     * @hidden
     * @return {?}
     */
    IgxToastComponent.prototype.close = /**
     * Wraps \@hide() method due \@IToggleView interface implementation.
     * @hidden
     * @return {?}
     */
    function () {
        this.hide();
    };
    /**
     * Toggles the visible state of the toast.
     * ```typescript
     * this.toast.toggle();
     * ```
     * @memberof IgxToastComponent
     */
    /**
     * Toggles the visible state of the toast.
     * ```typescript
     * this.toast.toggle();
     * ```
     * \@memberof IgxToastComponent
     * @return {?}
     */
    IgxToastComponent.prototype.toggle = /**
     * Toggles the visible state of the toast.
     * ```typescript
     * this.toast.toggle();
     * ```
     * \@memberof IgxToastComponent
     * @return {?}
     */
    function () {
        this.isVisible ? this.close() : this.open();
    };
    /**
     * Sets/gets the class name of the toast based on the `position` value.
     * ```typescript
     * let className =  this.toast.mapPositionToClassName();
     * ```
     * @memberof IgxToastComponent
     */
    /**
     * Sets/gets the class name of the toast based on the `position` value.
     * ```typescript
     * let className =  this.toast.mapPositionToClassName();
     * ```
     * \@memberof IgxToastComponent
     * @return {?}
     */
    IgxToastComponent.prototype.mapPositionToClassName = /**
     * Sets/gets the class name of the toast based on the `position` value.
     * ```typescript
     * let className =  this.toast.mapPositionToClassName();
     * ```
     * \@memberof IgxToastComponent
     * @return {?}
     */
    function () {
        if (this.position === IgxToastPosition.Top) {
            return this.CSS_CLASSES.IGX_TOAST_TOP;
        }
        if (this.position === IgxToastPosition.Middle) {
            return this.CSS_CLASSES.IGX_TOAST_MIDDLE;
        }
        if (this.position === IgxToastPosition.Bottom) {
            return this.CSS_CLASSES.IGX_TOAST_BOTTOM;
        }
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxToastComponent.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (this.navService && this.id) {
            this.navService.add(this.id, this);
        }
    };
    /**
     *@hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxToastComponent.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (this.navService && this.id) {
            this.navService.remove(this.id);
        }
    };
    IgxToastComponent.decorators = [
        { type: Component, args: [{
                    animations: [
                        trigger('animate', [
                            state('show', style({
                                opacity: 1
                            })),
                            transition('* => show', animate('.20s ease')),
                            transition('show => *', animate('.40s ease-out'))
                        ])
                    ],
                    selector: 'igx-toast',
                    template: "<div [ngClass]=\"mapPositionToClassName()\" *ngIf=\"this.isVisible\" [@animate]=\"'show'\">\n    {{ message }}\n</div>\n",
                    styles: ["\n        :host {\n            display: block;\n        }\n    "]
                }] }
    ];
    /** @nocollapse */
    IgxToastComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: IgxNavigationService, decorators: [{ type: Optional }] }
    ]; };
    IgxToastComponent.propDecorators = {
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        onShowing: [{ type: Output }],
        onShown: [{ type: Output }],
        onHiding: [{ type: Output }],
        onHidden: [{ type: Output }],
        role: [{ type: Input }],
        autoHide: [{ type: Input }],
        displayTime: [{ type: Input }],
        isVisible: [{ type: Input }],
        message: [{ type: Input }],
        position: [{ type: Input }]
    };
    return IgxToastComponent;
}());
/** @enum {number} */
var IgxToastPosition = {
    Bottom: 0,
    Middle: 1,
    Top: 2,
};
IgxToastPosition[IgxToastPosition.Bottom] = 'Bottom';
IgxToastPosition[IgxToastPosition.Middle] = 'Middle';
IgxToastPosition[IgxToastPosition.Top] = 'Top';
/**
 * @hidden
 */
var IgxToastModule = /** @class */ (function () {
    function IgxToastModule() {
    }
    IgxToastModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxToastComponent],
                    exports: [IgxToastComponent],
                    imports: [CommonModule]
                },] }
    ];
    return IgxToastModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * The `<igx-select-item>` is a container intended for row items in
 * a `<igx-select>` container.
 */
var IgxSelectGroupComponent = /** @class */ (function (_super) {
    __extends(IgxSelectGroupComponent, _super);
    function IgxSelectGroupComponent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    IgxSelectGroupComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-select-item-group',
                    template: "\n        <label id=\"{{labelId}}\">{{ label }}</label>\n        <ng-content select=\"igx-select-item\"></ng-content>\n    "
                }] }
    ];
    return IgxSelectGroupComponent;
}(IgxDropDownGroupComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var IgxSelectItemComponent = /** @class */ (function (_super) {
    __extends(IgxSelectItemComponent, _super);
    function IgxSelectItemComponent() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(IgxSelectItemComponent.prototype, "itemText", {
        /** @hidden @internal */
        get: /**
         * @hidden \@internal
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement.innerText.trim();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSelectItemComponent.prototype, "selected", {
        /**
         * Sets/Gets if the item is the currently selected one in the select
         *
         * ```typescript
         *  let mySelectedItem = this.select.selectedItem;
         *  let isMyItemSelected = mySelectedItem.selected; // true
         * ```
         */
        get: /**
         * Sets/Gets if the item is the currently selected one in the select
         *
         * ```typescript
         *  let mySelectedItem = this.select.selectedItem;
         *  let isMyItemSelected = mySelectedItem.selected; // true
         * ```
         * @return {?}
         */
        function () {
            return !this.isHeader && !this.disabled && this.selection.is_item_selected(this.dropDown.id, this);
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value && !this.isHeader && !this.disabled) {
                this.dropDown.selectItem(this);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    IgxSelectItemComponent.prototype.ngDoCheck = /**
     * @return {?}
     */
    function () {
    };
    IgxSelectItemComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-select-item',
                    template: '<ng-content></ng-content>'
                }] }
    ];
    return IgxSelectItemComponent;
}(IgxDropDownItemComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
var Direction$1 = {
    Top: -1,
    Bottom: 1,
    None: 0,
};
Direction$1[Direction$1.Top] = 'Top';
Direction$1[Direction$1.Bottom] = 'Bottom';
Direction$1[Direction$1.None] = 'None';
/**
 * @hidden \@internal
 */
var /**
 * @hidden \@internal
 */
SelectPositioningStrategy = /** @class */ (function (_super) {
    __extends(SelectPositioningStrategy, _super);
    function SelectPositioningStrategy(select, settings) {
        var _this = _super.call(this) || this;
        _this.select = select;
        _this._selectDefaultSettings = {
            target: null,
            horizontalDirection: HorizontalAlignment.Right,
            verticalDirection: VerticalAlignment.Bottom,
            horizontalStartPoint: HorizontalAlignment.Left,
            verticalStartPoint: VerticalAlignment.Top,
            openAnimation: fadeIn,
            closeAnimation: fadeOut
        };
        _this.defaultWindowToListOffset = 5;
        _this.viewPort = getViewportRect(document);
        _this.settings = Object.assign({}, _this._selectDefaultSettings, settings);
        return _this;
    }
    /**
     * @private
     * @param {?} contentElement
     * @param {?} outBoundsAmount
     * @return {?}
     */
    SelectPositioningStrategy.prototype.positionAndScrollBottom = /**
     * @private
     * @param {?} contentElement
     * @param {?} outBoundsAmount
     * @return {?}
     */
    function (contentElement, outBoundsAmount) {
        contentElement.style.top = this.viewPort.bottom - this.listContainerBoundRect.height - this.defaultWindowToListOffset + "px";
        contentElement.firstElementChild.scrollTop -= outBoundsAmount - (this.inputBorderTop - this.defaultWindowToListOffset);
        this.deltaY = this.viewPort.bottom - this.listContainerBoundRect.height -
            this.defaultWindowToListOffset - ((/** @type {?} */ (this.select.input.nativeElement.getBoundingClientRect()))).top;
    };
    /**
     * @private
     * @param {?} contentElement
     * @param {?} CURRENT_POSITION_Y
     * @return {?}
     */
    SelectPositioningStrategy.prototype.positionNoScroll = /**
     * @private
     * @param {?} contentElement
     * @param {?} CURRENT_POSITION_Y
     * @return {?}
     */
    function (contentElement, CURRENT_POSITION_Y) {
        contentElement.style.top = CURRENT_POSITION_Y - this.inputBorderTop + "px";
        this.deltaY = CURRENT_POSITION_Y - this.inputBorderTop -
            ((/** @type {?} */ (this.select.input.nativeElement.getBoundingClientRect()))).top;
    };
    /**
     * @private
     * @param {?} contentElement
     * @param {?} outBoundsAmount
     * @return {?}
     */
    SelectPositioningStrategy.prototype.positionAndScrollTop = /**
     * @private
     * @param {?} contentElement
     * @param {?} outBoundsAmount
     * @return {?}
     */
    function (contentElement, outBoundsAmount) {
        contentElement.style.top = this.viewPort.top + this.defaultWindowToListOffset + "px";
        contentElement.firstElementChild.scrollTop += outBoundsAmount + this.inputBorderTop + this.defaultWindowToListOffset;
        this.deltaY = this.viewPort.top + this.defaultWindowToListOffset -
            ((/** @type {?} */ (this.select.input.nativeElement.getBoundingClientRect()))).top;
    };
    /**
     * @private
     * @param {?} contentElement
     * @param {?} itemHeight
     * @return {?}
     */
    SelectPositioningStrategy.prototype.getItemsOutOfView = /**
     * @private
     * @param {?} contentElement
     * @param {?} itemHeight
     * @return {?}
     */
    function (contentElement, itemHeight) {
        if (contentElement.firstElementChild.scrollHeight <= contentElement.firstElementChild.clientHeight) {
            return {
                'currentScroll': 0,
                'remainingScroll': 0
            };
        }
        /** @type {?} */
        var currentScroll = contentElement.firstElementChild.scrollTop;
        /** @type {?} */
        var remainingScroll = this.select.items.length * itemHeight - currentScroll - this.listContainerBoundRect.height;
        return {
            'currentScroll': currentScroll,
            'remainingScroll': remainingScroll
        };
    };
    /**
     * @private
     * @param {?} elementContainer
     * @param {?} document
     * @return {?}
     */
    SelectPositioningStrategy.prototype.listOutOfBounds = /**
     * @private
     * @param {?} elementContainer
     * @param {?} document
     * @return {?}
     */
    function (elementContainer, document) {
        /** @type {?} */
        var container = {
            TOP: elementContainer.top,
            BOTTOM: elementContainer.bottom,
        };
        /** @type {?} */
        var viewPort = getViewportRect(document);
        /** @type {?} */
        var documentElement = {
            TOP: viewPort.top,
            BOTTOM: viewPort.bottom
        };
        /** @type {?} */
        var returnVals = {
            Direction: Direction$1.None,
            Amount: 0
        };
        if (documentElement.TOP + this.defaultWindowToListOffset > container.TOP) {
            returnVals.Direction = Direction$1.Top;
            returnVals.Amount = documentElement.TOP - container.TOP;
        }
        else if (documentElement.BOTTOM - this.defaultWindowToListOffset < container.BOTTOM) {
            returnVals.Direction = Direction$1.Bottom;
            returnVals.Amount = container.BOTTOM - documentElement.BOTTOM;
        }
        else {
            return null;
        }
        return returnVals;
    };
    /**
     * @param {?} contentElement
     * @param {?} size
     * @param {?=} document
     * @param {?=} initialCall
     * @return {?}
     */
    SelectPositioningStrategy.prototype.position = /**
     * @param {?} contentElement
     * @param {?} size
     * @param {?=} document
     * @param {?=} initialCall
     * @return {?}
     */
    function (contentElement, size, document, initialCall) {
        /** @type {?} */
        var inputElement = this.select.input.nativeElement;
        /** @type {?} */
        var inputRect = (/** @type {?} */ (inputElement.getBoundingClientRect()));
        this.listContainerBoundRect = (/** @type {?} */ (contentElement.getBoundingClientRect()));
        /** @type {?} */
        var LIST_HEIGHT = this.listContainerBoundRect.height;
        if (!initialCall) {
            this.deltaX = inputRect.left - this.itemTextPadding - this.itemTextIndent;
            /** @type {?} */
            var point = new Point(this.deltaX, inputRect.top + this.deltaY);
            this.settings.target = point;
            _super.prototype.position.call(this, contentElement, size);
            return;
        }
        /** @type {?} */
        var START = {
            X: inputRect.left,
            Y: inputRect.top
        };
        /** @type {?} */
        var itemElement;
        if (this.select.selectedItem) {
            itemElement = this.select.selectedItem.element.nativeElement;
            // D.P. Feb 22 2019, #3921 Force item scroll before measuring in IE11, due to base scrollToItem delay
            if (isIE()) {
                contentElement.firstElementChild.scrollTop = this.select.calculateScrollPosition(this.select.selectedItem);
            }
        }
        else {
            itemElement = this.select.getFirstItemElement();
        }
        /** @type {?} */
        var inputHeight = inputRect.height;
        /** @type {?} */
        var itemBoundRect = (/** @type {?} */ (itemElement.getBoundingClientRect()));
        /** @type {?} */
        var itemTopListOffset = itemBoundRect.top - this.listContainerBoundRect.top;
        /** @type {?} */
        var itemHeight = itemBoundRect.height;
        /** @type {?} */
        var CURRENT_POSITION_Y = START.Y - itemTopListOffset;
        /** @type {?} */
        var CURRENT_BOTTOM_Y = CURRENT_POSITION_Y + this.listContainerBoundRect.height;
        /** @type {?} */
        var OUT_OF_BOUNDS = this.listOutOfBounds({ top: CURRENT_POSITION_Y, bottom: CURRENT_BOTTOM_Y }, document);
        if (OUT_OF_BOUNDS) {
            if (OUT_OF_BOUNDS.Direction === Direction$1.Top) {
                CURRENT_POSITION_Y = START.Y;
            }
            else {
                CURRENT_POSITION_Y = -1 * (LIST_HEIGHT - (itemHeight - (itemHeight - inputHeight) / 2));
                CURRENT_POSITION_Y += START.Y;
            }
        }
        /** @type {?} */
        var inputBorderTop = window.getComputedStyle(inputElement).borderTopWidth;
        this.inputBorderTop = parseInt(inputBorderTop.slice(0, inputBorderTop.indexOf('p')), 10) || 0;
        /** @type {?} */
        var itemLeftPadding = window.getComputedStyle(itemElement).paddingLeft;
        /** @type {?} */
        var itemTextIndent = window.getComputedStyle(itemElement).textIndent;
        /** @type {?} */
        var numericPadding = parseInt(itemLeftPadding.slice(0, itemLeftPadding.indexOf('p')), 10) || 0;
        /** @type {?} */
        var numericTextIndent = parseInt(itemTextIndent.slice(0, itemTextIndent.indexOf('r')), 10) || 0;
        this.itemTextPadding = numericPadding;
        this.itemTextIndent = numericTextIndent;
        contentElement.style.left += START.X - numericPadding - numericTextIndent + "px";
        contentElement.style.width = inputRect.width + 24 + 32 + 'px';
        this.deltaX = START.X - numericPadding - numericTextIndent;
        /** @type {?} */
        var currentScroll = this.getItemsOutOfView(contentElement, itemHeight)['currentScroll'];
        /** @type {?} */
        var remainingScroll = this.getItemsOutOfView(contentElement, itemHeight)['remainingScroll'];
        // (5 items or less) no scroll and respectively no remaining scroll
        if (remainingScroll === 0 && currentScroll === 0) {
            this.positionNoScroll(contentElement, CURRENT_POSITION_Y);
        }
        // (more than 5 items) there is scroll OR remaining scroll
        if (remainingScroll !== 0 || currentScroll !== 0) {
            if (remainingScroll !== 0 && !OUT_OF_BOUNDS) {
                this.positionNoScroll(contentElement, CURRENT_POSITION_Y);
            }
            // (more than 5 items) and container getting out of the visible port
            if (remainingScroll !== 0 && OUT_OF_BOUNDS) {
                // if there is enough remaining scroll to scroll the item
                if (remainingScroll > itemHeight) {
                    if (OUT_OF_BOUNDS.Direction === Direction$1.Top) {
                        this.positionAndScrollTop(contentElement, OUT_OF_BOUNDS.Amount);
                        return;
                    }
                    if (OUT_OF_BOUNDS.Direction === Direction$1.Bottom) {
                        // (more than 5 items) and no current scroll
                        if (currentScroll === 0) {
                            this.positionNoScroll(contentElement, CURRENT_POSITION_Y);
                            return;
                            // (more than 5 items) and current scroll
                        }
                        else {
                            this.positionAndScrollBottom(contentElement, OUT_OF_BOUNDS.Amount);
                            return;
                        }
                    }
                }
                // if there is no enough remaining scroll to scroll the item
                if (remainingScroll < itemHeight) {
                    if (OUT_OF_BOUNDS.Direction === Direction$1.Top) {
                        this.positionNoScroll(contentElement, CURRENT_POSITION_Y);
                    }
                    if (OUT_OF_BOUNDS.Direction === Direction$1.Bottom) {
                        this.positionAndScrollBottom(contentElement, OUT_OF_BOUNDS.Amount);
                    }
                }
            }
            // (more than 5 items) and no remaining scroll
            if (remainingScroll === 0 && currentScroll !== 0) {
                if (OUT_OF_BOUNDS) {
                    if (OUT_OF_BOUNDS.Direction === Direction$1.Bottom) {
                        this.positionAndScrollBottom(contentElement, OUT_OF_BOUNDS.Amount);
                        return;
                    }
                }
                this.positionNoScroll(contentElement, CURRENT_POSITION_Y);
            }
        }
    };
    return SelectPositioningStrategy;
}(ConnectedPositioningStrategy));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden \@internal
 */
var IgxSelectToggleIconDirective = /** @class */ (function () {
    function IgxSelectToggleIconDirective() {
    }
    IgxSelectToggleIconDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxSelectToggleIcon]'
                },] }
    ];
    return IgxSelectToggleIconDirective;
}());
/** @type {?} */
var noop$7 = function () { };
/**
 * **Ignite UI for Angular Select** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/select.html)
 *
 * The `igxSelect` provides an input with dropdown list allowing selection of a single item.
 *
 * Example:
 * ```html
 * <igx-select #select1 [placeholder]="'Pick One'">
 *   <label igxLabel>Select Label</label>
 *   <igx-select-item *ngFor="let item of items" [value]="item.field">
 *     {{ item.field }}
 *   </igx-select-item>
 * </igx-select>
 * ```
 */
var IgxSelectComponent = /** @class */ (function (_super) {
    __extends(IgxSelectComponent, _super);
    function IgxSelectComponent(elementRef, cdr, selection) {
        var _this = _super.call(this, elementRef, cdr, selection) || this;
        _this.elementRef = elementRef;
        _this.cdr = cdr;
        _this.selection = selection;
        /**
         * @hidden \@internal do not use the drop-down container class
         */
        _this.cssClass = false;
        /**
         * @hidden \@internal
         */
        _this.allowItemsFocus = false;
        /**
         * An \@Input property that sets input placeholder.
         *
         */
        _this.placeholder = '';
        /**
         * An \@Input property that disables the `IgxSelectComponent`.
         * ```html
         * <igx-select [disabled]="'true'"></igx-select>
         * ```
         */
        _this.disabled = false;
        /**
         * @hidden \@internal
         */
        _this.maxHeight = '256px';
        /**
         * An \@Input property that sets how the select will be styled.
         * The allowed values are `line`, `box` and `border`. The default is `line`.
         * ```html
         * <igx-select [type]="'box'"></igx-select>
         * ```
         */
        _this.type = 'line';
        /**
         * An \@Input property that sets what display density to be used for the input group.
         * The allowed values are `compact`, `cosy` and `comfortable`. The default is `comfortable`.
         * ```html
         * <igx-select [displayDensity]="'compact'"></igx-select>
         * ```
         */
        _this.displayDensity = 'comfortable';
        /**
         * The custom template, if any, that should be used when rendering the select TOGGLE(open/close) button
         *
         * ```typescript
         * // Set in typescript
         * const myCustomTemplate: TemplateRef<any> = myComponent.customTemplate;
         * myComponent.select.toggleIconTemplate = myCustomTemplate;
         * ```
         * ```html
         * <!-- Set in markup -->
         *  <igx-select #select>
         *      ...
         *      <ng-template igxSelectToggleIcon let-collapsed>
         *          <igx-icon>{{ collapsed ? 'remove_circle' : 'remove_circle_outline'}}</igx-icon>
         *      </ng-template>
         *  </igx-select>
         * ```
         */
        _this.toggleIconTemplate = null;
        /**
         * @hidden \@internal
         */
        _this._onChangeCallback = noop$7;
        /**
         * @hidden \@internal
         */
        _this.writeValue = function (value) {
            _this.value = value;
        };
        return _this;
    }
    Object.defineProperty(IgxSelectComponent.prototype, "value", {
        /**
         * An @Input property that gets/sets the component value.
         *
         * ```typescript
         * // get
         * let selectValue = this.select.value;
         * ```
         *
         * ```typescript
         * // set
         * this.select.value = 'London';
         * ```
         * ```html
         * <igx-select [value]="value"></igx-select>
         * ```
         */
        get: /**
         * An \@Input property that gets/sets the component value.
         *
         * ```typescript
         * // get
         * let selectValue = this.select.value;
         * ```
         *
         * ```typescript
         * // set
         * this.select.value = 'London';
         * ```
         * ```html
         * <igx-select [value]="value"></igx-select>
         * ```
         * @return {?}
         */
        function () {
            return this._value;
        },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            var _this = this;
            if (this._value === v) {
                return;
            }
            this._value = v;
            this.setSelection(this.items.find(function (x) { return x.value === _this.value; }));
            this.cdr.detectChanges();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSelectComponent.prototype, "selectionValue", {
        /** @hidden @internal */
        get: /**
         * @hidden \@internal
         * @return {?}
         */
        function () {
            /** @type {?} */
            var selectedItem = this.selectedItem;
            return selectedItem ? selectedItem.itemText : '';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxSelectComponent.prototype, "selectedItem", {
        /** @hidden @internal */
        get: /**
         * @hidden \@internal
         * @return {?}
         */
        function () {
            return this.selection.first_item(this.id);
        },
        enumerable: true,
        configurable: true
    });
    /** @hidden @internal */
    /**
     * @hidden \@internal
     * @param {?} fn
     * @return {?}
     */
    IgxSelectComponent.prototype.registerOnChange = /**
     * @hidden \@internal
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._onChangeCallback = fn;
    };
    /** @hidden @internal */
    /**
     * @hidden \@internal
     * @param {?} fn
     * @return {?}
     */
    IgxSelectComponent.prototype.registerOnTouched = /**
     * @hidden \@internal
     * @param {?} fn
     * @return {?}
     */
    function (fn) { };
    /** @hidden @internal */
    /**
     * @hidden \@internal
     * @return {?}
     */
    IgxSelectComponent.prototype.getEditElement = /**
     * @hidden \@internal
     * @return {?}
     */
    function () {
        return this.input.nativeElement;
    };
    /** @hidden @internal */
    /**
     * @hidden \@internal
     * @param {?} newSelection
     * @param {?=} event
     * @return {?}
     */
    IgxSelectComponent.prototype.selectItem = /**
     * @hidden \@internal
     * @param {?} newSelection
     * @param {?=} event
     * @return {?}
     */
    function (newSelection, event) {
        /** @type {?} */
        var oldSelection = this.selectedItem;
        if (event) {
            this.toggleDirective.close();
        }
        if (newSelection === null || newSelection === oldSelection || newSelection.disabled || newSelection.isHeader) {
            return;
        }
        /** @type {?} */
        var args = { oldSelection: oldSelection, newSelection: newSelection, cancel: false };
        this.onSelection.emit(args);
        if (args.cancel) {
            return;
        }
        this.setSelection(newSelection);
        this._value = newSelection.value;
        this.cdr.detectChanges();
        this._onChangeCallback(this.value);
    };
    /** @hidden @internal */
    /**
     * @hidden \@internal
     * @return {?}
     */
    IgxSelectComponent.prototype.getFirstItemElement = /**
     * @hidden \@internal
     * @return {?}
     */
    function () {
        return this.children.first.element.nativeElement;
    };
    /**
     * Opens the select
     *
     * ```typescript
     * this.select.open();
     * ```
     */
    /**
     * Opens the select
     *
     * ```typescript
     * this.select.open();
     * ```
     * @param {?=} overlaySettings
     * @return {?}
     */
    IgxSelectComponent.prototype.open = /**
     * Opens the select
     *
     * ```typescript
     * this.select.open();
     * ```
     * @param {?=} overlaySettings
     * @return {?}
     */
    function (overlaySettings) {
        if (this.disabled || this.items.length === 0) {
            return;
        }
        if (!this.selectedItem) {
            this.navigateFirst();
        }
        _super.prototype.open.call(this, Object.assign({}, this._overlayDefaults, this.overlaySettings, overlaySettings));
    };
    /** @hidden @internal */
    /**
     * @hidden \@internal
     * @return {?}
     */
    IgxSelectComponent.prototype.ngAfterContentInit = /**
     * @hidden \@internal
     * @return {?}
     */
    function () {
        var _this = this;
        this._overlayDefaults = {
            modal: false,
            closeOnOutsideClick: false,
            positionStrategy: new SelectPositioningStrategy(this, { target: this.inputGroup.element.nativeElement }),
            scrollStrategy: new AbsoluteScrollStrategy(),
            excludePositionTarget: true
        };
        this.children.changes.subscribe(function () {
            _this.setSelection(_this.items.find(function (x) { return x.value === _this.value; }));
            _this.cdr.detectChanges();
        });
        Promise.resolve().then(function () { return _this.children.notifyOnChanges(); });
    };
    /** @hidden @internal */
    /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    IgxSelectComponent.prototype.onToggleOpening = /**
     * @hidden \@internal
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onOpening.emit(event);
        if (event.cancel) {
            return;
        }
        this.scrollToItem(this.selectedItem);
    };
    /**
     * @protected
     * @param {?} direction
     * @param {?=} currentIndex
     * @return {?}
     */
    IgxSelectComponent.prototype.navigate = /**
     * @protected
     * @param {?} direction
     * @param {?=} currentIndex
     * @return {?}
     */
    function (direction, currentIndex) {
        if (this.collapsed && this.selectedItem) {
            this.navigateItem(this.selectedItem.itemIndex);
        }
        _super.prototype.navigate.call(this, direction, currentIndex);
    };
    /**
     * @private
     * @param {?} item
     * @return {?}
     */
    IgxSelectComponent.prototype.setSelection = /**
     * @private
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (item && item.value !== undefined && item.value !== null) {
            this.selection.set(this.id, new Set([item]));
        }
        else {
            this.selection.clear(this.id);
        }
    };
    /** @hidden @internal */
    /**
     * @hidden \@internal
     * @return {?}
     */
    IgxSelectComponent.prototype.onBlur = /**
     * @hidden \@internal
     * @return {?}
     */
    function () {
        if (!this.collapsed) {
            this.toggleDirective.close();
        }
    };
    IgxSelectComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-select',
                    template: "<igx-input-group #inputGroup class=\"input-group\" [disabled]=\"disabled\" (click)=\"toggle()\" [type]=\"type\" [displayDensity]=\"displayDensity\">\n    <ng-container ngProjectAs=\"[igxLabel]\">\n        <ng-content select=\"[igxLabel]\"></ng-content>\n    </ng-container>\n    <ng-container ngProjectAs=\"igx-prefix\">\n        <ng-content select=\"igx-prefix,[igxPrefix]\"></ng-content>\n    </ng-container>\n        <input #input class=\"input\" type=\"text\" igxInput [igxSelectItemNavigation]=\"this\"\n            readonly=\"true\"\n            [placeholder]=\"this.placeholder\"\n            [value]=\"this.selectionValue\"\n            role=\"combobox\"\n            aria-haspopup=\"listbox\"\n            [attr.aria-labelledby]=\"this.label ? this.label.id : ''\"\n            [attr.aria-expanded]=\"!this.collapsed\"\n            [attr.aria-owns]=\"this.listId\"\n            [attr.aria-activedescendant]=\"!this.collapsed ? this.focusedItem?.id : null\"\n            (blur)=\"onBlur()\"\n            />\n        <ng-container ngProjectAs=\"igx-suffix\">\n                <ng-content select=\"igx-suffix,[igxSuffix]\"></ng-content>\n            </ng-container>\n        <igx-suffix>\n            <ng-container *ngIf=\"toggleIconTemplate\">\n                <ng-container *ngTemplateOutlet=\"toggleIconTemplate; context: {$implicit: this.collapsed}\"></ng-container>\n                </ng-container>\n            <igx-icon *ngIf=\"!toggleIconTemplate\" fontSet=\"material\">{{ collapsed ? 'arrow_drop_down' : 'arrow_drop_up'}}</igx-icon>\n        </igx-suffix>\n    </igx-input-group>\n    <div class=\"igx-drop-down__list--select\" igxToggle [style.maxHeight]=\"maxHeight\"\n        (onOpening)=\"onToggleOpening($event)\" (onOpened)=\"onToggleOpened()\"\n        (onClosing)=\"onToggleClosing($event)\" (onClosed)=\"onToggleClosed()\"\n        [attr.id]=\"this.listId\" role=\"listbox\">\n        <ng-content select=\"igx-select-item, igx-select-item-group\">\n        </ng-content>\n    </div>\n",
                    providers: [
                        { provide: NG_VALUE_ACCESSOR, useExisting: IgxSelectComponent, multi: true },
                        { provide: IGX_DROPDOWN_BASE, useExisting: IgxSelectComponent }
                    ],
                    styles: ["\n        :host {\n            display: block;\n        }\n    "]
                }] }
    ];
    /** @nocollapse */
    IgxSelectComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ChangeDetectorRef },
        { type: IgxSelectionAPIService }
    ]; };
    IgxSelectComponent.propDecorators = {
        inputGroup: [{ type: ViewChild, args: ['inputGroup', { read: IgxInputGroupComponent },] }],
        input: [{ type: ViewChild, args: ['input', { read: IgxInputDirective },] }],
        children: [{ type: ContentChildren, args: [forwardRef(function () { return IgxSelectItemComponent; }), { descendants: true },] }],
        label: [{ type: ContentChild, args: [forwardRef(function () { return IgxLabelDirective; }),] }],
        value: [{ type: Input }],
        placeholder: [{ type: Input }],
        disabled: [{ type: Input }],
        overlaySettings: [{ type: Input }],
        maxHeight: [{ type: HostBinding, args: ['style.maxHeight',] }],
        type: [{ type: Input }],
        displayDensity: [{ type: Input }],
        toggleIconTemplate: [{ type: ContentChild, args: [IgxSelectToggleIconDirective, { read: TemplateRef },] }]
    };
    return IgxSelectComponent;
}(IgxDropDownComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden \@internal
 */
var IgxSelectItemNavigationDirective = /** @class */ (function (_super) {
    __extends(IgxSelectItemNavigationDirective, _super);
    function IgxSelectItemNavigationDirective() {
        var _this = _super.call(this, null) || this;
        // tslint:disable:member-ordering
        _this.inputStream = '';
        _this.clearStream$ = Subscription.EMPTY;
        return _this;
    }
    /** Captures keydown events and calls the appropriate handlers on the target component */
    /**
     * Captures keydown events and calls the appropriate handlers on the target component
     * @param {?} event
     * @return {?}
     */
    IgxSelectItemNavigationDirective.prototype.handleKeyDown = /**
     * Captures keydown events and calls the appropriate handlers on the target component
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!event || event.shiftKey) {
            return;
        }
        /** @type {?} */
        var key = event.key.toLowerCase();
        if (event.altKey && (key === 'arrowdown' || key === 'arrowup' || key === 'down' || key === 'up')) {
            this.target.toggle();
            return;
        }
        if (this.target.collapsed) {
            switch (key) {
                case 'space':
                case 'spacebar':
                case ' ':
                case 'enter':
                    event.preventDefault();
                    this.target.open();
                    return;
                case 'arrowdown':
                case 'down':
                    this.target.navigateNext();
                    this.target.selectItem(this.target.focusedItem);
                    event.preventDefault();
                    return;
                case 'arrowup':
                case 'up':
                    this.target.navigatePrev();
                    this.target.selectItem(this.target.focusedItem);
                    event.preventDefault();
                    return;
                default:
                    break;
            }
        }
        _super.prototype.handleKeyDown.call(this, event);
    };
    /** Handle continuous letter typing navigation */
    /**
     * Handle continuous letter typing navigation
     * @param {?} event
     * @return {?}
     */
    IgxSelectItemNavigationDirective.prototype.captureKey = /**
     * Handle continuous letter typing navigation
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        // relying only on key, available on all major browsers:
        // https://caniuse.com/#feat=keyboardevent-key (IE/Edge quirk doesn't affect letter typing)
        if (!event || !event.key || event.key.length > 1) {
            // ignore longer keys ('Alt', 'ArrowDown', etc)
            return;
        }
        this.clearStream$.unsubscribe();
        this.clearStream$ = timer(500).subscribe(function () {
            _this.inputStream = '';
        });
        this.inputStream += event.key;
        /** @type {?} */
        var focusedItem = (/** @type {?} */ (this.target.focusedItem));
        // select the item
        if (focusedItem && this.inputStream.length > 1 && focusedItem.itemText.toLowerCase().startsWith(this.inputStream.toLowerCase())) {
            return;
        }
        this.activateItemByText(this.inputStream);
    };
    /**
     * @param {?} text
     * @return {?}
     */
    IgxSelectItemNavigationDirective.prototype.activateItemByText = /**
     * @param {?} text
     * @return {?}
     */
    function (text) {
        /** @type {?} */
        var items = (/** @type {?} */ (this.target.items));
        /** @type {?} */
        var activeItemIndex = items.indexOf((/** @type {?} */ (this.target.focusedItem))) || 0;
        // ^ this is focused OR selected if the dd is closed
        /** @type {?} */
        var nextItem = items.slice(activeItemIndex + 1).find(function (x) { return !x.disabled && (x.itemText.toLowerCase().startsWith(text.toLowerCase())); });
        if (!nextItem) {
            nextItem = items.slice(0, activeItemIndex).find(function (x) { return !x.disabled && (x.itemText.toLowerCase().startsWith(text.toLowerCase())); });
        }
        if (!nextItem) {
            return;
        }
        if (this.target.collapsed) {
            this.target.selectItem(nextItem);
        }
        this.target.navigateItem(items.indexOf(nextItem));
    };
    /**
     * @return {?}
     */
    IgxSelectItemNavigationDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.clearStream$.unsubscribe();
    };
    IgxSelectItemNavigationDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxSelectItemNavigation]'
                },] }
    ];
    /** @nocollapse */
    IgxSelectItemNavigationDirective.ctorParameters = function () { return []; };
    IgxSelectItemNavigationDirective.propDecorators = {
        target: [{ type: Input, args: ['igxSelectItemNavigation',] }],
        captureKey: [{ type: HostListener, args: ['keyup', ['$event'],] }]
    };
    return IgxSelectItemNavigationDirective;
}(IgxDropDownItemNavigationDirective));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @hidden
 */
var IgxSelectModule = /** @class */ (function () {
    function IgxSelectModule() {
    }
    IgxSelectModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxSelectComponent, IgxSelectItemComponent, IgxSelectItemNavigationDirective,
                        IgxSelectToggleIconDirective, IgxSelectGroupComponent],
                    exports: [IgxSelectComponent, IgxSelectItemComponent, IgxSelectItemNavigationDirective,
                        IgxSelectToggleIconDirective, IgxSelectGroupComponent],
                    imports: [IgxRippleModule, CommonModule, IgxInputGroupModule, FormsModule, ReactiveFormsModule,
                        IgxToggleModule, IgxDropDownModule, IgxButtonModule, IgxIconModule],
                    providers: []
                },] }
    ];
    return IgxSelectModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { changei18n, getCurrentResourceStrings, InteractionMode, fadeIn, fadeOut, flipTop, flipRight, flipBottom, flipLeft, flipHorFwd, flipHorBck, flipVerFwd, flipVerBck, rotateInCenter, rotateInTop, rotateInRight, rotateInLeft, rotateInBottom, rotateInTr, rotateInBr, rotateInBl, rotateInTl, rotateInDiagonal1, rotateInDiagonal2, rotateInHor, rotateInVer, rotateOutCenter, rotateOutTop, rotateOutRight, rotateOutLeft, rotateOutBottom, rotateOutTr, rotateOutBr, rotateOutBl, rotateOutTl, rotateOutDiagonal1, rotateOutDiagonal2, rotateOutHor, rotateOutVer, shakeHor, shakeVer, shakeTop, shakeBottom, shakeRight, shakeLeft, shakeCenter, shakeTr, shakeBr, shakeBl, shakeTl, heartbeat, pulsateFwd, pulsateBck, blink, scaleInTop, scaleInRight, scaleInBottom, scaleInLeft, scaleInCenter, scaleInTr, scaleInBr, scaleInBl, scaleInTl, scaleInVerTop, scaleInVerBottom, scaleInVerCenter, scaleInHorCenter, scaleInHorLeft, scaleInHorRight, scaleOutTop, scaleOutRight, scaleOutBottom, scaleOutLeft, scaleOutCenter, scaleOutTr, scaleOutBr, scaleOutBl, scaleOutTl, scaleOutVerTop, scaleOutVerBottom, scaleOutVerCenter, scaleOutHorCenter, scaleOutHorLeft, scaleOutHorRight, slideInTop, slideInRight, slideInBottom, slideInLeft, slideInTr, slideInBr, slideInBl, slideInTl, slideOutTop, slideOutBottom, slideOutRight, slideOutLeft, slideOutTr, slideOutBr, slideOutBl, slideOutTl, swingInTopFwd, swingInRightFwd, swingInLeftFwd, swingInBottomFwd, swingInTopBck, swingInRightBck, swingInBottomBck, swingInLeftBck, swingOutTopFwd, swingOutRightFwd, swingOutBottomFwd, swingOutLefttFwd, swingOutTopBck, swingOutRightBck, swingOutBottomBck, swingOutLeftBck, growVerIn, growVerOut, IgxNavigationService, IgxNavigationToggleDirective, IgxNavigationCloseDirective, IgxNavigationModule, IgxAutocompleteDirective, IgxAutocompleteModule, IgxButtonDirective, IgxButtonModule, IgxDividerType, IgxDividerDirective, IgxDividerModule, RestrictDrag, IgxDragDirective, IgxDropDirective, IgxDragDropModule, IgxFilterOptions, IgxFilterDirective, IgxFilterPipe, IgxFilterModule, IgxFocusDirective, IgxFocusModule, getTypeNameForDebugging, IgxForOfDirective, IgxGridForOfDirective, IgxForOfModule, IgxLayoutDirective, IgxFlexDirective, IgxLayoutModule, IgxMaskDirective, IgxMaskModule, IgxRadioGroupDirective, IgxRadioModule, IgxRippleDirective, IgxRippleModule, IgxTextHighlightDirective, IgxTextHighlightModule, IgxTextSelectionDirective, IgxTextSelectionModule, IgxToggleDirective, IgxToggleActionDirective, IgxOverlayOutletDirective, IgxToggleModule, IgxTooltipTargetDirective, IgxTooltipDirective, IgxTooltipModule, FilteringLogic, FilteringExpressionsTree, IgxFilteringOperand, IgxBooleanFilteringOperand, IgxDateFilteringOperand, IgxNumberFilteringOperand, IgxStringFilteringOperand, InFilteringOperation, InDateFilteringOperation, filteringStateDefaults, BaseFilteringStrategy, FilteringStrategy, GroupedRecords, IgxGrouping, SortingDirection, DefaultSortingStrategy, IgxSorting, IgxDataRecordSorting, PagingError, DataType, DataUtil, Size$1 as Size, AvatarType, IgxAvatarComponent, IgxAvatarModule, Type, IgxBadgeComponent, IgxBadgeModule, IgxBannerComponent, IgxBannerModule, ButtonGroupAlignment, IgxButtonGroupComponent, IgxButtonGroupModule, range, isLeap, weekDay, monthRange, isDateInRanges, WEEKDAYS, Calendar, IgxCalendarComponent, IgxDaysViewComponent, IgxMonthsViewComponent, CalendarHammerConfig, IgxYearsViewComponent, IgxMonthPickerComponent, IgxCalendarYearDirective, IgxCalendarMonthDirective, IgxCalendarHeaderTemplateDirective, IgxCalendarSubheaderTemplateDirective, IgxCalendarScrollMonthDirective, IgxCalendarModule, IgxCardMediaDirective, IgxCardHeaderComponent, IgxCardThumbnailDirective, IgxCardHeaderTitleDirective, IgxCardHeaderSubtitleDirective, IgxCardContentDirective, IgxCardFooterDirective, IgxCardType, IgxCardComponent, IgxCardActionsLayout, IgxCardActionsComponent, IgxCardModule, Direction, IgxCarouselComponent, IgxSlideComponent, IgxCarouselModule, LabelPosition, IgxCheckboxComponent, IGX_CHECKBOX_REQUIRED_VALIDATOR, IgxCheckboxRequiredDirective, IgxCheckboxModule, IgxChipComponent, IgxChipsAreaComponent, IgxChipsModule, IgxPrefixDirective, IgxPrefixModule, IgxSuffixDirective, IgxSuffixModule, IgxComboState, IgxComboComponent, IgxComboModule, PredefinedFormatOptions, IgxDatePickerComponent, IgxDatePickerModule, IgxDialogComponent, IgxDialogModule, IgxDropDownModule, IgxDropDownComponent, IgxDropDownItemComponent, IgxDropDownItemNavigationDirective, IgxDropDownBase, IgxDropDownItemBase, IgxDropDownGroupComponent, ColumnDisplayOrder, GridBaseAPIService, IgxGridCellComponent, IgxRowComponent, IgxColumnComponent, IgxColumnGroupComponent, IgxColumnLayoutComponent, IgxGridTransaction, GridSummaryPosition, GridSummaryCalculationMode, FilterMode, GridKeydownTargetType, IgxGridBaseComponent, IgxResizeHandleDirective, IgxColumnResizerDirective, IgxFilterCellTemplateDirective, IgxCellTemplateDirective, IgxCellHeaderTemplateDirective, IgxCellFooterTemplateDirective, IgxCellEditorTemplateDirective, IgxColumnMovingService, DropPosition, IgxColumnMovingDragDirective, IgxColumnMovingDropDirective, IgxGridBodyDirective, IgxDatePipeComponent, IgxDecimalPipeComponent, ContainerPositioningStrategy, IgxSummaryOperand, IgxNumberSummaryOperand, IgxDateSummaryOperand, IgxGridCommonModule, IgxColumnHidingComponent, IgxColumnHidingModule, IgxColumnPinningItemDirective, IgxColumnPinningComponent, IgxColumnPinningModule, IgxGridGroupByRowComponent, IgxGridComponent, IgxGroupByRowTemplateDirective, IgxGroupAreaDropDirective, IgxGridModule, IgxGridAPIService, IgxGridRowComponent, IgxTreeGridComponent, IgxTreeGridModule, IgxTreeGridAPIService, IgxTreeGridRowComponent, IgxTreeGridCellComponent, hierarchicalTransactionServiceFactory, IgxHierarchicalTransactionServiceFactory, IgxHierarchicalGridBaseComponent, IgxHierarchicalGridComponent, IgxHierarchicalGridModule, IgxHierarchicalGridAPIService, IgxHierarchicalRowComponent, IgxRowIslandAPIService, IgxRowIslandComponent, IgxIconModule, IgxIconComponent, IgxIconService, IgxInputGroupComponent, IgxInputGroupModule, IgxInputState, IgxInputDirective, IgxLabelDirective, IgxHintDirective, IgxListComponent, IgxListModule, IgxListBase, IgxListPanState, IgxEmptyListTemplateDirective, IgxDataLoadingTemplateDirective, IgxListItemLeftPanningTemplateDirective, IgxListItemRightPanningTemplateDirective, IgxListItemComponent, IgxExpansionPanelHeaderComponent, IgxExpansionPanelBodyComponent, IgxExpansionPanelComponent, IgxExpansionPanelModule, IgxActionIconDirective, IgxNavbarComponent, IgxNavbarModule, IgxNavigationDrawerComponent, IgxNavDrawerItemDirective, IgxNavDrawerTemplateDirective, IgxNavDrawerMiniTemplateDirective, IgxNavigationDrawerModule, getValueInProperRange, convertInPercentage, IgxTextAlign, IgxProgressType, BaseProgress, IgxLinearProgressBarComponent, IgxCircularProgressBarComponent, IgxProgressBarModule, RadioLabelPosition, IgxRadioComponent, SliderType, IgxSliderComponent, IgxSliderModule, IgxSnackbarComponent, IgxSnackbarModule, SwitchLabelPosition, IgxSwitchComponent, IGX_SWITCH_REQUIRED_VALIDATOR, IgxSwitchRequiredDirective, IgxSwitchModule, IgxTabTemplateDirective, IgxBottomNavComponent, IgxTabPanelComponent, IgxTabComponent, IgxBottomNavModule, TabsType, IgxTabsComponent, IgxTabsModule, IgxTabItemComponent, IgxTabsGroupComponent, IgxRightButtonStyleDirective, IgxLeftButtonStyleDirective, IgxTabItemTemplateDirective, TimePickerHammerConfig, IgxTimePickerComponent, IgxTimePickerModule, IgxToastComponent, IgxToastPosition, IgxToastModule, IgxSelectGroupComponent, IgxSelectItemComponent, IgxSelectToggleIconDirective, IgxSelectComponent, IgxSelectModule, HorizontalAlignment, VerticalAlignment, Point, IgxCsvExporterService, IgxCsvExporterOptions, CsvFileTypes, IgxExcelExporterService, IgxExcelExporterOptions, IgxBaseExporter, IgxExporterOptionsBase, IgxOverlayService, GlobalPositionStrategy, ConnectedPositioningStrategy, AutoPositionStrategy, ElasticPositionStrategy, ScrollStrategy, AbsoluteScrollStrategy, BlockScrollStrategy, CloseScrollStrategy, NoOpScrollStrategy, IgxTransactionService, IgxBaseTransactionService, TransactionType, IgxHierarchicalTransactionService, DateRangeType, DisplayDensity, DisplayDensityToken, DisplayDensityBase, EaseIn as Éµg, EaseOut as Éµh, IgxBannerActionsDirective as Éµs, IgxCalendarBase as Éµx, IgxDayItemComponent as Éµy, IgxMonthPickerBase as Éµw, IgxChipComponent as Éµco, IgxChipsAreaComponent as Éµcn, IgxComboAddItemComponent as Éµbq, IgxComboDropDownComponent as Éµbc, IgxComboItemComponent as Éµbd, IgxComboAPIService as Éµz, IGX_COMBO_COMPONENT as Éµba, IgxComboAddItemDirective as Éµbj, IgxComboClearIconDirective as Éµbl, IgxComboEmptyDirective as Éµbh, IgxComboFooterDirective as Éµbf, IgxComboHeaderDirective as Éµbe, IgxComboHeaderItemDirective as Éµbi, IgxComboItemDirective as Éµbg, IgxComboToggleIconDirective as Éµbk, IgxComboFilterConditionPipe as Éµbp, IgxComboFilteringPipe as Éµbm, IgxComboGroupingPipe as Éµbo, IgxComboSortingPipe as Éµbn, DeprecateMethod as Éµj, DeprecateProperty as Éµk, IgxGridCRUDService as Éµbz, IgxGridSelectionService as Éµca, IgxSelectionAPIService as Éµl, HammerGesturesManager as Éµdx, IgxCalendarContainerComponent as Éµbs, IGX_DATE_PICKER_COMPONENT as Éµbv, IgxDatePickerTemplateDirective as Éµbr, DatePickerDisplayValuePipe as Éµbt, DatePickerInputValuePipe as Éµbu, IgxDialogActionsDirective as Éµby, IgxDialogTitleDirective as Éµbx, DisplayContainerComponent as Éµn, IgxForOfSyncService as Éµm, HVirtualHelperComponent as Éµp, VirtualHelperComponent as Éµo, IgxScrollInertiaDirective as Éµq, IgxScrollInertiaModule as Éµr, IgxTemplateOutletDirective as Éµdd, IgxTemplateOutletModule as Éµde, IgxDropDownComponent as Éµdp, IGX_DROPDOWN_BASE as Éµa, IGX_EXPANSION_PANEL_COMPONENT as Éµf, IgxExpansionPanelDescriptionDirective as Éµu, IgxExpansionPanelIconDirective as Éµv, IgxExpansionPanelTitleDirective as Éµt, ColumnChooserBase as Éµc, ColumnChooserItemBase as Éµdg, ItemPropertyValueChanged as Éµdf, IgxColumnHidingItemDirective as Éµd, IgxGridDragSelectDirective as Éµdc, IgxExcelStyleColumnMovingComponent as Éµdv, IgxExcelStyleCustomDialogComponent as Éµdq, IgxExcelStyleDateExpressionComponent as Éµds, IgxExcelStyleDefaultExpressionComponent as Éµdr, IgxExcelStyleSearchComponent as Éµdt, IgxExcelStyleSearchFilterPipe as Éµdw, IgxExcelStyleSortingComponent as Éµdu, IgxExcelStyleHidingTemplateDirective as Éµcg, IgxExcelStyleMovingTemplateDirective as Éµcf, IgxExcelStylePinningTemplateDirective as Éµch, IgxExcelStyleSortingTemplateDirective as Éµce, IgxGridExcelStyleFilteringComponent as Éµci, IgxGridExcelStyleFilteringModule as Éµdo, IgxGridFilteringCellComponent as Éµcm, IgxGridFilteringRowComponent as Éµcu, IgxFilteringService as Éµcl, GridBaseAPIService as Éµes, IgxGridColumnResizerComponent as Éµcc, IgxColumnResizingService as Éµcd, IgxGridCellStylesPipe as Éµdj, IgxGridFilterConditionPipe as Éµdm, IgxGridNotGroupedPipe as Éµdk, IgxGridTopLevelColumns as Éµdl, IgxGridTransactionPipe as Éµdn, IgxGridHeaderGroupComponent as Éµcj, IgxGridHeaderComponent as Éµck, IgxGridNavigationService as Éµcp, IgxGridPipesModule as Éµdi, IgxGridToolbarComponent as Éµcs, IgxGridToolbarCustomContentDirective as Éµct, IgxRowEditActionsDirective as Éµcx, IgxRowEditTabStopDirective as Éµcy, IgxRowEditTemplateDirective as Éµcv, IgxRowEditTextDirective as Éµcw, IgxGridFilteringPipe as Éµef, IgxGridPagingPipe as Éµee, IgxGridPostGroupingPipe as Éµed, IgxGridPreGroupingPipe as Éµec, IgxGridSortingPipe as Éµeb, IgxGridSummaryPipe as Éµeg, IgxChildGridRowComponent as Éµet, IgxHierarchicalGridCellComponent as Éµeu, IgxHierarchicalGridNavigationService as Éµer, IgxGridHierarchicalPagingPipe as Éµew, IgxGridHierarchicalPipe as Éµev, IgxHierarchicalSelectionAPIService as Éµeq, IgxDragIndicatorIconDirective as Éµdz, IgxRowDragDirective as Éµdy, IgxRowDragModule as Éµea, IgxSummaryDataPipe as Éµdb, IgxGridSummaryService as Éµcz, IgxSummaryCellComponent as Éµcr, IgxSummaryRowComponent as Éµcq, IgxTreeGridNavigationService as Éµeh, IgxRowLoadingIndicatorTemplateDirective as Éµei, IgxTreeGridFilteringPipe as Éµeo, IgxTreeGridFlatteningPipe as Éµek, IgxTreeGridHierarchizingPipe as Éµej, IgxTreeGridPagingPipe as Éµem, IgxTreeGridSortingPipe as Éµel, IgxTreeGridTransactionPipe as Éµen, IgxTreeGridSummaryPipe as Éµep, WatchChanges as Éµcb, IgxInputGroupBase as Éµi, IgxProcessBarTextTemplateDirective as Éµdh, IgxSelectItemNavigationDirective as Éµfh, ConnectedPositioningStrategy as Éµda, IgxTabsBase as Éµex, IGX_TIME_PICKER_COMPONENT as Éµey, IgxAmPmItemDirective as Éµfd, IgxHourItemDirective as Éµfb, IgxItemListDirective as Éµfa, IgxMinuteItemDirective as Éµfc, IgxTimePickerTemplateDirective as Éµfe, TimeDisplayFormatPipe as Éµff, TimeInputFormatPipe as Éµfg };

//# sourceMappingURL=igniteui-angular.js.map