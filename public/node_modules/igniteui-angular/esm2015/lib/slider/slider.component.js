/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { CommonModule } from '@angular/common';
import { Component, ElementRef, EventEmitter, HostBinding, Input, NgModule, Output, Renderer2, ViewChild } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
/** @enum {number} */
const SliderType = {
    /**
     * Slider with single thumb.
     */
    SLIDER: 0,
    /**
     *  Range slider with multiple thumbs, that can mark the range.
     */
    RANGE: 1,
};
export { SliderType };
SliderType[SliderType.SLIDER] = 'SLIDER';
SliderType[SliderType.RANGE] = 'RANGE';
/** @enum {number} */
const SliderHandle = {
    FROM: 0,
    TO: 1,
};
SliderHandle[SliderHandle.FROM] = 'FROM';
SliderHandle[SliderHandle.TO] = 'TO';
/**
 * @record
 */
export function IRangeSliderValue() { }
if (false) {
    /** @type {?} */
    IRangeSliderValue.prototype.lower;
    /** @type {?} */
    IRangeSliderValue.prototype.upper;
}
/**
 * @record
 */
export function ISliderValueChangeEventArgs() { }
if (false) {
    /** @type {?} */
    ISliderValueChangeEventArgs.prototype.oldValue;
    /** @type {?} */
    ISliderValueChangeEventArgs.prototype.value;
}
/** @type {?} */
const noop = () => {
};
const ɵ0 = noop;
/** @type {?} */
let NEXT_ID = 0;
/**
 * **Ignite UI for Angular Slider** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/slider.html)
 *
 * The Ignite UI Slider allows selection in a given range by moving the thumb along the track. The track
 * can be defined as continuous or stepped, and you can choose between single and range slider types.
 *
 * Example:
 * ```html
 * <igx-slider id="slider"
 *            [minValue]="0" [maxValue]="100"
 *            [isContinuous]=true [(ngModel)]="volume">
 * </igx-slider>
 * ```
 */
export class IgxSliderComponent {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        this.renderer = renderer;
        /**
         * An \@Input property that sets the value of the `id` attribute.
         * If not provided it will be automatically generated.
         * ```html
         * <igx-slider [id]="'igx-slider-32'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
         * ```
         */
        this.id = `igx-slider-${NEXT_ID++}`;
        /**
         * An \@Input property that marks the `IgxSliderComponent` as continuous.
         * By default is considered that the `IgxSliderComponent` is discrete.
         * Discrete `IgxSliderComponent` does not have ticks and does not shows bubble labels for values.
         * ```html
         * <igx-slider #slider [isContinuous]="'true'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
         * ```
         */
        this.isContinuous = false;
        /**
         * An \@Input property that sets the type of the `IgxSliderComponent`. The slider can be SliderType.SLIDER(default) or SliderType.RANGE.
         * ```typescript
         * sliderType: SliderType = SliderType.RANGE;
         * //...
         * ```
         * ```html
         * <igx-slider #slider2 [type]="sliderType" [(ngModel)]="rangeValue" [minValue]="0" [maxValue]="100">
         * ```
         */
        this.type = SliderType.SLIDER;
        /**
         * An \@Input property that sets the duration visibility of thumbs labels. The default value is 750 milliseconds.
         * ```html
         * <igx-slider #slider [thumbLabelVisibilityDuration]="3000" [(ngModel)]="task.percentCompleted" [step]="5">
         * ```
         */
        this.thumbLabelVisibilityDuration = 750;
        /**
         * An \@Input property that sets the incremental/decremental step of the value when dragging the thumb.
         * The default step is 1, and step should not be less or equal than 0.
         * ```html
         * <igx-slider #slider [(ngModel)]="task.percentCompleted" [step]="5">
         * ```
         */
        this.step = 1;
        /**
         * This event is emitted when user has stopped interacting the thumb and value is changed.
         * ```typescript
         * public change(event){
         *    alert("The value has been changed!");
         * }
         * ```
         * ```html
         * <igx-slider (onValueChange)="change($event)" #slider [(ngModel)]="task.percentCompleted" [step]="5">
         * ```
         */
        this.onValueChange = new EventEmitter();
        /**
         * @hidden
         */
        this.isActiveLabel = false;
        this.activeHandle = SliderHandle.TO;
        // Measures & Coordinates
        this.width = 0;
        this.xOffset = 0;
        this.xPointer = 0;
        this.pPointer = 0;
        // Limit handle travel zone
        this.pMin = 0;
        this.pMax = 1;
        // From/upperValue in percent values
        this.hasViewInit = false;
        this._minValue = 0;
        this._maxValue = 100;
        this._onChangeCallback = noop;
        this._onTouchedCallback = noop;
    }
    /**
     * Returns whether the `IgxSliderComponent` type is RANGE.
     * ```typescript
     * \@ViewChild("slider")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *    let sliderRange = this.slider.isRange;
     * }
     * ```
     * @return {?}
     */
    get isRange() {
        /** @type {?} */
        const isRange = this.type === SliderType.RANGE;
        return isRange;
    }
    /**
     * Returns the maximum value for the `IgxSliderComponent`.
     * ```typescript
     * \@ViewChild("slider")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *    let sliderMax = this.slider.maxValue;
     * }
     * ```
     * @return {?}
     */
    get maxValue() {
        return this._maxValue;
    }
    /**
     * Sets the maximal value for the `IgxSliderComponent`.
     * The default maximum value is 100.
     * ```html
     * <igx-slider [type]="sliderType" [minValue]="56" [maxValue]="256">
     * ```
     * @param {?} value
     * @return {?}
     */
    set maxValue(value) {
        if (value <= this._minValue) {
            this._maxValue = this._minValue + 1;
        }
        else {
            this._maxValue = value;
        }
        if (this._trackUpperBound) {
            this._upperBound = this._maxValue;
        }
        this.invalidateValue();
    }
    /**
     * Returns the minimal value of the `IgxSliderComponent`.
     * ```typescript
     * \@ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *    let sliderMin = this.slider.minValue;
     * }
     * ```
     * @return {?}
     */
    get minValue() {
        return this._minValue;
    }
    /**
     * Sets the minimal value for the `IgxSliderComponent`.
     * The default minimal value is 0.
     * ```html
     * <igx-slider [type]="sliderType" [minValue]="56" [maxValue]="100">
     * ```
     * @param {?} value
     * @return {?}
     */
    set minValue(value) {
        if (value >= this.maxValue) {
            this._minValue = this.maxValue - 1;
        }
        else {
            this._minValue = value;
        }
        if (this._trackLowerBound) {
            this._lowerBound = this._minValue;
        }
        this.invalidateValue();
    }
    /**
     * Returns the lower boundary of the `IgxSliderComponent`.
     * ```typescript
     * \@ViewChild("slider")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *    let sliderLowBound = this.slider.lowerBound;
     * }
     * ```
     * @return {?}
     */
    get lowerBound() {
        return this._lowerBound;
    }
    /**
     * Sets the lower boundary of the `IgxSliderComponent`.
     * If not set is the same as min value.
     * ```html
     * <igx-slider [step]="5" [lowerBound]="20">
     * ```
     * @param {?} value
     * @return {?}
     */
    set lowerBound(value) {
        if (this._trackLowerBound) {
            this._trackLowerBound = false;
        }
        if (value >= this.upperBound) {
            this._lowerBound = this.minValue;
            return;
        }
        this._lowerBound = this.valueInRange(value, this.minValue, this.maxValue);
    }
    /**
     * Returns the upper boundary of the `IgxSliderComponent`.
     * ```typescript
     * \@ViewChild("slider")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *    let sliderUpBound = this.slider.upperBound;
     * }
     * ```
     * @return {?}
     */
    get upperBound() {
        return this._upperBound;
    }
    /**
     * Sets the upper boundary of the `IgxSliderComponent`.
     * If not set is the same as max value.
     * ```html
     * <igx-slider [step]="5" [upperBound]="20">
     * ```
     * @param {?} value
     * @return {?}
     */
    set upperBound(value) {
        if (this._trackUpperBound) {
            this._trackUpperBound = false;
        }
        if (value <= this.lowerBound) {
            this._upperBound = this.maxValue;
            return;
        }
        this._upperBound = this.valueInRange(value, this.minValue, this.maxValue);
    }
    /**
     * Returns the lower value of the `IgxSliderComponent`.
     * ```typescript
     * \@ViewChild("slider")
     * public slider: IgxSliderComponent;
     * public lowValue(event){
     *    let sliderLowValue = this.slider.lowerValue;
     * }
     * ```
     * @return {?}
     */
    get lowerValue() {
        return this._lowerValue;
    }
    /**
     * Sets the lower value of the `IgxSliderComponent`.
     * ```typescript
     * \@ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * public lowValue(event){
     *    this.slider.lowerValue = 120;
     * }
     * ```
     * @param {?} value
     * @return {?}
     */
    set lowerValue(value) {
        value = this.valueInRange(value, this.lowerBound, this.upperBound);
        if (this.isRange && value > this.upperValue) {
            return;
        }
        this._lowerValue = value;
    }
    /**
     * Returns the upper value of the `IgxSliderComponent`.
     * ```typescript
     * \@ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * public upperValue(event){
     *    let upperValue = this.slider.upperValue;
     * }
     * ```
     * @return {?}
     */
    get upperValue() {
        return this._upperValue;
    }
    /**
     * Sets the upper value of the `IgxSliderComponent`.
     * ```typescript
     * \@ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * public upperValue(event){
     *    this.slider.upperValue = 120;
     * }
     * ```
     * @param {?} value
     * @return {?}
     */
    set upperValue(value) {
        value = this.valueInRange(value, this.lowerBound, this.upperBound);
        if (this.isRange && value < this.lowerValue) {
            return;
        }
        this._upperValue = value;
    }
    /**
     * Returns the slider value. If the slider is of type SLIDER the returned value is number.
     * If the slider type is RANGE the returned value is object containing lower and upper properties for the values.
     * ```typescript
     * \@ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * public sliderValue(event){
     *    let sliderVal = this.slider.value;
     * }
     * ```
     * @return {?}
     */
    get value() {
        if (this.isRange) {
            return {
                lower: this.snapValueToStep(this.lowerValue),
                upper: this.snapValueToStep(this.upperValue)
            };
        }
        else {
            /** @type {?} */
            const val = this.snapValueToStep(this.upperValue);
            return val;
        }
    }
    /**
     * Sets the slider value.
     * If the slider is of type SLIDER the argument is number. By default if no value is set the default value is
     * same as lower upper bound.
     * If the slider type is RANGE the the argument is object containing lower and upper properties for the values.
     * By default if no value is set the default value is for lower value it is the same as lower bound and if no
     * value is set for the upper value it is the same as the upper bound.
     * ```typescript
     * rangeValue = {
     *   lower: 30,
     *   upper: 60
     * };
     * ```
     * ```html
     * <igx-slider [type]="sliderType" [(ngModel)]="rangeValue" [minValue]="56" [maxValue]="256">
     * ```
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        if (!this.isRange) {
            this.upperValue = this.snapValueToStep((/** @type {?} */ (value)));
        }
        else {
            this.upperValue =
                this.snapValueToStep(((/** @type {?} */ (value))) == null ? null : ((/** @type {?} */ (value))).upper);
            this.lowerValue =
                this.snapValueToStep(((/** @type {?} */ (value))) == null ? null : ((/** @type {?} */ (value))).lower);
        }
        this._onChangeCallback(this.value);
        if (this.hasViewInit) {
            this.positionHandlesAndUpdateTrack();
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        if (this.lowerBound === undefined) {
            this.lowerBound = this.minValue;
            this._trackLowerBound = true;
        }
        if (this.upperBound === undefined) {
            this.upperBound = this.maxValue;
            this._trackUpperBound = true;
        }
        if (this.isRange) {
            if (Number.isNaN(((/** @type {?} */ (this.value))).lower)) {
                this.value = {
                    lower: this.lowerBound,
                    upper: ((/** @type {?} */ (this.value))).upper
                };
            }
            if (Number.isNaN(((/** @type {?} */ (this.value))).upper)) {
                this.value = {
                    lower: ((/** @type {?} */ (this.value))).lower,
                    upper: this.upperBound
                };
            }
        }
        else {
            if (Number.isNaN((/** @type {?} */ (this.value)))) {
                this.value = this.lowerBound;
            }
        }
        this.pMin = this.valueToFraction(this.lowerBound) || 0;
        this.pMax = this.valueToFraction(this.upperBound) || 1;
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterViewInit() {
        this.hasViewInit = true;
        this.positionHandlesAndUpdateTrack();
        this.setTickInterval();
    }
    /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.value = value;
    }
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /**
     * @hidden
     * @return {?}
     */
    getEditElement() {
        return this.isRange ? this.thumbFrom.nativeElement : this.thumbTo.nativeElement;
    }
    /**
     * @hidden
     * @return {?}
     */
    showThumbsLabels() {
        if (this.disabled) {
            return;
        }
        if (this.isContinuous) {
            return;
        }
        if (this.timer !== null) {
            clearInterval(this.timer);
        }
        this.isActiveLabel = true;
    }
    /**
     *
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    onFocus($event) {
        if (this.isRange && $event.target === this.thumbFrom.nativeElement) {
            this.activeHandle = SliderHandle.FROM;
        }
        if ($event.target === this.thumbTo.nativeElement) {
            this.activeHandle = SliderHandle.TO;
        }
        this.toggleThumbLabel();
    }
    /**
     *
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    onPanEnd($event) {
        this.hideThumbsLabels();
        this.emitValueChanged(null);
    }
    /**
     *
     * @hidden
     * @return {?}
     */
    hideThumbLabelsOnBlur() {
        if (this.timer !== null) {
            clearInterval(this.timer);
        }
        this.isActiveLabel = false;
    }
    /**
     *
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    onKeyDown($event) {
        if (this.disabled) {
            return true;
        }
        /** @type {?} */
        let incrementSign;
        if ($event.key.endsWith('Left')) {
            incrementSign = -1;
        }
        else if ($event.key.endsWith('Right')) {
            incrementSign = 1;
        }
        else {
            return;
        }
        /** @type {?} */
        const value = this.value;
        if (this.isRange) {
            if (this.activeHandle === SliderHandle.FROM) {
                /** @type {?} */
                const newLower = ((/** @type {?} */ (this.value))).lower + incrementSign * this.step;
                if (newLower >= ((/** @type {?} */ (this.value))).upper) {
                    this.thumbTo.nativeElement.focus();
                    return;
                }
                this.value = {
                    lower: newLower,
                    upper: ((/** @type {?} */ (this.value))).upper
                };
            }
            else {
                /** @type {?} */
                const newUpper = ((/** @type {?} */ (this.value))).upper + incrementSign * this.step;
                if (newUpper <= ((/** @type {?} */ (this.value))).lower) {
                    this.thumbFrom.nativeElement.focus();
                    return;
                }
                this.value = {
                    lower: ((/** @type {?} */ (this.value))).lower,
                    upper: ((/** @type {?} */ (this.value))).upper + incrementSign * this.step
                };
            }
        }
        else {
            this.value = (/** @type {?} */ (this.value)) + incrementSign * this.step;
        }
        if (this.hasValueChanged(value)) {
            this.emitValueChanged(value);
        }
        this.showThumbsLabels();
    }
    /**
     *
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    onTap($event) {
        /** @type {?} */
        const value = this.value;
        this.update($event);
        if (this.hasValueChanged(value)) {
            this.emitValueChanged(value);
        }
    }
    /**
     *
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    update($event) {
        if (this.disabled) {
            return;
        }
        if ($event.type === 'tap') {
            this.toggleThumbLabel();
        }
        // Set width and offset first
        this.setSliderWidth();
        this.setSliderOffset();
        // Then get pointer coordinates
        this.setPointerPosition($event);
        this.setPointerPercent();
        // Find the closest handle if dual slider
        if (this.isRange) {
            this.closestHandle();
        }
        // Update To/From Values
        this.setValues();
        // this.printInfo();
        // Finally do positionHandlesAndUpdateTrack the DOM
        // based on data values
        this.positionHandlesAndUpdateTrack();
        this._onTouchedCallback();
    }
    /**
     * @hidden
     * @return {?}
     */
    hideThumbsLabels() {
        if (this.disabled) {
            return;
        }
        if (this.isContinuous) {
            return;
        }
        this.timer = setTimeout(() => this.isActiveLabel = false, this.thumbLabelVisibilityDuration);
    }
    /**
     * @private
     * @param {?} value
     * @param {?=} min
     * @param {?=} max
     * @return {?}
     */
    valueInRange(value, min = 0, max = 100) {
        return Math.max(Math.min(value, max), min);
    }
    /**
     * @private
     * @return {?}
     */
    invalidateValue() {
        if (!this.isRange) {
            if (this.value >= this._lowerBound && this.value <= this._upperBound) {
                this.positionHandlesAndUpdateTrack();
            }
            else if (this.value < this._lowerBound) {
                this.value = this._lowerBound;
            }
            else if (this.value > this._upperBound) {
                this.value = this._upperBound;
            }
        }
        else {
            /** @type {?} */
            const value = (/** @type {?} */ (this.value));
            if (value.lower >= this._lowerBound && value.lower <= this._upperBound) {
                this.positionHandlesAndUpdateTrack();
            }
            else if (value.lower < this._lowerBound) {
                this.value = {
                    lower: this._lowerBound,
                    upper: value.upper
                };
            }
            else if (value.lower > this._upperBound) {
                this.value = {
                    lower: value.lower,
                    upper: this._upperBound
                };
            }
            if (value.upper >= this._lowerBound && value.upper <= this._upperBound) {
                this.positionHandlesAndUpdateTrack();
            }
            else if (value.upper < this._lowerBound) {
                this.value = {
                    lower: this._lowerBound,
                    upper: value.upper
                };
            }
            else if (value.upper > this._upperBound) {
                this.value = {
                    lower: value.lower,
                    upper: this._upperBound
                };
            }
        }
    }
    /**
     * @private
     * @param {?} color
     * @param {?} interval
     * @return {?}
     */
    generateTickMarks(color, interval) {
        return `repeating-linear-gradient(
            ${'to left'},
            ${color},
            ${color} 1.5px,
            transparent 1.5px,
            transparent ${interval}%
        ), repeating-linear-gradient(
            ${'to right'},
            ${color},
            ${color} 1.5px,
            transparent 1.5px,
            transparent ${interval}%
        )`;
    }
    /**
     * @private
     * @return {?}
     */
    toggleThumbLabel() {
        this.showThumbsLabels();
        this.hideThumbsLabels();
    }
    /**
     * @private
     * @return {?}
     */
    getSliderOffset() {
        return this.xOffset;
    }
    /**
     * @private
     * @param {?} num
     * @return {?}
     */
    toFixed(num) {
        num = parseFloat(num.toFixed(20));
        return num;
    }
    /**
     * @private
     * @param {?} handle
     * @param {?} position
     * @return {?}
     */
    positionHandle(handle, position) {
        handle.nativeElement.style.left = `${this.valueToFraction(position) * 100}%`;
    }
    /**
     * @private
     * @return {?}
     */
    positionHandlesAndUpdateTrack() {
        if (!this.isRange) {
            this.positionHandle(this.thumbTo, (/** @type {?} */ (this.value)));
        }
        else {
            this.positionHandle(this.thumbTo, ((/** @type {?} */ (this.value))).upper);
            this.positionHandle(this.thumbFrom, ((/** @type {?} */ (this.value))).lower);
        }
        this.updateTrack();
    }
    /**
     * @private
     * @return {?}
     */
    closestHandle() {
        /** @type {?} */
        const fromOffset = this.thumbFrom.nativeElement.offsetLeft + this.thumbFrom.nativeElement.offsetWidth / 2;
        /** @type {?} */
        const toOffset = this.thumbTo.nativeElement.offsetLeft + this.thumbTo.nativeElement.offsetWidth / 2;
        /** @type {?} */
        const match = this.closestTo(this.xPointer, [fromOffset, toOffset]);
        if (match === toOffset) {
            this.thumbTo.nativeElement.focus();
        }
        else if (match === fromOffset) {
            this.thumbFrom.nativeElement.focus();
        }
    }
    /**
     * @private
     * @return {?}
     */
    setTickInterval() {
        if (this.isContinuous) {
            return;
        }
        /** @type {?} */
        const interval = this.step > 1 ? this.step : null;
        this.renderer.setStyle(this.ticks.nativeElement, 'background', this.generateTickMarks('white', interval));
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    snapValueToStep(value) {
        /** @type {?} */
        const valueModStep = (value - this.minValue) % this.step;
        /** @type {?} */
        let snapValue = value - valueModStep;
        if (Math.abs(valueModStep) * 2 >= this.step) {
            snapValue += (valueModStep > 0) ? this.step : (-this.step);
        }
        return parseFloat(snapValue.toFixed(20));
    }
    /**
     * @private
     * @param {?} goal
     * @param {?} positions
     * @return {?}
     */
    closestTo(goal, positions) {
        return positions.reduce((previous, current) => {
            return (Math.abs(goal - current) < Math.abs(goal - previous) ? current : previous);
        });
    }
    // Set Values for To/From based on active handle
    /**
     * @private
     * @return {?}
     */
    setValues() {
        if (this.activeHandle === SliderHandle.TO) {
            if (this.isRange) {
                this.value = {
                    lower: ((/** @type {?} */ (this.value))).lower,
                    upper: this.fractionToValue(this.pPointer)
                };
            }
            else {
                this.value = this.fractionToValue(this.pPointer);
            }
        }
        if (this.activeHandle === SliderHandle.FROM) {
            this.value = {
                lower: this.fractionToValue(this.pPointer),
                upper: ((/** @type {?} */ (this.value))).upper
            };
        }
    }
    /**
     * @private
     * @return {?}
     */
    setSliderWidth() {
        this.width = this.slider.nativeElement.offsetWidth;
    }
    /**
     * @private
     * @param {?} e
     * @return {?}
     */
    setPointerPosition(e) {
        this.xPointer = e.center.x - this.getSliderOffset();
    }
    /**
     * @private
     * @return {?}
     */
    setSliderOffset() {
        /** @type {?} */
        const rect = this.slider.nativeElement.getBoundingClientRect();
        this.xOffset = rect.left;
    }
    /**
     * @private
     * @return {?}
     */
    setPointerPercent() {
        this.pPointer = this.valueInRange(this.toFixed(this.xPointer / this.width), this.pMin, this.pMax);
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    valueToFraction(value) {
        return this.valueInRange((value - this.minValue) / (this.maxValue - this.minValue), this.pMin, this.pMax);
    }
    /**
     * @private
     * @param {?} fraction
     * @return {?}
     */
    fractionToValue(fraction) {
        /** @type {?} */
        const max = this.maxValue;
        /** @type {?} */
        const min = this.minValue;
        return (max - min) * fraction + min;
    }
    /**
     * @private
     * @return {?}
     */
    updateTrack() {
        /** @type {?} */
        const fromPosition = this.valueToFraction(this.lowerValue);
        /** @type {?} */
        const toPosition = this.valueToFraction(this.upperValue);
        /** @type {?} */
        const positionGap = (this.valueToFraction(this.upperValue) - this.valueToFraction(this.lowerValue));
        if (!this.isRange) {
            this.track.nativeElement.style.transform = `scaleX(${toPosition})`;
        }
        if (this.isRange) {
            this.track.nativeElement.style.transform = `scaleX(${1})`;
            this.track.nativeElement.style.left = `${fromPosition * 100}%`;
            this.track.nativeElement.style.width = `${positionGap * 100}%`;
        }
    }
    /**
     * @private
     * @param {?} oldValue
     * @return {?}
     */
    hasValueChanged(oldValue) {
        /** @type {?} */
        const isSliderWithDifferentValue = !this.isRange && oldValue !== this.value;
        /** @type {?} */
        const isRangeWithOneDifferentValue = this.isRange &&
            (((/** @type {?} */ (oldValue))).lower !== ((/** @type {?} */ (this.value))).lower ||
                ((/** @type {?} */ (oldValue))).upper !== ((/** @type {?} */ (this.value))).upper);
        return isSliderWithDifferentValue || isRangeWithOneDifferentValue;
    }
    /**
     * @private
     * @param {?} oldValue
     * @return {?}
     */
    emitValueChanged(oldValue) {
        this.onValueChange.emit({ oldValue, value: this.value });
    }
}
IgxSliderComponent.decorators = [
    { type: Component, args: [{
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: IgxSliderComponent, multi: true }],
                selector: 'igx-slider',
                template: "<div class=\"igx-slider\" [class.igx-slider--disabled]=\"disabled\" #slider (panstart)=\"showThumbsLabels()\" (panend)=\"onPanEnd($event)\"\n    (pan)=\"update($event)\" (tap)=\"onTap($event)\">\n    <div class=\"igx-slider__track\">\n        <div #track class=\"igx-slider__track-fill\"></div>\n        <div #ticks class=\"igx-slider__track-ticks\"></div>\n    </div>\n    <div class=\"igx-slider__thumbs\">\n        <div (keydown)=\"onKeyDown($event);\" (keyup)=\"hideThumbsLabels()\" (blur)=\"hideThumbLabelsOnBlur()\" (focus)=\"onFocus($event);\"\n            *ngIf=\"isRange\" class=\"igx-slider__thumb-from\" tabindex=\"1\" [ngClass]=\"{ 'igx-slider__thumb-from--active': isActiveLabel }\"\n            #thumbFrom>\n            <span class=\"label\">{{ lowerValue}}</span>\n            <span class=\"dot\"></span>\n        </div>\n        <div (keydown)=\"onKeyDown($event);\" (keyup)=\"hideThumbsLabels()\" (blur)=\"hideThumbLabelsOnBlur()\" (focus)=\"onFocus($event);\"\n            class=\"igx-slider__thumb-to\" tabindex=\"1\" [ngClass]=\"{ 'igx-slider__thumb-to--active': isActiveLabel }\" #thumbTo>\n            <span *ngIf=\"isRange\" class=\"label\">{{ upperValue}}</span>\n            <span *ngIf=\"!isRange\" class=\"label\">{{ value }}</span>\n            <span class=\"dot\"></span>\n        </div>\n    </div>\n</div>\n",
                styles: [`
        :host {
            display: block;
        }
    `]
            }] }
];
/** @nocollapse */
IgxSliderComponent.ctorParameters = () => [
    { type: Renderer2 }
];
IgxSliderComponent.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    disabled: [{ type: Input }],
    isContinuous: [{ type: Input }],
    type: [{ type: Input }],
    thumbLabelVisibilityDuration: [{ type: Input }],
    step: [{ type: Input }],
    onValueChange: [{ type: Output }],
    slider: [{ type: ViewChild, args: ['slider',] }],
    track: [{ type: ViewChild, args: ['track',] }],
    ticks: [{ type: ViewChild, args: ['ticks',] }],
    thumbFrom: [{ type: ViewChild, args: ['thumbFrom',] }],
    thumbTo: [{ type: ViewChild, args: ['thumbTo',] }],
    maxValue: [{ type: Input }],
    minValue: [{ type: Input }],
    lowerBound: [{ type: Input }],
    upperBound: [{ type: Input }],
    value: [{ type: Input }]
};
if (false) {
    /**
     * An \@Input property that sets the value of the `id` attribute.
     * If not provided it will be automatically generated.
     * ```html
     * <igx-slider [id]="'igx-slider-32'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
     * ```
     * @type {?}
     */
    IgxSliderComponent.prototype.id;
    /**
     * An \@Input property that disables or enables UI interaction.
     * ```html
     * <igx-slider #slider [disabled]="'true'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
     * ```
     * @type {?}
     */
    IgxSliderComponent.prototype.disabled;
    /**
     * An \@Input property that marks the `IgxSliderComponent` as continuous.
     * By default is considered that the `IgxSliderComponent` is discrete.
     * Discrete `IgxSliderComponent` does not have ticks and does not shows bubble labels for values.
     * ```html
     * <igx-slider #slider [isContinuous]="'true'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
     * ```
     * @type {?}
     */
    IgxSliderComponent.prototype.isContinuous;
    /**
     * An \@Input property that sets the type of the `IgxSliderComponent`. The slider can be SliderType.SLIDER(default) or SliderType.RANGE.
     * ```typescript
     * sliderType: SliderType = SliderType.RANGE;
     * //...
     * ```
     * ```html
     * <igx-slider #slider2 [type]="sliderType" [(ngModel)]="rangeValue" [minValue]="0" [maxValue]="100">
     * ```
     * @type {?}
     */
    IgxSliderComponent.prototype.type;
    /**
     * An \@Input property that sets the duration visibility of thumbs labels. The default value is 750 milliseconds.
     * ```html
     * <igx-slider #slider [thumbLabelVisibilityDuration]="3000" [(ngModel)]="task.percentCompleted" [step]="5">
     * ```
     * @type {?}
     */
    IgxSliderComponent.prototype.thumbLabelVisibilityDuration;
    /**
     * An \@Input property that sets the incremental/decremental step of the value when dragging the thumb.
     * The default step is 1, and step should not be less or equal than 0.
     * ```html
     * <igx-slider #slider [(ngModel)]="task.percentCompleted" [step]="5">
     * ```
     * @type {?}
     */
    IgxSliderComponent.prototype.step;
    /**
     * This event is emitted when user has stopped interacting the thumb and value is changed.
     * ```typescript
     * public change(event){
     *    alert("The value has been changed!");
     * }
     * ```
     * ```html
     * <igx-slider (onValueChange)="change($event)" #slider [(ngModel)]="task.percentCompleted" [step]="5">
     * ```
     * @type {?}
     */
    IgxSliderComponent.prototype.onValueChange;
    /**
     * @hidden
     * @type {?}
     */
    IgxSliderComponent.prototype.isActiveLabel;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype.activeHandle;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype.slider;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype.track;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype.ticks;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype.thumbFrom;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype.thumbTo;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype.width;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype.xOffset;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype.xPointer;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype.pPointer;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype.pMin;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype.pMax;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype.hasViewInit;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype.timer;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._minValue;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._maxValue;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._lowerBound;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._upperBound;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._lowerValue;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._upperValue;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._trackUpperBound;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._trackLowerBound;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._onChangeCallback;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._onTouchedCallback;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype.renderer;
}
/**
 * @hidden
 */
export class IgxSliderModule {
}
IgxSliderModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxSliderComponent],
                exports: [IgxSliderComponent],
                imports: [CommonModule]
            },] }
];
export { ɵ0 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2xpZGVyLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvc2xpZGVyL3NsaWRlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMvQyxPQUFPLEVBQ1ksU0FBUyxFQUFFLFVBQVUsRUFBRSxZQUFZLEVBQ3RDLFdBQVcsRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFVLE1BQU0sRUFBRSxTQUFTLEVBQ25FLFNBQVMsRUFDWixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQXdCLGlCQUFpQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7OztJQUlyRTs7T0FFRztJQUNILFNBQU07SUFDTjs7T0FFRztJQUNILFFBQUs7Ozs7Ozs7SUFJTCxPQUFJO0lBQ0osS0FBRTs7Ozs7OztBQUdOLHVDQUdDOzs7SUFGRyxrQ0FBYzs7SUFDZCxrQ0FBYzs7Ozs7QUFHbEIsaURBR0M7OztJQUZHLCtDQUFxQzs7SUFDckMsNENBQWtDOzs7TUFHaEMsSUFBSSxHQUFHLEdBQUcsRUFBRTtBQUNsQixDQUFDOzs7SUFFRyxPQUFPLEdBQUcsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7OztBQTJCZixNQUFNLE9BQU8sa0JBQWtCOzs7O0lBOEgzQixZQUFvQixRQUFtQjtRQUFuQixhQUFRLEdBQVIsUUFBUSxDQUFXOzs7Ozs7OztRQW5IaEMsT0FBRSxHQUFHLGNBQWMsT0FBTyxFQUFFLEVBQUUsQ0FBQzs7Ozs7Ozs7O1FBbUIvQixpQkFBWSxHQUFHLEtBQUssQ0FBQzs7Ozs7Ozs7Ozs7UUFhckIsU0FBSSxHQUFlLFVBQVUsQ0FBQyxNQUFNLENBQUM7Ozs7Ozs7UUFTckMsaUNBQTRCLEdBQUcsR0FBRyxDQUFDOzs7Ozs7OztRQVVuQyxTQUFJLEdBQUcsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7UUFjVCxrQkFBYSxHQUFHLElBQUksWUFB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dWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7XG4gICAgQWZ0ZXJWaWV3SW5pdCwgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsXG4gICAgZm9yd2FyZFJlZiwgSG9zdEJpbmRpbmcsIElucHV0LCBOZ01vZHVsZSwgT25Jbml0LCBPdXRwdXQsIFJlbmRlcmVyMixcbiAgICBWaWV3Q2hpbGRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgeyBFZGl0b3JQcm92aWRlciB9IGZyb20gJy4uL2NvcmUvZWRpdC1wcm92aWRlcic7XG5cbmV4cG9ydCBlbnVtIFNsaWRlclR5cGUge1xuICAgIC8qKlxuICAgICAqIFNsaWRlciB3aXRoIHNpbmdsZSB0aHVtYi5cbiAgICAgKi9cbiAgICBTTElERVIsXG4gICAgLyoqXG4gICAgICogIFJhbmdlIHNsaWRlciB3aXRoIG11bHRpcGxlIHRodW1icywgdGhhdCBjYW4gbWFyayB0aGUgcmFuZ2UuXG4gICAgICovXG4gICAgUkFOR0Vcbn1cblxuZW51bSBTbGlkZXJIYW5kbGUge1xuICAgIEZST00sXG4gICAgVE9cbn1cblxuZXhwb3J0IGludGVyZmFjZSBJUmFuZ2VTbGlkZXJWYWx1ZSB7XG4gICAgbG93ZXI6IG51bWJlcjtcbiAgICB1cHBlcjogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElTbGlkZXJWYWx1ZUNoYW5nZUV2ZW50QXJncyB7XG4gICAgb2xkVmFsdWU6IG51bWJlciB8IElSYW5nZVNsaWRlclZhbHVlO1xuICAgIHZhbHVlOiBudW1iZXIgfCBJUmFuZ2VTbGlkZXJWYWx1ZTtcbn1cblxuY29uc3Qgbm9vcCA9ICgpID0+IHtcbn07XG5cbmxldCBORVhUX0lEID0gMDtcblxuLyoqXG4gKiAqKklnbml0ZSBVSSBmb3IgQW5ndWxhciBTbGlkZXIqKiAtXG4gKiBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly93d3cuaW5mcmFnaXN0aWNzLmNvbS9wcm9kdWN0cy9pZ25pdGUtdWktYW5ndWxhci9hbmd1bGFyL2NvbXBvbmVudHMvc2xpZGVyLmh0bWwpXG4gKlxuICogVGhlIElnbml0ZSBVSSBTbGlkZXIgYWxsb3dzIHNlbGVjdGlvbiBpbiBhIGdpdmVuIHJhbmdlIGJ5IG1vdmluZyB0aGUgdGh1bWIgYWxvbmcgdGhlIHRyYWNrLiBUaGUgdHJhY2tcbiAqIGNhbiBiZSBkZWZpbmVkIGFzIGNvbnRpbnVvdXMgb3Igc3RlcHBlZCwgYW5kIHlvdSBjYW4gY2hvb3NlIGJldHdlZW4gc2luZ2xlIGFuZCByYW5nZSBzbGlkZXIgdHlwZXMuXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYGh0bWxcbiAqIDxpZ3gtc2xpZGVyIGlkPVwic2xpZGVyXCJcbiAqICAgICAgICAgICAgW21pblZhbHVlXT1cIjBcIiBbbWF4VmFsdWVdPVwiMTAwXCJcbiAqICAgICAgICAgICAgW2lzQ29udGludW91c109dHJ1ZSBbKG5nTW9kZWwpXT1cInZvbHVtZVwiPlxuICogPC9pZ3gtc2xpZGVyPlxuICogYGBgXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsIHVzZUV4aXN0aW5nOiBJZ3hTbGlkZXJDb21wb25lbnQsIG11bHRpOiB0cnVlIH1dLFxuICAgIHNlbGVjdG9yOiAnaWd4LXNsaWRlcicsXG4gICAgdGVtcGxhdGVVcmw6ICdzbGlkZXIuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlczogW2BcbiAgICAgICAgOmhvc3Qge1xuICAgICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIH1cbiAgICBgXVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hTbGlkZXJDb21wb25lbnQgaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciwgRWRpdG9yUHJvdmlkZXIsIE9uSW5pdCwgQWZ0ZXJWaWV3SW5pdCB7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSB2YWx1ZSBvZiB0aGUgYGlkYCBhdHRyaWJ1dGUuXG4gICAgICogSWYgbm90IHByb3ZpZGVkIGl0IHdpbGwgYmUgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc2xpZGVyIFtpZF09XCInaWd4LXNsaWRlci0zMidcIiBbKG5nTW9kZWwpXT1cInRhc2sucGVyY2VudENvbXBsZXRlZFwiIFtzdGVwXT1cIjVcIiBbbG93ZXJCb3VuZF09XCIyMFwiPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5pZCcpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgaWQgPSBgaWd4LXNsaWRlci0ke05FWFRfSUQrK31gO1xuICAgIC8qKlxuICAgICAqQW4gQElucHV0IHByb3BlcnR5IHRoYXQgZGlzYWJsZXMgb3IgZW5hYmxlcyBVSSBpbnRlcmFjdGlvbi5cbiAgICAgKmBgYGh0bWxcbiAgICAgKjxpZ3gtc2xpZGVyICNzbGlkZXIgW2Rpc2FibGVkXT1cIid0cnVlJ1wiIFsobmdNb2RlbCldPVwidGFzay5wZXJjZW50Q29tcGxldGVkXCIgW3N0ZXBdPVwiNVwiIFtsb3dlckJvdW5kXT1cIjIwXCI+XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBkaXNhYmxlZDogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IG1hcmtzIHRoZSBgSWd4U2xpZGVyQ29tcG9uZW50YCBhcyBjb250aW51b3VzLlxuICAgICAqIEJ5IGRlZmF1bHQgaXMgY29uc2lkZXJlZCB0aGF0IHRoZSBgSWd4U2xpZGVyQ29tcG9uZW50YCBpcyBkaXNjcmV0ZS5cbiAgICAgKiBEaXNjcmV0ZSBgSWd4U2xpZGVyQ29tcG9uZW50YCBkb2VzIG5vdCBoYXZlIHRpY2tzIGFuZCBkb2VzIG5vdCBzaG93cyBidWJibGUgbGFiZWxzIGZvciB2YWx1ZXMuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc2xpZGVyICNzbGlkZXIgW2lzQ29udGludW91c109XCIndHJ1ZSdcIiBbKG5nTW9kZWwpXT1cInRhc2sucGVyY2VudENvbXBsZXRlZFwiIFtzdGVwXT1cIjVcIiBbbG93ZXJCb3VuZF09XCIyMFwiPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGlzQ29udGludW91cyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgdHlwZSBvZiB0aGUgYElneFNsaWRlckNvbXBvbmVudGAuIFRoZSBzbGlkZXIgY2FuIGJlIFNsaWRlclR5cGUuU0xJREVSKGRlZmF1bHQpIG9yIFNsaWRlclR5cGUuUkFOR0UuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHNsaWRlclR5cGU6IFNsaWRlclR5cGUgPSBTbGlkZXJUeXBlLlJBTkdFO1xuICAgICAqIC8vLi4uXG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc2xpZGVyICNzbGlkZXIyIFt0eXBlXT1cInNsaWRlclR5cGVcIiBbKG5nTW9kZWwpXT1cInJhbmdlVmFsdWVcIiBbbWluVmFsdWVdPVwiMFwiIFttYXhWYWx1ZV09XCIxMDBcIj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyB0eXBlOiBTbGlkZXJUeXBlID0gU2xpZGVyVHlwZS5TTElERVI7XG5cbiAgICAvKipcbiAgICAgKkFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIGR1cmF0aW9uIHZpc2liaWxpdHkgb2YgdGh1bWJzIGxhYmVscy4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgNzUwIG1pbGxpc2Vjb25kcy5cbiAgICAgKmBgYGh0bWxcbiAgICAgKjxpZ3gtc2xpZGVyICNzbGlkZXIgW3RodW1iTGFiZWxWaXNpYmlsaXR5RHVyYXRpb25dPVwiMzAwMFwiIFsobmdNb2RlbCldPVwidGFzay5wZXJjZW50Q29tcGxldGVkXCIgW3N0ZXBdPVwiNVwiPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdGh1bWJMYWJlbFZpc2liaWxpdHlEdXJhdGlvbiA9IDc1MDtcblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIGluY3JlbWVudGFsL2RlY3JlbWVudGFsIHN0ZXAgb2YgdGhlIHZhbHVlIHdoZW4gZHJhZ2dpbmcgdGhlIHRodW1iLlxuICAgICAqIFRoZSBkZWZhdWx0IHN0ZXAgaXMgMSwgYW5kIHN0ZXAgc2hvdWxkIG5vdCBiZSBsZXNzIG9yIGVxdWFsIHRoYW4gMC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zbGlkZXIgI3NsaWRlciBbKG5nTW9kZWwpXT1cInRhc2sucGVyY2VudENvbXBsZXRlZFwiIFtzdGVwXT1cIjVcIj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzdGVwID0gMTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZXZlbnQgaXMgZW1pdHRlZCB3aGVuIHVzZXIgaGFzIHN0b3BwZWQgaW50ZXJhY3RpbmcgdGhlIHRodW1iIGFuZCB2YWx1ZSBpcyBjaGFuZ2VkLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgY2hhbmdlKGV2ZW50KXtcbiAgICAgKiAgICBhbGVydChcIlRoZSB2YWx1ZSBoYXMgYmVlbiBjaGFuZ2VkIVwiKTtcbiAgICAgKn1cbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zbGlkZXIgKG9uVmFsdWVDaGFuZ2UpPVwiY2hhbmdlKCRldmVudClcIiAjc2xpZGVyIFsobmdNb2RlbCldPVwidGFzay5wZXJjZW50Q29tcGxldGVkXCIgW3N0ZXBdPVwiNVwiPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBvblZhbHVlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxJU2xpZGVyVmFsdWVDaGFuZ2VFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGlzQWN0aXZlTGFiZWwgPSBmYWxzZTtcblxuICAgIHByaXZhdGUgYWN0aXZlSGFuZGxlOiBTbGlkZXJIYW5kbGUgPSBTbGlkZXJIYW5kbGUuVE87XG5cbiAgICBAVmlld0NoaWxkKCdzbGlkZXInKVxuICAgIHByaXZhdGUgc2xpZGVyOiBFbGVtZW50UmVmO1xuXG4gICAgQFZpZXdDaGlsZCgndHJhY2snKVxuICAgIHByaXZhdGUgdHJhY2s6IEVsZW1lbnRSZWY7XG5cbiAgICBAVmlld0NoaWxkKCd0aWNrcycpXG4gICAgcHJpdmF0ZSB0aWNrczogRWxlbWVudFJlZjtcblxuICAgIEBWaWV3Q2hpbGQoJ3RodW1iRnJvbScpXG4gICAgcHJpdmF0ZSB0aHVtYkZyb206IEVsZW1lbnRSZWY7XG5cbiAgICBAVmlld0NoaWxkKCd0aHVtYlRvJylcbiAgICBwcml2YXRlIHRodW1iVG86IEVsZW1lbnRSZWY7XG5cblxuICAgIC8vIE1lYXN1cmVzICYgQ29vcmRpbmF0ZXNcbiAgICBwcml2YXRlIHdpZHRoID0gMDtcbiAgICBwcml2YXRlIHhPZmZzZXQgPSAwO1xuICAgIHByaXZhdGUgeFBvaW50ZXIgPSAwO1xuICAgIHByaXZhdGUgcFBvaW50ZXIgPSAwO1xuXG4gICAgLy8gTGltaXQgaGFuZGxlIHRyYXZlbCB6b25lXG4gICAgcHJpdmF0ZSBwTWluID0gMDtcbiAgICBwcml2YXRlIHBNYXggPSAxO1xuXG4gICAgLy8gRnJvbS91cHBlclZhbHVlIGluIHBlcmNlbnQgdmFsdWVzXG4gICAgcHJpdmF0ZSBoYXNWaWV3SW5pdCA9IGZhbHNlO1xuICAgIHByaXZhdGUgdGltZXI7XG4gICAgcHJpdmF0ZSBfbWluVmFsdWUgPSAwO1xuICAgIHByaXZhdGUgX21heFZhbHVlID0gMTAwO1xuICAgIHByaXZhdGUgX2xvd2VyQm91bmQ/OiBudW1iZXI7XG4gICAgcHJpdmF0ZSBfdXBwZXJCb3VuZD86IG51bWJlcjtcbiAgICBwcml2YXRlIF9sb3dlclZhbHVlOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBfdXBwZXJWYWx1ZTogbnVtYmVyO1xuICAgIHByaXZhdGUgX3RyYWNrVXBwZXJCb3VuZDogYm9vbGVhbjtcbiAgICBwcml2YXRlIF90cmFja0xvd2VyQm91bmQ6IGJvb2xlYW47XG5cbiAgICBwcml2YXRlIF9vbkNoYW5nZUNhbGxiYWNrOiAoXzogYW55KSA9PiB2b2lkID0gbm9vcDtcbiAgICBwcml2YXRlIF9vblRvdWNoZWRDYWxsYmFjazogKCkgPT4gdm9pZCA9IG5vb3A7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlJldHVybnMgd2hldGhlciB0aGUgYElneFNsaWRlckNvbXBvbmVudGAgdHlwZSBpcyBSQU5HRS5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKkBWaWV3Q2hpbGQoXCJzbGlkZXJcIilcbiAgICAgKnB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKm5nQWZ0ZXJWaWV3SW5pdCgpe1xuICAgICAqICAgIGxldCBzbGlkZXJSYW5nZSA9IHRoaXMuc2xpZGVyLmlzUmFuZ2U7XG4gICAgICp9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCBpc1JhbmdlKCk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBpc1JhbmdlOiBib29sZWFuID0gdGhpcy50eXBlID09PSBTbGlkZXJUeXBlLlJBTkdFO1xuXG4gICAgICAgIHJldHVybiBpc1JhbmdlO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWF4aW11bSB2YWx1ZSBmb3IgdGhlIGBJZ3hTbGlkZXJDb21wb25lbnRgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKkBWaWV3Q2hpbGQoXCJzbGlkZXJcIilcbiAgICAgKnB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKm5nQWZ0ZXJWaWV3SW5pdCgpe1xuICAgICAqICAgIGxldCBzbGlkZXJNYXggPSB0aGlzLnNsaWRlci5tYXhWYWx1ZTtcbiAgICAgKn1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG1heFZhbHVlKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXhWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtYXhpbWFsIHZhbHVlIGZvciB0aGUgYElneFNsaWRlckNvbXBvbmVudGAuXG4gICAgICogVGhlIGRlZmF1bHQgbWF4aW11bSB2YWx1ZSBpcyAxMDAuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc2xpZGVyIFt0eXBlXT1cInNsaWRlclR5cGVcIiBbbWluVmFsdWVdPVwiNTZcIiBbbWF4VmFsdWVdPVwiMjU2XCI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2V0IG1heFZhbHVlKHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgaWYgKHZhbHVlIDw9IHRoaXMuX21pblZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXhWYWx1ZSA9IHRoaXMuX21pblZhbHVlICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX21heFZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fdHJhY2tVcHBlckJvdW5kKSB7XG4gICAgICAgICAgICB0aGlzLl91cHBlckJvdW5kID0gdGhpcy5fbWF4VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnZhbGlkYXRlVmFsdWUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlJldHVybnMgdGhlIG1pbmltYWwgdmFsdWUgb2YgdGhlIGBJZ3hTbGlkZXJDb21wb25lbnRgLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqQFZpZXdDaGlsZChcInNsaWRlcjJcIilcbiAgICAgKnB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKm5nQWZ0ZXJWaWV3SW5pdCgpe1xuICAgICAqICAgIGxldCBzbGlkZXJNaW4gPSB0aGlzLnNsaWRlci5taW5WYWx1ZTtcbiAgICAgKn1cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbWluVmFsdWUoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21pblZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1pbmltYWwgdmFsdWUgZm9yIHRoZSBgSWd4U2xpZGVyQ29tcG9uZW50YC5cbiAgICAgKiBUaGUgZGVmYXVsdCBtaW5pbWFsIHZhbHVlIGlzIDAuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc2xpZGVyIFt0eXBlXT1cInNsaWRlclR5cGVcIiBbbWluVmFsdWVdPVwiNTZcIiBbbWF4VmFsdWVdPVwiMTAwXCI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2V0IG1pblZhbHVlKHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgaWYgKHZhbHVlID49IHRoaXMubWF4VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX21pblZhbHVlID0gdGhpcy5tYXhWYWx1ZSAtIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9taW5WYWx1ZSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3RyYWNrTG93ZXJCb3VuZCkge1xuICAgICAgICAgICAgdGhpcy5fbG93ZXJCb3VuZCA9IHRoaXMuX21pblZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW52YWxpZGF0ZVZhbHVlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbG93ZXIgYm91bmRhcnkgb2YgdGhlIGBJZ3hTbGlkZXJDb21wb25lbnRgLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqQFZpZXdDaGlsZChcInNsaWRlclwiKVxuICAgICAqcHVibGljIHNsaWRlcjogSWd4U2xpZGVyQ29tcG9uZW50O1xuICAgICAqbmdBZnRlclZpZXdJbml0KCl7XG4gICAgICogICAgbGV0IHNsaWRlckxvd0JvdW5kID0gdGhpcy5zbGlkZXIubG93ZXJCb3VuZDtcbiAgICAgKn1cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbG93ZXJCb3VuZCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG93ZXJCb3VuZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsb3dlciBib3VuZGFyeSBvZiB0aGUgYElneFNsaWRlckNvbXBvbmVudGAuXG4gICAgICogSWYgbm90IHNldCBpcyB0aGUgc2FtZSBhcyBtaW4gdmFsdWUuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc2xpZGVyIFtzdGVwXT1cIjVcIiBbbG93ZXJCb3VuZF09XCIyMFwiPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNldCBsb3dlckJvdW5kKHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyYWNrTG93ZXJCb3VuZCkge1xuICAgICAgICAgICAgdGhpcy5fdHJhY2tMb3dlckJvdW5kID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgPj0gdGhpcy51cHBlckJvdW5kKSB7XG4gICAgICAgICAgICB0aGlzLl9sb3dlckJvdW5kID0gdGhpcy5taW5WYWx1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xvd2VyQm91bmQgPSB0aGlzLnZhbHVlSW5SYW5nZSh2YWx1ZSwgdGhpcy5taW5WYWx1ZSwgdGhpcy5tYXhWYWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdXBwZXIgYm91bmRhcnkgb2YgdGhlIGBJZ3hTbGlkZXJDb21wb25lbnRgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKkBWaWV3Q2hpbGQoXCJzbGlkZXJcIilcbiAgICAgKnB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKm5nQWZ0ZXJWaWV3SW5pdCgpe1xuICAgICAqICAgIGxldCBzbGlkZXJVcEJvdW5kID0gdGhpcy5zbGlkZXIudXBwZXJCb3VuZDtcbiAgICAgKn1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHVwcGVyQm91bmQoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VwcGVyQm91bmQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdXBwZXIgYm91bmRhcnkgb2YgdGhlIGBJZ3hTbGlkZXJDb21wb25lbnRgLlxuICAgICAqIElmIG5vdCBzZXQgaXMgdGhlIHNhbWUgYXMgbWF4IHZhbHVlLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXNsaWRlciBbc3RlcF09XCI1XCIgW3VwcGVyQm91bmRdPVwiMjBcIj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgdXBwZXJCb3VuZCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgICAgIGlmICh0aGlzLl90cmFja1VwcGVyQm91bmQpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYWNrVXBwZXJCb3VuZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlIDw9IHRoaXMubG93ZXJCb3VuZCkge1xuICAgICAgICAgICAgdGhpcy5fdXBwZXJCb3VuZCA9IHRoaXMubWF4VmFsdWU7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwcGVyQm91bmQgPSB0aGlzLnZhbHVlSW5SYW5nZSh2YWx1ZSwgdGhpcy5taW5WYWx1ZSwgdGhpcy5tYXhWYWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbG93ZXIgdmFsdWUgb2YgdGhlIGBJZ3hTbGlkZXJDb21wb25lbnRgLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwic2xpZGVyXCIpXG4gICAgICogcHVibGljIHNsaWRlcjogSWd4U2xpZGVyQ29tcG9uZW50O1xuICAgICAqIHB1YmxpYyBsb3dWYWx1ZShldmVudCl7XG4gICAgICogICAgbGV0IHNsaWRlckxvd1ZhbHVlID0gdGhpcy5zbGlkZXIubG93ZXJWYWx1ZTtcbiAgICAgKn1cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbG93ZXJWYWx1ZSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fbG93ZXJWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlNldHMgdGhlIGxvd2VyIHZhbHVlIG9mIHRoZSBgSWd4U2xpZGVyQ29tcG9uZW50YC5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKkBWaWV3Q2hpbGQoXCJzbGlkZXIyXCIpXG4gICAgICpwdWJsaWMgc2xpZGVyOiBJZ3hTbGlkZXJDb21wb25lbnQ7XG4gICAgICpwdWJsaWMgbG93VmFsdWUoZXZlbnQpe1xuICAgICAqICAgIHRoaXMuc2xpZGVyLmxvd2VyVmFsdWUgPSAxMjA7XG4gICAgICp9XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IGxvd2VyVmFsdWUodmFsdWU6IG51bWJlcikge1xuICAgICAgICB2YWx1ZSA9IHRoaXMudmFsdWVJblJhbmdlKHZhbHVlLCB0aGlzLmxvd2VyQm91bmQsIHRoaXMudXBwZXJCb3VuZCk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNSYW5nZSAmJiB2YWx1ZSA+IHRoaXMudXBwZXJWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbG93ZXJWYWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqUmV0dXJucyB0aGUgdXBwZXIgdmFsdWUgb2YgdGhlIGBJZ3hTbGlkZXJDb21wb25lbnRgLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqQFZpZXdDaGlsZChcInNsaWRlcjJcIilcbiAgICAgKnB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKnB1YmxpYyB1cHBlclZhbHVlKGV2ZW50KXtcbiAgICAgKiAgICBsZXQgdXBwZXJWYWx1ZSA9IHRoaXMuc2xpZGVyLnVwcGVyVmFsdWU7XG4gICAgICp9XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHVwcGVyVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91cHBlclZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqU2V0cyB0aGUgdXBwZXIgdmFsdWUgb2YgdGhlIGBJZ3hTbGlkZXJDb21wb25lbnRgLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqQFZpZXdDaGlsZChcInNsaWRlcjJcIilcbiAgICAgKnB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKnB1YmxpYyB1cHBlclZhbHVlKGV2ZW50KXtcbiAgICAgKiAgICB0aGlzLnNsaWRlci51cHBlclZhbHVlID0gMTIwO1xuICAgICAqfVxuICAgICAqYGBgXG4gICAgICovXG4gICAgcHVibGljIHNldCB1cHBlclZhbHVlKHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLnZhbHVlSW5SYW5nZSh2YWx1ZSwgdGhpcy5sb3dlckJvdW5kLCB0aGlzLnVwcGVyQm91bmQpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzUmFuZ2UgJiYgdmFsdWUgPCB0aGlzLmxvd2VyVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwcGVyVmFsdWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzbGlkZXIgdmFsdWUuIElmIHRoZSBzbGlkZXIgaXMgb2YgdHlwZSBTTElERVIgdGhlIHJldHVybmVkIHZhbHVlIGlzIG51bWJlci5cbiAgICAgKiBJZiB0aGUgc2xpZGVyIHR5cGUgaXMgUkFOR0UgdGhlIHJldHVybmVkIHZhbHVlIGlzIG9iamVjdCBjb250YWluaW5nIGxvd2VyIGFuZCB1cHBlciBwcm9wZXJ0aWVzIGZvciB0aGUgdmFsdWVzLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqQFZpZXdDaGlsZChcInNsaWRlcjJcIilcbiAgICAgKnB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKnB1YmxpYyBzbGlkZXJWYWx1ZShldmVudCl7XG4gICAgICogICAgbGV0IHNsaWRlclZhbCA9IHRoaXMuc2xpZGVyLnZhbHVlO1xuICAgICAqfVxuICAgICAqYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCB2YWx1ZSgpOiBudW1iZXIgfCBJUmFuZ2VTbGlkZXJWYWx1ZSB7XG4gICAgICAgIGlmICh0aGlzLmlzUmFuZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbG93ZXI6IHRoaXMuc25hcFZhbHVlVG9TdGVwKHRoaXMubG93ZXJWYWx1ZSksXG4gICAgICAgICAgICAgICAgdXBwZXI6IHRoaXMuc25hcFZhbHVlVG9TdGVwKHRoaXMudXBwZXJWYWx1ZSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSB0aGlzLnNuYXBWYWx1ZVRvU3RlcCh0aGlzLnVwcGVyVmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNsaWRlciB2YWx1ZS5cbiAgICAgKiBJZiB0aGUgc2xpZGVyIGlzIG9mIHR5cGUgU0xJREVSIHRoZSBhcmd1bWVudCBpcyBudW1iZXIuIEJ5IGRlZmF1bHQgaWYgbm8gdmFsdWUgaXMgc2V0IHRoZSBkZWZhdWx0IHZhbHVlIGlzXG4gICAgICogc2FtZSBhcyBsb3dlciB1cHBlciBib3VuZC5cbiAgICAgKiBJZiB0aGUgc2xpZGVyIHR5cGUgaXMgUkFOR0UgdGhlIHRoZSBhcmd1bWVudCBpcyBvYmplY3QgY29udGFpbmluZyBsb3dlciBhbmQgdXBwZXIgcHJvcGVydGllcyBmb3IgdGhlIHZhbHVlcy5cbiAgICAgKiBCeSBkZWZhdWx0IGlmIG5vIHZhbHVlIGlzIHNldCB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBmb3IgbG93ZXIgdmFsdWUgaXQgaXMgdGhlIHNhbWUgYXMgbG93ZXIgYm91bmQgYW5kIGlmIG5vXG4gICAgICogdmFsdWUgaXMgc2V0IGZvciB0aGUgdXBwZXIgdmFsdWUgaXQgaXMgdGhlIHNhbWUgYXMgdGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKnJhbmdlVmFsdWUgPSB7XG4gICAgICogICBsb3dlcjogMzAsXG4gICAgICogICB1cHBlcjogNjBcbiAgICAgKn07XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc2xpZGVyIFt0eXBlXT1cInNsaWRlclR5cGVcIiBbKG5nTW9kZWwpXT1cInJhbmdlVmFsdWVcIiBbbWluVmFsdWVdPVwiNTZcIiBbbWF4VmFsdWVdPVwiMjU2XCI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2V0IHZhbHVlKHZhbHVlOiBudW1iZXIgfCBJUmFuZ2VTbGlkZXJWYWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNSYW5nZSkge1xuICAgICAgICAgICAgdGhpcy51cHBlclZhbHVlID0gdGhpcy5zbmFwVmFsdWVUb1N0ZXAodmFsdWUgYXMgbnVtYmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBwZXJWYWx1ZSA9XG4gICAgICAgICAgICAgICAgdGhpcy5zbmFwVmFsdWVUb1N0ZXAoKHZhbHVlIGFzIElSYW5nZVNsaWRlclZhbHVlKSA9PSBudWxsID8gbnVsbCA6ICh2YWx1ZSBhcyBJUmFuZ2VTbGlkZXJWYWx1ZSkudXBwZXIpO1xuICAgICAgICAgICAgdGhpcy5sb3dlclZhbHVlID1cbiAgICAgICAgICAgICAgICB0aGlzLnNuYXBWYWx1ZVRvU3RlcCgodmFsdWUgYXMgSVJhbmdlU2xpZGVyVmFsdWUpID09IG51bGwgPyBudWxsIDogKHZhbHVlIGFzIElSYW5nZVNsaWRlclZhbHVlKS5sb3dlcik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrKHRoaXMudmFsdWUpO1xuXG4gICAgICAgIGlmICh0aGlzLmhhc1ZpZXdJbml0KSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uSGFuZGxlc0FuZFVwZGF0ZVRyYWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25Jbml0KCkge1xuICAgICAgICBpZiAodGhpcy5sb3dlckJvdW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMubG93ZXJCb3VuZCA9IHRoaXMubWluVmFsdWU7XG4gICAgICAgICAgICB0aGlzLl90cmFja0xvd2VyQm91bmQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudXBwZXJCb3VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnVwcGVyQm91bmQgPSB0aGlzLm1heFZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fdHJhY2tVcHBlckJvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlzUmFuZ2UpIHtcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNOYU4oKHRoaXMudmFsdWUgYXMgSVJhbmdlU2xpZGVyVmFsdWUpLmxvd2VyKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyOiB0aGlzLmxvd2VyQm91bmQsXG4gICAgICAgICAgICAgICAgICAgIHVwcGVyOiAodGhpcy52YWx1ZSBhcyBJUmFuZ2VTbGlkZXJWYWx1ZSkudXBwZXJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKCh0aGlzLnZhbHVlIGFzIElSYW5nZVNsaWRlclZhbHVlKS51cHBlcikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0ge1xuICAgICAgICAgICAgICAgICAgICBsb3dlcjogKHRoaXMudmFsdWUgYXMgSVJhbmdlU2xpZGVyVmFsdWUpLmxvd2VyLFxuICAgICAgICAgICAgICAgICAgICB1cHBlcjogdGhpcy51cHBlckJvdW5kXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChOdW1iZXIuaXNOYU4odGhpcy52YWx1ZSBhcyBudW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMubG93ZXJCb3VuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucE1pbiA9IHRoaXMudmFsdWVUb0ZyYWN0aW9uKHRoaXMubG93ZXJCb3VuZCkgfHwgMDtcbiAgICAgICAgdGhpcy5wTWF4ID0gdGhpcy52YWx1ZVRvRnJhY3Rpb24odGhpcy51cHBlckJvdW5kKSB8fCAxO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICB0aGlzLmhhc1ZpZXdJbml0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbkhhbmRsZXNBbmRVcGRhdGVUcmFjaygpO1xuICAgICAgICB0aGlzLnNldFRpY2tJbnRlcnZhbCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgd3JpdGVWYWx1ZSh2YWx1ZTogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrID0gZm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMuX29uVG91Y2hlZENhbGxiYWNrID0gZm47XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBnZXRFZGl0RWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNSYW5nZSA/IHRoaXMudGh1bWJGcm9tLm5hdGl2ZUVsZW1lbnQgOiB0aGlzLnRodW1iVG8ubmF0aXZlRWxlbWVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHNob3dUaHVtYnNMYWJlbHMoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc0NvbnRpbnVvdXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnRpbWVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc0FjdGl2ZUxhYmVsID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgb25Gb2N1cygkZXZlbnQ6IEZvY3VzRXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSYW5nZSAmJiAkZXZlbnQudGFyZ2V0ID09PSB0aGlzLnRodW1iRnJvbS5uYXRpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUhhbmRsZSA9IFNsaWRlckhhbmRsZS5GUk9NO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCRldmVudC50YXJnZXQgPT09IHRoaXMudGh1bWJUby5uYXRpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUhhbmRsZSA9IFNsaWRlckhhbmRsZS5UTztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudG9nZ2xlVGh1bWJMYWJlbCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgb25QYW5FbmQoJGV2ZW50KSB7XG4gICAgICAgIHRoaXMuaGlkZVRodW1ic0xhYmVscygpO1xuICAgICAgICB0aGlzLmVtaXRWYWx1ZUNoYW5nZWQobnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBoaWRlVGh1bWJMYWJlbHNPbkJsdXIoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMudGltZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc0FjdGl2ZUxhYmVsID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBvbktleURvd24oJGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpbmNyZW1lbnRTaWduO1xuXG4gICAgICAgIGlmICgkZXZlbnQua2V5LmVuZHNXaXRoKCdMZWZ0JykpIHtcbiAgICAgICAgICAgIGluY3JlbWVudFNpZ24gPSAtMTtcbiAgICAgICAgfSBlbHNlIGlmICgkZXZlbnQua2V5LmVuZHNXaXRoKCdSaWdodCcpKSB7XG4gICAgICAgICAgICBpbmNyZW1lbnRTaWduID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy52YWx1ZTtcblxuICAgICAgICBpZiAodGhpcy5pc1JhbmdlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVIYW5kbGUgPT09IFNsaWRlckhhbmRsZS5GUk9NKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3TG93ZXIgPSAodGhpcy52YWx1ZSBhcyBJUmFuZ2VTbGlkZXJWYWx1ZSkubG93ZXIgKyBpbmNyZW1lbnRTaWduICogdGhpcy5zdGVwO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5ld0xvd2VyID49ICh0aGlzLnZhbHVlIGFzIElSYW5nZVNsaWRlclZhbHVlKS51cHBlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRodW1iVG8ubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbG93ZXI6IG5ld0xvd2VyLFxuICAgICAgICAgICAgICAgICAgICB1cHBlcjogKHRoaXMudmFsdWUgYXMgSVJhbmdlU2xpZGVyVmFsdWUpLnVwcGVyXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VXBwZXIgPSAodGhpcy52YWx1ZSBhcyBJUmFuZ2VTbGlkZXJWYWx1ZSkudXBwZXIgKyBpbmNyZW1lbnRTaWduICogdGhpcy5zdGVwO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5ld1VwcGVyIDw9ICh0aGlzLnZhbHVlIGFzIElSYW5nZVNsaWRlclZhbHVlKS5sb3dlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRodW1iRnJvbS5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0ge1xuICAgICAgICAgICAgICAgICAgICBsb3dlcjogKHRoaXMudmFsdWUgYXMgSVJhbmdlU2xpZGVyVmFsdWUpLmxvd2VyLFxuICAgICAgICAgICAgICAgICAgICB1cHBlcjogKHRoaXMudmFsdWUgYXMgSVJhbmdlU2xpZGVyVmFsdWUpLnVwcGVyICsgaW5jcmVtZW50U2lnbiAqIHRoaXMuc3RlcFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZSBhcyBudW1iZXIgKyBpbmNyZW1lbnRTaWduICogdGhpcy5zdGVwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzVmFsdWVDaGFuZ2VkKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0VmFsdWVDaGFuZ2VkKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2hvd1RodW1ic0xhYmVscygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgb25UYXAoJGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgICAgdGhpcy51cGRhdGUoJGV2ZW50KTtcblxuICAgICAgICBpZiAodGhpcy5oYXNWYWx1ZUNoYW5nZWQodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRWYWx1ZUNoYW5nZWQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHVwZGF0ZSgkZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICgkZXZlbnQudHlwZSA9PT0gJ3RhcCcpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlVGh1bWJMYWJlbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0IHdpZHRoIGFuZCBvZmZzZXQgZmlyc3RcbiAgICAgICAgdGhpcy5zZXRTbGlkZXJXaWR0aCgpO1xuICAgICAgICB0aGlzLnNldFNsaWRlck9mZnNldCgpO1xuXG4gICAgICAgIC8vIFRoZW4gZ2V0IHBvaW50ZXIgY29vcmRpbmF0ZXNcbiAgICAgICAgdGhpcy5zZXRQb2ludGVyUG9zaXRpb24oJGV2ZW50KTtcbiAgICAgICAgdGhpcy5zZXRQb2ludGVyUGVyY2VudCgpO1xuXG4gICAgICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3QgaGFuZGxlIGlmIGR1YWwgc2xpZGVyXG4gICAgICAgIGlmICh0aGlzLmlzUmFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VzdEhhbmRsZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXBkYXRlIFRvL0Zyb20gVmFsdWVzXG4gICAgICAgIHRoaXMuc2V0VmFsdWVzKCk7XG4gICAgICAgIC8vIHRoaXMucHJpbnRJbmZvKCk7XG5cbiAgICAgICAgLy8gRmluYWxseSBkbyBwb3NpdGlvbkhhbmRsZXNBbmRVcGRhdGVUcmFjayB0aGUgRE9NXG4gICAgICAgIC8vIGJhc2VkIG9uIGRhdGEgdmFsdWVzXG4gICAgICAgIHRoaXMucG9zaXRpb25IYW5kbGVzQW5kVXBkYXRlVHJhY2soKTtcbiAgICAgICAgdGhpcy5fb25Ub3VjaGVkQ2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGhpZGVUaHVtYnNMYWJlbHMoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc0NvbnRpbnVvdXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KFxuICAgICAgICAgICAgKCkgPT4gdGhpcy5pc0FjdGl2ZUxhYmVsID0gZmFsc2UsXG4gICAgICAgICAgICB0aGlzLnRodW1iTGFiZWxWaXNpYmlsaXR5RHVyYXRpb25cbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHZhbHVlSW5SYW5nZSh2YWx1ZSwgbWluID0gMCwgbWF4ID0gMTAwKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChNYXRoLm1pbih2YWx1ZSwgbWF4KSwgbWluKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGludmFsaWRhdGVWYWx1ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzUmFuZ2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnZhbHVlID49IHRoaXMuX2xvd2VyQm91bmQgJiYgdGhpcy52YWx1ZSA8PSB0aGlzLl91cHBlckJvdW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbkhhbmRsZXNBbmRVcGRhdGVUcmFjaygpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnZhbHVlIDwgdGhpcy5fbG93ZXJCb3VuZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLl9sb3dlckJvdW5kO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnZhbHVlID4gdGhpcy5fdXBwZXJCb3VuZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLl91cHBlckJvdW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnZhbHVlIGFzIElSYW5nZVNsaWRlclZhbHVlO1xuXG4gICAgICAgICAgICBpZiAodmFsdWUubG93ZXIgPj0gdGhpcy5fbG93ZXJCb3VuZCAmJiB2YWx1ZS5sb3dlciA8PSB0aGlzLl91cHBlckJvdW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbkhhbmRsZXNBbmRVcGRhdGVUcmFjaygpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS5sb3dlciA8IHRoaXMuX2xvd2VyQm91bmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0ge1xuICAgICAgICAgICAgICAgICAgICBsb3dlcjogdGhpcy5fbG93ZXJCb3VuZCxcbiAgICAgICAgICAgICAgICAgICAgdXBwZXI6IHZhbHVlLnVwcGVyXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUubG93ZXIgPiB0aGlzLl91cHBlckJvdW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgbG93ZXI6IHZhbHVlLmxvd2VyLFxuICAgICAgICAgICAgICAgICAgICB1cHBlcjogdGhpcy5fdXBwZXJCb3VuZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZS51cHBlciA+PSB0aGlzLl9sb3dlckJvdW5kICYmIHZhbHVlLnVwcGVyIDw9IHRoaXMuX3VwcGVyQm91bmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aW9uSGFuZGxlc0FuZFVwZGF0ZVRyYWNrKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlLnVwcGVyIDwgdGhpcy5fbG93ZXJCb3VuZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyOiB0aGlzLl9sb3dlckJvdW5kLFxuICAgICAgICAgICAgICAgICAgICB1cHBlcjogdmFsdWUudXBwZXJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS51cHBlciA+IHRoaXMuX3VwcGVyQm91bmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0ge1xuICAgICAgICAgICAgICAgICAgICBsb3dlcjogdmFsdWUubG93ZXIsXG4gICAgICAgICAgICAgICAgICAgIHVwcGVyOiB0aGlzLl91cHBlckJvdW5kXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgZ2VuZXJhdGVUaWNrTWFya3MoY29sb3I6IHN0cmluZywgaW50ZXJ2YWw6IG51bWJlcikge1xuICAgICAgICByZXR1cm4gYHJlcGVhdGluZy1saW5lYXItZ3JhZGllbnQoXG4gICAgICAgICAgICAkeyd0byBsZWZ0J30sXG4gICAgICAgICAgICAke2NvbG9yfSxcbiAgICAgICAgICAgICR7Y29sb3J9IDEuNXB4LFxuICAgICAgICAgICAgdHJhbnNwYXJlbnQgMS41cHgsXG4gICAgICAgICAgICB0cmFuc3BhcmVudCAke2ludGVydmFsfSVcbiAgICAgICAgKSwgcmVwZWF0aW5nLWxpbmVhci1ncmFkaWVudChcbiAgICAgICAgICAgICR7J3RvIHJpZ2h0J30sXG4gICAgICAgICAgICAke2NvbG9yfSxcbiAgICAgICAgICAgICR7Y29sb3J9IDEuNXB4LFxuICAgICAgICAgICAgdHJhbnNwYXJlbnQgMS41cHgsXG4gICAgICAgICAgICB0cmFuc3BhcmVudCAke2ludGVydmFsfSVcbiAgICAgICAgKWA7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB0b2dnbGVUaHVtYkxhYmVsKCkge1xuICAgICAgICB0aGlzLnNob3dUaHVtYnNMYWJlbHMoKTtcbiAgICAgICAgdGhpcy5oaWRlVGh1bWJzTGFiZWxzKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRTbGlkZXJPZmZzZXQoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueE9mZnNldDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHRvRml4ZWQobnVtOiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICBudW0gPSBwYXJzZUZsb2F0KG51bS50b0ZpeGVkKDIwKSk7XG4gICAgICAgIHJldHVybiBudW07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwb3NpdGlvbkhhbmRsZShoYW5kbGU6IEVsZW1lbnRSZWYsIHBvc2l0aW9uOiBudW1iZXIpIHtcbiAgICAgICAgaGFuZGxlLm5hdGl2ZUVsZW1lbnQuc3R5bGUubGVmdCA9IGAke3RoaXMudmFsdWVUb0ZyYWN0aW9uKHBvc2l0aW9uKSAqIDEwMH0lYDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHBvc2l0aW9uSGFuZGxlc0FuZFVwZGF0ZVRyYWNrKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNSYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbkhhbmRsZSh0aGlzLnRodW1iVG8sIHRoaXMudmFsdWUgYXMgbnVtYmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25IYW5kbGUodGhpcy50aHVtYlRvLCAodGhpcy52YWx1ZSBhcyBJUmFuZ2VTbGlkZXJWYWx1ZSkudXBwZXIpO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbkhhbmRsZSh0aGlzLnRodW1iRnJvbSwgKHRoaXMudmFsdWUgYXMgSVJhbmdlU2xpZGVyVmFsdWUpLmxvd2VyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlVHJhY2soKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNsb3Nlc3RIYW5kbGUoKSB7XG4gICAgICAgIGNvbnN0IGZyb21PZmZzZXQgPSB0aGlzLnRodW1iRnJvbS5uYXRpdmVFbGVtZW50Lm9mZnNldExlZnQgKyB0aGlzLnRodW1iRnJvbS5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoIC8gMjtcbiAgICAgICAgY29uc3QgdG9PZmZzZXQgPSB0aGlzLnRodW1iVG8ubmF0aXZlRWxlbWVudC5vZmZzZXRMZWZ0ICsgdGhpcy50aHVtYlRvLm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGggLyAyO1xuICAgICAgICBjb25zdCBtYXRjaCA9IHRoaXMuY2xvc2VzdFRvKHRoaXMueFBvaW50ZXIsIFtmcm9tT2Zmc2V0LCB0b09mZnNldF0pO1xuXG4gICAgICAgIGlmIChtYXRjaCA9PT0gdG9PZmZzZXQpIHtcbiAgICAgICAgICAgIHRoaXMudGh1bWJUby5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2ggPT09IGZyb21PZmZzZXQpIHtcbiAgICAgICAgICAgIHRoaXMudGh1bWJGcm9tLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc2V0VGlja0ludGVydmFsKCkge1xuICAgICAgICBpZiAodGhpcy5pc0NvbnRpbnVvdXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGludGVydmFsID0gdGhpcy5zdGVwID4gMSA/IHRoaXMuc3RlcCA6IG51bGw7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy50aWNrcy5uYXRpdmVFbGVtZW50LCAnYmFja2dyb3VuZCcsIHRoaXMuZ2VuZXJhdGVUaWNrTWFya3MoJ3doaXRlJywgaW50ZXJ2YWwpKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNuYXBWYWx1ZVRvU3RlcCh2YWx1ZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgY29uc3QgdmFsdWVNb2RTdGVwID0gKHZhbHVlIC0gdGhpcy5taW5WYWx1ZSkgJSB0aGlzLnN0ZXA7XG4gICAgICAgIGxldCBzbmFwVmFsdWUgPSB2YWx1ZSAtIHZhbHVlTW9kU3RlcDtcblxuICAgICAgICBpZiAoTWF0aC5hYnModmFsdWVNb2RTdGVwKSAqIDIgPj0gdGhpcy5zdGVwKSB7XG4gICAgICAgICAgICBzbmFwVmFsdWUgKz0gKHZhbHVlTW9kU3RlcCA+IDApID8gdGhpcy5zdGVwIDogKC10aGlzLnN0ZXApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoc25hcFZhbHVlLnRvRml4ZWQoMjApKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNsb3Nlc3RUbyhnb2FsOiBudW1iZXIsIHBvc2l0aW9uczogbnVtYmVyW10pOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gcG9zaXRpb25zLnJlZHVjZSgocHJldmlvdXMsIGN1cnJlbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoTWF0aC5hYnMoZ29hbCAtIGN1cnJlbnQpIDwgTWF0aC5hYnMoZ29hbCAtIHByZXZpb3VzKSA/IGN1cnJlbnQgOiBwcmV2aW91cyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFNldCBWYWx1ZXMgZm9yIFRvL0Zyb20gYmFzZWQgb24gYWN0aXZlIGhhbmRsZVxuICAgIHByaXZhdGUgc2V0VmFsdWVzKCkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVIYW5kbGUgPT09IFNsaWRlckhhbmRsZS5UTykge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNSYW5nZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyOiAodGhpcy52YWx1ZSBhcyBJUmFuZ2VTbGlkZXJWYWx1ZSkubG93ZXIsXG4gICAgICAgICAgICAgICAgICAgIHVwcGVyOiB0aGlzLmZyYWN0aW9uVG9WYWx1ZSh0aGlzLnBQb2ludGVyKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLmZyYWN0aW9uVG9WYWx1ZSh0aGlzLnBQb2ludGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZUhhbmRsZSA9PT0gU2xpZGVySGFuZGxlLkZST00pIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB7XG4gICAgICAgICAgICAgICAgbG93ZXI6IHRoaXMuZnJhY3Rpb25Ub1ZhbHVlKHRoaXMucFBvaW50ZXIpLFxuICAgICAgICAgICAgICAgIHVwcGVyOiAodGhpcy52YWx1ZSBhcyBJUmFuZ2VTbGlkZXJWYWx1ZSkudXBwZXJcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHNldFNsaWRlcldpZHRoKCk6IHZvaWQge1xuICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5zbGlkZXIubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldFBvaW50ZXJQb3NpdGlvbihlKSB7XG4gICAgICAgIHRoaXMueFBvaW50ZXIgPSBlLmNlbnRlci54IC0gdGhpcy5nZXRTbGlkZXJPZmZzZXQoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldFNsaWRlck9mZnNldCgpIHtcbiAgICAgICAgY29uc3QgcmVjdCA9IHRoaXMuc2xpZGVyLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHRoaXMueE9mZnNldCA9IHJlY3QubGVmdDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNldFBvaW50ZXJQZXJjZW50KCkge1xuICAgICAgICB0aGlzLnBQb2ludGVyID0gdGhpcy52YWx1ZUluUmFuZ2UodGhpcy50b0ZpeGVkKHRoaXMueFBvaW50ZXIgLyB0aGlzLndpZHRoKSwgdGhpcy5wTWluLCB0aGlzLnBNYXgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdmFsdWVUb0ZyYWN0aW9uKHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVJblJhbmdlKCh2YWx1ZSAtIHRoaXMubWluVmFsdWUpIC8gKHRoaXMubWF4VmFsdWUgLSB0aGlzLm1pblZhbHVlKSwgdGhpcy5wTWluLCB0aGlzLnBNYXgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZnJhY3Rpb25Ub1ZhbHVlKGZyYWN0aW9uOiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBtYXg6IG51bWJlciA9IHRoaXMubWF4VmFsdWU7XG4gICAgICAgIGNvbnN0IG1pbjogbnVtYmVyID0gdGhpcy5taW5WYWx1ZTtcblxuICAgICAgICByZXR1cm4gKG1heCAtIG1pbikgKiBmcmFjdGlvbiArIG1pbjtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZVRyYWNrKCkge1xuICAgICAgICBjb25zdCBmcm9tUG9zaXRpb24gPSB0aGlzLnZhbHVlVG9GcmFjdGlvbih0aGlzLmxvd2VyVmFsdWUpO1xuICAgICAgICBjb25zdCB0b1Bvc2l0aW9uID0gdGhpcy52YWx1ZVRvRnJhY3Rpb24odGhpcy51cHBlclZhbHVlKTtcbiAgICAgICAgY29uc3QgcG9zaXRpb25HYXAgPSAodGhpcy52YWx1ZVRvRnJhY3Rpb24odGhpcy51cHBlclZhbHVlKSAtIHRoaXMudmFsdWVUb0ZyYWN0aW9uKHRoaXMubG93ZXJWYWx1ZSkpO1xuXG4gICAgICAgIGlmICghdGhpcy5pc1JhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNrLm5hdGl2ZUVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gYHNjYWxlWCgke3RvUG9zaXRpb259KWA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc1JhbmdlKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNrLm5hdGl2ZUVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gYHNjYWxlWCgkezF9KWA7XG4gICAgICAgICAgICB0aGlzLnRyYWNrLm5hdGl2ZUVsZW1lbnQuc3R5bGUubGVmdCA9IGAke2Zyb21Qb3NpdGlvbiAqIDEwMH0lYDtcbiAgICAgICAgICAgIHRoaXMudHJhY2submF0aXZlRWxlbWVudC5zdHlsZS53aWR0aCA9IGAke3Bvc2l0aW9uR2FwICogMTAwfSVgO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByaXZhdGUgaGFzVmFsdWVDaGFuZ2VkKG9sZFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGlzU2xpZGVyV2l0aERpZmZlcmVudFZhbHVlOiBib29sZWFuID0gIXRoaXMuaXNSYW5nZSAmJiBvbGRWYWx1ZSAhPT0gdGhpcy52YWx1ZTtcbiAgICAgICAgY29uc3QgaXNSYW5nZVdpdGhPbmVEaWZmZXJlbnRWYWx1ZTogYm9vbGVhbiA9IHRoaXMuaXNSYW5nZSAmJlxuICAgICAgICAgICAgKChvbGRWYWx1ZSBhcyBJUmFuZ2VTbGlkZXJWYWx1ZSkubG93ZXIgIT09ICh0aGlzLnZhbHVlIGFzIElSYW5nZVNsaWRlclZhbHVlKS5sb3dlciB8fFxuICAgICAgICAgICAgICAgIChvbGRWYWx1ZSBhcyBJUmFuZ2VTbGlkZXJWYWx1ZSkudXBwZXIgIT09ICh0aGlzLnZhbHVlIGFzIElSYW5nZVNsaWRlclZhbHVlKS51cHBlcik7XG5cbiAgICAgICAgcmV0dXJuIGlzU2xpZGVyV2l0aERpZmZlcmVudFZhbHVlIHx8IGlzUmFuZ2VXaXRoT25lRGlmZmVyZW50VmFsdWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBlbWl0VmFsdWVDaGFuZ2VkKG9sZFZhbHVlOiBudW1iZXIgfCBJUmFuZ2VTbGlkZXJWYWx1ZSkge1xuICAgICAgICB0aGlzLm9uVmFsdWVDaGFuZ2UuZW1pdCh7IG9sZFZhbHVlLCB2YWx1ZTogdGhpcy52YWx1ZSB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW0lneFNsaWRlckNvbXBvbmVudF0sXG4gICAgZXhwb3J0czogW0lneFNsaWRlckNvbXBvbmVudF0sXG4gICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZV1cbn0pXG5leHBvcnQgY2xhc3MgSWd4U2xpZGVyTW9kdWxlIHtcbn1cbiJdfQ==