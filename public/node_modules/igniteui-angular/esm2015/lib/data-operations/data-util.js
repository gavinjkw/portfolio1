/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { IgxSorting, IgxDataRecordSorting } from './sorting-strategy';
import { IgxGrouping } from './grouping-strategy';
import { PagingError } from './paging-state.interface';
import { TreeGridFilteringStrategy } from '../grids/tree-grid/tree-grid.filtering.pipe';
import { FilteringStrategy } from './filtering-strategy';
import { cloneValue, mergeObjects } from '../core/utils';
import { TransactionType } from '../services/transaction/transaction';
/** @enum {string} */
const DataType = {
    String: 'string',
    Number: 'number',
    Boolean: 'boolean',
    Date: 'date',
};
export { DataType };
/**
 * @hidden
 */
export class DataUtil {
    /**
     * @template T
     * @param {?} data
     * @param {?} expressions
     * @param {?=} sorting
     * @return {?}
     */
    static sort(data, expressions, sorting = new IgxSorting()) {
        return sorting.sort(data, expressions);
    }
    /**
     * @param {?} hierarchicalData
     * @param {?} expressions
     * @param {?=} parent
     * @return {?}
     */
    static treeGridSort(hierarchicalData, expressions, parent) {
        /** @type {?} */
        let res = [];
        hierarchicalData.forEach((hr) => {
            /** @type {?} */
            const rec = DataUtil.cloneTreeGridRecord(hr);
            rec.parent = parent;
            if (rec.children) {
                rec.children = DataUtil.treeGridSort(rec.children, expressions, rec);
            }
            res.push(rec);
        });
        res = DataUtil.sort(res, expressions, new IgxDataRecordSorting());
        return res;
    }
    /**
     * @param {?} hierarchicalRecord
     * @return {?}
     */
    static cloneTreeGridRecord(hierarchicalRecord) {
        /** @type {?} */
        const rec = {
            rowID: hierarchicalRecord.rowID,
            data: hierarchicalRecord.data,
            children: hierarchicalRecord.children,
            isFilteredOutParent: hierarchicalRecord.isFilteredOutParent,
            level: hierarchicalRecord.level,
            expanded: hierarchicalRecord.expanded
        };
        return rec;
    }
    /**
     * @template T
     * @param {?} data
     * @param {?} state
     * @param {?=} grid
     * @param {?=} groupsRecords
     * @return {?}
     */
    static group(data, state, grid = null, groupsRecords = []) {
        /** @type {?} */
        const grouping = new IgxGrouping();
        groupsRecords.splice(0, groupsRecords.length);
        return grouping.groupBy(data, state.expressions, grid, groupsRecords);
    }
    /**
     * @param {?} groupData
     * @param {?} state
     * @return {?}
     */
    static restoreGroups(groupData, state) {
        if (state.expressions.length === 0) {
            return groupData.data;
        }
        return this.restoreGroupsIterative(groupData, state);
    }
    /**
     * @private
     * @param {?} groupData
     * @param {?} state
     * @return {?}
     */
    static restoreGroupsIterative(groupData, state) {
        /** @type {?} */
        const metadata = groupData.metadata;
        /** @type {?} */
        const result = [];
        /** @type {?} */
        const added = [];
        /** @type {?} */
        let chain;
        /** @type {?} */
        let i = 0;
        /** @type {?} */
        let j;
        /** @type {?} */
        let pointer;
        /** @type {?} */
        let expanded;
        for (i = 0; i < metadata.length;) {
            chain = [metadata[i]];
            pointer = metadata[i].groupParent;
            // break off if the parent is already added
            while (pointer && added[0] !== pointer) {
                chain.push(pointer);
                if (added[0] && added[0].level === pointer.level) {
                    added.shift();
                }
                pointer = pointer.groupParent;
            }
            for (j = chain.length - 1; j >= 0; j--) {
                result.push(chain[j]);
                added.unshift(chain[j]);
                /** @type {?} */
                const hierarchy = this.getHierarchy(chain[j]);
                /** @type {?} */
                const expandState = state.expansion.find((s) => this.isHierarchyMatch(s.hierarchy || [{ fieldName: chain[j].expression.fieldName, value: chain[j].value }], hierarchy));
                expanded = expandState ? expandState.expanded : state.defaultExpanded;
                if (!expanded) {
                    break;
                }
            }
            added.shift();
            j = Math.max(j, 0);
            /** @type {?} */
            const start = chain[j].records.findIndex(r => r === groupData.data[i]);
            /** @type {?} */
            const end = Math.min(metadata.length - i + start, chain[j].records.length);
            if (expanded) {
                result.push(...chain[j].records.slice(start, end));
            }
            i += end - start;
        }
        return result;
    }
    /**
     * @template T
     * @param {?} data
     * @param {?} state
     * @return {?}
     */
    static page(data, state) {
        if (!state) {
            return data;
        }
        /** @type {?} */
        const len = data.length;
        /** @type {?} */
        const index = state.index;
        /** @type {?} */
        const res = [];
        /** @type {?} */
        const recordsPerPage = state.recordsPerPage;
        state.metadata = {
            countPages: 0,
            countRecords: data.length,
            error: PagingError.None
        };
        if (index < 0 || isNaN(index)) {
            state.metadata.error = PagingError.IncorrectPageIndex;
            return res;
        }
        if (recordsPerPage <= 0 || isNaN(recordsPerPage)) {
            state.metadata.error = PagingError.IncorrectRecordsPerPage;
            return res;
        }
        state.metadata.countPages = Math.ceil(len / recordsPerPage);
        if (!len) {
            return data;
        }
        if (index >= state.metadata.countPages) {
            state.metadata.error = PagingError.IncorrectPageIndex;
            return res;
        }
        return data.slice(index * recordsPerPage, (index + 1) * recordsPerPage);
    }
    /**
     * @template T
     * @param {?} data
     * @param {?} state
     * @return {?}
     */
    static filter(data, state) {
        if (!state.strategy) {
            state.strategy = new FilteringStrategy();
        }
        return state.strategy.filter(data, state.expressionsTree);
    }
    /**
     * @param {?} data
     * @param {?} state
     * @return {?}
     */
    static treeGridFilter(data, state) {
        if (!state.strategy) {
            state.strategy = new TreeGridFilteringStrategy();
        }
        return state.strategy.filter(data, state.expressionsTree);
    }
    /**
     * @param {?} gRow
     * @return {?}
     */
    static getHierarchy(gRow) {
        /** @type {?} */
        const hierarchy = [];
        if (gRow !== undefined && gRow.expression) {
            hierarchy.push({ fieldName: gRow.expression.fieldName, value: gRow.value });
            while (gRow.groupParent) {
                gRow = gRow.groupParent;
                hierarchy.unshift({ fieldName: gRow.expression.fieldName, value: gRow.value });
            }
        }
        return hierarchy;
    }
    /**
     * @param {?} h1
     * @param {?} h2
     * @return {?}
     */
    static isHierarchyMatch(h1, h2) {
        if (h1.length !== h2.length) {
            return false;
        }
        return h1.every((level, index) => {
            return level.fieldName === h2[index].fieldName && level.value === h2[index].value;
        });
    }
    /**
     * Merges all changes from provided transactions into provided data collection
     * @template T
     * @param {?} data Collection to merge
     * @param {?} transactions Transactions to merge into data
     * @param {?=} primaryKey Primary key of the collection, if any
     * @param {?=} deleteRows Should delete rows with DELETE transaction type from data
     * @return {?} Provided data collections updated with all provided transactions
     */
    static mergeTransactions(data, transactions, primaryKey, deleteRows = false) {
        data.forEach((item, index) => {
            /** @type {?} */
            const rowId = primaryKey ? item[primaryKey] : item;
            /** @type {?} */
            const transaction = transactions.find(t => t.id === rowId);
            if (transaction && transaction.type === TransactionType.UPDATE) {
                data[index] = transaction.newValue;
            }
        });
        if (deleteRows) {
            transactions
                .filter(t => t.type === TransactionType.DELETE)
                .forEach(t => {
                /** @type {?} */
                const index = primaryKey ? data.findIndex(d => d[primaryKey] === t.id) : data.findIndex(d => d === t.id);
                if (0 <= index && index < data.length) {
                    data.splice(index, 1);
                }
            });
        }
        data.push(...transactions
            .filter(t => t.type === TransactionType.ADD)
            .map(t => t.newValue));
        return data;
    }
    /**
     * Merges all changes from provided transactions into provided hierarchical data collection
     * @param {?} data Collection to merge
     * @param {?} transactions Transactions to merge into data
     * @param {?} childDataKey Data key of child collections
     * @param {?=} primaryKey Primary key of the collection, if any
     * @param {?=} deleteRows Should delete rows with DELETE transaction type from data
     * @return {?} Provided data collections updated with all provided transactions
     */
    static mergeHierarchicalTransactions(data, transactions, childDataKey, primaryKey, deleteRows = false) {
        for (const transaction of transactions) {
            if (transaction.path) {
                /** @type {?} */
                const parent = this.findParentFromPath(data, primaryKey, childDataKey, transaction.path);
                /** @type {?} */
                let collection = parent ? parent[childDataKey] : data;
                switch (transaction.type) {
                    case TransactionType.ADD:
                        //  if there is no parent this is ADD row at root level
                        if (parent && !parent[childDataKey]) {
                            parent[childDataKey] = collection = [];
                        }
                        collection.push(transaction.newValue);
                        break;
                    case TransactionType.UPDATE:
                        /** @type {?} */
                        const updateIndex = collection.findIndex(x => x[primaryKey] === transaction.id);
                        if (updateIndex !== -1) {
                            collection[updateIndex] = mergeObjects(cloneValue(collection[updateIndex]), transaction.newValue);
                        }
                        break;
                    case TransactionType.DELETE:
                        if (deleteRows) {
                            /** @type {?} */
                            const deleteIndex = collection.findIndex(r => r[primaryKey] === transaction.id);
                            if (deleteIndex !== -1) {
                                collection.splice(deleteIndex, 1);
                            }
                        }
                        break;
                }
            }
            else {
                //  if there is no path this is ADD row in root. Push the newValue to data
                data.push(transaction.newValue);
            }
        }
        return data;
    }
    /**
     * @private
     * @param {?} data
     * @param {?} primaryKey
     * @param {?} childDataKey
     * @param {?} path
     * @return {?}
     */
    static findParentFromPath(data, primaryKey, childDataKey, path) {
        /** @type {?} */
        let collection = data;
        /** @type {?} */
        let result;
        for (const id of path) {
            result = collection && collection.find(x => x[primaryKey] === id);
            if (!result) {
                break;
            }
            collection = result[childDataKey];
        }
        return result;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YS11dGlsLmpzIiwic291cmNlUm9vdCI6Im5nOi8vaWduaXRldWktYW5ndWxhci8iLCJzb3VyY2VzIjpbImxpYi9kYXRhLW9wZXJhdGlvbnMvZGF0YS11dGlsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFFQSxPQUFPLEVBQUUsVUFBVSxFQUFFLG9CQUFvQixFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDdEUsT0FBTyxFQUFrQixXQUFXLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUVsRSxPQUFPLEVBQWdCLFdBQVcsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBS3JFLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxNQUFNLDZDQUE2QyxDQUFDO0FBRXhGLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBRXpELE9BQU8sRUFBRSxVQUFVLEVBQUUsWUFBWSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3pELE9BQU8sRUFBZSxlQUFlLEVBQTJCLE1BQU0scUNBQXFDLENBQUM7OztJQU14RyxRQUFTLFFBQVE7SUFDakIsUUFBUyxRQUFRO0lBQ2pCLFNBQVUsU0FBUztJQUNuQixNQUFPLE1BQU07Ozs7OztBQU1qQixNQUFNLE9BQU8sUUFBUTs7Ozs7Ozs7SUFDVixNQUFNLENBQUMsSUFBSSxDQUFJLElBQVMsRUFBRSxXQUFpQyxFQUFFLFVBQXNCLElBQUksVUFBVSxFQUFFO1FBQ3RHLE9BQU8sT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFDM0MsQ0FBQzs7Ozs7OztJQUVNLE1BQU0sQ0FBQyxZQUFZLENBQUMsZ0JBQW1DLEVBQzFELFdBQWlDLEVBQ2pDLE1BQXdCOztZQUNwQixHQUFHLEdBQXNCLEVBQUU7UUFDL0IsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBbUIsRUFBRSxFQUFFOztrQkFDdkMsR0FBRyxHQUFvQixRQUFRLENBQUMsbUJBQW1CLENBQUMsRUFBRSxDQUFDO1lBQzdELEdBQUcsQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO1lBQ3BCLElBQUksR0FBRyxDQUFDLFFBQVEsRUFBRTtnQkFDZCxHQUFHLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLFFBQVEsRUFBRSxXQUFXLEVBQUUsR0FBRyxDQUFDLENBQUM7YUFDeEU7WUFDRCxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2xCLENBQUMsQ0FBQyxDQUFDO1FBRUgsR0FBRyxHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLFdBQVcsRUFBRSxJQUFJLG9CQUFvQixFQUFFLENBQUMsQ0FBQztRQUVsRSxPQUFPLEdBQUcsQ0FBQztJQUNmLENBQUM7Ozs7O0lBRU0sTUFBTSxDQUFDLG1CQUFtQixDQUFDLGtCQUFtQzs7Y0FDM0QsR0FBRyxHQUFvQjtZQUN6QixLQUFLLEVBQUUsa0JBQWtCLENBQUMsS0FBSztZQUMvQixJQUFJLEVBQUUsa0JBQWtCLENBQUMsSUFBSTtZQUM3QixRQUFRLEVBQUUsa0JBQWtCLENBQUMsUUFBUTtZQUNyQyxtQkFBbUIsRUFBRSxrQkFBa0IsQ0FBQyxtQkFBbUI7WUFDM0QsS0FBSyxFQUFFLGtCQUFrQixDQUFDLEtBQUs7WUFDL0IsUUFBUSxFQUFFLGtCQUFrQixDQUFDLFFBQVE7U0FDeEM7UUFDRCxPQUFPLEdBQUcsQ0FBQztJQUNmLENBQUM7Ozs7Ozs7OztJQUVNLE1BQU0sQ0FBQyxLQUFLLENBQUksSUFBUyxFQUFFLEtBQXFCLEVBQUUsT0FBWSxJQUFJLEVBQUUsZ0JBQXVCLEVBQUU7O2NBQzFGLFFBQVEsR0FBRyxJQUFJLFdBQVcsRUFBRTtRQUNsQyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDOUMsT0FBTyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsV0FBVyxFQUFFLElBQUksRUFBRSxhQUFhLENBQUMsQ0FBQztJQUMxRSxDQUFDOzs7Ozs7SUFDTSxNQUFNLENBQUMsYUFBYSxDQUFDLFNBQXlCLEVBQUUsS0FBcUI7UUFDeEUsSUFBSSxLQUFLLENBQUMsV0FBVyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDaEMsT0FBTyxTQUFTLENBQUMsSUFBSSxDQUFDO1NBQ3pCO1FBQ0QsT0FBTyxJQUFJLENBQUMsc0JBQXNCLENBQUMsU0FBUyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ3pELENBQUM7Ozs7Ozs7SUFDTyxNQUFNLENBQUMsc0JBQXNCLENBQUMsU0FBeUIsRUFBRSxLQUFxQjs7Y0FDNUUsUUFBUSxHQUFHLFNBQVMsQ0FBQyxRQUFROztjQUM3QixNQUFNLEdBQUcsRUFBRTs7Y0FBRSxLQUFLLEdBQUcsRUFBRTs7WUFDekIsS0FBWTs7WUFDWixDQUFDLEdBQUcsQ0FBQzs7WUFBRSxDQUFDOztZQUNSLE9BQXVCOztZQUN2QixRQUFpQjtRQUNyQixLQUFLLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxNQUFNLEdBQUc7WUFDOUIsS0FBSyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDdEIsT0FBTyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUM7WUFDbEMsMkNBQTJDO1lBQzNDLE9BQU8sT0FBTyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsS0FBSyxPQUFPLEVBQUU7Z0JBQ3BDLEtBQUssQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBQ3BCLElBQUksS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLEtBQUssT0FBTyxDQUFDLEtBQUssRUFBRTtvQkFDOUMsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDO2lCQUNqQjtnQkFDRCxPQUFPLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FBQzthQUNqQztZQUNELEtBQUssQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ3BDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ3RCLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7O3NCQUNsQixTQUFTLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7O3NCQUN2QyxXQUFXLEdBQXdCLEtBQUssQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FDaEUsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxTQUFTLElBQUksQ0FBQyxFQUFFLFNBQVMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLFNBQVMsRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUM7Z0JBQzNILFFBQVEsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxlQUFlLENBQUM7Z0JBQ3RFLElBQUksQ0FBQyxRQUFRLEVBQUU7b0JBQ1gsTUFBTTtpQkFDVDthQUNKO1lBQ0QsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDO1lBQ2QsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDOztrQkFDYixLQUFLLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQzs7a0JBQ2hFLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxHQUFHLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQztZQUMxRSxJQUFJLFFBQVEsRUFBRTtnQkFDVixNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUM7YUFDdEQ7WUFDRCxDQUFDLElBQUksR0FBRyxHQUFHLEtBQUssQ0FBQztTQUNwQjtRQUNELE9BQU8sTUFBTSxDQUFDO0lBQ2xCLENBQUM7Ozs7Ozs7SUFDTSxNQUFNLENBQUMsSUFBSSxDQUFJLElBQVMsRUFBRSxLQUFtQjtRQUNoRCxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ1IsT0FBTyxJQUFJLENBQUM7U0FDZjs7Y0FDSyxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU07O2NBQ2pCLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSzs7Y0FDbkIsR0FBRyxHQUFHLEVBQUU7O2NBQ1IsY0FBYyxHQUFHLEtBQUssQ0FBQyxjQUFjO1FBQzNDLEtBQUssQ0FBQyxRQUFRLEdBQUc7WUFDYixVQUFVLEVBQUUsQ0FBQztZQUNiLFlBQVksRUFBRSxJQUFJLENBQUMsTUFBTTtZQUN6QixLQUFLLEVBQUUsV0FBVyxDQUFDLElBQUk7U0FDMUIsQ0FBQztRQUNGLElBQUksS0FBSyxHQUFHLENBQUMsSUFBSSxLQUFLLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDM0IsS0FBSyxDQUFDLFFBQVEsQ0FBQyxLQUFLLEdBQUcsV0FBVyxDQUFDLGtCQUFrQixDQUFDO1lBQ3RELE9BQU8sR0FBRyxDQUFDO1NBQ2Q7UUFDRCxJQUFJLGNBQWMsSUFBSSxDQUFDLElBQUksS0FBSyxDQUFDLGNBQWMsQ0FBQyxFQUFFO1lBQzlDLEtBQUssQ0FBQyxRQUFRLENBQUMsS0FBSyxHQUFHLFdBQVcsQ0FBQyx1QkFBdUIsQ0FBQztZQUMzRCxPQUFPLEdBQUcsQ0FBQztTQUNkO1FBQ0QsS0FBSyxDQUFDLFFBQVEsQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEdBQUcsY0FBYyxDQUFDLENBQUM7UUFDNUQsSUFBSSxDQUFDLEdBQUcsRUFBRTtZQUNOLE9BQU8sSUFBSSxDQUFDO1NBQ2Y7UUFDRCxJQUFJLEtBQUssSUFBSSxLQUFLLENBQUMsUUFBUSxDQUFDLFVBQVUsRUFBRTtZQUNwQyxLQUFLLENBQUMsUUFBUSxDQUFDLEtBQUssR0FBRyxXQUFXLENBQUMsa0JBQWtCLENBQUM7WUFDdEQsT0FBTyxHQUFHLENBQUM7U0FDZDtRQUNELE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsY0FBYyxFQUFFLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxHQUFHLGNBQWMsQ0FBQyxDQUFDO0lBQzVFLENBQUM7Ozs7Ozs7SUFDTSxNQUFNLENBQUMsTUFBTSxDQUFJLElBQVMsRUFBRSxLQUFzQjtRQUNyRCxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsRUFBRTtZQUNqQixLQUFLLENBQUMsUUFBUSxHQUFHLElBQUksaUJBQWlCLEVBQUUsQ0FBQztTQUM1QztRQUNELE9BQU8sS0FBSyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxlQUFlLENBQUMsQ0FBQztJQUM5RCxDQUFDOzs7Ozs7SUFFTSxNQUFNLENBQUMsY0FBYyxDQUFDLElBQXVCLEVBQUUsS0FBc0I7UUFDeEUsSUFBSSxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUU7WUFDakIsS0FBSyxDQUFDLFFBQVEsR0FBRyxJQUFJLHlCQUF5QixFQUFFLENBQUM7U0FDcEQ7UUFDRCxPQUFPLEtBQUssQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsZUFBZSxDQUFDLENBQUM7SUFDOUQsQ0FBQzs7Ozs7SUFFTSxNQUFNLENBQUMsWUFBWSxDQUFDLElBQW9COztjQUNyQyxTQUFTLEdBQXVCLEVBQUU7UUFDeEMsSUFBSSxJQUFJLEtBQUssU0FBUyxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7WUFDdkMsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUFFLFNBQVMsRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7WUFDNUUsT0FBTyxJQUFJLENBQUMsV0FBVyxFQUFFO2dCQUNyQixJQUFJLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQztnQkFDeEIsU0FBUyxDQUFDLE9BQU8sQ0FBQyxFQUFFLFNBQVMsRUFBRSxJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7YUFDbEY7U0FDSjtRQUNELE9BQU8sU0FBUyxDQUFDO0lBQ3JCLENBQUM7Ozs7OztJQUVNLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFzQixFQUFFLEVBQXNCO1FBQ3pFLElBQUksRUFBRSxDQUFDLE1BQU0sS0FBSyxFQUFFLENBQUMsTUFBTSxFQUFFO1lBQ3pCLE9BQU8sS0FBSyxDQUFDO1NBQ2hCO1FBQ0QsT0FBTyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsS0FBSyxFQUFFLEtBQUssRUFBVyxFQUFFO1lBQ3RDLE9BQU8sS0FBSyxDQUFDLFNBQVMsS0FBSyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsU0FBUyxJQUFJLEtBQUssQ0FBQyxLQUFLLEtBQUssRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLEtBQUssQ0FBQztRQUN0RixDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7Ozs7Ozs7Ozs7SUFVTSxNQUFNLENBQUMsaUJBQWlCLENBQUksSUFBUyxFQUFFLFlBQTJCLEVBQUUsVUFBZ0IsRUFBRSxhQUFzQixLQUFLO1FBQ3BILElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFTLEVBQUUsS0FBYSxFQUFFLEVBQUU7O2tCQUNoQyxLQUFLLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUk7O2tCQUM1QyxXQUFXLEdBQUcsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLEtBQUssS0FBSyxDQUFDO1lBQzFELElBQUksV0FBVyxJQUFJLFdBQVcsQ0FBQyxJQUFJLEtBQUssZUFBZSxDQUFDLE1BQU0sRUFBRTtnQkFDNUQsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLFdBQVcsQ0FBQyxRQUFRLENBQUM7YUFDdEM7UUFDTCxDQUFDLENBQUMsQ0FBQztRQUVILElBQUksVUFBVSxFQUFFO1lBQ1osWUFBWTtpQkFDUCxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLGVBQWUsQ0FBQyxNQUFNLENBQUM7aUJBQzlDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRTs7c0JBQ0gsS0FBSyxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQztnQkFDeEcsSUFBSSxDQUFDLElBQUksS0FBSyxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFO29CQUNuQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztpQkFDekI7WUFDTCxDQUFDLENBQUMsQ0FBQztTQUNWO1FBRUQsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLFlBQVk7YUFDcEIsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxlQUFlLENBQUMsR0FBRyxDQUFDO2FBQzNDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBRTNCLE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7Ozs7Ozs7Ozs7SUFXTSxNQUFNLENBQUMsNkJBQTZCLENBQ3ZDLElBQVcsRUFDWCxZQUF1QyxFQUN2QyxZQUFpQixFQUNqQixVQUFnQixFQUNoQixhQUFzQixLQUFLO1FBRTNCLEtBQUssTUFBTSxXQUFXLElBQUksWUFBWSxFQUFFO1lBQ3BDLElBQUksV0FBVyxDQUFDLElBQUksRUFBRTs7c0JBQ1osTUFBTSxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxJQUFJLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBRSxXQUFXLENBQUMsSUFBSSxDQUFDOztvQkFDcEYsVUFBVSxHQUFVLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJO2dCQUM1RCxRQUFRLFdBQVcsQ0FBQyxJQUFJLEVBQUU7b0JBQ3RCLEtBQUssZUFBZSxDQUFDLEdBQUc7d0JBQ3BCLHVEQUF1RDt3QkFDdkQsSUFBSSxNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLEVBQUU7NEJBQ2pDLE1BQU0sQ0FBQyxZQUFZLENBQUMsR0FBRyxVQUFVLEdBQUcsRUFBRSxDQUFDO3lCQUMxQzt3QkFDRCxVQUFVLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQzt3QkFDdEMsTUFBTTtvQkFDVixLQUFLLGVBQWUsQ0FBQyxNQUFNOzs4QkFDakIsV0FBVyxHQUFHLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLEtBQUssV0FBVyxDQUFDLEVBQUUsQ0FBQzt3QkFDL0UsSUFBSSxXQUFXLEtBQUssQ0FBQyxDQUFDLEVBQUU7NEJBQ3BCLFVBQVUsQ0FBQyxXQUFXLENBQUMsR0FBRyxZQUFZLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQzt5QkFDckc7d0JBQ0QsTUFBTTtvQkFDVixLQUFLLGVBQWUsQ0FBQyxNQUFNO3dCQUN2QixJQUFJLFVBQVUsRUFBRTs7a0NBQ04sV0FBVyxHQUFHLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLEtBQUssV0FBVyxDQUFDLEVBQUUsQ0FBQzs0QkFDL0UsSUFBSSxXQUFXLEtBQUssQ0FBQyxDQUFDLEVBQUU7Z0NBQ3BCLFVBQVUsQ0FBQyxNQUFNLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQyxDQUFDOzZCQUNyQzt5QkFDSjt3QkFDRCxNQUFNO2lCQUNiO2FBQ0o7aUJBQU07Z0JBQ0gsMEVBQTBFO2dCQUMxRSxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUNuQztTQUNKO1FBQ0QsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQzs7Ozs7Ozs7O0lBRU8sTUFBTSxDQUFDLGtCQUFrQixDQUFDLElBQVcsRUFBRSxVQUFlLEVBQUUsWUFBaUIsRUFBRSxJQUFXOztZQUN0RixVQUFVLEdBQVUsSUFBSTs7WUFDeEIsTUFBVztRQUVmLEtBQUssTUFBTSxFQUFFLElBQUksSUFBSSxFQUFFO1lBQ25CLE1BQU0sR0FBRyxVQUFVLElBQUksVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztZQUNsRSxJQUFJLENBQUMsTUFBTSxFQUFFO2dCQUNULE1BQU07YUFDVDtZQUVELFVBQVUsR0FBRyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUM7U0FDckM7UUFFRCxPQUFPLE1BQU0sQ0FBQztJQUNsQixDQUFDO0NBQ0oiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJRmlsdGVyaW5nU3RhdGUgfSBmcm9tICcuL2ZpbHRlcmluZy1zdGF0ZS5pbnRlcmZhY2UnO1xuXG5pbXBvcnQgeyBJZ3hTb3J0aW5nLCBJZ3hEYXRhUmVjb3JkU29ydGluZyB9IGZyb20gJy4vc29ydGluZy1zdHJhdGVneSc7XG5pbXBvcnQgeyBJR3JvdXBCeVJlc3VsdCwgSWd4R3JvdXBpbmcgfSBmcm9tICcuL2dyb3VwaW5nLXN0cmF0ZWd5JztcblxuaW1wb3J0IHsgSVBhZ2luZ1N0YXRlLCBQYWdpbmdFcnJvciB9IGZyb20gJy4vcGFnaW5nLXN0YXRlLmludGVyZmFjZSc7XG5cbmltcG9ydCB7IElHcm91cEJ5RXhwYW5kU3RhdGUsIElHcm91cEJ5S2V5IH0gZnJvbSAnLi9ncm91cGJ5LWV4cGFuZC1zdGF0ZS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSUdyb3VwQnlSZWNvcmQgfSBmcm9tICcuL2dyb3VwYnktcmVjb3JkLmludGVyZmFjZSc7XG5pbXBvcnQgeyBJR3JvdXBpbmdTdGF0ZSB9IGZyb20gJy4vZ3JvdXBieS1zdGF0ZS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgVHJlZUdyaWRGaWx0ZXJpbmdTdHJhdGVneSB9IGZyb20gJy4uL2dyaWRzL3RyZWUtZ3JpZC90cmVlLWdyaWQuZmlsdGVyaW5nLnBpcGUnO1xuaW1wb3J0IHsgSVNvcnRpbmdFeHByZXNzaW9uIH0gZnJvbSAnLi9zb3J0aW5nLWV4cHJlc3Npb24uaW50ZXJmYWNlJztcbmltcG9ydCB7IEZpbHRlcmluZ1N0cmF0ZWd5IH0gZnJvbSAnLi9maWx0ZXJpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHsgSVRyZWVHcmlkUmVjb3JkIH0gZnJvbSAnLi4vZ3JpZHMvdHJlZS1ncmlkJztcbmltcG9ydCB7IGNsb25lVmFsdWUsIG1lcmdlT2JqZWN0cyB9IGZyb20gJy4uL2NvcmUvdXRpbHMnO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24sIFRyYW5zYWN0aW9uVHlwZSwgSGllcmFyY2hpY2FsVHJhbnNhY3Rpb24gfSBmcm9tICcuLi9zZXJ2aWNlcy90cmFuc2FjdGlvbi90cmFuc2FjdGlvbic7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgZW51bSBEYXRhVHlwZSB7XG4gICAgU3RyaW5nID0gJ3N0cmluZycsXG4gICAgTnVtYmVyID0gJ251bWJlcicsXG4gICAgQm9vbGVhbiA9ICdib29sZWFuJyxcbiAgICBEYXRlID0gJ2RhdGUnXG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgRGF0YVV0aWwge1xuICAgIHB1YmxpYyBzdGF0aWMgc29ydDxUPihkYXRhOiBUW10sIGV4cHJlc3Npb25zOiBJU29ydGluZ0V4cHJlc3Npb25bXSwgc29ydGluZzogSWd4U29ydGluZyA9IG5ldyBJZ3hTb3J0aW5nKCkpOiBUW10ge1xuICAgICAgICByZXR1cm4gc29ydGluZy5zb3J0KGRhdGEsIGV4cHJlc3Npb25zKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIHRyZWVHcmlkU29ydChoaWVyYXJjaGljYWxEYXRhOiBJVHJlZUdyaWRSZWNvcmRbXSxcbiAgICAgICAgZXhwcmVzc2lvbnM6IElTb3J0aW5nRXhwcmVzc2lvbltdLFxuICAgICAgICBwYXJlbnQ/OiBJVHJlZUdyaWRSZWNvcmQpOiBJVHJlZUdyaWRSZWNvcmRbXSB7XG4gICAgICAgIGxldCByZXM6IElUcmVlR3JpZFJlY29yZFtdID0gW107XG4gICAgICAgIGhpZXJhcmNoaWNhbERhdGEuZm9yRWFjaCgoaHI6IElUcmVlR3JpZFJlY29yZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVjOiBJVHJlZUdyaWRSZWNvcmQgPSBEYXRhVXRpbC5jbG9uZVRyZWVHcmlkUmVjb3JkKGhyKTtcbiAgICAgICAgICAgIHJlYy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICBpZiAocmVjLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgcmVjLmNoaWxkcmVuID0gRGF0YVV0aWwudHJlZUdyaWRTb3J0KHJlYy5jaGlsZHJlbiwgZXhwcmVzc2lvbnMsIHJlYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMucHVzaChyZWMpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXMgPSBEYXRhVXRpbC5zb3J0KHJlcywgZXhwcmVzc2lvbnMsIG5ldyBJZ3hEYXRhUmVjb3JkU29ydGluZygpKTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgY2xvbmVUcmVlR3JpZFJlY29yZChoaWVyYXJjaGljYWxSZWNvcmQ6IElUcmVlR3JpZFJlY29yZCkge1xuICAgICAgICBjb25zdCByZWM6IElUcmVlR3JpZFJlY29yZCA9IHtcbiAgICAgICAgICAgIHJvd0lEOiBoaWVyYXJjaGljYWxSZWNvcmQucm93SUQsXG4gICAgICAgICAgICBkYXRhOiBoaWVyYXJjaGljYWxSZWNvcmQuZGF0YSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBoaWVyYXJjaGljYWxSZWNvcmQuY2hpbGRyZW4sXG4gICAgICAgICAgICBpc0ZpbHRlcmVkT3V0UGFyZW50OiBoaWVyYXJjaGljYWxSZWNvcmQuaXNGaWx0ZXJlZE91dFBhcmVudCxcbiAgICAgICAgICAgIGxldmVsOiBoaWVyYXJjaGljYWxSZWNvcmQubGV2ZWwsXG4gICAgICAgICAgICBleHBhbmRlZDogaGllcmFyY2hpY2FsUmVjb3JkLmV4cGFuZGVkXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZWM7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBncm91cDxUPihkYXRhOiBUW10sIHN0YXRlOiBJR3JvdXBpbmdTdGF0ZSwgZ3JpZDogYW55ID0gbnVsbCwgZ3JvdXBzUmVjb3JkczogYW55W10gPSBbXSk6IElHcm91cEJ5UmVzdWx0IHtcbiAgICAgICAgY29uc3QgZ3JvdXBpbmcgPSBuZXcgSWd4R3JvdXBpbmcoKTtcbiAgICAgICAgZ3JvdXBzUmVjb3Jkcy5zcGxpY2UoMCwgZ3JvdXBzUmVjb3Jkcy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gZ3JvdXBpbmcuZ3JvdXBCeShkYXRhLCBzdGF0ZS5leHByZXNzaW9ucywgZ3JpZCwgZ3JvdXBzUmVjb3Jkcyk7XG4gICAgfVxuICAgIHB1YmxpYyBzdGF0aWMgcmVzdG9yZUdyb3Vwcyhncm91cERhdGE6IElHcm91cEJ5UmVzdWx0LCBzdGF0ZTogSUdyb3VwaW5nU3RhdGUpOiBhbnlbXSB7XG4gICAgICAgIGlmIChzdGF0ZS5leHByZXNzaW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBncm91cERhdGEuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZXN0b3JlR3JvdXBzSXRlcmF0aXZlKGdyb3VwRGF0YSwgc3RhdGUpO1xuICAgIH1cbiAgICBwcml2YXRlIHN0YXRpYyByZXN0b3JlR3JvdXBzSXRlcmF0aXZlKGdyb3VwRGF0YTogSUdyb3VwQnlSZXN1bHQsIHN0YXRlOiBJR3JvdXBpbmdTdGF0ZSk6IGFueVtdIHtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBncm91cERhdGEubWV0YWRhdGE7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdLCBhZGRlZCA9IFtdO1xuICAgICAgICBsZXQgY2hhaW46IGFueVtdO1xuICAgICAgICBsZXQgaSA9IDAsIGo7XG4gICAgICAgIGxldCBwb2ludGVyOiBJR3JvdXBCeVJlY29yZDtcbiAgICAgICAgbGV0IGV4cGFuZGVkOiBib29sZWFuO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbWV0YWRhdGEubGVuZ3RoOykge1xuICAgICAgICAgICAgY2hhaW4gPSBbbWV0YWRhdGFbaV1dO1xuICAgICAgICAgICAgcG9pbnRlciA9IG1ldGFkYXRhW2ldLmdyb3VwUGFyZW50O1xuICAgICAgICAgICAgLy8gYnJlYWsgb2ZmIGlmIHRoZSBwYXJlbnQgaXMgYWxyZWFkeSBhZGRlZFxuICAgICAgICAgICAgd2hpbGUgKHBvaW50ZXIgJiYgYWRkZWRbMF0gIT09IHBvaW50ZXIpIHtcbiAgICAgICAgICAgICAgICBjaGFpbi5wdXNoKHBvaW50ZXIpO1xuICAgICAgICAgICAgICAgIGlmIChhZGRlZFswXSAmJiBhZGRlZFswXS5sZXZlbCA9PT0gcG9pbnRlci5sZXZlbCkge1xuICAgICAgICAgICAgICAgICAgICBhZGRlZC5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb2ludGVyID0gcG9pbnRlci5ncm91cFBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoaiA9IGNoYWluLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hhaW5bal0pO1xuICAgICAgICAgICAgICAgIGFkZGVkLnVuc2hpZnQoY2hhaW5bal0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhpZXJhcmNoeSA9IHRoaXMuZ2V0SGllcmFyY2h5KGNoYWluW2pdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBleHBhbmRTdGF0ZTogSUdyb3VwQnlFeHBhbmRTdGF0ZSA9IHN0YXRlLmV4cGFuc2lvbi5maW5kKChzKSA9PlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzSGllcmFyY2h5TWF0Y2gocy5oaWVyYXJjaHkgfHwgW3sgZmllbGROYW1lOiBjaGFpbltqXS5leHByZXNzaW9uLmZpZWxkTmFtZSwgdmFsdWU6IGNoYWluW2pdLnZhbHVlIH1dLCBoaWVyYXJjaHkpKTtcbiAgICAgICAgICAgICAgICBleHBhbmRlZCA9IGV4cGFuZFN0YXRlID8gZXhwYW5kU3RhdGUuZXhwYW5kZWQgOiBzdGF0ZS5kZWZhdWx0RXhwYW5kZWQ7XG4gICAgICAgICAgICAgICAgaWYgKCFleHBhbmRlZCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZGRlZC5zaGlmdCgpO1xuICAgICAgICAgICAgaiA9IE1hdGgubWF4KGosIDApO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBjaGFpbltqXS5yZWNvcmRzLmZpbmRJbmRleChyID0+IHIgPT09IGdyb3VwRGF0YS5kYXRhW2ldKTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKG1ldGFkYXRhLmxlbmd0aCAtIGkgKyBzdGFydCwgY2hhaW5bal0ucmVjb3Jkcy5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKGV4cGFuZGVkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goLi4uY2hhaW5bal0ucmVjb3Jkcy5zbGljZShzdGFydCwgZW5kKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpICs9IGVuZCAtIHN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHB1YmxpYyBzdGF0aWMgcGFnZTxUPihkYXRhOiBUW10sIHN0YXRlOiBJUGFnaW5nU3RhdGUpOiBUW10ge1xuICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgY29uc3QgaW5kZXggPSBzdGF0ZS5pbmRleDtcbiAgICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICAgIGNvbnN0IHJlY29yZHNQZXJQYWdlID0gc3RhdGUucmVjb3Jkc1BlclBhZ2U7XG4gICAgICAgIHN0YXRlLm1ldGFkYXRhID0ge1xuICAgICAgICAgICAgY291bnRQYWdlczogMCxcbiAgICAgICAgICAgIGNvdW50UmVjb3JkczogZGF0YS5sZW5ndGgsXG4gICAgICAgICAgICBlcnJvcjogUGFnaW5nRXJyb3IuTm9uZVxuICAgICAgICB9O1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGlzTmFOKGluZGV4KSkge1xuICAgICAgICAgICAgc3RhdGUubWV0YWRhdGEuZXJyb3IgPSBQYWdpbmdFcnJvci5JbmNvcnJlY3RQYWdlSW5kZXg7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWNvcmRzUGVyUGFnZSA8PSAwIHx8IGlzTmFOKHJlY29yZHNQZXJQYWdlKSkge1xuICAgICAgICAgICAgc3RhdGUubWV0YWRhdGEuZXJyb3IgPSBQYWdpbmdFcnJvci5JbmNvcnJlY3RSZWNvcmRzUGVyUGFnZTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubWV0YWRhdGEuY291bnRQYWdlcyA9IE1hdGguY2VpbChsZW4gLyByZWNvcmRzUGVyUGFnZSk7XG4gICAgICAgIGlmICghbGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggPj0gc3RhdGUubWV0YWRhdGEuY291bnRQYWdlcykge1xuICAgICAgICAgICAgc3RhdGUubWV0YWRhdGEuZXJyb3IgPSBQYWdpbmdFcnJvci5JbmNvcnJlY3RQYWdlSW5kZXg7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhLnNsaWNlKGluZGV4ICogcmVjb3Jkc1BlclBhZ2UsIChpbmRleCArIDEpICogcmVjb3Jkc1BlclBhZ2UpO1xuICAgIH1cbiAgICBwdWJsaWMgc3RhdGljIGZpbHRlcjxUPihkYXRhOiBUW10sIHN0YXRlOiBJRmlsdGVyaW5nU3RhdGUpOiBUW10ge1xuICAgICAgICBpZiAoIXN0YXRlLnN0cmF0ZWd5KSB7XG4gICAgICAgICAgICBzdGF0ZS5zdHJhdGVneSA9IG5ldyBGaWx0ZXJpbmdTdHJhdGVneSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZS5zdHJhdGVneS5maWx0ZXIoZGF0YSwgc3RhdGUuZXhwcmVzc2lvbnNUcmVlKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIHRyZWVHcmlkRmlsdGVyKGRhdGE6IElUcmVlR3JpZFJlY29yZFtdLCBzdGF0ZTogSUZpbHRlcmluZ1N0YXRlKTogSVRyZWVHcmlkUmVjb3JkW10ge1xuICAgICAgICBpZiAoIXN0YXRlLnN0cmF0ZWd5KSB7XG4gICAgICAgICAgICBzdGF0ZS5zdHJhdGVneSA9IG5ldyBUcmVlR3JpZEZpbHRlcmluZ1N0cmF0ZWd5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlLnN0cmF0ZWd5LmZpbHRlcihkYXRhLCBzdGF0ZS5leHByZXNzaW9uc1RyZWUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0SGllcmFyY2h5KGdSb3c6IElHcm91cEJ5UmVjb3JkKTogQXJyYXk8SUdyb3VwQnlLZXk+IHtcbiAgICAgICAgY29uc3QgaGllcmFyY2h5OiBBcnJheTxJR3JvdXBCeUtleT4gPSBbXTtcbiAgICAgICAgaWYgKGdSb3cgIT09IHVuZGVmaW5lZCAmJiBnUm93LmV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgIGhpZXJhcmNoeS5wdXNoKHsgZmllbGROYW1lOiBnUm93LmV4cHJlc3Npb24uZmllbGROYW1lLCB2YWx1ZTogZ1Jvdy52YWx1ZSB9KTtcbiAgICAgICAgICAgIHdoaWxlIChnUm93Lmdyb3VwUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgZ1JvdyA9IGdSb3cuZ3JvdXBQYXJlbnQ7XG4gICAgICAgICAgICAgICAgaGllcmFyY2h5LnVuc2hpZnQoeyBmaWVsZE5hbWU6IGdSb3cuZXhwcmVzc2lvbi5maWVsZE5hbWUsIHZhbHVlOiBnUm93LnZhbHVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoaWVyYXJjaHk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBpc0hpZXJhcmNoeU1hdGNoKGgxOiBBcnJheTxJR3JvdXBCeUtleT4sIGgyOiBBcnJheTxJR3JvdXBCeUtleT4pOiBib29sZWFuIHtcbiAgICAgICAgaWYgKGgxLmxlbmd0aCAhPT0gaDIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGgxLmV2ZXJ5KChsZXZlbCwgaW5kZXgpOiBib29sZWFuID0+IHtcbiAgICAgICAgICAgIHJldHVybiBsZXZlbC5maWVsZE5hbWUgPT09IGgyW2luZGV4XS5maWVsZE5hbWUgJiYgbGV2ZWwudmFsdWUgPT09IGgyW2luZGV4XS52YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVyZ2VzIGFsbCBjaGFuZ2VzIGZyb20gcHJvdmlkZWQgdHJhbnNhY3Rpb25zIGludG8gcHJvdmlkZWQgZGF0YSBjb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIGRhdGEgQ29sbGVjdGlvbiB0byBtZXJnZVxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbnMgVHJhbnNhY3Rpb25zIHRvIG1lcmdlIGludG8gZGF0YVxuICAgICAqIEBwYXJhbSBwcmltYXJ5S2V5IFByaW1hcnkga2V5IG9mIHRoZSBjb2xsZWN0aW9uLCBpZiBhbnlcbiAgICAgKiBAcGFyYW0gZGVsZXRlUm93cyBTaG91bGQgZGVsZXRlIHJvd3Mgd2l0aCBERUxFVEUgdHJhbnNhY3Rpb24gdHlwZSBmcm9tIGRhdGFcbiAgICAgKiBAcmV0dXJucyBQcm92aWRlZCBkYXRhIGNvbGxlY3Rpb25zIHVwZGF0ZWQgd2l0aCBhbGwgcHJvdmlkZWQgdHJhbnNhY3Rpb25zXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBtZXJnZVRyYW5zYWN0aW9uczxUPihkYXRhOiBUW10sIHRyYW5zYWN0aW9uczogVHJhbnNhY3Rpb25bXSwgcHJpbWFyeUtleT86IGFueSwgZGVsZXRlUm93czogYm9vbGVhbiA9IGZhbHNlKTogVFtdIHtcbiAgICAgICAgZGF0YS5mb3JFYWNoKChpdGVtOiBhbnksIGluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJvd0lkID0gcHJpbWFyeUtleSA/IGl0ZW1bcHJpbWFyeUtleV0gOiBpdGVtO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbnMuZmluZCh0ID0+IHQuaWQgPT09IHJvd0lkKTtcbiAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbiAmJiB0cmFuc2FjdGlvbi50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuVVBEQVRFKSB7XG4gICAgICAgICAgICAgICAgZGF0YVtpbmRleF0gPSB0cmFuc2FjdGlvbi5uZXdWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGRlbGV0ZVJvd3MpIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIodCA9PiB0LnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5ERUxFVEUpXG4gICAgICAgICAgICAgICAgLmZvckVhY2godCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcHJpbWFyeUtleSA/IGRhdGEuZmluZEluZGV4KGQgPT4gZFtwcmltYXJ5S2V5XSA9PT0gdC5pZCkgOiBkYXRhLmZpbmRJbmRleChkID0+IGQgPT09IHQuaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoMCA8PSBpbmRleCAmJiBpbmRleCA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGEucHVzaCguLi50cmFuc2FjdGlvbnNcbiAgICAgICAgICAgIC5maWx0ZXIodCA9PiB0LnR5cGUgPT09IFRyYW5zYWN0aW9uVHlwZS5BREQpXG4gICAgICAgICAgICAubWFwKHQgPT4gdC5uZXdWYWx1ZSkpO1xuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1lcmdlcyBhbGwgY2hhbmdlcyBmcm9tIHByb3ZpZGVkIHRyYW5zYWN0aW9ucyBpbnRvIHByb3ZpZGVkIGhpZXJhcmNoaWNhbCBkYXRhIGNvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0gZGF0YSBDb2xsZWN0aW9uIHRvIG1lcmdlXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9ucyBUcmFuc2FjdGlvbnMgdG8gbWVyZ2UgaW50byBkYXRhXG4gICAgICogQHBhcmFtIGNoaWxkRGF0YUtleSBEYXRhIGtleSBvZiBjaGlsZCBjb2xsZWN0aW9uc1xuICAgICAqIEBwYXJhbSBwcmltYXJ5S2V5IFByaW1hcnkga2V5IG9mIHRoZSBjb2xsZWN0aW9uLCBpZiBhbnlcbiAgICAgKiBAcGFyYW0gZGVsZXRlUm93cyBTaG91bGQgZGVsZXRlIHJvd3Mgd2l0aCBERUxFVEUgdHJhbnNhY3Rpb24gdHlwZSBmcm9tIGRhdGFcbiAgICAgKiBAcmV0dXJucyBQcm92aWRlZCBkYXRhIGNvbGxlY3Rpb25zIHVwZGF0ZWQgd2l0aCBhbGwgcHJvdmlkZWQgdHJhbnNhY3Rpb25zXG4gICAgICovXG4gICAgcHVibGljIHN0YXRpYyBtZXJnZUhpZXJhcmNoaWNhbFRyYW5zYWN0aW9ucyhcbiAgICAgICAgZGF0YTogYW55W10sXG4gICAgICAgIHRyYW5zYWN0aW9uczogSGllcmFyY2hpY2FsVHJhbnNhY3Rpb25bXSxcbiAgICAgICAgY2hpbGREYXRhS2V5OiBhbnksXG4gICAgICAgIHByaW1hcnlLZXk/OiBhbnksXG4gICAgICAgIGRlbGV0ZVJvd3M6IGJvb2xlYW4gPSBmYWxzZSk6IGFueVtdIHtcblxuICAgICAgICBmb3IgKGNvbnN0IHRyYW5zYWN0aW9uIG9mIHRyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmZpbmRQYXJlbnRGcm9tUGF0aChkYXRhLCBwcmltYXJ5S2V5LCBjaGlsZERhdGFLZXksIHRyYW5zYWN0aW9uLnBhdGgpO1xuICAgICAgICAgICAgICAgIGxldCBjb2xsZWN0aW9uOiBhbnlbXSA9IHBhcmVudCA/IHBhcmVudFtjaGlsZERhdGFLZXldIDogZGF0YTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRyYW5zYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuQUREOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gIGlmIHRoZXJlIGlzIG5vIHBhcmVudCB0aGlzIGlzIEFERCByb3cgYXQgcm9vdCBsZXZlbFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudCAmJiAhcGFyZW50W2NoaWxkRGF0YUtleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRbY2hpbGREYXRhS2V5XSA9IGNvbGxlY3Rpb24gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24ucHVzaCh0cmFuc2FjdGlvbi5uZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuVVBEQVRFOlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlSW5kZXggPSBjb2xsZWN0aW9uLmZpbmRJbmRleCh4ID0+IHhbcHJpbWFyeUtleV0gPT09IHRyYW5zYWN0aW9uLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1cGRhdGVJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uW3VwZGF0ZUluZGV4XSA9IG1lcmdlT2JqZWN0cyhjbG9uZVZhbHVlKGNvbGxlY3Rpb25bdXBkYXRlSW5kZXhdKSwgdHJhbnNhY3Rpb24ubmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgVHJhbnNhY3Rpb25UeXBlLkRFTEVURTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWxldGVSb3dzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVsZXRlSW5kZXggPSBjb2xsZWN0aW9uLmZpbmRJbmRleChyID0+IHJbcHJpbWFyeUtleV0gPT09IHRyYW5zYWN0aW9uLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVsZXRlSW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24uc3BsaWNlKGRlbGV0ZUluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vICBpZiB0aGVyZSBpcyBubyBwYXRoIHRoaXMgaXMgQUREIHJvdyBpbiByb290LiBQdXNoIHRoZSBuZXdWYWx1ZSB0byBkYXRhXG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKHRyYW5zYWN0aW9uLm5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBmaW5kUGFyZW50RnJvbVBhdGgoZGF0YTogYW55W10sIHByaW1hcnlLZXk6IGFueSwgY2hpbGREYXRhS2V5OiBhbnksIHBhdGg6IGFueVtdKTogYW55IHtcbiAgICAgICAgbGV0IGNvbGxlY3Rpb246IGFueVtdID0gZGF0YTtcbiAgICAgICAgbGV0IHJlc3VsdDogYW55O1xuXG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgcGF0aCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gY29sbGVjdGlvbiAmJiBjb2xsZWN0aW9uLmZpbmQoeCA9PiB4W3ByaW1hcnlLZXldID09PSBpZCk7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb2xsZWN0aW9uID0gcmVzdWx0W2NoaWxkRGF0YUtleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbiJdfQ==