/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable, NgZone } from '@angular/core';
/**
 * @hidden
 */
export class IgxColumnResizingService {
    /**
     * @param {?} zone
     */
    constructor(zone) {
        this.zone = zone;
        /**
         * @hidden
         */
        this.resizeCursor = null;
        /**
         * @hidden
         */
        this.showResizer = false;
    }
    /**
     * @hidden
     * @return {?}
     */
    get resizerHeight() {
        /** @type {?} */
        let height = this.column.grid.getVisibleContentHeight();
        // Column height multiplier in case there are Column Layouts. The resizer height need to take into account rowStart.
        /** @type {?} */
        let columnHeightMultiplier = 1;
        if (this.column.parent && this.column.parent.columnLayout) {
            columnHeightMultiplier = this.column.grid.multiRowLayoutRowSize - this.column.rowStart + 1;
        }
        if (this.column.level !== 0) {
            height -= this.column.topLevelParent.headerGroup.height - this.column.headerGroup.height * columnHeightMultiplier;
        }
        return height;
    }
    /**
     * Returns the minimal possible width to which the column can be resized.
     * @return {?}
     */
    get restrictResizeMin() {
        /** @type {?} */
        const columnLayoutMultiplier = this.column.grid.hasColumnLayouts ? this.column.gridColumnSpan : 1;
        /** @type {?} */
        const actualMinWidth = parseFloat(this.column.minWidth);
        /** @type {?} */
        const defaultMinWidth = parseFloat(this.column.defaultMinWidth) * columnLayoutMultiplier;
        /** @type {?} */
        let minWidth = Number.isNaN(actualMinWidth) || actualMinWidth < defaultMinWidth ? defaultMinWidth : actualMinWidth;
        minWidth = minWidth < parseFloat(this.column.width) ? minWidth : parseFloat(this.column.width);
        return this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width - minWidth;
    }
    /**
     * Returns the maximal possible width to which the column can be resized.
     * @return {?}
     */
    get restrictResizeMax() {
        /** @type {?} */
        const actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        if (this.column.pinned) {
            /** @type {?} */
            const pinnedMaxWidth = this.pinnedMaxWidth =
                this.column.grid.calcPinnedContainerMaxWidth - this.column.grid.getPinnedWidth(true) + actualWidth;
            if (this.column.maxWidth && parseFloat(this.column.maxWidth) < pinnedMaxWidth) {
                this.pinnedMaxWidth = this.column.maxWidth;
                return parseFloat(this.column.maxWidth) - actualWidth;
            }
            else {
                return pinnedMaxWidth - actualWidth;
            }
        }
        else {
            if (this.column.maxWidth) {
                return parseFloat(this.column.maxWidth) - actualWidth;
            }
            else {
                return Number.MAX_SAFE_INTEGER;
            }
        }
    }
    /**
     * Autosizes the column to the longest currently visible cell value, including the header cell.
     * If the column has a predifined maxWidth and the autosized column width will become bigger than it,
     * then the column is sized to its maxWidth.
     * If the column is pinned and the autosized column width will cause the pinned area to become bigger
     * than the maximum allowed pinned area width (80% of the total grid width), autosizing will be deismissed.
     * @return {?}
     */
    autosizeColumnOnDblClick() {
        /** @type {?} */
        const currentColWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        /** @type {?} */
        const size = this.column.getLargestCellWidth();
        if (this.column.pinned) {
            /** @type {?} */
            const newPinnedWidth = this.column.grid.getPinnedWidth(true) - currentColWidth + parseFloat(size);
            if (newPinnedWidth <= this.column.grid.calcPinnedContainerMaxWidth) {
                this.column.width = size;
            }
        }
        else if (this.column.maxWidth && (parseFloat(size) > parseFloat(this.column.maxWidth))) {
            this.column.width = parseFloat(this.column.maxWidth) + 'px';
        }
        else if (parseFloat(size) < parseFloat(this.column.defaultMinWidth)) {
            this.column.width = this.column.defaultMinWidth + 'px';
        }
        else {
            this.column.width = size;
        }
        this.zone.run(() => { });
        this.column.grid.reflow();
        this.column.grid.onColumnResized.emit({
            column: this.column,
            prevWidth: currentColWidth.toString(),
            newWidth: this.column.width
        });
    }
    /**
     * Resizes the column regaridng to the column minWidth and maxWidth.
     * @param {?} event
     * @return {?}
     */
    resizeColumn(event) {
        this.showResizer = false;
        /** @type {?} */
        const diff = event.clientX - this.startResizePos;
        /** @type {?} */
        let currentColWidth = parseFloat(this.column.width);
        /** @type {?} */
        const actualWidth = this.column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        currentColWidth = Number.isNaN(currentColWidth) || (currentColWidth < actualWidth) ? actualWidth : currentColWidth;
        /** @type {?} */
        const colMinWidth = this.getColMinWidth(this.column);
        /** @type {?} */
        const colMaxWidth = this.getColMaxWidth(this.column);
        if (this.column.grid.hasColumnLayouts) {
            this.resizeColumnLayoutFor(this.column, diff);
        }
        else {
            if (currentColWidth + diff < colMinWidth) {
                this.column.width = colMinWidth + 'px';
            }
            else if (colMaxWidth && (currentColWidth + diff > colMaxWidth)) {
                this.column.width = colMaxWidth + 'px';
            }
            else {
                this.column.width = (currentColWidth + diff) + 'px';
            }
        }
        this.zone.run(() => { });
        this.column.grid.reflow();
        if (currentColWidth !== parseFloat(this.column.width)) {
            this.column.grid.onColumnResized.emit({
                column: this.column,
                prevWidth: currentColWidth.toString(),
                newWidth: this.column.width
            });
        }
        this.isColumnResizing = false;
    }
    /**
     * @protected
     * @param {?} column
     * @return {?}
     */
    getColMinWidth(column) {
        /** @type {?} */
        let currentColWidth = parseFloat(column.width);
        /** @type {?} */
        const actualWidth = column.headerCell.elementRef.nativeElement.getBoundingClientRect().width;
        currentColWidth = Number.isNaN(currentColWidth) || (currentColWidth < actualWidth) ? actualWidth : currentColWidth;
        /** @type {?} */
        const columnLayoutMultiplier = column.grid.hasColumnLayouts ? column.gridColumnSpan : 1;
        /** @type {?} */
        const actualMinWidth = parseFloat(column.minWidth);
        /** @type {?} */
        const defaultMinWidth = parseFloat(column.defaultMinWidth) * columnLayoutMultiplier;
        /** @type {?} */
        const colMinWidth = Number.isNaN(actualMinWidth) || actualMinWidth < defaultMinWidth ? defaultMinWidth : actualMinWidth;
        return colMinWidth < currentColWidth ? colMinWidth : currentColWidth;
    }
    /**
     * @protected
     * @param {?} column
     * @return {?}
     */
    getColMaxWidth(column) {
        return column.pinned ? parseFloat(this.pinnedMaxWidth) : parseFloat(column.maxWidth);
    }
    /**
     * @protected
     * @param {?} column
     * @param {?} diff
     * @return {?}
     */
    resizeColumnLayoutFor(column, diff) {
        /** @type {?} */
        const relativeColumns = column.getResizableColUnderEnd();
        /** @type {?} */
        const combinedSpan = relativeColumns.reduce((acc, col) => acc + col.spanUsed, 0);
        if (column.pinned) {
            /** @type {?} */
            const pinnedWidth = this.column.grid.getPinnedWidth(true);
            /** @type {?} */
            const maxPinnedWidth = this.column.grid.calcPinnedContainerMaxWidth;
            if (pinnedWidth + diff > maxPinnedWidth) {
                diff = maxPinnedWidth - pinnedWidth;
            }
        }
        // Resize first those who might reach min/max width
        /** @type {?} */
        let columnsToResize = [...relativeColumns];
        /** @type {?} */
        let updatedDiff = diff;
        /** @type {?} */
        let updatedCombinedSpan = combinedSpan;
        /** @type {?} */
        let setMinMaxCols = false;
        do {
            // Cycle them until there are not ones that reach min/max size, because the diff accumulates after each cycle.
            // This is because we can have at first 2 cols reaching min width and then after
            // recalculating the diff there might be 1 more that reaches min width.
            setMinMaxCols = false;
            /** @type {?} */
            let newCombinedSpan = updatedCombinedSpan;
            /** @type {?} */
            const newColsToResize = [];
            columnsToResize.forEach((col) => {
                /** @type {?} */
                const currentResizeWidth = parseFloat(col.target.calcWidth);
                /** @type {?} */
                const resizeScaled = (diff / updatedCombinedSpan) * col.target.gridColumnSpan;
                /** @type {?} */
                const minWidth = this.getColMinWidth(col.target);
                /** @type {?} */
                const maxWidth = this.getColMaxWidth(col.target);
                if (currentResizeWidth + resizeScaled < minWidth) {
                    col.target.width = minWidth + 'px';
                    updatedDiff += (currentResizeWidth - minWidth);
                    newCombinedSpan -= col.spanUsed;
                    setMinMaxCols = true;
                }
                else if (maxWidth && (currentResizeWidth + resizeScaled > maxWidth)) {
                    col.target.width = maxWidth + 'px';
                    updatedDiff -= (maxWidth - currentResizeWidth);
                    newCombinedSpan -= col.spanUsed;
                    setMinMaxCols = true;
                }
                else {
                    // Save new ones that can be resized
                    newColsToResize.push(col);
                }
            });
            updatedCombinedSpan = newCombinedSpan;
            columnsToResize = newColsToResize;
        } while (setMinMaxCols);
        // Those left that don't reach min/max size resize them normally.
        columnsToResize.forEach((col) => {
            /** @type {?} */
            const currentResizeWidth = parseFloat(col.target.calcWidth);
            /** @type {?} */
            const resizeScaled = (updatedDiff / updatedCombinedSpan) * col.target.gridColumnSpan;
            col.target.width = (currentResizeWidth + resizeScaled) + 'px';
        });
    }
}
IgxColumnResizingService.decorators = [
    { type: Injectable }
];
/** @nocollapse */
IgxColumnResizingService.ctorParameters = () => [
    { type: NgZone }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    IgxColumnResizingService.prototype.pinnedMaxWidth;
    /**
     * @hidden
     * @type {?}
     */
    IgxColumnResizingService.prototype.startResizePos;
    /**
     * Indicates that a column is currently being resized.
     * @type {?}
     */
    IgxColumnResizingService.prototype.isColumnResizing;
    /**
     * @hidden
     * @type {?}
     */
    IgxColumnResizingService.prototype.resizeCursor;
    /**
     * @hidden
     * @type {?}
     */
    IgxColumnResizingService.prototype.showResizer;
    /**
     * The column being resized.
     * @type {?}
     */
    IgxColumnResizingService.prototype.column;
    /**
     * @type {?}
     * @private
     */
    IgxColumnResizingService.prototype.zone;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZC1jb2x1bW4tcmVzaXppbmcuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvZ3JpZHMvZ3JpZC1jb2x1bW4tcmVzaXppbmcuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7Ozs7QUFLbkQsTUFBTSxPQUFPLHdCQUF3Qjs7OztJQXlCakMsWUFBb0IsSUFBWTtRQUFaLFNBQUksR0FBSixJQUFJLENBQVE7Ozs7UUFWekIsaUJBQVksR0FBVyxJQUFJLENBQUM7Ozs7UUFJNUIsZ0JBQVcsR0FBRyxLQUFLLENBQUM7SUFNUyxDQUFDOzs7OztJQUtyQyxJQUFJLGFBQWE7O1lBQ1QsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLHVCQUF1QixFQUFFOzs7WUFHbkQsc0JBQXNCLEdBQUcsQ0FBQztRQUM5QixJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLFlBQVksRUFBRTtZQUN2RCxzQkFBc0IsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxxQkFBcUIsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUM7U0FDOUY7UUFFRCxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxLQUFLLENBQUMsRUFBRTtZQUN6QixNQUFNLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsV0FBVyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEdBQUcsc0JBQXNCLENBQUM7U0FDckg7UUFFRCxPQUFPLE1BQU0sQ0FBQztJQUNsQixDQUFDOzs7OztJQUtELElBQUksaUJBQWlCOztjQUNYLHNCQUFzQixHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7Y0FDM0YsY0FBYyxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQzs7Y0FDakQsZUFBZSxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQyxHQUFHLHNCQUFzQjs7WUFFcEYsUUFBUSxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLElBQUksY0FBYyxHQUFHLGVBQWUsQ0FBQyxDQUFDLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxjQUFjO1FBQ2xILFFBQVEsR0FBRyxRQUFRLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFL0YsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLHFCQUFxQixFQUFFLENBQUMsS0FBSyxHQUFHLFFBQVEsQ0FBQztJQUNwRyxDQUFDOzs7OztJQUtELElBQUksaUJBQWlCOztjQUNYLFdBQVcsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLHFCQUFxQixFQUFFLENBQUMsS0FBSztRQUVqRyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFOztrQkFDZCxjQUFjLEdBQUcsSUFBSSxDQUFDLGNBQWM7Z0JBQ3RDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLDJCQUEyQixHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsR0FBRyxXQUFXO1lBRXRHLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLElBQUksVUFBVSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEdBQUcsY0FBYyxFQUFFO2dCQUMzRSxJQUFJLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDO2dCQUUzQyxPQUFPLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLFdBQVcsQ0FBQzthQUN6RDtpQkFBTTtnQkFDSCxPQUFPLGNBQWMsR0FBRyxXQUFXLENBQUM7YUFDdkM7U0FDSjthQUFNO1lBQ0gsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRTtnQkFDdEIsT0FBTyxVQUFVLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxXQUFXLENBQUM7YUFDekQ7aUJBQU07Z0JBQ0gsT0FBTyxNQUFNLENBQUMsZ0JBQWdCLENBQUM7YUFDbEM7U0FDSjtJQUNMLENBQUM7Ozs7Ozs7OztJQVNNLHdCQUF3Qjs7Y0FDckIsZUFBZSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMscUJBQXFCLEVBQUUsQ0FBQyxLQUFLOztjQUUvRixJQUFJLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxtQkFBbUIsRUFBRTtRQUU5QyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFOztrQkFDZCxjQUFjLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxHQUFHLGVBQWUsR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDO1lBRWpHLElBQUksY0FBYyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLDJCQUEyQixFQUFFO2dCQUNoRSxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7YUFDNUI7U0FDSjthQUFNLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRTtZQUN0RixJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxJQUFJLENBQUM7U0FDL0Q7YUFBTSxJQUFJLFVBQVUsQ0FBQyxJQUFJLENBQUMsR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxlQUFlLENBQUMsRUFBRTtZQUNuRSxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUM7U0FDMUQ7YUFBTTtZQUNILElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztTQUM1QjtRQUVELElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFFLENBQUMsQ0FBQyxDQUFDO1FBRXhCLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQzFCLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUM7WUFDbEMsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNO1lBQ25CLFNBQVMsRUFBRSxlQUFlLENBQUMsUUFBUSxFQUFFO1lBQ3JDLFFBQVEsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUs7U0FDOUIsQ0FBQyxDQUFDO0lBQ1AsQ0FBQzs7Ozs7O0lBS00sWUFBWSxDQUFDLEtBQWlCO1FBQ2pDLElBQUksQ0FBQyxXQUFXLEdBQUcsS0FBSyxDQUFDOztjQUNuQixJQUFJLEdBQUcsS0FBSyxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsY0FBYzs7WUFFNUMsZUFBZSxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQzs7Y0FDN0MsV0FBVyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUMscUJBQXFCLEVBQUUsQ0FBQyxLQUFLO1FBQ2pHLGVBQWUsR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsZUFBZSxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQzs7Y0FFN0csV0FBVyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQzs7Y0FDOUMsV0FBVyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUNwRCxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGdCQUFnQixFQUFFO1lBQ25DLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDO1NBQ2pEO2FBQU07WUFDSCxJQUFJLGVBQWUsR0FBRyxJQUFJLEdBQUcsV0FBVyxFQUFFO2dCQUN0QyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssR0FBRyxXQUFXLEdBQUcsSUFBSSxDQUFDO2FBQzFDO2lCQUFNLElBQUksV0FBVyxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksR0FBRyxXQUFXLENBQUMsRUFBRTtnQkFDOUQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEdBQUcsV0FBVyxHQUFHLElBQUksQ0FBQzthQUMxQztpQkFBTTtnQkFDSCxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssR0FBRyxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUM7YUFDdkQ7U0FDSjtRQUVELElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxHQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3hCLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBRTFCLElBQUksZUFBZSxLQUFLLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ25ELElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUM7Z0JBQ2xDLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTTtnQkFDbkIsU0FBUyxFQUFFLGVBQWUsQ0FBQyxRQUFRLEVBQUU7Z0JBQ3JDLFFBQVEsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUs7YUFDOUIsQ0FBQyxDQUFDO1NBQ047UUFFRCxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsS0FBSyxDQUFDO0lBQ2xDLENBQUM7Ozs7OztJQUVTLGNBQWMsQ0FBQyxNQUEwQjs7WUFDM0MsZUFBZSxHQUFHLFVBQVUsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDOztjQUN4QyxXQUFXLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLHFCQUFxQixFQUFFLENBQUMsS0FBSztRQUM1RixlQUFlLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxlQUFlLENBQUMsSUFBSSxDQUFDLGVBQWUsR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxlQUFlLENBQUM7O2NBRTdHLHNCQUFzQixHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLENBQUM7O2NBQ2pGLGNBQWMsR0FBRyxVQUFVLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQzs7Y0FDNUMsZUFBZSxHQUFHLFVBQVUsQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLEdBQUcsc0JBQXNCOztjQUM3RSxXQUFXLEdBQUcsTUFBTSxDQUFDLEtBQUssQ0FBQyxjQUFjLENBQUMsSUFBSSxjQUFjLEdBQUcsZUFBZSxDQUFDLENBQUMsQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLGNBQWM7UUFDdkgsT0FBTyxXQUFXLEdBQUcsZUFBZSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQztJQUN6RSxDQUFDOzs7Ozs7SUFFUyxjQUFjLENBQUMsTUFBMEI7UUFDL0MsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3pGLENBQUM7Ozs7Ozs7SUFFUyxxQkFBcUIsQ0FBQyxNQUEwQixFQUFFLElBQVk7O2NBQzlELGVBQWUsR0FBRyxNQUFNLENBQUMsdUJBQXVCLEVBQUU7O2NBQ2xELFlBQVksR0FBRyxlQUFlLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLEdBQUcsRUFBRSxFQUFFLENBQUUsR0FBRyxHQUFHLEdBQUcsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO1FBRWpGLElBQUksTUFBTSxDQUFDLE1BQU0sRUFBRTs7a0JBQ1QsV0FBVyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUM7O2tCQUNuRCxjQUFjLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsMkJBQTJCO1lBRW5FLElBQUksV0FBVyxHQUFHLElBQUksR0FBRyxjQUFjLEVBQUU7Z0JBQ3JDLElBQUksR0FBRyxjQUFjLEdBQUcsV0FBVyxDQUFDO2FBQ3ZDO1NBQ0o7OztZQUdHLGVBQWUsR0FBRyxDQUFDLEdBQUcsZUFBZSxDQUFDOztZQUN0QyxXQUFXLEdBQUcsSUFBSTs7WUFDbEIsbUJBQW1CLEdBQUcsWUFBWTs7WUFDbEMsYUFBYSxHQUFHLEtBQUs7UUFDekIsR0FBRztZQUNDLDhHQUE4RztZQUM5RyxnRkFBZ0Y7WUFDaEYsdUVBQXVFO1lBQ3ZFLGFBQWEsR0FBRyxLQUFLLENBQUM7O2dCQUNsQixlQUFlLEdBQUcsbUJBQW1COztrQkFDbkMsZUFBZSxHQUFHLEVBQUU7WUFDMUIsZUFBZSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFOztzQkFDdEIsa0JBQWtCLEdBQUcsVUFBVSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDOztzQkFDckQsWUFBWSxHQUFHLENBQUMsSUFBSSxHQUFHLG1CQUFtQixDQUFDLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxjQUFjOztzQkFFdkUsUUFBUSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQzs7c0JBQzFDLFFBQVEsR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUM7Z0JBQ2hELElBQUksa0JBQWtCLEdBQUcsWUFBWSxHQUFHLFFBQVEsRUFBRTtvQkFDOUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEdBQUcsUUFBUSxHQUFHLElBQUksQ0FBQztvQkFDbkMsV0FBVyxJQUFJLENBQUMsa0JBQWtCLEdBQUcsUUFBUSxDQUFDLENBQUM7b0JBQy9DLGVBQWUsSUFBSSxHQUFHLENBQUMsUUFBUSxDQUFDO29CQUNoQyxhQUFhLEdBQUcsSUFBSSxDQUFDO2lCQUN4QjtxQkFBTSxJQUFJLFFBQVEsSUFBSSxDQUFDLGtCQUFrQixHQUFHLFlBQVksR0FBRyxRQUFRLENBQUMsRUFBRTtvQkFDbkUsR0FBRyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEdBQUcsUUFBUSxHQUFHLElBQUksQ0FBQztvQkFDbkMsV0FBVyxJQUFJLENBQUMsUUFBUSxHQUFHLGtCQUFrQixDQUFDLENBQUM7b0JBQy9DLGVBQWUsSUFBSSxHQUFHLENBQUMsUUFBUSxDQUFDO29CQUNoQyxhQUFhLEdBQUcsSUFBSSxDQUFDO2lCQUN4QjtxQkFBTTtvQkFDSCxvQ0FBb0M7b0JBQ3BDLGVBQWUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7aUJBQzdCO1lBQ0wsQ0FBQyxDQUFDLENBQUM7WUFFSCxtQkFBbUIsR0FBRyxlQUFlLENBQUM7WUFDdEMsZUFBZSxHQUFHLGVBQWUsQ0FBQztTQUNyQyxRQUFRLGFBQWEsRUFBRTtRQUV4QixpRUFBaUU7UUFDakUsZUFBZSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFOztrQkFDdEIsa0JBQWtCLEdBQUcsVUFBVSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDOztrQkFDckQsWUFBWSxHQUFHLENBQUMsV0FBVyxHQUFHLG1CQUFtQixDQUFDLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxjQUFjO1lBQ3BGLEdBQUcsQ0FBQyxNQUFNLENBQUMsS0FBSyxHQUFHLENBQUMsa0JBQWtCLEdBQUcsWUFBWSxDQUFDLEdBQUcsSUFBSSxDQUFDO1FBQ2xFLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQzs7O1lBM09KLFVBQVU7Ozs7WUFKVSxNQUFNOzs7Ozs7O0lBT3ZCLGtEQUErQjs7Ozs7SUFLL0Isa0RBQThCOzs7OztJQUk5QixvREFBaUM7Ozs7O0lBSWpDLGdEQUFtQzs7Ozs7SUFJbkMsK0NBQTJCOzs7OztJQUkzQiwwQ0FBa0M7Ozs7O0lBRXRCLHdDQUFvQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIE5nWm9uZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSWd4Q29sdW1uQ29tcG9uZW50IH0gZnJvbSAnLi9jb2x1bW4uY29tcG9uZW50JztcblxuLyoqIEBoaWRkZW4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBJZ3hDb2x1bW5SZXNpemluZ1NlcnZpY2Uge1xuXG4gICAgcHJpdmF0ZSBwaW5uZWRNYXhXaWR0aDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHN0YXJ0UmVzaXplUG9zOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgYSBjb2x1bW4gaXMgY3VycmVudGx5IGJlaW5nIHJlc2l6ZWQuXG4gICAgICovXG4gICAgcHVibGljIGlzQ29sdW1uUmVzaXppbmc6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHJlc2l6ZUN1cnNvcjogc3RyaW5nID0gbnVsbDtcbiAgICAvKipcbiAgICAgKkBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgc2hvd1Jlc2l6ZXIgPSBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBUaGUgY29sdW1uIGJlaW5nIHJlc2l6ZWQuXG4gICAgICovXG4gICAgcHVibGljIGNvbHVtbjogSWd4Q29sdW1uQ29tcG9uZW50O1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSB6b25lOiBOZ1pvbmUpIHsgfVxuXG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHJlc2l6ZXJIZWlnaHQoKTogbnVtYmVyIHtcbiAgICAgICAgbGV0IGhlaWdodCA9IHRoaXMuY29sdW1uLmdyaWQuZ2V0VmlzaWJsZUNvbnRlbnRIZWlnaHQoKTtcblxuICAgICAgICAvLyBDb2x1bW4gaGVpZ2h0IG11bHRpcGxpZXIgaW4gY2FzZSB0aGVyZSBhcmUgQ29sdW1uIExheW91dHMuIFRoZSByZXNpemVyIGhlaWdodCBuZWVkIHRvIHRha2UgaW50byBhY2NvdW50IHJvd1N0YXJ0LlxuICAgICAgICBsZXQgY29sdW1uSGVpZ2h0TXVsdGlwbGllciA9IDE7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbi5wYXJlbnQgJiYgdGhpcy5jb2x1bW4ucGFyZW50LmNvbHVtbkxheW91dCkge1xuICAgICAgICAgICAgY29sdW1uSGVpZ2h0TXVsdGlwbGllciA9IHRoaXMuY29sdW1uLmdyaWQubXVsdGlSb3dMYXlvdXRSb3dTaXplIC0gdGhpcy5jb2x1bW4ucm93U3RhcnQgKyAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY29sdW1uLmxldmVsICE9PSAwKSB7XG4gICAgICAgICAgICBoZWlnaHQgLT0gdGhpcy5jb2x1bW4udG9wTGV2ZWxQYXJlbnQuaGVhZGVyR3JvdXAuaGVpZ2h0IC0gdGhpcy5jb2x1bW4uaGVhZGVyR3JvdXAuaGVpZ2h0ICogY29sdW1uSGVpZ2h0TXVsdGlwbGllcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoZWlnaHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWluaW1hbCBwb3NzaWJsZSB3aWR0aCB0byB3aGljaCB0aGUgY29sdW1uIGNhbiBiZSByZXNpemVkLlxuICAgICAqL1xuICAgIGdldCByZXN0cmljdFJlc2l6ZU1pbigpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBjb2x1bW5MYXlvdXRNdWx0aXBsaWVyID0gdGhpcy5jb2x1bW4uZ3JpZC5oYXNDb2x1bW5MYXlvdXRzID8gdGhpcy5jb2x1bW4uZ3JpZENvbHVtblNwYW4gOiAxO1xuICAgICAgICBjb25zdCBhY3R1YWxNaW5XaWR0aCA9IHBhcnNlRmxvYXQodGhpcy5jb2x1bW4ubWluV2lkdGgpO1xuICAgICAgICBjb25zdCBkZWZhdWx0TWluV2lkdGggPSBwYXJzZUZsb2F0KHRoaXMuY29sdW1uLmRlZmF1bHRNaW5XaWR0aCkgKiBjb2x1bW5MYXlvdXRNdWx0aXBsaWVyO1xuXG4gICAgICAgIGxldCBtaW5XaWR0aCA9IE51bWJlci5pc05hTihhY3R1YWxNaW5XaWR0aCkgfHwgYWN0dWFsTWluV2lkdGggPCBkZWZhdWx0TWluV2lkdGggPyBkZWZhdWx0TWluV2lkdGggOiBhY3R1YWxNaW5XaWR0aDtcbiAgICAgICAgbWluV2lkdGggPSBtaW5XaWR0aCA8IHBhcnNlRmxvYXQodGhpcy5jb2x1bW4ud2lkdGgpID8gbWluV2lkdGggOiBwYXJzZUZsb2F0KHRoaXMuY29sdW1uLndpZHRoKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW4uaGVhZGVyQ2VsbC5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLSBtaW5XaWR0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXhpbWFsIHBvc3NpYmxlIHdpZHRoIHRvIHdoaWNoIHRoZSBjb2x1bW4gY2FuIGJlIHJlc2l6ZWQuXG4gICAgICovXG4gICAgZ2V0IHJlc3RyaWN0UmVzaXplTWF4KCk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IGFjdHVhbFdpZHRoID0gdGhpcy5jb2x1bW4uaGVhZGVyQ2VsbC5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG5cbiAgICAgICAgaWYgKHRoaXMuY29sdW1uLnBpbm5lZCkge1xuICAgICAgICAgICAgY29uc3QgcGlubmVkTWF4V2lkdGggPSB0aGlzLnBpbm5lZE1heFdpZHRoID1cbiAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbi5ncmlkLmNhbGNQaW5uZWRDb250YWluZXJNYXhXaWR0aCAtIHRoaXMuY29sdW1uLmdyaWQuZ2V0UGlubmVkV2lkdGgodHJ1ZSkgKyBhY3R1YWxXaWR0aDtcblxuICAgICAgICAgICAgaWYgKHRoaXMuY29sdW1uLm1heFdpZHRoICYmIHBhcnNlRmxvYXQodGhpcy5jb2x1bW4ubWF4V2lkdGgpIDwgcGlubmVkTWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBpbm5lZE1heFdpZHRoID0gdGhpcy5jb2x1bW4ubWF4V2lkdGg7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLmNvbHVtbi5tYXhXaWR0aCkgLSBhY3R1YWxXaWR0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBpbm5lZE1heFdpZHRoIC0gYWN0dWFsV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb2x1bW4ubWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLmNvbHVtbi5tYXhXaWR0aCkgLSBhY3R1YWxXaWR0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXV0b3NpemVzIHRoZSBjb2x1bW4gdG8gdGhlIGxvbmdlc3QgY3VycmVudGx5IHZpc2libGUgY2VsbCB2YWx1ZSwgaW5jbHVkaW5nIHRoZSBoZWFkZXIgY2VsbC5cbiAgICAgKiBJZiB0aGUgY29sdW1uIGhhcyBhIHByZWRpZmluZWQgbWF4V2lkdGggYW5kIHRoZSBhdXRvc2l6ZWQgY29sdW1uIHdpZHRoIHdpbGwgYmVjb21lIGJpZ2dlciB0aGFuIGl0LFxuICAgICAqIHRoZW4gdGhlIGNvbHVtbiBpcyBzaXplZCB0byBpdHMgbWF4V2lkdGguXG4gICAgICogSWYgdGhlIGNvbHVtbiBpcyBwaW5uZWQgYW5kIHRoZSBhdXRvc2l6ZWQgY29sdW1uIHdpZHRoIHdpbGwgY2F1c2UgdGhlIHBpbm5lZCBhcmVhIHRvIGJlY29tZSBiaWdnZXJcbiAgICAgKiB0aGFuIHRoZSBtYXhpbXVtIGFsbG93ZWQgcGlubmVkIGFyZWEgd2lkdGggKDgwJSBvZiB0aGUgdG90YWwgZ3JpZCB3aWR0aCksIGF1dG9zaXppbmcgd2lsbCBiZSBkZWlzbWlzc2VkLlxuICAgICAqL1xuICAgIHB1YmxpYyBhdXRvc2l6ZUNvbHVtbk9uRGJsQ2xpY2soKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDb2xXaWR0aCA9IHRoaXMuY29sdW1uLmhlYWRlckNlbGwuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuXG4gICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLmNvbHVtbi5nZXRMYXJnZXN0Q2VsbFdpZHRoKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuY29sdW1uLnBpbm5lZCkge1xuICAgICAgICAgICAgY29uc3QgbmV3UGlubmVkV2lkdGggPSB0aGlzLmNvbHVtbi5ncmlkLmdldFBpbm5lZFdpZHRoKHRydWUpIC0gY3VycmVudENvbFdpZHRoICsgcGFyc2VGbG9hdChzaXplKTtcblxuICAgICAgICAgICAgaWYgKG5ld1Bpbm5lZFdpZHRoIDw9IHRoaXMuY29sdW1uLmdyaWQuY2FsY1Bpbm5lZENvbnRhaW5lck1heFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2x1bW4ud2lkdGggPSBzaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY29sdW1uLm1heFdpZHRoICYmIChwYXJzZUZsb2F0KHNpemUpID4gcGFyc2VGbG9hdCh0aGlzLmNvbHVtbi5tYXhXaWR0aCkpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbi53aWR0aCA9IHBhcnNlRmxvYXQodGhpcy5jb2x1bW4ubWF4V2lkdGgpICsgJ3B4JztcbiAgICAgICAgfSBlbHNlIGlmIChwYXJzZUZsb2F0KHNpemUpIDwgcGFyc2VGbG9hdCh0aGlzLmNvbHVtbi5kZWZhdWx0TWluV2lkdGgpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbi53aWR0aCA9IHRoaXMuY29sdW1uLmRlZmF1bHRNaW5XaWR0aCArICdweCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbi53aWR0aCA9IHNpemU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHt9KTtcblxuICAgICAgICB0aGlzLmNvbHVtbi5ncmlkLnJlZmxvdygpO1xuICAgICAgICB0aGlzLmNvbHVtbi5ncmlkLm9uQ29sdW1uUmVzaXplZC5lbWl0KHtcbiAgICAgICAgICAgIGNvbHVtbjogdGhpcy5jb2x1bW4sXG4gICAgICAgICAgICBwcmV2V2lkdGg6IGN1cnJlbnRDb2xXaWR0aC50b1N0cmluZygpLFxuICAgICAgICAgICAgbmV3V2lkdGg6IHRoaXMuY29sdW1uLndpZHRoXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZXMgdGhlIGNvbHVtbiByZWdhcmlkbmcgdG8gdGhlIGNvbHVtbiBtaW5XaWR0aCBhbmQgbWF4V2lkdGguXG4gICAgICovXG4gICAgcHVibGljIHJlc2l6ZUNvbHVtbihldmVudDogTW91c2VFdmVudCkge1xuICAgICAgICB0aGlzLnNob3dSZXNpemVyID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGRpZmYgPSBldmVudC5jbGllbnRYIC0gdGhpcy5zdGFydFJlc2l6ZVBvcztcblxuICAgICAgICBsZXQgY3VycmVudENvbFdpZHRoID0gcGFyc2VGbG9hdCh0aGlzLmNvbHVtbi53aWR0aCk7XG4gICAgICAgIGNvbnN0IGFjdHVhbFdpZHRoID0gdGhpcy5jb2x1bW4uaGVhZGVyQ2VsbC5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgICAgIGN1cnJlbnRDb2xXaWR0aCA9IE51bWJlci5pc05hTihjdXJyZW50Q29sV2lkdGgpIHx8IChjdXJyZW50Q29sV2lkdGggPCBhY3R1YWxXaWR0aCkgPyBhY3R1YWxXaWR0aCA6IGN1cnJlbnRDb2xXaWR0aDtcblxuICAgICAgICBjb25zdCBjb2xNaW5XaWR0aCA9IHRoaXMuZ2V0Q29sTWluV2lkdGgodGhpcy5jb2x1bW4pO1xuICAgICAgICBjb25zdCBjb2xNYXhXaWR0aCA9IHRoaXMuZ2V0Q29sTWF4V2lkdGgodGhpcy5jb2x1bW4pO1xuICAgICAgICBpZiAodGhpcy5jb2x1bW4uZ3JpZC5oYXNDb2x1bW5MYXlvdXRzKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZUNvbHVtbkxheW91dEZvcih0aGlzLmNvbHVtbiwgZGlmZik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudENvbFdpZHRoICsgZGlmZiA8IGNvbE1pbldpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2x1bW4ud2lkdGggPSBjb2xNaW5XaWR0aCArICdweCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbE1heFdpZHRoICYmIChjdXJyZW50Q29sV2lkdGggKyBkaWZmID4gY29sTWF4V2lkdGgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2x1bW4ud2lkdGggPSBjb2xNYXhXaWR0aCArICdweCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uLndpZHRoID0gKGN1cnJlbnRDb2xXaWR0aCArIGRpZmYpICsgJ3B4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge30pO1xuICAgICAgICB0aGlzLmNvbHVtbi5ncmlkLnJlZmxvdygpO1xuXG4gICAgICAgIGlmIChjdXJyZW50Q29sV2lkdGggIT09IHBhcnNlRmxvYXQodGhpcy5jb2x1bW4ud2lkdGgpKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbi5ncmlkLm9uQ29sdW1uUmVzaXplZC5lbWl0KHtcbiAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uLFxuICAgICAgICAgICAgICAgIHByZXZXaWR0aDogY3VycmVudENvbFdpZHRoLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgbmV3V2lkdGg6IHRoaXMuY29sdW1uLndpZHRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXNDb2x1bW5SZXNpemluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXRDb2xNaW5XaWR0aChjb2x1bW46IElneENvbHVtbkNvbXBvbmVudCkge1xuICAgICAgICBsZXQgY3VycmVudENvbFdpZHRoID0gcGFyc2VGbG9hdChjb2x1bW4ud2lkdGgpO1xuICAgICAgICBjb25zdCBhY3R1YWxXaWR0aCA9IGNvbHVtbi5oZWFkZXJDZWxsLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICAgICAgY3VycmVudENvbFdpZHRoID0gTnVtYmVyLmlzTmFOKGN1cnJlbnRDb2xXaWR0aCkgfHwgKGN1cnJlbnRDb2xXaWR0aCA8IGFjdHVhbFdpZHRoKSA/IGFjdHVhbFdpZHRoIDogY3VycmVudENvbFdpZHRoO1xuXG4gICAgICAgIGNvbnN0IGNvbHVtbkxheW91dE11bHRpcGxpZXIgPSBjb2x1bW4uZ3JpZC5oYXNDb2x1bW5MYXlvdXRzID8gY29sdW1uLmdyaWRDb2x1bW5TcGFuIDogMTtcbiAgICAgICAgY29uc3QgYWN0dWFsTWluV2lkdGggPSBwYXJzZUZsb2F0KGNvbHVtbi5taW5XaWR0aCk7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRNaW5XaWR0aCA9IHBhcnNlRmxvYXQoY29sdW1uLmRlZmF1bHRNaW5XaWR0aCkgKiBjb2x1bW5MYXlvdXRNdWx0aXBsaWVyO1xuICAgICAgICBjb25zdCBjb2xNaW5XaWR0aCA9IE51bWJlci5pc05hTihhY3R1YWxNaW5XaWR0aCkgfHwgYWN0dWFsTWluV2lkdGggPCBkZWZhdWx0TWluV2lkdGggPyBkZWZhdWx0TWluV2lkdGggOiBhY3R1YWxNaW5XaWR0aDtcbiAgICAgICAgcmV0dXJuIGNvbE1pbldpZHRoIDwgY3VycmVudENvbFdpZHRoID8gY29sTWluV2lkdGggOiBjdXJyZW50Q29sV2lkdGg7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldENvbE1heFdpZHRoKGNvbHVtbjogSWd4Q29sdW1uQ29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiBjb2x1bW4ucGlubmVkID8gcGFyc2VGbG9hdCh0aGlzLnBpbm5lZE1heFdpZHRoKSA6IHBhcnNlRmxvYXQoY29sdW1uLm1heFdpZHRoKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgcmVzaXplQ29sdW1uTGF5b3V0Rm9yKGNvbHVtbjogSWd4Q29sdW1uQ29tcG9uZW50LCBkaWZmOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgcmVsYXRpdmVDb2x1bW5zID0gY29sdW1uLmdldFJlc2l6YWJsZUNvbFVuZGVyRW5kKCk7XG4gICAgICAgIGNvbnN0IGNvbWJpbmVkU3BhbiA9IHJlbGF0aXZlQ29sdW1ucy5yZWR1Y2UoKGFjYywgY29sKSA9PiAgYWNjICsgY29sLnNwYW5Vc2VkLCAwKTtcblxuICAgICAgICBpZiAoY29sdW1uLnBpbm5lZCkge1xuICAgICAgICAgICAgY29uc3QgcGlubmVkV2lkdGggPSB0aGlzLmNvbHVtbi5ncmlkLmdldFBpbm5lZFdpZHRoKHRydWUpO1xuICAgICAgICAgICAgY29uc3QgbWF4UGlubmVkV2lkdGggPSB0aGlzLmNvbHVtbi5ncmlkLmNhbGNQaW5uZWRDb250YWluZXJNYXhXaWR0aDtcblxuICAgICAgICAgICAgaWYgKHBpbm5lZFdpZHRoICsgZGlmZiA+IG1heFBpbm5lZFdpZHRoKSB7XG4gICAgICAgICAgICAgICAgZGlmZiA9IG1heFBpbm5lZFdpZHRoIC0gcGlubmVkV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXNpemUgZmlyc3QgdGhvc2Ugd2hvIG1pZ2h0IHJlYWNoIG1pbi9tYXggd2lkdGhcbiAgICAgICAgbGV0IGNvbHVtbnNUb1Jlc2l6ZSA9IFsuLi5yZWxhdGl2ZUNvbHVtbnNdO1xuICAgICAgICBsZXQgdXBkYXRlZERpZmYgPSBkaWZmO1xuICAgICAgICBsZXQgdXBkYXRlZENvbWJpbmVkU3BhbiA9IGNvbWJpbmVkU3BhbjtcbiAgICAgICAgbGV0IHNldE1pbk1heENvbHMgPSBmYWxzZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgLy8gQ3ljbGUgdGhlbSB1bnRpbCB0aGVyZSBhcmUgbm90IG9uZXMgdGhhdCByZWFjaCBtaW4vbWF4IHNpemUsIGJlY2F1c2UgdGhlIGRpZmYgYWNjdW11bGF0ZXMgYWZ0ZXIgZWFjaCBjeWNsZS5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB3ZSBjYW4gaGF2ZSBhdCBmaXJzdCAyIGNvbHMgcmVhY2hpbmcgbWluIHdpZHRoIGFuZCB0aGVuIGFmdGVyXG4gICAgICAgICAgICAvLyByZWNhbGN1bGF0aW5nIHRoZSBkaWZmIHRoZXJlIG1pZ2h0IGJlIDEgbW9yZSB0aGF0IHJlYWNoZXMgbWluIHdpZHRoLlxuICAgICAgICAgICAgc2V0TWluTWF4Q29scyA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IG5ld0NvbWJpbmVkU3BhbiA9IHVwZGF0ZWRDb21iaW5lZFNwYW47XG4gICAgICAgICAgICBjb25zdCBuZXdDb2xzVG9SZXNpemUgPSBbXTtcbiAgICAgICAgICAgIGNvbHVtbnNUb1Jlc2l6ZS5mb3JFYWNoKChjb2wpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50UmVzaXplV2lkdGggPSBwYXJzZUZsb2F0KGNvbC50YXJnZXQuY2FsY1dpZHRoKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNpemVTY2FsZWQgPSAoZGlmZiAvIHVwZGF0ZWRDb21iaW5lZFNwYW4pICogY29sLnRhcmdldC5ncmlkQ29sdW1uU3BhbjtcblxuICAgICAgICAgICAgICAgIGNvbnN0IG1pbldpZHRoID0gdGhpcy5nZXRDb2xNaW5XaWR0aChjb2wudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXhXaWR0aCA9IHRoaXMuZ2V0Q29sTWF4V2lkdGgoY29sLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRSZXNpemVXaWR0aCArIHJlc2l6ZVNjYWxlZCA8IG1pbldpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbC50YXJnZXQud2lkdGggPSBtaW5XaWR0aCArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWREaWZmICs9IChjdXJyZW50UmVzaXplV2lkdGggLSBtaW5XaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbWJpbmVkU3BhbiAtPSBjb2wuc3BhblVzZWQ7XG4gICAgICAgICAgICAgICAgICAgIHNldE1pbk1heENvbHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWF4V2lkdGggJiYgKGN1cnJlbnRSZXNpemVXaWR0aCArIHJlc2l6ZVNjYWxlZCA+IG1heFdpZHRoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb2wudGFyZ2V0LndpZHRoID0gbWF4V2lkdGggKyAncHgnO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkRGlmZiAtPSAobWF4V2lkdGggLSBjdXJyZW50UmVzaXplV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICBuZXdDb21iaW5lZFNwYW4gLT0gY29sLnNwYW5Vc2VkO1xuICAgICAgICAgICAgICAgICAgICBzZXRNaW5NYXhDb2xzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBTYXZlIG5ldyBvbmVzIHRoYXQgY2FuIGJlIHJlc2l6ZWRcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29sc1RvUmVzaXplLnB1c2goY29sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdXBkYXRlZENvbWJpbmVkU3BhbiA9IG5ld0NvbWJpbmVkU3BhbjtcbiAgICAgICAgICAgIGNvbHVtbnNUb1Jlc2l6ZSA9IG5ld0NvbHNUb1Jlc2l6ZTtcbiAgICAgICAgfSB3aGlsZSAoc2V0TWluTWF4Q29scyk7XG5cbiAgICAgICAgLy8gVGhvc2UgbGVmdCB0aGF0IGRvbid0IHJlYWNoIG1pbi9tYXggc2l6ZSByZXNpemUgdGhlbSBub3JtYWxseS5cbiAgICAgICAgY29sdW1uc1RvUmVzaXplLmZvckVhY2goKGNvbCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFJlc2l6ZVdpZHRoID0gcGFyc2VGbG9hdChjb2wudGFyZ2V0LmNhbGNXaWR0aCk7XG4gICAgICAgICAgICBjb25zdCByZXNpemVTY2FsZWQgPSAodXBkYXRlZERpZmYgLyB1cGRhdGVkQ29tYmluZWRTcGFuKSAqIGNvbC50YXJnZXQuZ3JpZENvbHVtblNwYW47XG4gICAgICAgICAgICBjb2wudGFyZ2V0LndpZHRoID0gKGN1cnJlbnRSZXNpemVXaWR0aCArIHJlc2l6ZVNjYWxlZCkgKyAncHgnO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iXX0=