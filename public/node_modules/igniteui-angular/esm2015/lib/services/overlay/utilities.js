/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { cloneValue } from '../../core/utils';
/** @enum {number} */
const HorizontalAlignment = {
    Left: -1,
    Center: -0.5,
    Right: 0,
};
export { HorizontalAlignment };
HorizontalAlignment[HorizontalAlignment.Left] = 'Left';
HorizontalAlignment[HorizontalAlignment.Center] = 'Center';
HorizontalAlignment[HorizontalAlignment.Right] = 'Right';
/** @enum {number} */
const VerticalAlignment = {
    Top: -1,
    Middle: -0.5,
    Bottom: 0,
};
export { VerticalAlignment };
VerticalAlignment[VerticalAlignment.Top] = 'Top';
VerticalAlignment[VerticalAlignment.Middle] = 'Middle';
VerticalAlignment[VerticalAlignment.Bottom] = 'Bottom';
export class Point {
    /**
     * @param {?} x
     * @param {?} y
     */
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
}
if (false) {
    /** @type {?} */
    Point.prototype.x;
    /** @type {?} */
    Point.prototype.y;
}
/**
 * @record
 */
export function PositionSettings() { }
if (false) {
    /**
     * Attaching target for the component to show
     * @type {?|undefined}
     */
    PositionSettings.prototype.target;
    /**
     * Direction in which the component should show
     * @type {?|undefined}
     */
    PositionSettings.prototype.horizontalDirection;
    /**
     * Direction in which the component should show
     * @type {?|undefined}
     */
    PositionSettings.prototype.verticalDirection;
    /**
     * Target's starting point
     * @type {?|undefined}
     */
    PositionSettings.prototype.horizontalStartPoint;
    /**
     * Target's starting point
     * @type {?|undefined}
     */
    PositionSettings.prototype.verticalStartPoint;
    /**
     * Animation applied while overlay opens
     * @type {?|undefined}
     */
    PositionSettings.prototype.openAnimation;
    /**
     * Animation applied while overlay closes
     * @type {?|undefined}
     */
    PositionSettings.prototype.closeAnimation;
    /**
     * The size up to which element may shrink when shown in elastic position strategy
     * @type {?|undefined}
     */
    PositionSettings.prototype.minSize;
}
/**
 * @record
 */
export function OverlaySettings() { }
if (false) {
    /**
     * Position strategy to use with this settings
     * @type {?|undefined}
     */
    OverlaySettings.prototype.positionStrategy;
    /**
     * Scroll strategy to use with this settings
     * @type {?|undefined}
     */
    OverlaySettings.prototype.scrollStrategy;
    /**
     * Set if the overlay should be in modal mode
     * @type {?|undefined}
     */
    OverlaySettings.prototype.modal;
    /**
     * Set if the overlay should closed on outside click
     * @type {?|undefined}
     */
    OverlaySettings.prototype.closeOnOutsideClick;
    /**
     * Set the outlet container to attach the overlay to
     * @type {?|undefined}
     */
    OverlaySettings.prototype.outlet;
    /**
     * @hidden \@internal
     * Exclude the position strategy target for outside clicks
     * @type {?|undefined}
     */
    OverlaySettings.prototype.excludePositionTarget;
}
/**
 * @record
 */
export function OverlayEventArgs() { }
if (false) {
    /**
     * Id of the overlay generated with `attach()` method
     * @type {?}
     */
    OverlayEventArgs.prototype.id;
    /**
     * Available when `Type<T>` is provided to the `attach()` method and allows access to the created Component instance
     * @type {?|undefined}
     */
    OverlayEventArgs.prototype.componentRef;
}
/**
 * @record
 */
export function OverlayCancelableEventArgs() { }
/**
 * @record
 */
export function OverlayClosingEventArgs() { }
/**
 * @record
 */
export function OverlayAnimationEventArgs() { }
if (false) {
    /**
     * Id of the overlay generated with `attach()` method
     * @type {?}
     */
    OverlayAnimationEventArgs.prototype.id;
    /**
     * Animation player that will play the animation
     * @type {?}
     */
    OverlayAnimationEventArgs.prototype.animationPlayer;
    /**
     * Type of animation to be played. It should be either 'open' or 'close'
     * @type {?}
     */
    OverlayAnimationEventArgs.prototype.animationType;
}
/**
 * @record
 */
export function Size() { }
if (false) {
    /**
     * Gets or sets the horizontal component of Size
     * @type {?}
     */
    Size.prototype.width;
    /**
     * Gets or sets the vertical component of Size
     * @type {?}
     */
    Size.prototype.height;
}
/**
 * @hidden
 * Calculates the rectangle of target for provided overlay settings. Defaults to 0,0,0,0 rectangle
 * if no target is provided
 * @param {?} settings Overlay settings for which to calculate target rectangle
 * @return {?}
 */
export function getTargetRect(settings) {
    /** @type {?} */
    let targetRect = {
        bottom: 0,
        height: 0,
        left: 0,
        right: 0,
        top: 0,
        width: 0
    };
    if (settings.target instanceof HTMLElement) {
        targetRect = ((/** @type {?} */ (settings.target))).getBoundingClientRect();
    }
    else if (settings.target instanceof Point) {
        /** @type {?} */
        const targetPoint = (/** @type {?} */ (settings.target));
        targetRect = {
            bottom: targetPoint.y,
            height: 0,
            left: targetPoint.x,
            right: targetPoint.x,
            top: targetPoint.y,
            width: 0
        };
    }
    return targetRect;
}
/**
 * @hidden
 * @record
 */
export function OverlayInfo() { }
if (false) {
    /** @type {?|undefined} */
    OverlayInfo.prototype.id;
    /** @type {?|undefined} */
    OverlayInfo.prototype.elementRef;
    /** @type {?|undefined} */
    OverlayInfo.prototype.componentRef;
    /** @type {?|undefined} */
    OverlayInfo.prototype.settings;
    /** @type {?|undefined} */
    OverlayInfo.prototype.initialSize;
    /** @type {?|undefined} */
    OverlayInfo.prototype.hook;
    /** @type {?|undefined} */
    OverlayInfo.prototype.openAnimationPlayer;
    /** @type {?|undefined} */
    OverlayInfo.prototype.closeAnimationPlayer;
    /** @type {?|undefined} */
    OverlayInfo.prototype.openAnimationInnerPlayer;
    /** @type {?|undefined} */
    OverlayInfo.prototype.closeAnimationInnerPlayer;
    /** @type {?} */
    OverlayInfo.prototype.ngZone;
}
/**
 * @hidden \@internal
 * @param {?} document
 * @return {?}
 */
export function getViewportRect(document) {
    /** @type {?} */
    const width = document.documentElement.clientWidth;
    /** @type {?} */
    const height = document.documentElement.clientHeight;
    /** @type {?} */
    const scrollPosition = getViewportScrollPosition();
    return {
        top: scrollPosition.y,
        left: scrollPosition.x,
        right: scrollPosition.x + width,
        bottom: scrollPosition.y + height,
        width: width,
        height: height,
    };
}
/**
 * @hidden \@internal
 * @return {?}
 */
export function getViewportScrollPosition() {
    /** @type {?} */
    const documentElement = document.documentElement;
    /** @type {?} */
    const documentRect = documentElement.getBoundingClientRect();
    /** @type {?} */
    const horizontalScrollPosition = -documentRect.left || document.body.scrollLeft || window.scrollX || documentElement.scrollLeft || 0;
    /** @type {?} */
    const verticalScrollPosition = -documentRect.top || document.body.scrollTop || window.scrollY || documentElement.scrollTop || 0;
    return new Point(horizontalScrollPosition, verticalScrollPosition);
}
/**
 * @hidden \@internal
 * @param {?} object
 * @return {?}
 */
export function cloneInstance(object) {
    /** @type {?} */
    const clonedObj = Object.assign(Object.create(Object.getPrototypeOf(object)), object);
    clonedObj.settings = cloneValue(clonedObj.settings);
    return clonedObj;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbGl0aWVzLmpzIiwic291cmNlUm9vdCI6Im5nOi8vaWduaXRldWktYW5ndWxhci8iLCJzb3VyY2VzIjpbImxpYi9zZXJ2aWNlcy9vdmVybGF5L3V0aWxpdGllcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBTUEsT0FBTyxFQUFtRCxVQUFVLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQzs7O0lBRzNGLFFBQVM7SUFDVCxZQUFhO0lBQ2IsUUFBUzs7Ozs7Ozs7SUFJVCxPQUFRO0lBQ1IsWUFBYTtJQUNiLFNBQVU7Ozs7OztBQUdkLE1BQU0sT0FBTyxLQUFLOzs7OztJQUNkLFlBQW1CLENBQVMsRUFBUyxDQUFTO1FBQTNCLE1BQUMsR0FBRCxDQUFDLENBQVE7UUFBUyxNQUFDLEdBQUQsQ0FBQyxDQUFRO0lBQUksQ0FBQztDQUN0RDs7O0lBRGUsa0JBQWdCOztJQUFFLGtCQUFnQjs7Ozs7QUFHbEQsc0NBaUJDOzs7Ozs7SUFmRyxrQ0FBNkI7Ozs7O0lBRTdCLCtDQUEwQzs7Ozs7SUFFMUMsNkNBQXNDOzs7OztJQUV0QyxnREFBMkM7Ozs7O0lBRTNDLDhDQUF1Qzs7Ozs7SUFFdkMseUNBQTJDOzs7OztJQUUzQywwQ0FBNEM7Ozs7O0lBRTVDLG1DQUFlOzs7OztBQUduQixxQ0FnQkM7Ozs7OztJQWRHLDJDQUFxQzs7Ozs7SUFFckMseUNBQWlDOzs7OztJQUVqQyxnQ0FBZ0I7Ozs7O0lBRWhCLDhDQUE4Qjs7Ozs7SUFFOUIsaUNBQWdEOzs7Ozs7SUFLaEQsZ0RBQWdDOzs7OztBQUdwQyxzQ0FLQzs7Ozs7O0lBSEcsOEJBQVc7Ozs7O0lBRVgsd0NBQWdDOzs7OztBQUdwQyxnREFDQzs7OztBQUVELDZDQUNDOzs7O0FBRUQsK0NBT0M7Ozs7OztJQUxHLHVDQUFXOzs7OztJQUVYLG9EQUFpQzs7Ozs7SUFFakMsa0RBQWdDOzs7OztBQUdwQywwQkFNQzs7Ozs7O0lBSkcscUJBQWM7Ozs7O0lBR2Qsc0JBQWU7Ozs7Ozs7OztBQVNuQixNQUFNLFVBQVUsYUFBYSxD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ZnJvbSAnLi9wb3NpdGlvbi9JUG9zaXRpb25TdHJhdGVneSc7XG5cbmltcG9ydCB7IElTY3JvbGxTdHJhdGVneSB9IGZyb20gJy4vc2Nyb2xsJztcbmltcG9ydCB7IEFuaW1hdGlvblJlZmVyZW5jZU1ldGFkYXRhLCBBbmltYXRpb25QbGF5ZXIgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IENvbXBvbmVudFJlZiwgRWxlbWVudFJlZiwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJZ3hPdmVybGF5T3V0bGV0RGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy90b2dnbGUvdG9nZ2xlLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBDYW5jZWxhYmxlRXZlbnRBcmdzLCBDYW5jZWxhYmxlQnJvd3NlckV2ZW50QXJncywgY2xvbmVWYWx1ZSB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbHMnO1xuXG5leHBvcnQgZW51bSBIb3Jpem9udGFsQWxpZ25tZW50IHtcbiAgICBMZWZ0ID0gLTEsXG4gICAgQ2VudGVyID0gLTAuNSxcbiAgICBSaWdodCA9IDBcbn1cblxuZXhwb3J0IGVudW0gVmVydGljYWxBbGlnbm1lbnQge1xuICAgIFRvcCA9IC0xLFxuICAgIE1pZGRsZSA9IC0wLjUsXG4gICAgQm90dG9tID0gMFxufVxuXG5leHBvcnQgY2xhc3MgUG9pbnQge1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyB4OiBudW1iZXIsIHB1YmxpYyB5OiBudW1iZXIpIHsgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFBvc2l0aW9uU2V0dGluZ3Mge1xuICAgIC8qKiBBdHRhY2hpbmcgdGFyZ2V0IGZvciB0aGUgY29tcG9uZW50IHRvIHNob3cgKi9cbiAgICB0YXJnZXQ/OiBQb2ludCB8IEhUTUxFbGVtZW50O1xuICAgIC8qKiBEaXJlY3Rpb24gaW4gd2hpY2ggdGhlIGNvbXBvbmVudCBzaG91bGQgc2hvdyAqL1xuICAgIGhvcml6b250YWxEaXJlY3Rpb24/OiBIb3Jpem9udGFsQWxpZ25tZW50O1xuICAgIC8qKiBEaXJlY3Rpb24gaW4gd2hpY2ggdGhlIGNvbXBvbmVudCBzaG91bGQgc2hvdyAqL1xuICAgIHZlcnRpY2FsRGlyZWN0aW9uPzogVmVydGljYWxBbGlnbm1lbnQ7XG4gICAgLyoqIFRhcmdldCdzIHN0YXJ0aW5nIHBvaW50ICovXG4gICAgaG9yaXpvbnRhbFN0YXJ0UG9pbnQ/OiBIb3Jpem9udGFsQWxpZ25tZW50O1xuICAgIC8qKiBUYXJnZXQncyBzdGFydGluZyBwb2ludCAqL1xuICAgIHZlcnRpY2FsU3RhcnRQb2ludD86IFZlcnRpY2FsQWxpZ25tZW50O1xuICAgIC8qKiBBbmltYXRpb24gYXBwbGllZCB3aGlsZSBvdmVybGF5IG9wZW5zICovXG4gICAgb3BlbkFuaW1hdGlvbj86IEFuaW1hdGlvblJlZmVyZW5jZU1ldGFkYXRhO1xuICAgIC8qKiBBbmltYXRpb24gYXBwbGllZCB3aGlsZSBvdmVybGF5IGNsb3NlcyAqL1xuICAgIGNsb3NlQW5pbWF0aW9uPzogQW5pbWF0aW9uUmVmZXJlbmNlTWV0YWRhdGE7XG4gICAgLyoqIFRoZSBzaXplIHVwIHRvIHdoaWNoIGVsZW1lbnQgbWF5IHNocmluayB3aGVuIHNob3duIGluIGVsYXN0aWMgcG9zaXRpb24gc3RyYXRlZ3kgKi9cbiAgICBtaW5TaXplPzogU2l6ZTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBPdmVybGF5U2V0dGluZ3Mge1xuICAgIC8qKiBQb3NpdGlvbiBzdHJhdGVneSB0byB1c2Ugd2l0aCB0aGlzIHNldHRpbmdzICovXG4gICAgcG9zaXRpb25TdHJhdGVneT86IElQb3NpdGlvblN0cmF0ZWd5O1xuICAgIC8qKiBTY3JvbGwgc3RyYXRlZ3kgdG8gdXNlIHdpdGggdGhpcyBzZXR0aW5ncyAqL1xuICAgIHNjcm9sbFN0cmF0ZWd5PzogSVNjcm9sbFN0cmF0ZWd5O1xuICAgIC8qKiBTZXQgaWYgdGhlIG92ZXJsYXkgc2hvdWxkIGJlIGluIG1vZGFsIG1vZGUgKi9cbiAgICBtb2RhbD86IGJvb2xlYW47XG4gICAgLyoqIFNldCBpZiB0aGUgb3ZlcmxheSBzaG91bGQgY2xvc2VkIG9uIG91dHNpZGUgY2xpY2sgKi9cbiAgICBjbG9zZU9uT3V0c2lkZUNsaWNrPzogYm9vbGVhbjtcbiAgICAvKiogU2V0IHRoZSBvdXRsZXQgY29udGFpbmVyIHRvIGF0dGFjaCB0aGUgb3ZlcmxheSB0byAqL1xuICAgIG91dGxldD86IElneE92ZXJsYXlPdXRsZXREaXJlY3RpdmUgfCBFbGVtZW50UmVmO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogRXhjbHVkZSB0aGUgcG9zaXRpb24gc3RyYXRlZ3kgdGFyZ2V0IGZvciBvdXRzaWRlIGNsaWNrc1xuICAgICAqL1xuICAgIGV4Y2x1ZGVQb3NpdGlvblRhcmdldD86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3ZlcmxheUV2ZW50QXJncyB7XG4gICAgLyoqIElkIG9mIHRoZSBvdmVybGF5IGdlbmVyYXRlZCB3aXRoIGBhdHRhY2goKWAgbWV0aG9kICovXG4gICAgaWQ6IHN0cmluZztcbiAgICAvKiogQXZhaWxhYmxlIHdoZW4gYFR5cGU8VD5gIGlzIHByb3ZpZGVkIHRvIHRoZSBgYXR0YWNoKClgIG1ldGhvZCBhbmQgYWxsb3dzIGFjY2VzcyB0byB0aGUgY3JlYXRlZCBDb21wb25lbnQgaW5zdGFuY2UgKi9cbiAgICBjb21wb25lbnRSZWY/OiBDb21wb25lbnRSZWY8e30+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE92ZXJsYXlDYW5jZWxhYmxlRXZlbnRBcmdzIGV4dGVuZHMgT3ZlcmxheUV2ZW50QXJncywgQ2FuY2VsYWJsZUV2ZW50QXJncyB7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3ZlcmxheUNsb3NpbmdFdmVudEFyZ3MgZXh0ZW5kcyBPdmVybGF5RXZlbnRBcmdzLCBDYW5jZWxhYmxlQnJvd3NlckV2ZW50QXJncyB7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3ZlcmxheUFuaW1hdGlvbkV2ZW50QXJncyB7XG4gICAgLyoqIElkIG9mIHRoZSBvdmVybGF5IGdlbmVyYXRlZCB3aXRoIGBhdHRhY2goKWAgbWV0aG9kICovXG4gICAgaWQ6IHN0cmluZztcbiAgICAvKiogQW5pbWF0aW9uIHBsYXllciB0aGF0IHdpbGwgcGxheSB0aGUgYW5pbWF0aW9uICovXG4gICAgYW5pbWF0aW9uUGxheWVyOiBBbmltYXRpb25QbGF5ZXI7XG4gICAgLyoqIFR5cGUgb2YgYW5pbWF0aW9uIHRvIGJlIHBsYXllZC4gSXQgc2hvdWxkIGJlIGVpdGhlciAnb3Blbicgb3IgJ2Nsb3NlJyAqL1xuICAgIGFuaW1hdGlvblR5cGU6ICdvcGVuJyB8ICdjbG9zZSc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2l6ZSB7XG4gICAgLyoqIEdldHMgb3Igc2V0cyB0aGUgaG9yaXpvbnRhbCBjb21wb25lbnQgb2YgU2l6ZSAqL1xuICAgIHdpZHRoOiBudW1iZXI7XG5cbiAgICAvKiogR2V0cyBvciBzZXRzIHRoZSB2ZXJ0aWNhbCBjb21wb25lbnQgb2YgU2l6ZSAqL1xuICAgIGhlaWdodDogbnVtYmVyO1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqIENhbGN1bGF0ZXMgdGhlIHJlY3RhbmdsZSBvZiB0YXJnZXQgZm9yIHByb3ZpZGVkIG92ZXJsYXkgc2V0dGluZ3MuIERlZmF1bHRzIHRvIDAsMCwwLDAgcmVjdGFuZ2xlXG4gKiBpZiBubyB0YXJnZXQgaXMgcHJvdmlkZWRcbiAqIEBwYXJhbSBzZXR0aW5ncyBPdmVybGF5IHNldHRpbmdzIGZvciB3aGljaCB0byBjYWxjdWxhdGUgdGFyZ2V0IHJlY3RhbmdsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGFyZ2V0UmVjdChzZXR0aW5nczogUG9zaXRpb25TZXR0aW5ncyk6IENsaWVudFJlY3Qge1xuICAgIGxldCB0YXJnZXRSZWN0OiBDbGllbnRSZWN0ID0ge1xuICAgICAgICBib3R0b206IDAsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgd2lkdGg6IDBcbiAgICB9O1xuXG4gICAgaWYgKHNldHRpbmdzLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgIHRhcmdldFJlY3QgPSAoc2V0dGluZ3MudGFyZ2V0IGFzIEhUTUxFbGVtZW50KS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9IGVsc2UgaWYgKHNldHRpbmdzLnRhcmdldCBpbnN0YW5jZW9mIFBvaW50KSB7XG4gICAgICAgIGNvbnN0IHRhcmdldFBvaW50ID0gc2V0dGluZ3MudGFyZ2V0IGFzIFBvaW50O1xuICAgICAgICB0YXJnZXRSZWN0ID0ge1xuICAgICAgICAgICAgYm90dG9tOiB0YXJnZXRQb2ludC55LFxuICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgbGVmdDogdGFyZ2V0UG9pbnQueCxcbiAgICAgICAgICAgIHJpZ2h0OiB0YXJnZXRQb2ludC54LFxuICAgICAgICAgICAgdG9wOiB0YXJnZXRQb2ludC55LFxuICAgICAgICAgICAgd2lkdGg6IDBcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0UmVjdDtcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgT3ZlcmxheUluZm8ge1xuICAgIGlkPzogc3RyaW5nO1xuICAgIGVsZW1lbnRSZWY/OiBFbGVtZW50UmVmO1xuICAgIGNvbXBvbmVudFJlZj86IENvbXBvbmVudFJlZjx7fT47XG4gICAgc2V0dGluZ3M/OiBPdmVybGF5U2V0dGluZ3M7XG4gICAgaW5pdGlhbFNpemU/OiBTaXplO1xuICAgIGhvb2s/OiBIVE1MRWxlbWVudDtcbiAgICBvcGVuQW5pbWF0aW9uUGxheWVyPzogQW5pbWF0aW9uUGxheWVyO1xuICAgIGNsb3NlQW5pbWF0aW9uUGxheWVyPzogQW5pbWF0aW9uUGxheWVyO1xuICAgIG9wZW5BbmltYXRpb25Jbm5lclBsYXllcj86IGFueTtcbiAgICBjbG9zZUFuaW1hdGlvbklubmVyUGxheWVyPzogYW55O1xuICAgIG5nWm9uZTogTmdab25lO1xufVxuXG4vKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRWaWV3cG9ydFJlY3QoZG9jdW1lbnQ6IERvY3VtZW50KTogQ2xpZW50UmVjdCB7XG4gICAgY29uc3Qgd2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICBjb25zdCBzY3JvbGxQb3NpdGlvbiA9IGdldFZpZXdwb3J0U2Nyb2xsUG9zaXRpb24oKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogc2Nyb2xsUG9zaXRpb24ueSxcbiAgICAgICAgbGVmdDogc2Nyb2xsUG9zaXRpb24ueCxcbiAgICAgICAgcmlnaHQ6IHNjcm9sbFBvc2l0aW9uLnggKyB3aWR0aCxcbiAgICAgICAgYm90dG9tOiBzY3JvbGxQb3NpdGlvbi55ICsgaGVpZ2h0LFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIH07XG59XG5cbi8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFZpZXdwb3J0U2Nyb2xsUG9zaXRpb24oKTogUG9pbnQge1xuICAgIGNvbnN0IGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICBjb25zdCBkb2N1bWVudFJlY3QgPSBkb2N1bWVudEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICBjb25zdCBob3Jpem9udGFsU2Nyb2xsUG9zaXRpb24gPSAtZG9jdW1lbnRSZWN0LmxlZnQgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0IHx8IHdpbmRvdy5zY3JvbGxYIHx8IGRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IDA7XG4gICAgY29uc3QgdmVydGljYWxTY3JvbGxQb3NpdGlvbiA9IC1kb2N1bWVudFJlY3QudG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wIHx8IHdpbmRvdy5zY3JvbGxZIHx8IGRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgMDtcblxuICAgIHJldHVybiBuZXcgUG9pbnQoaG9yaXpvbnRhbFNjcm9sbFBvc2l0aW9uLCB2ZXJ0aWNhbFNjcm9sbFBvc2l0aW9uKTtcbn1cblxuLyoqIEBoaWRkZW4gQGludGVybmFsKi9cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZUluc3RhbmNlKG9iamVjdCkge1xuICAgIGNvbnN0IGNsb25lZE9iaiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KSksIG9iamVjdCk7XG4gICAgY2xvbmVkT2JqLnNldHRpbmdzID0gY2xvbmVWYWx1ZShjbG9uZWRPYmouc2V0dGluZ3MpO1xuICAgIHJldHVybiBjbG9uZWRPYmo7XG59XG4iXX0=